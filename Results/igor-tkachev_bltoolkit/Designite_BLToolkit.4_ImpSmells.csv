Implementation smell,Namespace,Class,File,Method,Description
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToBoolean,The method has 104 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToByte,The method has 104 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToChar,The method has 104 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDecimal,The method has 104 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDouble,The method has 120 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt16,The method has 104 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt32,The method has 104 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt64,The method has 120 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSByte,The method has 104 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSingle,The method has 104 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToString,The method has 136 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt16,The method has 104 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt32,The method has 104 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt64,The method has 104 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableBoolean,The method has 102 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableByte,The method has 102 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableChar,The method has 102 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDecimal,The method has 102 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDouble,The method has 118 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt16,The method has 102 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt32,The method has 102 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt64,The method has 118 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableSByte,The method has 102 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableSingle,The method has 102 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt16,The method has 102 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt32,The method has 102 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt64,The method has 102 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlBoolean,The method has 100 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlByte,The method has 100 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlBytes,The method has 104 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDecimal,The method has 100 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDouble,The method has 116 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt16,The method has 100 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt32,The method has 100 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt64,The method has 116 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlMoney,The method has 100 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlSingle,The method has 100 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlString,The method has 130 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToByteArray,The method has 138 lines of code.
Long Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ChangeTypeFromString,The method has 130 lines of code.
Long Method,BLToolkit.Common,Operator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Operator.cs,GetOperable,The method has 102 lines of code.
Long Method,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildAbstractMethod,The method has 121 lines of code.
Long Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The method has 109 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildExpression,The method has 352 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The method has 222 lines of code.
Long Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertEnumConversion,The method has 101 lines of code.
Long Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildPredicate,The method has 118 lines of code.
Long Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildExpression,The method has 113 lines of code.
Long Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The method has 248 lines of code.
Long Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveCountSubQuery,The method has 102 lines of code.
Long Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveSubQueryColumn,The method has 128 lines of code.
Long Method,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,Visit1,The method has 224 lines of code.
Long Method,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,Visit2,The method has 242 lines of code.
Long Method,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The method has 337 lines of code.
Long Method,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ResolveFields,The method has 127 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The method has 249 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The method has 149 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The method has 128 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The method has 128 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Find,The method has 101 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert,The method has 280 lines of code.
Long Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert2,The method has 220 lines of code.
Long Method,BLToolkit.Mapping,MapSetData,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MapSetDataT.cs,GetSetter,The method has 143 lines of code.
Long Method,BLToolkit.Mapping,MapGetData,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MapGetDataT.cs,GetGetter,The method has 143 lines of code.
Long Method,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertChangeType,The method has 188 lines of code.
Long Method,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The method has 104 lines of code.
Long Method,BLToolkit.Reflection,ExprMemberAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\ExprMemberAccessor.cs,GetMemberAccessor,The method has 127 lines of code.
Long Method,BLToolkit.TypeBuilder.Builders,DuckTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DuckTypeBuilder.cs,BuildMembers,The method has 103 lines of code.
Long Method,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The method has 151 lines of code.
Long Method,BLToolkit.TypeBuilder.Builders,ImplementInterfaceBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\ImplementInterfaceBuilder.cs,BuildInterfaceMethod,The method has 115 lines of code.
Complex Method,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,Build,Cyclomatic complexity of the method is 22
Complex Method,BLToolkit.Aspects.Builders,MixinAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\MixinAspectBuilder.cs,Build,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Aspects.Builders,MixinAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\MixinAspectBuilder.cs,CheckOverrideAttribute,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Aspects.Builders,OverloadAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\OverloadAspectBuilder.cs,BuildAbstractMethod,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Aspects.Builders,OverloadAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\OverloadAspectBuilder.cs,GetOverloadedMethod,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Aspects,CacheAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,Init,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Aspects,CacheAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,AfterCall,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Aspects,Interceptor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Interceptor.cs,Intercept,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Aspects,LoggingAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\LoggingAspect.cs,Init,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToBoolean,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToByte,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToChar,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDecimal,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDouble,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt16,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt32,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt64,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSByte,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSingle,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToString,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt16,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt32,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt64,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableBoolean,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableByte,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableChar,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDecimal,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDouble,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt16,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt32,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt64,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableSByte,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableSingle,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt16,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt32,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt64,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlBoolean,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlByte,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlBytes,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDecimal,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDouble,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt16,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt32,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt64,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlMoney,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlSingle,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlString,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToByteArray,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToBoolean,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ChangeTypeFromString,Cyclomatic complexity of the method is 40
Complex Method,BLToolkit.DataAccess,DataAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorTA.cs,ExecuteEnumerable,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.DataAccess,DataAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorTA.cs,ExecuteEnumerable,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildAbstractMethod,Cyclomatic complexity of the method is 54
Complex Method,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ProcessParameters,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteScalar,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,CreateReturnTypeInstance,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetSprocNameOrSqlQueryTest,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildRefParameters,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,LoadParameterOrNull,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,StoreParameterValue,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,GetKeyFieldList,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateSqlText,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,Close,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateSpParameters,Cyclomatic complexity of the method is 16
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,PrepareParameters,Cyclomatic complexity of the method is 16
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DiscoverSpParameters,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateParameters,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,MapOutputParameters,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,SetCommand,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,GetCommand,Cyclomatic complexity of the method is 24
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,SetCommandParameters,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,InitParameters,Cyclomatic complexity of the method is 32
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,Cyclomatic complexity of the method is 22
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteScalar,Cyclomatic complexity of the method is 22
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteScalarDictionary,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteScalarDictionary,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteScalarDictionary,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteScalarDictionary,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DbManager,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,GetDataProvider,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,FindFirstSuitableProvider,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,GetSqlText,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,Interpret,Cyclomatic complexity of the method is 15
Complex Method,BLToolkit.Data.DataProvider,SqlDataProviderVersionResolver,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderVersionResolver.cs,InvalidateDataProviderInternal,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.DataProvider,AccessDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,DeriveParameters,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data.DataProvider,AccessDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,GetOleDbType,Cyclomatic complexity of the method is 64
Complex Method,BLToolkit.Data.DataProvider,OleDbDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OleDbDataProvider.cs,Convert,Cyclomatic complexity of the method is 20
Complex Method,BLToolkit.Data.DataProvider.Interpreters,OracleDataProviderInterpreter,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\Interpreters\OracleDataProviderInterpreter.cs,GetInsertBatchSqlListWithInsertAll,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildExpression,Cyclomatic complexity of the method is 158
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,VisitMembers,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,ParseSet,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Data.Linq.Builder,SelectManyBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectManyBuilder.cs,BuildMethodCall,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,TableAttributeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableAttributeBuilder.cs,BuildMethodCall,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertExpressionTree,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,OptimizeExpressionImpl,Cyclomatic complexity of the method is 26
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSubquery,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertWhere,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsExpression,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,Cyclomatic complexity of the method is 88
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsServerSideOnly,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,Cyclomatic complexity of the method is 32
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,Cyclomatic complexity of the method is 44
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertEnumConversion,Cyclomatic complexity of the method is 22
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertObjectComparison,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertInPredicate,Cyclomatic complexity of the method is 15
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildSearchCondition,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ProcessProjection,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Linq.Builder,MethodCallBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\MethodCallBuilder.cs,ConvertMethod,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Data.Linq.Builder,ExpressionContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionContext.cs,IsExpression,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,Cyclomatic complexity of the method is 21
Complex Method,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToSql,Cyclomatic complexity of the method is 25
Complex Method,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,IsExpression,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetContext,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ProcessMemberAccess,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetSequence,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetMemberExpression,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.Data.Linq.Builder,SelectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,Convert,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data.Linq.Builder,SelectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,GetExpressions,Cyclomatic complexity of the method is 22
Complex Method,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DateAdd,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,SetParameters,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,GetQuery,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,BuildDataType,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,BuildFunction,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSql,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInsertClause,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInsertOrUpdateQueryAsMerge,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildFromClause,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildPhysicalTable,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildJoinTable,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildJoinType,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildPredicate,Cyclomatic complexity of the method is 64
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildExpression,Cyclomatic complexity of the method is 43
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildValue,Cyclomatic complexity of the method is 15
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetAlternativeUpdate,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,Cyclomatic complexity of the method is 84
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertPredicate,Cyclomatic complexity of the method is 27
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,InvertOperator,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,Cyclomatic complexity of the method is 19
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,Compare,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveCountSubQuery,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,BuildSql,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,Cyclomatic complexity of the method is 22
Complex Method,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,Convert,Cyclomatic complexity of the method is 16
Complex Method,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,BuildDataType,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,BuildInsertClause,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,Convert,Cyclomatic complexity of the method is 16
Complex Method,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ConvertExpression,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,BuildDataType,Cyclomatic complexity of the method is 33
Complex Method,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,Convert,Cyclomatic complexity of the method is 20
Complex Method,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,BuildDataType,Cyclomatic complexity of the method is 18
Complex Method,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,Convert,Cyclomatic complexity of the method is 16
Complex Method,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,Convert,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,BuildDataType,Cyclomatic complexity of the method is 25
Complex Method,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,Finalize,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,Convert,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,BuildDataType,Cyclomatic complexity of the method is 25
Complex Method,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,Convert,Cyclomatic complexity of the method is 15
Complex Method,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,BuildInsertClause,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,Cyclomatic complexity of the method is 28
Complex Method,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildDataType,Cyclomatic complexity of the method is 20
Complex Method,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,Cyclomatic complexity of the method is 34
Complex Method,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,Convert,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,BuildDataType,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,Visit1,Cyclomatic complexity of the method is 123
Complex Method,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,Visit2,Cyclomatic complexity of the method is 131
Complex Method,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,Find,Cyclomatic complexity of the method is 46
Complex Method,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,Cyclomatic complexity of the method is 100
Complex Method,BLToolkit.Data.Sql,SqlDataType,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,GetDataType,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Data.Sql,SqlDataType,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,GetDataType,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ResolveFields,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeSearchCondition,Cyclomatic complexity of the method is 39
Complex Method,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,RemoveSubQuery,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeApply,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ConvertInListPredicate,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Data.Sql,SqlTable,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Data.Sql,SqlTable,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,InitFromBase,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,IsConstant,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,Cyclomatic complexity of the method is 89
Complex Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,Cyclomatic complexity of the method is 72
Complex Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,Cyclomatic complexity of the method is 69
Complex Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,Cyclomatic complexity of the method is 69
Complex Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Find,Cyclomatic complexity of the method is 55
Complex Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert,Cyclomatic complexity of the method is 64
Complex Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,ConvertMethodArguments,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert2,Cyclomatic complexity of the method is 64
Complex Method,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,GetMembers,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetBindings,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Mapping,MemberMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,GetDbType,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Mapping,MemberMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,GetDbSize,Cyclomatic complexity of the method is 31
Complex Method,BLToolkit.Mapping,TextDataWriter,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataWriter.cs,WriteRecord,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,GetDefaultNullValue,Cyclomatic complexity of the method is 15
Complex Method,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertChangeType,Cyclomatic complexity of the method is 41
Complex Method,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapInternal,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapSourceListToDestinationList,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapValueToEnum,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapValueToEnum,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapResultSets,Cyclomatic complexity of the method is 15
Complex Method,BLToolkit.Mapping,ObjectMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ObjectMapperT.cs,CreateMemberMapper,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Mapping,ObjectMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ObjectMapperT.cs,Init,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.ComponentModel,BindingListImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,NewObject_ObjectEdit,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.ComponentModel,BindingListImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,GetSortComparer,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.ComponentModel,TypedListImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\TypedListImpl.cs,GetItemProperties,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,LoadTypes,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.EditableObjects,EditableXmlDocument,F:\newReposMay17\igor-tkachev_bltoolkit\Source\EditableObjects\EditableXmlDocument.cs,RejectChanges,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.EditableObjects,EditableArrayList,F:\newReposMay17\igor-tkachev_bltoolkit\Source\EditableObjects\EditableArrayList.cs,RejectChanges,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Patterns,DuckTyping,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Patterns\DuckTyping.cs,Aggregate,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Reflection,ExprMemberAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\ExprMemberAccessor.cs,GetMemberAccessor,Cyclomatic complexity of the method is 44
Complex Method,BLToolkit.Reflection,ExprTypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\ExprTypeAccessor.cs,ExprTypeAccessor,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.Reflection,TypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessorT.cs,GetMember,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Reflection,TypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessorT.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetAttributesTreeInternal,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,IsSameOrParent,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetListItemType,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetGenericArguments,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,IsIntegerType,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,Equals,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetMapValues,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetRelations,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Reflection.MetadataProvider,ExtensionMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\ExtensionMetadataProvider.cs,GetRelations,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.ServiceModel,LinqService,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\LinqService.cs,ExecuteReader,Cyclomatic complexity of the method is 35
Complex Method,BLToolkit.ServiceModel,LinqService,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\LinqService.cs,ExecuteBatch,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.ServiceModel,RemoteDataContextBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\RemoteDataContextBase.cs,GetSqlText,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.ServiceModel,ServiceModelDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\ServiceModelDataReader.cs,GetValue,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.TypeBuilder,TypeFactory,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,AssemblyResolver,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.TypeBuilder.Builders,GeneratedAttributeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\GeneratedAttributeBuilder.cs,GeneratedAttributeBuilder,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.TypeBuilder.Builders,DuckTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DuckTypeBuilder.cs,BuildMembers,Cyclomatic complexity of the method is 28
Complex Method,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,Build,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,CheckCompatibility,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,DefineNonAbstractType,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,Cyclomatic complexity of the method is 28
Complex Method,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateParametrizedInstance,Cyclomatic complexity of the method is 26
Complex Method,BLToolkit.TypeBuilder.Builders,ImplementInterfaceBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\ImplementInterfaceBuilder.cs,BuildInterfaceMethod,Cyclomatic complexity of the method is 28
Complex Method,BLToolkit.TypeBuilder.Builders,PropertyChangedBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\PropertyChangedBuilder.cs,GenerateIsSameValueComparison,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildMembers,Cyclomatic complexity of the method is 15
Complex Method,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildMember,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildIsNull,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildCloneValueMethod,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.TypeBuilder.Builders,InstanceTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\InstanceTypeBuilder.cs,BuildAbstractGetter,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.TypeBuilder.Builders,InstanceTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\InstanceTypeBuilder.cs,BuildAbstractSetter,Cyclomatic complexity of the method is 14
Complex Method,BLToolkit.Reflection.Extension,ValueCollection,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Extension\ValueCollection.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Reflection.Extension,TypeExtension,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Extension\TypeExtension.cs,GetExtensions,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Reflection.Emit,AssemblyBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\AssemblyBuilderHelper.cs,AssemblyBuilderHelper,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,conv,Cyclomatic complexity of the method is 37
Complex Method,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldarg,Cyclomatic complexity of the method is 17
Complex Method,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,Cyclomatic complexity of the method is 34
Complex Method,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldind,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,stind,Cyclomatic complexity of the method is 30
Complex Method,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,stloc_s,Cyclomatic complexity of the method is 15
Complex Method,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,LoadInitValue,Cyclomatic complexity of the method is 26
Complex Method,BLToolkit.Reflection.Emit,MethodBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\MethodBuilderHelper.cs,MethodBuilderHelper,Cyclomatic complexity of the method is 10
Complex Method,BLToolkit.Reflection.Emit,TypeBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineMethod,Cyclomatic complexity of the method is 8
Complex Method,BLToolkit.Validation,MaxValueAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Validation\MaxValueAttribute.cs,IsValid,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.Validation,MinValueAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Validation\MinValueAttribute.cs,IsValid,Cyclomatic complexity of the method is 13
Complex Method,BLToolkit.Validation,Validator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Validation\Validator.cs,IsValid,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Net,HttpReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Net\HttpReader.cs,PrepareRequest,Cyclomatic complexity of the method is 12
Complex Method,BLToolkit.Net,HttpReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Net\HttpReader.cs,Request,Cyclomatic complexity of the method is 9
Complex Method,BLToolkit.Net,HttpReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Net\HttpReader.cs,Request,Cyclomatic complexity of the method is 11
Complex Method,BLToolkit.Net,HttpReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Net\HttpReader.cs,Post,Cyclomatic complexity of the method is 11
Long Parameter List,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,InterceptorAspectBuilder,The method has 5 parameters.
Long Parameter List,BLToolkit.Aspects,InterceptorAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\InterceptorAttribute.cs,InterceptorAttribute,The method has 5 parameters.
Long Parameter List,BLToolkit.DataAccess,DataAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorTA.cs,CreateParameters,The method has 6 parameters.
Long Parameter List,BLToolkit.DataAccess,DataAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorTA.cs,CreateParameters,The method has 6 parameters.
Long Parameter List,BLToolkit.DataAccess,DataAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorTA.cs,ExecuteDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.DataAccess,DataAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorTA.cs,ExecuteScalarDictionary,The method has 7 parameters.
Long Parameter List,BLToolkit.DataAccess,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQuery.cs,ExecuteForEach,The method has 5 parameters.
Long Parameter List,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateParameters,The method has 5 parameters.
Long Parameter List,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateParameters,The method has 5 parameters.
Long Parameter List,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,Parameter,The method has 5 parameters.
Long Parameter List,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,Parameter,The method has 5 parameters.
Long Parameter List,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteScalarDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.DataProvider,DataProviderInterpreterBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderInterpreterBase.cs,GetInsertBatchSqlList,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionString,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionStringWithoutPooling,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionString,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionStringWithoutPooling,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionString,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.DataProvider,DataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderBase.cs,InsertBatchWithIdentity,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.DataProvider,DataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderBase.cs,InsertBatch,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,InsertBatch,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.DataProvider.Interpreters,OracleDataProviderInterpreter,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\Interpreters\OracleDataProviderInterpreter.cs,GetInsertBatchSqlList,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.DataProvider.Interpreters,OracleDataProviderInterpreter,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\Interpreters\OracleDataProviderInterpreter.cs,GetInsertBatchSqlListUnionAll,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildSetter,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildSetter,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,ParseSet,The method has 7 parameters.
Long Parameter List,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,ParseSet,The method has 7 parameters.
Long Parameter List,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertObjectComparison,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,MakeIsPredicate,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Linq.Builder,JoinBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildJoin,The method has 8 parameters.
Long Parameter List,BLToolkit.Data.Linq.Builder,MethodCallBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\MethodCallBuilder.cs,ConvertMethod,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Linq,CompiledQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\CompiledQuery.cs,Invoke,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Linq,CompiledQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\CompiledQuery.cs,Invoke,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,ToDate,The method has 7 parameters.
Long Parameter List,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,ToDate,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,MakeDateTime,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,RunQuery,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,Map,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,Map,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSql,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSqlBuilder,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildExpression,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildExpression,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,BuildExpression,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildSql,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,BuildSql,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Sql.SqlProvider,ISqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\ISqlProvider.cs,BuildSql,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Sql,SqlDataType,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,SqlDataType,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Sql,SqlDataType,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,SqlDataType,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Sql,SqlDataType,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,SqlDataType,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Sql,SqlBinaryExpression,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlBinaryExpression.cs,SqlBinaryExpression,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Sql,SqlField,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlField.cs,SqlField,The method has 7 parameters.
Long Parameter List,BLToolkit.Data.Sql,SqlParameter,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlParameter.cs,SqlParameter,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Sql,SqlParameter,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlParameter.cs,SqlParameter,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,Init,The method has 13 parameters.
Long Parameter List,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeSubQuery,The method has 6 parameters.
Long Parameter List,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,CheckColumn,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,RemoveSubQuery,The method has 5 parameters.
Long Parameter List,BLToolkit.Data.Sql,SqlTable,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,The method has 11 parameters.
Long Parameter List,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The method has 5 parameters.
Long Parameter List,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The method has 5 parameters.
Long Parameter List,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,Association,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Association.cs,Association,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetValueMapper,The method has 7 parameters.
Long Parameter List,BLToolkit.Mapping,TextDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,GetBytes,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,TextDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,GetChars,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,IValueMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\IValueMapper.cs,Map,The method has 6 parameters.
Long Parameter List,BLToolkit.Mapping,NullDateTimeAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\NullDateTimeAttribute.cs,NullDateTimeAttribute,The method has 6 parameters.
Long Parameter List,BLToolkit.Mapping,NullDateTimeAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\NullDateTimeAttribute.cs,NullDateTimeAttribute,The method has 7 parameters.
Long Parameter List,BLToolkit.Mapping,NullDecimalAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\NullDecimalAttribute.cs,NullDecimalAttribute,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,NullGuidAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\NullGuidAttribute.cs,NullGuidAttribute,The method has 11 parameters.
Long Parameter List,BLToolkit.Mapping,NullGuidAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\NullGuidAttribute.cs,NullGuidAttribute,The method has 11 parameters.
Long Parameter List,BLToolkit.Mapping,Map,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,MapSourceToDestination,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,Map,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,ListToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,Map,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,ListToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,Map,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DataTableToList,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,Map,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DataTableToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,Map,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DataTableToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,Map,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DataReaderToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,Map,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DataReaderToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,Map,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DictionaryToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,Map,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DictionaryToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MapNextResult,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MapNextResult.cs,MapNextResult,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MapNextResult,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MapNextResult.cs,MapNextResult,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapInternal,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapInternal,The method has 6 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapInternal,The method has 6 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapSourceToDestination,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToList,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDictionary,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MapValueAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MapValueAttribute.cs,MapValueAttribute,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MapValueAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MapValueAttribute.cs,MapValueAttribute,The method has 6 parameters.
Long Parameter List,BLToolkit.Mapping,MapValueAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MapValueAttribute.cs,MapValueAttribute,The method has 5 parameters.
Long Parameter List,BLToolkit.Mapping,MapValueAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MapValueAttribute.cs,MapValueAttribute,The method has 6 parameters.
Long Parameter List,BLToolkit.Mapping,MapValueAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MapValueAttribute.cs,MapValueAttribute,The method has 7 parameters.
Long Parameter List,BLToolkit.Reflection,GenericBinder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\GenericBinder.cs,BindToMethod,The method has 7 parameters.
Long Parameter List,BLToolkit.Reflection,GenericBinder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\GenericBinder.cs,SelectProperty,The method has 5 parameters.
Long Parameter List,BLToolkit.Reflection,TypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessorT.cs,GetExtendedProperties,The method has 6 parameters.
Long Parameter List,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetMethod,The method has 5 parameters.
Long Parameter List,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetRelations,The method has 5 parameters.
Long Parameter List,BLToolkit.Reflection.MetadataProvider,ExtensionMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\ExtensionMetadataProvider.cs,GetRelations,The method has 5 parameters.
Long Parameter List,BLToolkit.Reflection.MetadataProvider,MetadataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\MetadataProviderBase.cs,GetRelations,The method has 5 parameters.
Long Parameter List,BLToolkit.Reflection.MetadataProvider,MetadataProviderList,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\MetadataProviderList.cs,GetRelations,The method has 5 parameters.
Long Parameter List,BLToolkit.ServiceModel,ServiceModelDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\ServiceModelDataReader.cs,GetBytes,The method has 5 parameters.
Long Parameter List,BLToolkit.ServiceModel,ServiceModelDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\ServiceModelDataReader.cs,GetChars,The method has 5 parameters.
Long Parameter List,BLToolkit.TypeBuilder,GlobalInstanceTypeAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\GlobalInstanceTypeAttribute.cs,GlobalInstanceTypeAttribute,The method has 5 parameters.
Long Parameter List,BLToolkit.TypeBuilder,GlobalInstanceTypeAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\GlobalInstanceTypeAttribute.cs,GlobalInstanceTypeAttribute,The method has 6 parameters.
Long Parameter List,BLToolkit.TypeBuilder,GlobalInstanceTypeAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\GlobalInstanceTypeAttribute.cs,GlobalInstanceTypeAttribute,The method has 7 parameters.
Long Parameter List,BLToolkit.TypeBuilder,InstanceTypeAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\InstanceTypeAttribute.cs,InstanceTypeAttribute,The method has 5 parameters.
Long Parameter List,BLToolkit.TypeBuilder,InstanceTypeAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\InstanceTypeAttribute.cs,InstanceTypeAttribute,The method has 6 parameters.
Long Parameter List,BLToolkit.TypeBuilder,ParameterAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\ParameterAttribute.cs,ParameterAttribute,The method has 5 parameters.
Long Parameter List,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateParametrizedInstance,The method has 5 parameters.
Long Parameter List,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateAbstractInitContextInstance,The method has 5 parameters.
Long Parameter List,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateInitContextDefaultInstance,The method has 6 parameters.
Long Parameter List,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateInitContextLazyInstance,The method has 5 parameters.
Long Parameter List,BLToolkit.TypeBuilder.Builders,FakeMethodInfo,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\FakeMethodInfo.cs,Invoke,The method has 5 parameters.
Long Parameter List,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,MarkSequencePoint,The method has 5 parameters.
Long Parameter List,BLToolkit.Reflection.Emit,MethodBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\MethodBuilderHelper.cs,MethodBuilderHelper,The method has 5 parameters.
Long Parameter List,BLToolkit.Reflection.Emit,TypeBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineMethod,The method has 5 parameters.
Long Parameter List,BLToolkit.Reflection.Emit,TypeBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineGenericMethod,The method has 6 parameters.
Long Parameter List,BLToolkit.Validation,MaxDateValueAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Validation\MaxDateValueAttribute.cs,MaxDateValueAttribute,The method has 5 parameters.
Long Parameter List,BLToolkit.Validation,MinDateValueAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Validation\MinDateValueAttribute.cs,MinDateValueAttribute,The method has 5 parameters.
Long Identifier,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateSpParameters,The length of the parameter openNewConnectionToDiscoverParameters is 37.
Long Identifier,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,GetSpParameters,The length of the parameter openNewConnectionToDiscoverParameters is 37.
Long Identifier,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,SetSpCommand,The length of the parameter openNewConnectionToDiscoverParameters is 37.
Long Identifier,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,SetSpCommand,The length of the parameter openNewConnectionToDiscoverParameters is 37.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,BuildAbstractMethod,The length of the statement  "			throw new TypeBuilderException (string.Format ("Method '{0}.{1}' is not a 'Begin' nor an 'End' method."' mi.DeclaringType.FullName' mi.Name)); " is 142.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,BuildBeginMethod,The length of the statement  "	emit.newobj (type).dup.dup.dup.stloc (arLocal).ldarg_0.ldftn (method).newobj (delegateType' typeof(object)' typeof(IntPtr)).stloc (dLocal).ldloc (dLocal).stfld (type.GetField ("Delegate")).ldloc (dLocal); " is 204.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,BuildBeginMethod,The length of the statement  "			emit.ldloc (arLocal).dup.ldarg (parameters [i]).stfld (type.GetField ("AsyncCallback")).ldftn (type.GetMethod ("CallBack")).newobj (typeof(AsyncCallback)' typeof(object)' typeof(IntPtr)); " is 187.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,BuildBeginMethod,The length of the statement  "	emit.callvirt (delegateType.GetMethod ("BeginInvoke")).stfld (type.GetField ("InnerResult")).stloc (Context.ReturnValue); " is 121.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,BuildEndMethod,The length of the statement  "	emit.ldarg_1.castclass (type).dup.stloc (arLocal).ldfld (type.GetField ("Delegate")).castclass (delegateType).ldloc (arLocal).ldfld (type.GetField ("InnerResult")).callvirt (delegateType' "EndInvoke"' typeof(IAsyncResult)); " is 223.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,GetTargetMethod,The length of the statement  "			throw new TypeBuilderException (string.Format (Resources.AsyncAspectBuilder_NoTargetMethod' mi.DeclaringType.FullName' mi.Name)); " is 129.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,GetTargetMethod,The length of the statement  "	return _parameterTypes == null ? context.Type.GetMethod (targetMethodName) : context.Type.GetMethod (targetMethodName' _parameterTypes); " is 136.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,EnsureDelegateType,The length of the statement  "		const MethodAttributes ma = MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Virtual; " is 135.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,EnsureDelegateType,The length of the statement  "		var delegateBuilder = context.AssemblyBuilder.DefineType (delegateName' TypeAttributes.Class | TypeAttributes.NotPublic | TypeAttributes.Sealed | TypeAttributes.AnsiClass | TypeAttributes.AutoClass' typeof(MulticastDelegate)); " is 226.
Long Statement,BLToolkit.Aspects.Builders,AsyncAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,EnsureDelegateType,The length of the statement  "		var ctorBuilder = delegateBuilder.DefineConstructor (MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.RTSpecialName' CallingConventions.Standard' typeof(object)' typeof(IntPtr)); " is 201.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,Build,The length of the statement  "		emit.ldloc (_infoField).callvirt (typeof(InterceptCallInfo).GetProperty ("ParameterValues").GetGetMethod ()).ldc_i4 (i).ldargEx (p' true).stelem_ref.end (); " is 156.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,Build,The length of the statement  "		emit.ldloc (_infoField).ldloc (Context.ReturnValue).boxIfValueType (Context.CurrentMethod.ReturnType).callvirt (typeof(InterceptCallInfo).GetProperty ("ReturnValue").GetSetMethod ()); " is 183.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,Build,The length of the statement  "		emit.ldloc (_infoField).ldloc (Context.Exception).callvirt (typeof(InterceptCallInfo).GetProperty ("Exception").GetSetMethod ()); " is 129.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,Build,The length of the statement  "	emit.ldloc (_infoField).ldc_i4 ((int)InterceptResult.Continue).callvirt (typeof(InterceptCallInfo).GetProperty ("InterceptResult").GetSetMethod ()); " is 148.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,Build,The length of the statement  "	emit.ldloc (_infoField).ldc_i4 ((int)interceptType).callvirt (typeof(InterceptCallInfo).GetProperty ("InterceptType").GetSetMethod ())// Call interceptor. " is 154.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,Build,The length of the statement  "	.LoadField (_interceptorField).ldloc (_infoField).callvirt (typeof(IInterceptor)' "Intercept"' typeof(InterceptCallInfo)); " is 122.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,Build,The length of the statement  "		emit.ldloc (_infoField).callvirt (typeof(InterceptCallInfo).GetProperty ("ReturnValue").GetGetMethod ()).CastFromObject (Context.CurrentMethod.ReturnType).stloc (Context.ReturnValue); " is 183.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,Build,The length of the statement  "		emit.ldarg (p).ldloc (_infoField).callvirt (typeof(InterceptCallInfo).GetProperty ("ParameterValues").GetGetMethod ()).ldc_i4 (i).ldelem_ref.CastFromObject (type).stind (type); " is 176.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,Build,The length of the statement  "	emit.ldloc (_infoField).callvirt (typeof(InterceptCallInfo).GetProperty ("InterceptResult").GetGetMethod ()).ldc_i4 ((int)InterceptResult.Return).beq (Context.ReturnLabel); " is 172.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,GetInfoField,The length of the statement  "		var syncRoot = Context.CreatePrivateStaticField (Context.CurrentMethod.Name + "$Lock" + _methodCounter' typeof(object)); " is 120.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,GetInfoField,The length of the statement  "		var methodInfo = Context.CreatePrivateStaticField ("_methodInfo$" + Context.CurrentMethod.Name + _methodCounter' typeof(CallMethodInfo)); " is 137.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,GetInfoField,The length of the statement  "		emit.LoadField (methodInfo).brtrue_s (checkMethodInfo).call (typeof(MethodBase)' "GetCurrentMethod").castclass (typeof(MethodInfo)).newobj (TypeHelper.GetConstructor (typeof(CallMethodInfo)' typeof(MethodInfo))).stsfld (methodInfo).LoadField (methodInfo).LoadField (syncRoot).call (typeof(CallMethodInfo)' "set_SyncRoot"' typeof(object)).MarkLabel (checkMethodInfo); " is 366.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,GetInfoField,The length of the statement  "		emit.newobj (TypeHelper.GetDefaultConstructor (typeof(InterceptCallInfo))).dup.ldarg_0.callvirt (typeof(InterceptCallInfo).GetProperty ("Object").GetSetMethod ()).dup.LoadField (methodInfo).callvirt (typeof(InterceptCallInfo).GetProperty ("CallMethodInfo").GetSetMethod ()); " is 274.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,GetInfoField,The length of the statement  "			emit.dup.callvirt (typeof(InterceptCallInfo).GetProperty ("ParameterValues").GetGetMethod ()).ldc_i4 (i).ldargEx (p' true).stelem_ref.end (); " is 141.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,GetInterceptorField,The length of the statement  "		field = _localInterceptor ? Context.CreatePrivateField (fieldName' typeof(IInterceptor)) : Context.CreatePrivateStaticField (fieldName' typeof(IInterceptor)); " is 158.
Long Statement,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,GetInterceptorField,The length of the statement  "		emit.LoadField (field).LoadField (methodInfo).ldstrEx (_configString ?? "").callvirt (typeof(IInterceptor)' "Init"' typeof(CallMethodInfo)' typeof(string)).MarkLabel (checkInterceptor); " is 185.
Long Statement,BLToolkit.Aspects.Builders,MixinAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\MixinAspectBuilder.cs,Build,The length of the statement  "			throw new TypeBuilderException (string.Format ("Field '{0}.{1}' must be protected or public."' Context.Type.Name' _memberName)); " is 128.
Long Statement,BLToolkit.Aspects.Builders,MixinAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\MixinAspectBuilder.cs,Build,The length of the statement  "				throw new TypeBuilderException (string.Format ("Property '{0}.{1}' getter not found."' Context.Type.Name' _memberName)); " is 120.
Long Statement,BLToolkit.Aspects.Builders,MixinAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\MixinAspectBuilder.cs,Build,The length of the statement  "				throw new TypeBuilderException (string.Format ("Property '{0}.{1}' getter must be protected or public."' Context.Type.Name' _memberName)); " is 138.
Long Statement,BLToolkit.Aspects.Builders,MixinAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\MixinAspectBuilder.cs,CheckNull,The length of the statement  "		string message = string.Format (string.IsNullOrEmpty (_exceptionMessage) ? "'{0}.{1}' is not initialized." : _exceptionMessage' _targetInterface.Name' _memberName' _targetInterface.FullName); " is 191.
Long Statement,BLToolkit.Aspects.Builders,MixinAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\MixinAspectBuilder.cs,CheckNull,The length of the statement  "		emit.brtrue (label).ldstr (message).newobj (typeof(InvalidOperationException)' typeof(string)).@throw.MarkLabel (label); " is 120.
Long Statement,BLToolkit.Aspects.Builders,OverloadAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\OverloadAspectBuilder.cs,BuildAbstractMethod,The length of the statement  "		throw new TypeBuilderException (string.Format (Resources.OverloadAspectBuilder_NoOverloadedMethod' Context.Type.FullName' methodName)); " is 135.
Long Statement,BLToolkit.Aspects.Builders,OverloadAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\OverloadAspectBuilder.cs,GetOverloadedMethod,The length of the statement  "		return bestMatch != null && MatchParameters (currentMethodParameters' bestMatch.GetParameters ()) >= 0 ? bestMatch : null; " is 122.
Long Statement,BLToolkit.Aspects.Builders,OverloadAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\OverloadAspectBuilder.cs,GetOverloadedMethod,The length of the statement  "	const BindingFlags bindingFlags = BindingFlags.Static | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic; " is 125.
Long Statement,BLToolkit.Aspects.Builders,ClearCacheAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\ClearCacheAspectBuilder.cs,Build,The length of the statement  "		emit.ldsfld (type).brtrue_s (checkType).ldarg_0.LoadType (_declaringType).call (typeof(ClearCacheAspect)' "GetType"' typeof(object)' typeof(Type)).stsfld (type).MarkLabel (checkType).ldsfld (type).call (typeof(CacheAspect)' "ClearCache"' typeof(Type)); " is 252.
Long Statement,BLToolkit.Aspects.Builders,ClearCacheAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\ClearCacheAspectBuilder.cs,Build,The length of the statement  "		FieldBuilder methodInfo = Context.CreatePrivateStaticField ("_methodInfo$ClearCacheAspect$" + ++_methodCounter' typeof(MethodInfo)); " is 132.
Long Statement,BLToolkit.Aspects.Builders,ClearCacheAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\ClearCacheAspectBuilder.cs,Build,The length of the statement  "		emit.call (typeof(ClearCacheAspect)' "GetMethodInfo"' typeof(object)' typeof(Type)' typeof(string)' typeof(Type[])).stsfld (methodInfo).MarkLabel (checkMethodInfo).ldsfld (methodInfo).call (typeof(CacheAspect)' "ClearCache"' typeof(MethodInfo)); " is 245.
Long Statement,BLToolkit.Aspects,CacheAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,AfterCall,The length of the statement  "		MaxCacheTime = maxCacheTime == int.MaxValue || maxCacheTime < 0 ? DateTime.MaxValue : DateTime.Now.AddMilliseconds (maxCacheTime)' " is 130.
Long Statement,BLToolkit.Aspects,CacheAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,GetMethodInfo,The length of the statement  "	var methodInfo = declaringType.GetMethod (methodName' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' parameterTypes' null); " is 152.
Long Statement,BLToolkit.Aspects,CacheAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,GetMethodInfo,The length of the statement  "		methodInfo = declaringType.GetMethod (methodName' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 120.
Long Statement,BLToolkit.Aspects,CounterAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\CounterAspect.cs,GetCounter,The length of the statement  "			if ((methodInfo.DeclaringType == c.MethodInfo.DeclaringType || methodInfo.DeclaringType == c.MethodInfo.DeclaringType.BaseType) && methodInfo.Name == c.MethodInfo.Name) { " is 170.
Long Statement,BLToolkit.Aspects,LoggingAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\LoggingAspect.cs,LogOperationInternal,The length of the statement  "		LogOutput (string.Format ("{0}: {1}.{2}({3}) - {4} ms{5}{6}."' end' info.CallMethodInfo.MethodInfo.DeclaringType.FullName' info.CallMethodInfo.MethodInfo.Name' callParameters' time' info.Cached ? " from cache" : null' exText)' parameters.FileName); " is 248.
Long Statement,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "	return p == null ? Configuration.NullableValues.DateTime : DateTime.Parse (p' null' DateTimeStyles.NoCurrentDateDefault); " is 121.
Long Statement,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The length of the statement  "	return p == null || p.Length == 0 ? Configuration.NullableValues.DateTime : DateTime.FromBinary (ToInt64 (p.ToArray ())); " is 121.
Long Statement,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The length of the statement  "	return p == null || p.Length == 0 ? Configuration.NullableValues.TimeSpan : TimeSpan.FromTicks (ToInt64 (p.ToArray ())); " is 120.
Long Statement,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,CreateInvalidCastException,The length of the statement  "	return new InvalidCastException (string.Format (Resources.Convert_InvalidCast' originalType.FullName' conversionType.FullName)); " is 128.
Long Statement,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,GetConverter,The length of the statement  "	var mi = typeof(Convert).GetMethod (methodName' BindingFlags.Public | BindingFlags.Static | BindingFlags.ExactBinding' null' new[] { " is 132.
Long Statement,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,GetConverter,The length of the statement  "		mi = typeof(NullableConvert<' >).MakeGenericType (toType' fromType).GetMethod (methodName' BindingFlags.Public | BindingFlags.Static); " is 134.
Long Statement,BLToolkit.Common,Tuple,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,Equals,The length of the statement  "		return (Field1 == null ? t.Field1 == null : Field1.Equals (t.Field1)) && (Field2 == null ? t.Field2 == null : Field2.Equals (t.Field2)); " is 136.
Long Statement,BLToolkit.Common,Tuple,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,Equals,The length of the statement  "		return (Field1 == null ? t.Field1 == null : Field1.Equals (t.Field1)) && (Field2 == null ? t.Field2 == null : Field2.Equals (t.Field2)) && (Field3 == null ? t.Field3 == null : Field3.Equals (t.Field3)); " is 202.
Long Statement,BLToolkit.Common,Tuple,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,Equals,The length of the statement  "		return (Field1 == null ? t.Field1 == null : Field1.Equals (t.Field1)) && (Field2 == null ? t.Field2 == null : Field2.Equals (t.Field2)) && (Field3 == null ? t.Field3 == null : Field3.Equals (t.Field3)) && (Field4 == null ? t.Field4 == null : Field4.Equals (t.Field4)); " is 268.
Long Statement,BLToolkit.DataAccess,DataAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorTA.cs,GetParameter,The length of the statement  "	Debug.WriteLineIf (p.Direction == ParameterDirection.Input' string.Format ("'{0}.{1}' is an input parameter."' db.Command.CommandText' paramName)); " is 147.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetReturnType,The length of the statement  "	if (!returnType.IsArray && (IsInterfaceOf (returnType' typeof(IList)) || returnType.IsGenericType && returnType.GetGenericTypeDefinition () == typeof(IList<>))) " is 160.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetReturnType,The length of the statement  "	if (IsInterfaceOf (returnType' typeof(IDictionary)) || returnType.IsGenericType && returnType.GetGenericTypeDefinition () == typeof(IDictionary<' >)) " is 149.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetReturnType,The length of the statement  "	if (returnType == typeof(IEnumerable) || returnType.IsGenericType && returnType.GetGenericTypeDefinition () == typeof(IEnumerable<>)) " is 133.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ThrowTypeBuilderException,The length of the statement  "	throw new TypeBuilderException (string.Format (message' Context.CurrentMethod.DeclaringType.Name' Context.CurrentMethod.Name)); " is 127.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteReader,The length of the statement  "		Context.MethodBuilder.Emitter.callvirt (typeof(DbManager).GetMethod ("ExecuteReader"' Type.EmptyTypes)).stloc (Context.ReturnValue); " is 132.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteReader,The length of the statement  "		Context.MethodBuilder.Emitter.ldc_i4_ ((int)((CommandBehaviorAttribute)attrs [0]).CommandBehavior).callvirt (typeof(DbManager)' "ExecuteReader"' typeof(CommandBehavior)).stloc (Context.ReturnValue); " is 198.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteDataSet,The length of the statement  "			emit.ldNameOrIndex (((DataSetTableAttribute)attrs [0]).NameOrIndex).callvirt (typeof(DbManager)' "ExecuteDataSet"' typeof(DataSet)' typeof(NameOrIndexParameter)).pop.end (); " is 173.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteDataSet,The length of the statement  "		emit.callvirt (typeof(DataSet).GetProperty ("Tables").GetGetMethod ()).callvirt (typeof(InternalDataCollectionBase).GetProperty ("Count").GetGetMethod ()).ldc_i4_0.ble_s (l1).ldloc (_locManager); " is 195.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteDataSet,The length of the statement  "			emit.callvirt (typeof(DataSet).GetProperty ("Tables").GetGetMethod ()).ldc_i4_0.callvirt (typeof(DataTableCollection)' "get_Item"' typeof(int)).callvirt (typeof(DataTable).GetProperty ("TableName").GetGetMethod ()).call (typeof(NameOrIndexParameter)' "op_Implicit"' typeof(string)); " is 282.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteDataSet,The length of the statement  "		emit.callvirt (typeof(DbManager)' "ExecuteDataSet"' typeof(DataSet)' typeof(NameOrIndexParameter)).pop.br_s (l2).MarkLabel (l1).ldloc (_locManager); " is 148.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteDataTable,The length of the statement  "			throw new TypeBuilderException (string.Format (Resources.DataAccessorBuilder_DataSetTableMustBeByName' Context.CurrentMethod.DeclaringType.Name' Context.CurrentMethod.Name)); " is 174.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteScalarList,The length of the statement  "		Context.MethodBuilder.Emitter.ldloc (_locObjType).callvirt (typeof(DbManager)' "ExecuteScalarList"' typeof(IList)' typeof(Type)).pop.end (); " is 140.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteScalarList,The length of the statement  "		Context.MethodBuilder.Emitter.ldloc (_locObjType).ldNameOrIndex (((ScalarFieldNameAttribute)attrs [0]).NameOrIndex).callvirt (typeof(DbManager)' "ExecuteScalarList"' typeof(IList)' typeof(Type)' typeof(NameOrIndexParameter)).pop.end (); " is 236.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteList,The length of the statement  "	Context.MethodBuilder.Emitter.CastIfNecessary (typeof(IList)' MethodReturnType).ldloc (_locObjType).callvirt (typeof(DbManager)' "ExecuteList"' typeof(IList)' typeof(Type)).pop.end (); " is 184.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetIndexField,The length of the statement  "	var id = "index$" + string.Join ("%"' Array.ConvertAll<NameOrIndexParameter' string> (namesOrIndexes' delegate (NameOrIndexParameter nameOrIndex) { " is 147.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteScalarDictionaryWithPK,The length of the statement  "	Context.MethodBuilder.Emitter.ldloc (_locObjType).LoadType (keyType).ldstr (Context.CurrentMethod.Name).ldNameOrIndex (scalarField).LoadType (elementType).callvirt (_baseType' "ExecuteScalarDictionary"' _bindingFlags' typeof(DbManager)' typeof(IDictionary)' typeof(Type)' typeof(Type)' typeof(string)' typeof(NameOrIndexParameter)' typeof(Type)); " is 346.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteScalarDictionaryWithMapIndex,The length of the statement  "	Context.MethodBuilder.Emitter.ldsfld (GetIndexField (index)).ldNameOrIndex (scalarField).ldloc (_locObjType).callvirt (typeof(DbManager)' "ExecuteScalarDictionary"' typeof(IDictionary)' typeof(MapIndex)' typeof(NameOrIndexParameter)' typeof(Type)).pop.end (); " is 259.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteScalarDictionaryWithScalarKey,The length of the statement  "	Context.MethodBuilder.Emitter.ldNameOrIndex (keyField).LoadType (keyType).ldNameOrIndex (scalarField).ldloc (_locObjType).callvirt (typeof(DbManager)' "ExecuteScalarDictionary"' typeof(IDictionary)' typeof(NameOrIndexParameter)' typeof(Type)' typeof(NameOrIndexParameter)' typeof(Type)).pop.end (); " is 298.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteDictionaryWithPK,The length of the statement  "		emit.ldloc (_locObjType).LoadType (keyType).ldstr (Context.CurrentMethod.Name).callvirt (_baseType' "ExecuteDictionary"' _bindingFlags' typeof(DbManager)' typeof(IDictionary)' typeof(Type)' typeof(Type)' typeof(string)); " is 220.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteDictionaryWithMapIndex,The length of the statement  "	Context.MethodBuilder.Emitter.ldsfld (GetIndexField (index)).ldloc (_locObjType).ldnull.callvirt (typeof(DbManager)' "ExecuteDictionary"' typeof(IDictionary)' typeof(MapIndex)' typeof(Type)' typeof(object[])).pop.end (); " is 220.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteDictionaryWithScalarKey,The length of the statement  "		MethodInfo method = typeof(DbManager).GetMethod ("ExecuteDictionary"' _bindingFlags' GenericBinder.Generic' types' null).MakeGenericMethod (genericArgs); " is 153.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteDictionaryWithScalarKey,The length of the statement  "		emit.ldNameOrIndex (keyField).ldloc (_locObjType).ldnull.callvirt (typeof(DbManager)' "ExecuteDictionary"' typeof(IDictionary)' typeof(NameOrIndexParameter)' typeof(Type)' typeof(object[])).pop.end (); " is 201.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteEnumerable,The length of the statement  "	MethodInfo method = _baseType.GetMethod ("ExecuteEnumerable"' _bindingFlags' GenericBinder.Generic' types' null).MakeGenericMethod (genericArgs); " is 145.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteScalar,The length of the statement  "			throw new TypeBuilderException (string.Format (Resources.DataAccessorBuilder_IncompatibleDestinationType' returnType.FullName' Context.CurrentMethod.Name' scalarType.FullName)); " is 177.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteScalar,The length of the statement  "		emit.ldc_i4_ ((int)attr.ScalarType).ldNameOrIndex (attr.NameOrIndex).callvirtNoGenerics (typeof(DbManager)' "ExecuteScalar"' typeof(ScalarSourceType)' typeof(NameOrIndexParameter)); " is 181.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,ExecuteScalar,The length of the statement  "		emit.LoadType (scalarType).ldnull.callvirt (_baseType' "ConvertChangeType"' _bindingFlags' typeof(DbManager)' typeof(object)' typeof(Type)' typeof(object)).unboxIfValueType (scalarType); " is 186.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,Finally,The length of the statement  "		Context.MethodBuilder.Emitter.BeginFinallyBlock ().ldarg_0.ldloc (_locManager).callvirt (_baseType' "Dispose"' _bindingFlags' typeof(DbManager)).EndExceptionBlock (); " is 166.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,CreateReturnTypeInstance,The length of the statement  "		Context.MethodBuilder.Emitter.ldarg (_destination).CastIfNecessary (Context.ReturnValue.LocalType' _destination.ParameterType).stloc (Context.ReturnValue); " is 155.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,CreateReturnTypeInstance,The length of the statement  "			throw new TypeBuilderException (string.Format (Resources.DataAccessorBuilder_CantCreateTypeInstance' Context.CurrentMethod.ReturnType.FullName)); " is 145.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetSprocNameOrSqlQueryTest,The length of the statement  "			emit.ldsfld (field).brtrue_s (isNull).ldarg_0.call (typeof(MethodBase)' "GetCurrentMethod").castclass (typeof(MethodInfo)).callvirt (_baseType' "GetSqlQueryAttribute"' _bindingFlags' typeof(MethodInfo)).stsfld (field).MarkLabel (isNull).ldsfld (field).ldarg_0.ldloc (_locManager).callvirt (attrType' "GetSqlText"' _bindingFlags' typeof(DataAccessor)' typeof(DbManager)); " is 370.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetSprocNameOrSqlQueryTest,The length of the statement  "			emit.callvirt (_baseType' "PrepareSqlQuery"' _bindingFlags' typeof(DbManager)' typeof(int)' typeof(int)' typeof(string)); " is 121.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetSprocNameOrSqlQueryTest,The length of the statement  "			emit.ldloc (_locManager).ldarg_0.ldloc (_locObjType).ldstr (actionName).callvirt (_baseType' "GetSpName"' _bindingFlags' typeof(Type)' typeof(string)); " is 151.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildParameters,The length of the statement  "	emit.ldarg_0.ldloc (_locManager).ldloc (locParams).callvirt (_baseType' "PrepareParameters"' _bindingFlags' typeof(DbManager)' typeof(object[])).stloc (retParams); " is 163.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildSimpleParameters,The length of the statement  "	LocalBuilder locParams = emit.DeclareLocal (_sqlQueryAttribute == null ? typeof(object[]) : typeof(IDbDataParameter[])); " is 120.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,CreateNullValueField,The length of the statement  "		emit.LoadType (type).call (typeof(TypeDescriptor)' "GetConverter"' typeof(Type)).ldstr (value).callvirt (typeof(TypeConverter)' "ConvertFromInvariantString"' typeof(string)).unbox_any (type).stsfld (fieldBuilder); " is 213.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildRefParameters,The length of the statement  "			var type = pi.ParameterType == typeof(DataRow) || pi.ParameterType.IsSubclassOf (typeof(DataRow)) ? typeof(DataRow) : typeof(object); " is 133.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildRefParameters,The length of the statement  "			emit.ldnull.callvirt (_baseType' "CreateParameters"' _bindingFlags' typeof(DbManager)' type' typeof(string[])' typeof(string[])' typeof(string[])' typeof(IDbDataParameter[])); " is 175.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildParameter,The length of the statement  "	ParameterDirection direction = !type.IsByRef ? ParameterDirection.Input : pi.IsOut ? ParameterDirection.Output : ParameterDirection.InputOutput; " is 144.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildParameter,The length of the statement  "		emit.ldarg_0.ldloc (_locManager).ldstr (paramName).callvirt (_baseType' methodName' _bindingFlags' typeof(DbManager)' typeof(string)); " is 134.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildParameter,The length of the statement  "		emit.ldstr (((ParamTypeNameAttribute)attrs [0]).TypeName).callvirt (typeof(DbManager)' "Parameter"' typeof(ParameterDirection)' typeof(string)' typeof(object)' typeof(string)); " is 176.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildParameter,The length of the statement  "		emit.dup.ldc_i4_ ((int)((ParamDbTypeAttribute)attrs [0]).DbType).callvirt (typeof(IDataParameter)' "set_DbType"' typeof(DbType)); " is 129.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,StoreParameterValue,The length of the statement  "		emit.ldarg_0.ldloc (_locManager).ldloc (param).callvirt (typeof(IDataParameter).GetProperty ("Value").GetGetMethod ()).ldloc (param).callvirt (_baseType' "IsNull"' _bindingFlags' typeof(DbManager)' typeof(object)' typeof(object)).brtrue (labelNull); " is 249.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,StoreParameterValue,The length of the statement  "		emit.ldloc (_locManager).callvirt (typeof(DbManager).GetProperty ("MappingSchema").GetGetMethod ()).ldloc (param).callvirt (typeof(IDataParameter).GetProperty ("Value").GetGetMethod ()).LoadType (type).callvirt (typeof(MappingSchema)' "MapValueToEnum"' typeof(object)' typeof(Type)).CastFromObject (type); " is 305.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,StoreParameterValue,The length of the statement  "		emit.ldloc (_locManager).callvirt (typeof(DbManager).GetProperty ("DataProvider").GetGetMethod ()).ldloc (param).callvirt (typeof(IDataParameter).GetProperty ("Value").GetGetMethod ()).callvirt (typeof(DataProviderBase)' "GetRefCursorDataReader"' typeof(object)).CastFromObject (typeof(IDataReader)).stloc (dataReader); " is 319.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,StoreParameterValue,The length of the statement  "		emit.ldloc (_locManager).callvirt (typeof(DbManager).GetProperty ("MappingSchema").GetGetMethod ()).ldloc (dataReader).ldnull.callvirt (mapDataReaderToListMethodInfo); " is 167.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,StoreParameterValue,The length of the statement  "			emit.LoadType (type).ldloc (param).callvirt (_baseType' "ConvertChangeType"' _bindingFlags' typeof(DbManager)' typeof(object)' typeof(Type)' typeof(object)).unboxIfValueType (type); " is 181.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetOutRefParameters,The length of the statement  "				emit.ldarg_0.ldloc (_locManager).ldstr (paramName).callvirt (_baseType' methodName' _bindingFlags' typeof(DbManager)' typeof(string)); " is 134.
Long Statement,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetOutRefParameters,The length of the statement  "		emit.ldloc (_locManager).ldstrEx (v.ReturnValueMember).ldarg (v.ParameterInfo).callvirt (typeof(DbManager)' "MapOutputParameters"' typeof(string)' typeof(object)); " is 163.
Long Statement,BLToolkit.DataAccess,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQuery.cs,Insert,The length of the statement  "	return db.DataProvider.InsertBatch (db' query.QueryText' list' query.GetMemberMappers ()' maxBatchSize' obj => query.GetParameters (db' obj)); " is 142.
Long Statement,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,AddWherePK,The length of the statement  "		throw new DataAccessException (string.Format ("No primary key field(s) in the type '{0}'."' query.ObjectType.FullName)); " is 120.
Long Statement,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,AddWherePK,The length of the statement  "		var p = query.AddParameter (db.DataProvider.Convert (mm.Name + "_W"' ConvertType.NameToQueryParameter).ToString ()' mm.Name); " is 125.
Long Statement,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,AppendTableName,The length of the statement  "	db.DataProvider.CreateSqlProvider ().BuildTableName (sb' database == null ? null : db.DataProvider.Convert (database' ConvertType.NameToDatabase).ToString ()' owner == null ? null : db.DataProvider.Convert (owner' ConvertType.NameToOwner).ToString ()' name == null ? null : db.DataProvider.Convert (name' ConvertType.NameToQueryTable).ToString ()); " is 348.
Long Statement,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateInsertSqlText,The length of the statement  "		var p = query.AddParameter (db.DataProvider.Convert (mm.Name + "_P"' ConvertType.NameToQueryParameter).ToString ()' mm.Name); " is 125.
Long Statement,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateUpdateSqlText,The length of the statement  "		var p = query.AddParameter (db.DataProvider.Convert (mm.Name + "_P"' ConvertType.NameToQueryParameter).ToString ()' mm.Name); " is 125.
Long Statement,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateUpdateSqlText,The length of the statement  "		throw new DataAccessException (string.Format ("There are no fields to update in the type '{0}'."' query.ObjectType.FullName)); " is 126.
Long Statement,BLToolkit.DataAccess,SqlQueryInfo,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryInfo.cs,GetParameters,The length of the statement  "			parameters [i] = mmi.IsDbSizeSet ? db.Parameter (info.ParameterName' val' info.MemberMapper.DbType' mmi.DbSize) : db.Parameter (info.ParameterName' val' info.MemberMapper.DbType); " is 179.
Long Statement,BLToolkit.DataAccess,SqlQueryInfo,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryInfo.cs,GetParameters,The length of the statement  "			parameters [i] = val != DBNull.Value ? db.Parameter (info.ParameterName' val) : db.Parameter (info.ParameterName' val' info.MemberMapper.GetDbType ()); " is 151.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteReaderInternal,The length of the statement  "	return ExecuteOperation (OperationType.ExecuteReader' () => _dataProvider.GetDataReader (_mappingSchema' SelectCommand.ExecuteReader (commandBehavior))); " is 153.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateSpParameters,The length of the statement  "	if (parameterValues == null || parameterValues.Length == 0 || parameterValues [0] is IDbDataParameter || parameterValues [0] is IDbDataParameter[]) { " is 149.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateSpParameters,The length of the statement  "					var convertedParameterName = _dataProvider.Convert (paramWithValue.ParameterName' ConvertType.NameToSprocParameter).ToString (); " is 128.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateSpParameters,The length of the statement  "						WriteTraceLine (string.Format ("Stored Procedure '{0}'. Parameter '{1}' has different direction '{2}'. Should be '{3}'."' spName' spParamName' spParam.Direction' paramWithValue.Direction)' TraceSwitch.DisplayName); " is 214.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateSpParameters,The length of the statement  "			if (found == false && (spParam.Direction == ParameterDirection.Input || spParam.Direction == ParameterDirection.InputOutput)) { " is 127.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateSpParameters,The length of the statement  "					WriteTraceLine (string.Format ("Stored Procedure '{0}'. Parameter '{1}' not assigned."' spName' spParamName)' TraceSwitch.DisplayName); " is 135.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,AssignParameterValues,The length of the statement  "				throw new ArgumentException (string.Format ("Parsing for {0} failed: {1}"' spName' GetMissedColumnNames (index' commandParameters))); " is 133.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,AssignParameterValues,The length of the statement  "		throw new ArgumentException (string.Format ("Parsing for {0} failed: {1}"' spName' GetExceedParameters (nValues' parameterValues))); " is 132.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,AssignParameterValues,The length of the statement  "			//						value == null || (mm.MapMemberInfo.Nullable && !TypeHelper.IsNullable(mm.MapMemberInfo.Type)  && _mappingSchema.IsNull(value))? " is 135.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateParameters,The length of the statement  "		var parameter = c.AllowDBNull ? NullParameter (name' dataRow [c.ColumnName]) : Parameter (name' dataRow [c.ColumnName]); " is 120.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateParameters,The length of the statement  "		var parameter = value == null ? NullParameter (name' value' mm.MapMemberInfo.NullValue) : (mm.DbType != DbType.Object) ? Parameter (name' value' mm.DbType) : Parameter (name' value); " is 182.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,MapOutputParameters,The length of the statement  "			ordinal = dest.GetOrdinal (_dataProvider.Convert (parameter.ParameterName' ConvertType.SprocParameterToName).ToString ()); " is 122.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,GetConvertTypeToParameter,The length of the statement  "	return Command.CommandType == CommandType.StoredProcedure ? ConvertType.NameToSprocParameter : ConvertType.NameToCommandParameter; " is 130.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,SetSpCommand,The length of the statement  "	return SetCommand (commandAction' CommandType.StoredProcedure' spName' CreateSpParameters (spName' parameterValues' openNewConnectionToDiscoverParameters)); " is 156.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,SetSpCommand,The length of the statement  "	return SetCommand (commandAction' CommandType.StoredProcedure' spName' CreateSpParameters (spName' parameterValues' Configuration.OpenNewConnectionToDiscoverParameters)); " is 170.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The length of the statement  "	var maxRows = Math.Max (Math.Min (Math.Max (members.Length == 0 ? 1000 : _dataProvider.MaxParameters / members.Length' members.Length)' maxBatchSize)' 1); " is 154.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The length of the statement  "			sb.Append ("\n").AppendFormat (baseSql' Array.ConvertAll (baseParameters' baseParameters.Length > 0 && baseParameters [0].ParameterName != paramName ? c1 : c2)); " is 161.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The length of the statement  "				if ((value == null || value == DBNull.Value) && (dbType == DbType.Binary || type == typeof(byte[])) || type == typeof(System.Data.Linq.Binary)) { " is 145.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The length of the statement  "					p = value != null ? Parameter (baseParameters [i].ParameterName + nRows' value) : Parameter (baseParameters [i].ParameterName + nRows' DBNull.Value' members [i].GetDbType ()); " is 175.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The length of the statement  "	return nameOrIndex.ByName ? ExecuteForEach (dataSet.Tables [nameOrIndex.Name]) : ExecuteForEach (dataSet.Tables [nameOrIndex.Index]); " is 133.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteArray,The length of the statement  "	return ExecuteOperation<int> (OperationType.ExecuteNonQuery' () => DataProvider.ExecuteArray (SelectCommand' iterations)); " is 122.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteObjectInternal,The length of the statement  "				return entity == null ? _mappingSchema.MapDataReaderToObject (dr' type' parameters) : _mappingSchema.MapDataReaderToObject (dr' entity' parameters); " is 148.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,Update,The length of the statement  "	return ExecuteOperation (OperationType.Update' () => (table.ByName) ? da.Update (dataSet' table.Name) : da.Update (dataSet.Tables [table.Index])); " is 146.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,IsMatchedConfigurationString,The length of the statement  "	return !configurationString.StartsWith (AnyProvider) && (dividerPos = configurationString.IndexOf (ProviderNameDivider)) >= 0 && 0 == StringComparer.OrdinalIgnoreCase.Compare (configurationString.Substring (dividerPos + ProviderNameDivider.Length)' csWithoutProvider); " is 268.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,GetConnectionString,The length of the statement  "			var key = string.Format ("ConnectionString{0}{1}"' configurationString.Length == 0 ? String.Empty : ProviderNameDivider' configurationString); " is 142.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,GetParameters,The length of the statement  "				var parm = parameters.Length > i && parameters [i] == sqlp ? parameters [i] : parameters.FirstOrDefault (p => p == sqlp); " is 121.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteNonQuery,The length of the statement  "		WriteTraceLine (string.Format ("Execution time: {0}. Records affected: {1}.\r\n"' DateTime.Now - now' n)' TraceSwitch.DisplayName); " is 131.
Long Statement,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,GetSqlText,The length of the statement  "			sb.Append ("-- DECLARE ").Append (p.ParameterName).Append (' ').Append (p.Value == null ? p.DbType.ToString () : p.Value.GetType ().Name).AppendLine (); " is 152.
Long Statement,BLToolkit.Data.DataProvider,DataProviderVersionResolverBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderVersionResolverBase.cs,AddDataProvider,The length of the statement  "		throw new ArgumentException (string.Format (Resources.DataProviderVersionResolverBase_InvalidProviderType' providerType.FullName' _baseProviderType.FullName)); " is 159.
Long Statement,BLToolkit.Data.DataProvider,DataProviderVersionResolverBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderVersionResolverBase.cs,InvalidateDataProvider,The length of the statement  "		throw new InvalidOperationException (string.Format (Resources.DataProviderVersionResolverBase_ProviderIsNotRegistered' dataProvider.UniqueName' dataProviderType.FullName)); " is 172.
Long Statement,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionString,The length of the statement  "	return string.Format ("Data Source=(DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = {0})(PORT = {1})))(CONNECT_DATA = (SID = {2})));User Id={3};Password={4};"' server' port' sid' userName' password); " is 216.
Long Statement,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionStringWithoutPooling,The length of the statement  "	return string.Format ("Data Source=(DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = {0})(PORT = {1})))(CONNECT_DATA = (SID = {2})));User Id={3};Password={4};Pooling=False;"' server' port' sid' userName' password); " is 230.
Long Statement,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionString,The length of the statement  "	return string.Format ("Data Source=(DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = {0})(PORT = {1})))(CONNECT_DATA = (SID = {2})));User Id={3};Password={4};Connection Timeout={5};"' server' port' sid' userName' password' (int)timeOut.TotalSeconds); " is 266.
Long Statement,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,GetFullConnectionStringWithoutPooling,The length of the statement  "	return string.Format ("Data Source=(DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = {0})(PORT = {1})))(CONNECT_DATA = (SID = {2})));User Id={3};Password={4};Connection Timeout={5};Pooling=False;"' server' port' sid' userName' password' (int)timeOut.TotalSeconds); " is 280.
Long Statement,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,Interpret,The length of the statement  "			strQuery = strQuery.Replace (strParameter + " "' dt.Date == dt ? SqlConvertDate (dt) + " " : SqlConvertDateTime (dt) + " "); " is 124.
Long Statement,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,Interpret,The length of the statement  "		Debug.WriteLine ("Number of parameters in query is not equals to number of parameters set in the command object " + poCommand.CommandText); " is 139.
Long Statement,BLToolkit.Data.DataProvider,OracleHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OracleHelper.cs,Interpret,The length of the statement  "		var msg = "Number of parameters in query is not equals to number of parameters set in the command object : " + poCommand.CommandText + "\r\n" + "Query params :\r\n"; " is 165.
Long Statement,BLToolkit.Data.DataProvider,Sql2008DataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\Sql2008DataProvider.cs,SetUdtTypeName,The length of the statement  "		sqlParameter.UdtTypeName = _udtTypeNameResolvers.Select (_ => _ (valueType)).FirstOrDefault (_ => !string.IsNullOrEmpty (_)); " is 125.
Long Statement,BLToolkit.Data.DataProvider,Sql2012DataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\Sql2012DataProvider.cs,SetUdtTypeName,The length of the statement  "		sqlParameter.UdtTypeName = _udtTypeNameResolvers.Select (_ => _ (valueType)).FirstOrDefault (_ => !string.IsNullOrEmpty (_)); " is 125.
Long Statement,BLToolkit.Data.DataProvider,AccessDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,DeriveParameters,The length of the statement  "			_paramsExp = new Regex (@"PARAMETERS ((\[(?<name>[^\]]+)\]|(?<name>[^\s]+))\s(?<type>[^';\s]+(\s\([^\)]+\))?)[';]\s)*"' RegexOptions.Compiled | RegexOptions.ExplicitCapture); " is 174.
Long Statement,BLToolkit.Data.DataProvider,AccessDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,GetDataReader,The length of the statement  "	return dataReader is OleDbDataReader ? new DataReaderEx ((OleDbDataReader)dataReader) : base.GetDataReader (schema' dataReader); " is 128.
Long Statement,BLToolkit.Data.DataProvider,DataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderBase.cs,GetParameter,The length of the statement  "	return (IDbDataParameter)(nameOrIndex.ByName ? command.Parameters [nameOrIndex.Name] : command.Parameters [nameOrIndex.Index]); " is 127.
Long Statement,BLToolkit.Data.DataProvider,DataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderBase.cs,ExecuteArray,The length of the statement  "	var outParameters = parameters.Where (p => p.Parameter.Direction == ParameterDirection.InputOutput || p.Parameter.Direction == ParameterDirection.Output).ToArray (); " is 165.
Long Statement,BLToolkit.Data.DataProvider,DataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderBase.cs,ExecuteArray,The length of the statement  "			throw new InvalidOperationException ("ExecuteArray requires that all " + "parameter values are arrays. Parameter name: " + p.Parameter.ParameterName); " is 150.
Long Statement,BLToolkit.Data.DataProvider,DataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\DataProviderBase.cs,ExecuteArray,The length of the statement  "			throw new InvalidOperationException ("ExecuteArray requires that array sizes are " + "equal to the number of iterations. Parameter name: " + p.Parameter.ParameterName); " is 168.
Long Statement,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,IsMarsEnabled,The length of the statement  "		return conn.ConnectionString.Split (';').Select (s => s.Split ('=')).Where (s => s.Length == 2 && s [0].Trim ().ToLower () == "multipleactiveresultsets").Select (s => s [1].Trim ().ToLower ()).Any (s => s == "true" || s == "1" || s == "yes"); " is 242.
Long Statement,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,GetDataReader,The length of the statement  "	return dataReader is SqlDataReader ? new SqlDataReaderEx ((SqlDataReader)dataReader) : base.GetDataReader (schema' dataReader); " is 127.
Long Statement,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,InsertBatch,The length of the statement  "	var bc = new SqlBulkCopy ((SqlConnection)db.Connection' SqlDataProvider.SqlBulkCopyOptions' (SqlTransaction)db.Transaction) { " is 125.
Long Statement,BLToolkit.Data.DataProvider.Interpreters,OracleDataProviderInterpreter,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\Interpreters\OracleDataProviderInterpreter.cs,GetInsertBatchSqlListWithInsertAll,The length of the statement  "		string strItem = "\t" + insertText.Replace ("INSERT INTO"' "INTO").Replace ("\r"' "").Replace ("\n"' "").Replace ("\t"' " ").Replace ("( "' "("); " is 145.
Long Statement,BLToolkit.Data.Linq.Builder,ConcatUnionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ConcatUnionBuilder.cs,BuildMethodCall,The length of the statement  "	var sequence2 = new SubQueryContext (builder.BuildSequence (new BuildInfo (buildInfo' methodCall.Arguments [1]' new SqlQuery ()))); " is 131.
Long Statement,BLToolkit.Data.Linq.Builder,InsertOrUpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertOrUpdateBuilder.cs,BuildMethodCall,The length of the statement  "	UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' sequence' sequence.SqlQuery.Insert.Items' sequence); " is 153.
Long Statement,BLToolkit.Data.Linq.Builder,InsertOrUpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertOrUpdateBuilder.cs,BuildMethodCall,The length of the statement  "	UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence); " is 153.
Long Statement,BLToolkit.Data.Linq.Builder,InsertOrUpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertOrUpdateBuilder.cs,BuildMethodCall,The length of the statement  "			throw new LinqException ("InsertOrUpdate method requires the '{0}.{1}' field to be included in the insert setter."' table.Name' ((SqlField)missedKey).Name); " is 156.
Long Statement,BLToolkit.Data.Linq.Builder,InsertOrUpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertOrUpdateBuilder.cs,BuildMethodCall,The length of the statement  "		UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [3].Unwrap ()' sequence' sequence.SqlQuery.Update.Keys' sequence); " is 152.
Long Statement,BLToolkit.Data.Linq.Builder,OfTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\OfTypeBuilder.cs,MakeIsPredicate,The length of the statement  "	var discriminators = TableBuilder.TableContext.GetInheritanceDiscriminators (builder' table' fromType' mapper.InheritanceMapping); " is 130.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildExpression,The length of the statement  "		var ps = le.Parameters.Select (p => (GetTypeName (p.Type) + " " + p.Name).TrimStart ()).Aggregate (""' (p1' p2) => p1 + "' " + p2' p => p.TrimStart ('''' ' ')); " is 160.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildType,The length of the statement  "	if (type.Namespace != null && type.Namespace.StartsWith ("System") || IsAnonymous (type) || type.Assembly == GetType ().Assembly || type.IsGenericType && type.GetGenericTypeDefinition () != type) " is 195.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildType,The length of the statement  "		return string.Format ("{0}\n\t\tpublic {1}({2})\n\t\t{{\n\t\t\tthrow new NotImplementedException();\n\t\t}}"' attrs.Count > 0 ? attrs.Select (a => "\n\t\t" + a.ToString ()).Aggregate ((a1' a2) => a1 + a2) : ""' name' ps.Length == 0 ? "" : ps.Aggregate ((s' t) => s + "' " + t)); " is 278.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildType,The length of the statement  "		return string.Format ("{0}\n\t\tpublic {1} {2};"' attrs.Count > 0 ? attrs.Select (a => "\n\t\t" + a.ToString ()).Aggregate ((a1' a2) => a1 + a2) : ""' GetTypeName (f.FieldType)' f.Name); " is 186.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildType,The length of the statement  "		return string.Format ("{0}\n\t\t{3}{1} {2} {{ get; set; }}"' attrs.Count > 0 ? attrs.Select (a => "\n\t\t" + a.ToString ()).Aggregate ((a1' a2) => a1 + a2) : ""' GetTypeName (p.PropertyType)' p.Name' type.IsInterface ? "" : "public "); " is 235.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildType,The length of the statement  "		return string.Format ("{0}\n\t\t{5}{4}{1} {2}({3})\n\t\t{{\n\t\t\tthrow new NotImplementedException();\n\t\t}}"' attrs.Count > 0 ? attrs.Select (a => "\n\t\t" + a.ToString ()).Aggregate ((a1' a2) => a1 + a2) : ""' GetTypeName (m.ReturnType)' m.Name' ps.Length == 0 ? "" : ps.Aggregate ((s' t) => s + "' " + t)' m.IsStatic ? "static " : m.IsVirtual ? "virtual " : m.IsAbstract ? "abstract " : ""' type.IsInterface ? "" : "public "); " is 431.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildType,The length of the statement  ""' type.Namespace' type.IsInterface ? "interface" : type.IsClass ? "class" : "struct"' name' type.IsGenericType ? GetTypeNames (type.GetGenericArguments ()' "'") : null' ctors.Count == 0 ? "" : ctors.Aggregate ((s' t) => s + "\n" + t)' baseClasses.Length == 0 ? "" : " : " + GetTypeNames (baseClasses)' type.IsPublic ? "public " : ""' type.IsAbstract && !type.IsInterface ? "abstract " : ""' attrs.Count > 0 ? attrs.Select (a => "\n\t" + a.ToString ()).Aggregate ((a1' a2) => a1 + a2) : ""' members.Length > 0 ? (ctors.Count != 0 ? "\n" : "") + members.Aggregate ((f1' f2) => f1 + "\n" + f2) : ""); " is 598.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,GetTypeNames,The length of the statement  "	return types.Select (GetTypeName).Aggregate (""' (t1' t2) => t1 + separator + t2' p => p.TrimStart (separator.ToCharArray ())); " is 127.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,GetTypeName,The length of the statement  "			name = string.Format ("{0}<{1}>"' name' args.Select (GetTypeName).Aggregate (""' (s' t) => s + "'" + t' p => p.TrimStart ('''))); " is 129.
Long Statement,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The length of the statement  "		BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence); " is 139.
Long Statement,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The length of the statement  "			sequence = builder.BuildWhere (buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' false); " is 120.
Long Statement,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The length of the statement  "			BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence); " is 139.
Long Statement,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The length of the statement  "			// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter) " is 135.
Long Statement,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The length of the statement  "			BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Update.Items' sequence); " is 135.
Long Statement,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildSetter,The length of the statement  "				BuildSetter (builder' into' items' ctx' (MemberInitExpression)ma.Expression' Expression.MakeMemberAccess (path' member)); " is 121.
Long Statement,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,ParseSet,The length of the statement  "	}).Where (m => m != null && !TypeHelper.IsNullableValueMember (m)).Select (m => m.Name).Aggregate ((s1' s2) => s1 + "." + s2); " is 126.
Long Statement,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,ParseSet,The length of the statement  "	}).Where (m => m != null && !TypeHelper.IsNullableValueMember (m)).Select (m => m.Name).Aggregate ((s1' s2) => s1 + "." + s2); " is 126.
Long Statement,BLToolkit.Data.Linq.Builder,DeleteBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\DeleteBuilder.cs,BuildMethodCall,The length of the statement  "		sequence = builder.BuildWhere (buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' false); " is 120.
Long Statement,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The length of the statement  "		UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' sequence' sequence.SqlQuery.Insert.Items' sequence); " is 153.
Long Statement,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The length of the statement  "	case 3:// static int Insert<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter) " is 142.
Long Statement,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The length of the statement  "		UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Insert.Items' sequence); " is 149.
Long Statement,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The length of the statement  "	var q = insert.Into.Fields.Values.Cast<ISqlExpression> ().Except (insert.Items.Select (e => e.Column)).OfType<SqlField> ().Where (f => f.IsIdentity); " is 149.
Long Statement,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The length of the statement  "	return new InsertContext (buildInfo.Parent' sequence' sequence.SqlQuery.Insert.WithIdentity || sequence.SqlQuery.Insert.WithOutput); " is 132.
Long Statement,BLToolkit.Data.Linq.Builder,SelectManyBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectManyBuilder.cs,CanBuildMethodCall,The length of the statement  "	return methodCall.IsQueryable ("SelectMany") && methodCall.Arguments.Count == 3 && ((LambdaExpression)methodCall.Arguments [1].Unwrap ()).Parameters.Count == 1; " is 160.
Long Statement,BLToolkit.Data.Linq.Builder,SelectManyBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectManyBuilder.cs,BuildMethodCall,The length of the statement  "	var crossApply = null != new QueryVisitor ().Find (sql' e => e.ElementType == QueryElementType.TableSource && sequenceTables.Contains ((ISqlTableSource)e) || e.ElementType == QueryElementType.SqlField && sequenceTables.Contains (((SqlField)e).Table) || e.ElementType == QueryElementType.Column && sequenceTables.Contains (((SqlQuery.Column)e).Parent)); " is 352.
Long Statement,BLToolkit.Data.Linq.Builder,SelectManyBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectManyBuilder.cs,BuildMethodCall,The length of the statement  "		var join = table.SqlTable.TableArguments != null && table.SqlTable.TableArguments.Length > 0 ? (leftJoin ? SqlQuery.OuterApply (sql) : SqlQuery.CrossApply (sql)) : (leftJoin ? SqlQuery.LeftJoin (sql) : SqlQuery.InnerJoin (sql)); " is 228.
Long Statement,BLToolkit.Data.Linq.Builder,SqlInfo,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SqlInfo.cs,CompareMembers,The length of the statement  "	return Members.Count == info.Members.Count && !Members.Where ((t' i) => !TypeHelper.Equals (t' info.Members [i])).Any (); " is 121.
Long Statement,BLToolkit.Data.Linq.Builder,SqlInfo,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SqlInfo.cs,CompareLastMember,The length of the statement  "	return Members.Count > 0 && info.Members.Count > 0 && TypeHelper.Equals (Members [Members.Count - 1]' info.Members [info.Members.Count - 1]); " is 141.
Long Statement,BLToolkit.Data.Linq.Builder,TakeSkipBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TakeSkipBuilder.cs,BuildTake,The length of the statement  "			var parm = (SqlParameter)sql.Select.SkipValue.Clone (new Dictionary<ICloneableElement' ICloneableElement> ()' _ => true); " is 121.
Long Statement,BLToolkit.Data.Linq.Builder,TakeSkipBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TakeSkipBuilder.cs,BuildTake,The length of the statement  "			sql.Select.Take (builder.Convert (sequence' new SqlBinaryExpression (typeof(int)' sql.Select.SkipValue' "+"' sql.Select.TakeValue' Precedence.Additive))); " is 154.
Long Statement,BLToolkit.Data.Linq.Builder,TakeSkipBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TakeSkipBuilder.cs,BuildSkip,The length of the statement  "			sql.Select.Take (builder.Convert (sequence' new SqlBinaryExpression (typeof(int)' sql.Select.TakeValue' "-"' sql.Select.SkipValue' Precedence.Additive))); " is 154.
Long Statement,BLToolkit.Data.Linq.Builder,TakeSkipBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TakeSkipBuilder.cs,BuildSkip,The length of the statement  "			sql.Select.Skip (builder.Convert (sequence' new SqlBinaryExpression (typeof(int)' prevSkipValue' "+"' sql.Select.SkipValue' Precedence.Additive))); " is 147.
Long Statement,BLToolkit.Data.Linq.Builder,AggregationBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\AggregationBuilder.cs,BuildMethodCall,The length of the statement  "	if (sequence.SqlQuery.Select.IsDistinct || sequence.SqlQuery.Select.TakeValue != null || sequence.SqlQuery.Select.SkipValue != null || !sequence.SqlQuery.GroupBy.IsEmpty) { " is 172.
Long Statement,BLToolkit.Data.Linq.Builder,CountBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\CountBuilder.cs,BuildMethodCall,The length of the statement  "	if (sequence.SqlQuery.Select.IsDistinct || sequence.SqlQuery.Select.TakeValue != null || sequence.SqlQuery.Select.SkipValue != null || !sequence.SqlQuery.GroupBy.IsEmpty) { " is 172.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertParameters,The length of the statement  "					return Expression.Convert (Expression.ArrayIndex (ParametersParam' Expression.Constant (Array.IndexOf (CompiledParameters' (ParameterExpression)expr)))' expr.Type); " is 164.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ExposeExpression,The length of the statement  "				var ex = body.Convert2 (wpi => new ExpressionHelper.ConvertInfo (wpi.NodeType == ExpressionType.Parameter ? me.Expression : wpi)); " is 130.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,OptimizeExpressionImpl,The length of the statement  "				isList = me.Member.DeclaringType.GetInterfaces ().Any (t => t.IsGenericType && t.GetGenericTypeDefinition () == typeof(IList<>)); " is 129.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,OptimizeExpressionImpl,The length of the statement  "				var mi = EnumerableMethods.First (m => m.Name == "Count" && m.GetParameters ().Length == 1).MakeGenericMethod (TypeHelper.GetElementType (me.Expression.Type)); " is 159.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSingleOrFirst,The length of the statement  "	var select = call.Method.DeclaringType == typeof(Enumerable) ? EnumerableMethods.Where (m => m.Name == "Select" && m.GetParameters ().Length == 2).First (m => m.GetParameters () [1].ParameterType.GetGenericArguments ().Length == 2) : QueryableMethods.Where (m => m.Name == "Select" && m.GetParameters ().Length == 2).First (m => m.GetParameters () [1].ParameterType.GetGenericArguments () [0].GetGenericArguments ().Length == 2); " is 429.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSingleOrFirst,The length of the statement  "	return Expression.Call (null' method' Expression.Call (null' select' call.Arguments [0]' Expression.Lambda (selector' param))); " is 127.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertWhere,The length of the statement  "			expr = Expression.MemberInit (Expression.New (type)' Expression.Bind (fields [0]' expr)' Expression.Bind (fields [1]' ex)); " is 123.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertWhere,The length of the statement  "			method = Expression.Call (methodInfo' method' Expression.Lambda (exprs.Aggregate ((Expression)parameter' (current' _) => Expression.PropertyOrField (current' "p"))' parameter)); " is 177.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertGroupBy,The length of the statement  "	var types = method.Method.GetGenericMethodDefinition ().GetGenericArguments ().Zip (method.Method.GetGenericArguments ()' (n' t) => new { " is 137.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertGroupBy,The length of the statement  "	var elementSelector = types.ContainsKey ("TElement") ? (LambdaExpression)OptimizeExpression (method.Arguments [2].Unwrap ()) : null; " is 132.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertGroupBy,The length of the statement  "	var resultSelector = types.ContainsKey ("TResult") ? (LambdaExpression)OptimizeExpression (method.Arguments [types.ContainsKey ("TElement") ? 3 : 2].Unwrap ()) : null; " is 167.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertGroupBy,The length of the statement  "	var gtype = typeof(GroupByHelper<' ' ' >).MakeGenericType (types ["TSource"]' types ["TKey"]' types.ContainsKey ("TElement") ? types ["TElement"] : types ["TSource"]' types.ContainsKey ("TResult") ? types ["TResult"] : types ["TSource"]); " is 238.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSelectMany,The length of the statement  "	var types = method.Method.GetGenericMethodDefinition ().GetGenericArguments ().Zip (method.Method.GetGenericArguments ()' (n' t) => new { " is 137.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSelectMany,The length of the statement  "	return method.Method.DeclaringType == typeof(Queryable) ? helper.AddElementSelectorQ () : helper.AddElementSelectorE (); " is 120.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The length of the statement  "	return Expression.Call (null' cm' Expression.Call (null' wm' OptimizeExpression (method.Arguments [0])' OptimizeExpression (method.Arguments [1]))); " is 148.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSelector,The length of the statement  "	return Expression.Call (null' cm' OptimizeExpression (Expression.Call (null' sm' method.Arguments [0]' method.Arguments [1]))); " is 127.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSelect,The length of the statement  "	if (lambda1.Parameters.Count > 1 || sequence.NodeType != ExpressionType.Call || ((MethodCallExpression)sequence).Method.Name != method.Method.Name) { " is 149.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSelect,The length of the statement  "	var expr = Expression.Call (null' GetMethodInfo (method' "Select").MakeGenericMethod (types1 [0]' types2 [1])' ((MethodCallExpression)sequence).Arguments [0]' Expression.Lambda (lambda.Body.Convert (ex => ex == lambda.Parameters [0] ? sbody : ex)' slambda.Parameters [0])); " is 273.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertIQueriable,The length of the statement  "		var path = Expression.Call (Expression.Constant (_query)' ReflectionHelper.Expressor<Query>.MethodExpressor (a => a.GetIQueryable (0' null))' new[] { " is 149.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetQueriableMethodInfo,The length of the statement  "	return method.Method.DeclaringType == typeof(Enumerable) ? EnumerableMethods.FirstOrDefault (m => predicate (m' false)) ?? EnumerableMethods.First (m => predicate (m' true)) : QueryableMethods.FirstOrDefault (m => predicate (m' false)) ?? QueryableMethods.First (m => predicate (m' true)); " is 289.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetMethodInfo,The length of the statement  "	return method.Method.DeclaringType == typeof(Enumerable) ? EnumerableMethods.Where (m => m.Name == name && m.GetParameters ().Length == 2).First (m => m.GetParameters () [1].ParameterType.GetGenericArguments ().Length == 2) : QueryableMethods.Where (m => m.Name == name && m.GetParameters ().Length == 2).First (m => m.GetParameters () [1].ParameterType.GetGenericArguments () [0].GetGenericArguments ().Length == 2); " is 417.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetMethodGenericTypes,The length of the statement  "	return method.Method.DeclaringType == typeof(Enumerable) ? method.Method.GetParameters () [1].ParameterType.GetGenericArguments () : method.Method.GetParameters () [1].ParameterType.GetGenericArguments () [0].GetGenericArguments (); " is 232.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildWhere,The length of the statement  "	BuildSearchCondition (ctx' expr' makeHaving ? ctx.SqlQuery.Having.SearchCondition.Conditions : ctx.SqlQuery.Where.SearchCondition.Conditions); " is 142.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildTake,The length of the statement  "			var parm = (SqlParameter)sql.Select.SkipValue.Clone (new Dictionary<ICloneableElement' ICloneableElement> ()' _ => true); " is 121.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildTake,The length of the statement  "			sql.Select.Take (Convert (context' new SqlBinaryExpression (typeof(int)' sql.Select.SkipValue' "+"' sql.Select.TakeValue' Precedence.Additive))); " is 145.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetSubQuery,The length of the statement  "	if (ctx.SqlQuery.Select.Columns.Count == 0 && (ctx.IsExpression (null' 0' RequestFor.Expression).Result || ctx.IsExpression (null' 0' RequestFor.Field).Result)) { " is 162.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,SubQueryToSql,The length of the statement  "		var fromGroupBy = sequence.SqlQuery.Properties.OfType<System.Tuple<string' SqlQuery>> ().Where (p => p.Item1 == "from_group_by" && p.Item2 == context.SqlQuery).Any (); " is 167.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,SubQueryToSql,The length of the statement  "			if (subQuery.Select.Columns.Count == 1 && subQuery.Select.Columns [0].Expression.ElementType == QueryElementType.SqlFunction && subQuery.GroupBy.IsEmpty && !subQuery.Select.HasModifier && !subQuery.HasUnion && subQuery.Where.SearchCondition.Conditions.Count == 1) { " is 265.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,SubQueryToSql,The length of the statement  "				if (cond.Predicate.ElementType == QueryElementType.ExprExprPredicate && query.GroupBy.Items.Count == 1 || cond.Predicate.ElementType == QueryElementType.SearchCondition && query.GroupBy.Items.Count == ((SqlQuery.SearchCondition)cond.Predicate).Conditions.Count) { " is 263.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertExpression,The length of the statement  "					var method = ReflectionHelper.Expressor<object>.MethodExpressor (_ => Sql.DateDiff (Sql.DateParts.Day' DateTime.MinValue' DateTime.MinValue)); " is 142.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertExpression,The length of the statement  "					var call = Expression.Convert (Expression.Call (null' method' Expression.Constant (datePart)' Expression.Convert (ex.Right' typeof(DateTime?))' Expression.Convert (ex.Left' typeof(DateTime?)))' typeof(double)); " is 210.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertExpressions,The length of the statement  "		return expr.Bindings.Where (b => b is MemberAssignment).Cast<MemberAssignment> ().OrderBy (b => dic [b.Member]).Select (a => { " is 126.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The length of the statement  "		if (e.Type == t || t.IsEnum && Enum.GetUnderlyingType (t) == e.Type || e.Type.IsEnum && Enum.GetUnderlyingType (e.Type) == t) " is 125.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildParameter,The length of the statement  "	var mapper = Expression.Lambda<Func<Expression' object[]' object>> (Expression.Convert (newExpr' typeof(object))' new[] { " is 121.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The length of the statement  "			if (e.Method.DeclaringType == typeof(Enumerable) || TypeHelper.IsSameOrParent (typeof(IList)' e.Method.DeclaringType) || TypeHelper.IsSameOrParent (typeof(ICollection<>)' e.Method.DeclaringType)) { " is 197.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The length of the statement  "		} else if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent (typeof(Dictionary<' >)' e.Method.DeclaringType)) { " is 124.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The length of the statement  "			var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [1]); " is 126.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The length of the statement  "		} else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent (typeof(IDictionary<' >)' e.Method.DeclaringType)) { " is 123.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The length of the statement  "			var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [0]); " is 126.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The length of the statement  "		return Convert (context' new SqlQuery.Predicate.ExprExpr (ConvertToSql (context' expression' false)' SqlQuery.Predicate.Operator.Equal' new SqlValue (true))); " is 158.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The length of the statement  "		if (e.Member.Name == "HasValue" && e.Member.DeclaringType.IsGenericType && e.Member.DeclaringType.GetGenericTypeDefinition () == typeof(Nullable<>)) { " is 150.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The length of the statement  "	if (right.NodeType == ExpressionType.Convert && right.Type == typeof(int) && left.NodeType == ExpressionType.Constant) { " is 120.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The length of the statement  "	//			if (left.NodeType == ExpressionType.Convert && left.Type == typeof(int?) && right.NodeType == ExpressionType.Convert) " is 122.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The length of the statement  "	if (left.NodeType == ExpressionType.Convert || right.NodeType == ExpressionType.Convert || left.NodeType == ExpressionType.MemberAccess || right.NodeType == ExpressionType.MemberAccess) { " is 187.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The length of the statement  "		if (!context.SqlQuery.IsParameterDependent && (l is SqlParameter && l.CanBeNull () || r is SqlParameter && r.CanBeNull ())) " is 123.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The length of the statement  "		var q = l.ElementType == QueryElementType.SqlQuery && r.ElementType == QueryElementType.SqlValue && ((SqlValue)r).Value == null && ((SqlQuery)l).Select.Columns.Count == 0 ? (SqlQuery)l : r.ElementType == QueryElementType.SqlQuery && l.ElementType == QueryElementType.SqlValue && ((SqlValue)l).Value == null && ((SqlQuery)r).Select.Columns.Count == 0 ? (SqlQuery)r : null; " is 371.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertObjectNullComparison,The length of the statement  "			if (ctx != null && ctx.IsExpression (left' 0' RequestFor.Object).Result || left.NodeType == ExpressionType.Parameter && ctx.IsExpression (left' 0' RequestFor.Field).Result) { " is 174.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertObjectComparison,The length of the statement  "		var predicate = Convert (leftContext' new SqlQuery.Predicate.ExprExpr (lcol.Sql' nodeType == ExpressionType.Equal ? SqlQuery.Predicate.Operator.Equal : SqlQuery.Predicate.Operator.NotEqual' rex)); " is 196.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertNewObjectComparison,The length of the statement  "		var rex = newRight != null ? ConvertToSql (context' newRight.Arguments [i]' false) : GetParameter (right' newExpr.Members [i]); " is 127.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertNewObjectComparison,The length of the statement  "		var predicate = Convert (context' new SqlQuery.Predicate.ExprExpr (lex' nodeType == ExpressionType.Equal ? SqlQuery.Predicate.Operator.Equal : SqlQuery.Predicate.Operator.NotEqual' rex)); " is 187.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetParameter,The length of the statement  "	var expr = Expression.MakeMemberAccess (par.Type == typeof(object) ? Expression.Convert (par' member.DeclaringType) : par' member); " is 131.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetParameter,The length of the statement  "		SqlParameter = new SqlParameter (expr.Type' member.Name' null' MappingSchema' !DataContextInfo.DataContext.InlineParameters) " is 124.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertInPredicate,The length of the statement  "	if (ctx is TableBuilder.TableContext && ctx.SqlQuery != context.SqlQuery && ctx.IsExpression (arg' 0' RequestFor.Object).Result) { " is 130.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertInPredicate,The length of the statement  "			expr = new SqlExpression ('\x1' + string.Join ("'"' sql.Select (s => s.Members [s.Members.Count - 1].Name).ToArray ())' sql.Select (s => s.Sql).ToArray ()); " is 156.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertLikePredicate,The length of the statement  "		}) < 0 ? new SqlQuery.Predicate.Like (o' false' new SqlValue (start + value + end)' null) : new SqlQuery.Predicate.Like (o' false' new SqlValue (start + EscapeLikeText (value.ToString ()) + end)' new SqlValue ('~')); " is 216.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertLikePredicate,The length of the statement  "			SqlParameter = new SqlParameter (ep.Expression.Type' p.Name' p.Value' !DataContextInfo.DataContext.InlineParameters' GetLikeEscaper (start' end)) " is 145.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertLikePredicate,The length of the statement  "	var ex = Expression.Call (Expression.Call (Expression.Call (e.Arguments [0]' mi' Expression.Constant ("~")' Expression.Constant ("~~"))' mi' Expression.Constant ("%")' Expression.Constant ("~%"))' mi' Expression.Constant ("_")' Expression.Constant ("~_")); " is 256.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,MakeIsPredicate,The length of the statement  "	return MakeIsPredicate (table' table.InheritanceMapping' table.InheritanceDiscriminators' typeOperand' name => table.SqlTable.Fields.Values.First (f => f.Name == name)); " is 169.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,MakeIsPredicate,The length of the statement  "			cond.Conditions.Add (new SqlQuery.Condition (false' Convert (context' new SqlQuery.Predicate.ExprExpr (getSql (inheritanceDiscriminators [m.i])' SqlQuery.Predicate.Operator.NotEqual' new SqlValue (m.m.Code))))); " is 211.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,MakeIsPredicate,The length of the statement  "		return Convert (context' new SqlQuery.Predicate.ExprExpr (getSql (inheritanceDiscriminators [mapping [0].i])' SqlQuery.Predicate.Operator.Equal' new SqlValue (mapping [0].m.Code))); " is 181.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,MakeIsPredicate,The length of the statement  "			cond.Conditions.Add (new SqlQuery.Condition (false' Convert (context' new SqlQuery.Predicate.ExprExpr (getSql (inheritanceDiscriminators [m.i])' SqlQuery.Predicate.Operator.Equal' new SqlValue (m.m.Code)))' true)); " is 214.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,MakeIsPredicate,The length of the statement  "	var table = new TableBuilder.TableContext (this' new BuildInfo ((IBuildContext)null' Expression.Constant (null)' new SqlQuery ())' typeOperand); " is 144.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertTimeSpanMember,The length of the statement  "			return new SqlFunction (typeof(int)' "DateDiff"' new SqlValue (datePart)' ConvertToSql (context' e.Right' false)' ConvertToSql (context' e.Left' false)); " is 153.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSearchCondition,The length of the statement  "			return Convert (context' new SqlFunction (sqlExpression.SystemType' "CASE"' sqlExpression' new SqlValue (1)' notExpr' new SqlValue (0)' new SqlValue (null))); " is 158.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSearchCondition,The length of the statement  "		return Convert (context' new SqlFunction (sqlExpression.SystemType' "CASE"' sqlExpression' new SqlValue (1)' new SqlValue (0))); " is 128.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ProcessProjection,The length of the statement  "		foreach (var binding in expr.Bindings.Cast<MemberAssignment> ().OrderBy (b => dic.ContainsKey (b.Member.Name) ? dic [b.Member.Name] : 1000000)) { " is 145.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildSql,The length of the statement  "		mapper = Expression.Convert (Expression.Call (Expression.Constant (MappingSchema)' ReflectionHelper.MapSchema.MapValueToEnumWithMemberAccessor' expr' Expression.Constant (ma))' type); " is 183.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildSql,The length of the statement  "			mapper = Expression.Convert (Expression.Call (Expression.Constant (MappingSchema)' ReflectionHelper.MapSchema.ChangeType' expr' Expression.Constant (ma.Type))' ma.Type); " is 169.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildSql,The length of the statement  "		mapper = Expression.Convert (Expression.Call (Expression.Constant (MappingSchema)' ReflectionHelper.MapSchema.MapValueToEnum' expr' Expression.Constant (type))' type); " is 167.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildSql,The length of the statement  "			mapper = Expression.Convert (Expression.Call (Expression.Constant (MappingSchema)' ReflectionHelper.MapSchema.ChangeType' expr' Expression.Constant (type))' type); " is 163.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsNoneSqlMember,The length of the statement  "		return om != null && om.Associations.All (a => !TypeHelper.Equals (a.MemberAccessor.MemberInfo' me.Member)) && om [me.Member.Name' true] == null; " is 145.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildMapper,The length of the statement  "	var mapper = Expression.Lambda<Func<QueryContext' IDataContext' IDataReader' Expression' object[]' T>> (BuildBlock (expr)' new[] { " is 130.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildMultipleQuery,The length of the statement  "		throw new LinqException ("Multiple queries are not allowed. Set the 'BLToolkit.Common.Configuration.Linq.AllowMultipleQuery' flag to 'true' to allow multiple queries."); " is 169.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildMultipleQuery,The length of the statement  "						var method = typeof(LinqExtensions).GetMethod ("Where"' BindingFlags.NonPublic | BindingFlags.Static).MakeGenericMethod (e.Type' table.ObjectType' ttype); " is 154.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildMultipleQuery,The length of the statement  "							var ee = Expression.Equal (Expression.MakeMemberAccess (op' field2.MemberMapper.MemberAccessor.MemberInfo)' Expression.MakeMemberAccess (me.Expression' field1.MemberMapper.MemberAccessor.MemberInfo)); " is 200.
Long Statement,BLToolkit.Data.Linq.Builder,GroupByBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,CanBuildMethodCall,The length of the statement  "			throw new NotSupportedException (string.Format ("Explicit construction of entity type '{0}' in group by is not allowed."' body.Type)); " is 134.
Long Statement,BLToolkit.Data.Linq.Builder,GroupByBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,BuildMethodCall,The length of the statement  "	if (sequence.SqlQuery.Select.IsDistinct || sequence.SqlQuery.GroupBy.Items.Count > 0 || groupSql.Any (_ => !(_.Sql is SqlField || _.Sql is SqlQuery.Column))) { " is 159.
Long Statement,BLToolkit.Data.Linq.Builder,JoinBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,CanBuildMethodCall,The length of the statement  "			throw new NotSupportedException (string.Format ("Explicit construction of entity type '{0}' in join is not allowed."' body.Type)); " is 130.
Long Statement,BLToolkit.Data.Linq.Builder,JoinBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildMethodCall,The length of the statement  "				throw new LinqException (string.Format ("List of member inits does not match for entity type '{0}'."' outerKeySelector.Type)); " is 126.
Long Statement,BLToolkit.Data.Linq.Builder,JoinBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildMethodCall,The length of the statement  "		BuildJoin (builder' join' outerKeyContext' outerKeySelector' innerKeyContext' innerKeySelector' countKeyContext' counterSql); " is 125.
Long Statement,BLToolkit.Data.Linq.Builder,JoinBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildMethodCall,The length of the statement  "		return new GroupJoinContext (buildInfo.Parent' selector' context' inner' methodCall.Arguments [1]' outerKeyLambda' innerKeyLambda); " is 131.
Long Statement,BLToolkit.Data.Linq.Builder,JoinBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildJoin,The length of the statement  "	var predicate = builder.ConvertObjectComparison (ExpressionType.Equal' outerKeyContext' outerKeySelector' innerKeyContext' innerKeySelector); " is 141.
Long Statement,BLToolkit.Data.Linq.Builder,JoinBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildJoin,The length of the statement  "		join.Expr (builder.ConvertToSql (outerKeyContext' outerKeySelector' false)).Equal.Expr (builder.ConvertToSql (innerKeyContext' innerKeySelector' false)); " is 153.
Long Statement,BLToolkit.Data.Linq.Builder,JoinBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildJoin,The length of the statement  "	predicate = builder.ConvertObjectComparison (ExpressionType.Equal' outerKeyContext' outerKeySelector' countKeyContext' innerKeySelector); " is 137.
Long Statement,BLToolkit.Data.Linq.Builder,JoinBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,BuildJoin,The length of the statement  "		countSql.Where.Expr (builder.ConvertToSql (outerKeyContext' outerKeySelector' false)).Equal.Expr (builder.ConvertToSql (countKeyContext' innerKeySelector' false)); " is 163.
Long Statement,BLToolkit.Data.Linq.Builder,MethodCallBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\MethodCallBuilder.cs,ConvertMethod,The length of the statement  "					args [i] = Expression.Lambda (l.Body.Convert (ex => ConvertMethod (methodCall' sourceTypeNumber' info' param' ex))' info.Parameter); " is 132.
Long Statement,BLToolkit.Data.Linq.Builder,OrderByBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\OrderByBuilder.cs,CanBuildMethodCall,The length of the statement  "			throw new NotSupportedException (string.Format ("Explicit construction of entity type '{0}' in order by is not allowed."' body.Type)); " is 134.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionContext.cs,ConvertToSql,The length of the statement  "					return root == expression ? Sequence.ConvertToSql (null' 0' flags) : Sequence.ConvertToSql (expression' level + 1' flags); " is 122.
Long Statement,BLToolkit.Data.Linq.Builder,ExpressionContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionContext.cs,IsExpression,The length of the statement  "		return levelExpression == expression ? Sequence.IsExpression (null' 0' requestFlag) : Sequence.IsExpression (expression' level + 1' requestFlag); " is 145.
Long Statement,BLToolkit.Data.Linq.Builder,ScalarSelectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ScalarSelectBuilder.cs,CanBuild,The length of the statement  "	return buildInfo.Expression.NodeType == ExpressionType.Lambda && ((LambdaExpression)buildInfo.Expression).Parameters.Count == 0; " is 128.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The length of the statement  "		return ProcessScalar (expression' level' (ctx' ex' l) => ctx.BuildExpression (ex' l)' () => GetSequence (expression' level).BuildExpression (null' 0)); " is 151.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The length of the statement  "			return levelExpression == expression ? sequence.BuildExpression (null' 0) : sequence.BuildExpression (expression' level + 1); " is 125.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The length of the statement  "			var memberExpression = GetMemberExpression (((MemberExpression)levelExpression).Member' levelExpression == expression' levelExpression.Type); " is 141.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The length of the statement  "									if (sequence != null && !sequence.IsExpression (e' 0' RequestFor.Object).Result && !sequence.IsExpression (e' 0' RequestFor.Field).Result) { " is 140.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,CheckExpression,The length of the statement  "		expression.Sql = Builder.Convert (this' new SqlFunction (typeof(bool)' "CASE"' expression.Sql' new SqlValue (true)' new SqlValue (false))); " is 139.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,The length of the statement  "			return ProcessScalar (expression' level' (ctx' ex' l) => ctx.ConvertToIndex (ex' l' flags)' () => GetSequence (expression' level).ConvertToIndex (expression' level + 1' flags)); " is 177.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,The length of the statement  "				return ProcessMemberAccess (expression' (MemberExpression)levelExpression' level' (n' ctx' ex' l' _) => n == 0 ? GetSequence (expression' level).ConvertToIndex (expression' level + 1' flags) : ctx.ConvertToIndex (ex' l' flags)); " is 228.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,IsExpression,The length of the statement  "		return new IsExpressionResult (Sequence.Length == 1 ? expression == Lambda.Parameters [0] : Lambda.Parameters.Any (p => p == expression)); " is 138.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,IsExpression,The length of the statement  "			return ProcessScalar (expression' level' (ctx' ex' l) => ctx.IsExpression (ex' l' requestFlag)' () => new IsExpressionResult (requestFlag == RequestFor.Expression)); " is 165.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,IsExpression,The length of the statement  "				return ProcessMemberAccess (expression' (MemberExpression)levelExpression' level' (n' ctx' ex' l' _) => n == 0 ? new IsExpressionResult (requestFlag == RequestFor.Expression) : ctx.IsExpression (ex' l' requestFlag)); " is 216.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetContext,The length of the statement  "				var memberExpression = GetMemberExpression (((MemberExpression)levelExpression).Member' levelExpression == expression' levelExpression.Type); " is 141.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetContext,The length of the statement  "			var context = ProcessMemberAccess (expression' (MemberExpression)levelExpression' level' (n' ctx' ex' l' _) => n == 0 ? null : ctx.GetContext (ex' l' buildInfo)); " is 162.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetExpression,The length of the statement  "	return levelExpression != expression ? expression.Convert (ex => ex == levelExpression ? memberExpression : ex) : memberExpression; " is 131.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetMemberExpression,The length of the statement  "				return levelExpresion == expression ? expr.Arguments [i].Unwrap () : GetMemberExpression (expr.Arguments [i].Unwrap ()' expression' level + 1); " is 143.
Long Statement,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetMemberExpression,The length of the statement  "				return levelExpresion == expression ? binding.Expression.Unwrap () : GetMemberExpression (binding.Expression.Unwrap ()' expression' level + 1); " is 143.
Long Statement,BLToolkit.Data.Linq.Builder,SelectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,BuildMethodCall,The length of the statement  "	var context = selector.Parameters.Count == 1 ? new SelectContext (buildInfo.Parent' selector' sequence) : new SelectContext2 (buildInfo.Parent' selector' sequence); " is 164.
Long Statement,BLToolkit.Data.Linq.Builder,SelectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,Convert,The length of the statement  "		methodCall = (MethodCallExpression)methodCall.Convert (ex => ConvertMethod (methodCall' 0' info' selector.Parameters [0]' ex)); " is 127.
Long Statement,BLToolkit.Data.Linq.Builder,SelectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,Convert,The length of the statement  "				methodCall = Expression.Call (methodCall.Object' mgen.MakeGenericMethod (types [0]' btype)' methodCall.Arguments [0]' Expression.Lambda (Expression.MemberInit (Expression.New (btype)' Expression.Bind (fields [0]' psel)' Expression.Bind (fields [1]' selector.Body.Convert (e => e == pold ? psel : e)))' psel)); " is 309.
Long Statement,BLToolkit.Data.Linq.Builder,SelectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,GetExpressions,The length of the statement  "			if (TypeHelper.IsSameOrParent (typeof(IEnumerable)' call.Type) || TypeHelper.IsSameOrParent (typeof(IQueryable)' call.Type) || FirstSingleBuilder.MethodNames.Contains (call.Method.Name)) " is 186.
Long Statement,BLToolkit.Data.Linq.Builder,SubQueryContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SubQueryContext.cs,BuildQuery,The length of the statement  "		if (le.Parameters.Count == 1 && null != Expression.Find (e => e.NodeType == ExpressionType.Call && ((MethodCallExpression)e).IsQueryable ())) { " is 143.
Long Statement,BLToolkit.Data.Linq.Builder,SubQueryContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SubQueryContext.cs,BuildQuery,The length of the statement  "				var seq = new SelectContext (Parent' Expression.Lambda (Expression.New (ne.Constructor' ne.Members.Select (m => Expression.MakeMemberAccess (p' m)).ToArray ()' ne.Members)' p)' this); " is 183.
Long Statement,BLToolkit.Data.Linq.Builder,SubQueryContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SubQueryContext.cs,BuildQuery,The length of the statement  "					var seq = new SelectContext (Parent' Expression.Lambda (Expression.MemberInit (mi.NewExpression' mi.Bindings.OfType<MemberAssignment> ().Select (ma => Expression.Bind (ma.Member' Expression.MakeMemberAccess (p' ma.Member))).ToArray ())' p)' this); " is 247.
Long Statement,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The length of the statement  "			return new TableContext (builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType); " is 121.
Long Statement,BLToolkit.Data.Linq,CompiledQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\CompiledQuery.cs,CompileQuery,The length of the statement  "					var qtype = TypeHelper.GetGenericType (TypeHelper.IsSameOrParent (typeof(IQueryable)' expr.Type) ? typeof(IQueryable<>) : typeof(IEnumerable<>)' expr.Type); " is 156.
Long Statement,BLToolkit.Data.Linq,CompiledQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\CompiledQuery.cs,CompileQuery,The length of the statement  "					var helper = (ITableHelper)Activator.CreateInstance (typeof(TableHelper<>).MakeGenericType (qtype == null ? expr.Type : qtype.GetGenericArguments () [0])); " is 155.
Long Statement,BLToolkit.Data.Linq,CompiledQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\CompiledQuery.cs,CompileQuery,The length of the statement  "				var helper = (ITableHelper)Activator.CreateInstance (typeof(TableHelper<>).MakeGenericType (pi.Type.GetGenericArguments () [0])); " is 129.
Long Statement,BLToolkit.Data.Linq,CompiledTable,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\CompiledTableT.cs,GetInfo,The length of the statement  "					query = new ExpressionBuilder (new Query<T> ()' dataContextInfo' _expression' _lambda.Parameters.ToArray ()).Build<T> (); " is 121.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Like,The length of the statement  "	return matchExpression == null || pattern == null ? false : System.Data.Linq.SqlClient.SqlMethods.Like (matchExpression' pattern); " is 130.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Like,The length of the statement  "	return matchExpression == null || pattern == null || escapeCharacter == null ? false : System.Data.Linq.SqlClient.SqlMethods.Like (matchExpression' pattern' escapeCharacter.Value); " is 180.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Stuff,The length of the statement  "	return str == null || value == null || startLocation == null || length == null ? null : str.Remove (startLocation.Value - 1' length.Value).Insert (startLocation.Value - 1' value); " is 179.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,PadLeft,The length of the statement  "	return str == null || totalWidth == null || paddingChar == null ? null : str.PadLeft (totalWidth.Value' paddingChar.Value); " is 123.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,PadRight,The length of the statement  "	return str == null || totalWidth == null || paddingChar == null ? null : str.PadRight (totalWidth.Value' paddingChar.Value); " is 124.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,ToDate,The length of the statement  "	return year == null || month == null || day == null || hour == null || minute == null || second == null || millisecond == null ? (DateTime?)null : new DateTime (year.Value' month.Value' day.Value' hour.Value' minute.Value' second.Value' millisecond.Value); " is 256.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,ToDate,The length of the statement  "	return year == null || month == null || day == null || hour == null || minute == null || second == null ? (DateTime?)null : new DateTime (year.Value' month.Value' day.Value' hour.Value' minute.Value' second.Value); " is 214.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,ToDate,The length of the statement  "	return year == null || month == null || day == null ? (DateTime?)null : new DateTime (year.Value' month.Value' day.Value); " is 122.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,MakeDateTime,The length of the statement  "	return year == null || month == null || day == null ? (DateTime?)null : new DateTime (year.Value' month.Value' day.Value); " is 122.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,MakeDateTime,The length of the statement  "	return year == null || month == null || day == null || hour == null || minute == null || second == null ? (DateTime?)null : new DateTime (year.Value' month.Value' day.Value' hour.Value' minute.Value' second.Value); " is 214.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Round,The length of the statement  "	return value == null || precision == null ? null : (Decimal?)Math.Round (value.Value' precision.Value' MidpointRounding.AwayFromZero); " is 134.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Round,The length of the statement  "	return value == null || precision == null ? null : (Double?)Math.Round (value.Value' precision.Value' MidpointRounding.AwayFromZero); " is 133.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,RoundToEven,The length of the statement  "	return value == null || precision == null ? null : (Decimal?)Math.Round (value.Value' precision.Value' MidpointRounding.ToEven); " is 128.
Long Statement,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,RoundToEven,The length of the statement  "	return value == null || precision == null ? null : (Double?)Math.Round (value.Value' precision.Value' MidpointRounding.ToEven); " is 127.
Long Statement,BLToolkit.Data.Linq,Expressions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Expressions.cs,ConvertMember,The length of the statement  "		if (mi is MethodInfo && mi.Name == "CompareString" && mi.DeclaringType.FullName == "Microsoft.VisualBasic.CompilerServices.Operators") { " is 136.
Long Statement,BLToolkit.Data.Linq,Expressions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Expressions.cs,ConvertMember,The length of the statement  "					expr = L<S' S' B' I> ((s1' s2' b) => b ? string.CompareOrdinal (s1.ToUpper ()' s2.ToUpper ()) : string.CompareOrdinal (s1' s2)); " is 128.
Long Statement,BLToolkit.Data.Linq,Expressions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Expressions.cs,MakeDateTime2,The length of the statement  "	return year == null || month == null || day == null ? (DateTime?)null : new DateTime (year.Value' month.Value' day.Value); " is 122.
Long Statement,BLToolkit.Data.Linq,Expressions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Expressions.cs,Mdy,The length of the statement  "	return year == null || month == null || day == null ? (DateTime?)null : new DateTime (year.Value' month.Value' day.Value); " is 122.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Delete,The length of the statement  "	return source.Provider.Execute<int> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 131.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Delete,The length of the statement  "	return source.Provider.Execute<int> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 131.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Update,The length of the statement  "	return source.Provider.Execute<int> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 131.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Update,The length of the statement  "	return source.Provider.Execute<int> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 131.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Update,The length of the statement  "	return source.Provider.Execute<int> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 131.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Update,The length of the statement  "	return query.Provider.Execute<int> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 130.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,AsUpdatable,The length of the statement  "	var query = source.Provider.CreateQuery<T> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 138.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Set,The length of the statement  "	var query = source.Provider.CreateQuery<T> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 138.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Set,The length of the statement  "	query = query.Provider.CreateQuery<T> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Set,The length of the statement  "	var query = source.Provider.CreateQuery<T> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 138.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Set,The length of the statement  "	query = query.Provider.CreateQuery<T> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Set,The length of the statement  "	var query = source.Provider.CreateQuery<T> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 138.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Set,The length of the statement  "	query = query.Provider.CreateQuery<T> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Insert,The length of the statement  "	return query.Provider.Execute<int> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 130.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,InsertWithIdentity,The length of the statement  "	return query.Provider.Execute<object> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,InsertWithOutput,The length of the statement  "	return query.Provider.Execute<object> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Into,The length of the statement  "	var q = query.Provider.CreateQuery<T> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Value,The length of the statement  "	var q = query.Provider.CreateQuery<T> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Value,The length of the statement  "	var q = query.Provider.CreateQuery<T> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Value,The length of the statement  "	var q = query.Provider.CreateQuery<T> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Value,The length of the statement  "	var q = query.Provider.CreateQuery<T> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Insert,The length of the statement  "	return query.Provider.Execute<int> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 130.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,InsertWithIdentity,The length of the statement  "	return query.Provider.Execute<object> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,InsertWithOutput,The length of the statement  "	return query.Provider.Execute<object> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Insert,The length of the statement  "	return source.Provider.Execute<int> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 131.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,InsertWithIdentity,The length of the statement  "	return source.Provider.Execute<object> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 134.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,InsertWithOutput,The length of the statement  "	return source.Provider.Execute<object> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 134.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Into,The length of the statement  "	var q = source.Provider.CreateQuery<TSource> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 140.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Value,The length of the statement  "	var q = query.Provider.CreateQuery<TSource> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 139.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Value,The length of the statement  "	var q = query.Provider.CreateQuery<TSource> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 139.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Value,The length of the statement  "	var q = query.Provider.CreateQuery<TSource> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 139.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Insert,The length of the statement  "	return query.Provider.Execute<int> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 130.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,InsertWithIdentity,The length of the statement  "	return query.Provider.Execute<object> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 133.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,InsertOrUpdate,The length of the statement  "	return query.Provider.Execute<int> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 130.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,InsertOrUpdate,The length of the statement  "	return query.Provider.Execute<int> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 130.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Take,The length of the statement  "	return source.Provider.CreateQuery<TSource> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 139.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,Skip,The length of the statement  "	return source.Provider.CreateQuery<TSource> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 139.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,ElementAt,The length of the statement  "	return source.Provider.Execute<TSource> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 135.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,ElementAtOrDefault,The length of the statement  "	return source.Provider.Execute<TSource> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 135.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,ThenBy,The length of the statement  "	return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 167.
Long Statement,BLToolkit.Data.Linq,LinqExtensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\LinqExtensions.cs,ThenByDescending,The length of the statement  "	return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource> (Expression.Call (null' ((MethodInfo)MethodBase.GetCurrentMethod ()).MakeGenericMethod (new[] { " is 167.
Long Statement,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,Compare,The length of the statement  "	return ContextID.Length == contextID.Length && ContextID == contextID && MappingSchema == mappingSchema && ExpressionHelper.Compare (Expression' expr' _queryableAccessorDic); " is 174.
Long Statement,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,GetQuery,The length of the statement  "						DbManager.WriteTraceLine ("To generate test code to diagnose the problem set 'BLToolkit.Common.Configuration.Linq.GenerateExpressionTest = true'."' DbManager.TraceSwitch.DisplayName); " is 183.
Long Statement,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,SetParameters,The length of the statement  "			if (etype == null || etype == typeof(object) || etype.IsEnum || (TypeHelper.IsNullableType (etype) && etype.GetGenericArguments () [0].IsEnum)) { " is 145.
Long Statement,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,GetParameter,The length of the statement  "	Expression getter = Expression.Convert (Expression.Property (Expression.Convert (exprParam' typeof(ConstantExpression))' ReflectionHelper.Constant.Value)' typeof(T)); " is 166.
Long Statement,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,GetParameter,The length of the statement  "	var defValue = Expression.Constant (mm.MapMemberInfo.DefaultValue ?? TypeHelper.GetDefaultValue (mm.MapMemberInfo.Type)' mm.MapMemberInfo.Type); " is 144.
Long Statement,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,GetParameter,The length of the statement  "		var method = ReflectionHelper.Expressor<int>.MethodExpressor (_ => ConvertNullable (0' 0)).GetGenericMethodDefinition ().MakeGenericMethod (mm.Type); " is 149.
Long Statement,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,GetParameter,The length of the statement  "		SqlParameter = new SqlParameter (field.SystemType' field.Name.Replace ('.'' '_')' null' dataContext.MappingSchema' !dataContext.InlineParameters) " is 145.
Long Statement,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,InsertOrReplace,The length of the statement  "						throw new LinqException ("InsertOrUpdate method does not support identity field '{0}.{1}'."' sqlTable.Name' field.Name); " is 120.
Long Statement,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,InsertOrReplace,The length of the statement  "					throw new LinqException ("InsertOrUpdate method requires the '{0}.{1}' field to be included in the insert setter."' sqlTable.Name' missedKey.Name); " is 147.
Long Statement,BLToolkit.Data.Linq,Extensions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Extensions.cs,GetTable,The length of the statement  "		throw new LinqException ("Method '{0}.{1}' must return type 'Table<{2}>'"' methodInfo.Name' methodInfo.DeclaringType.FullName' typeof(T).FullName); " is 147.
Long Statement,BLToolkit.Data.Linq,SqlExpressionAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\SqlExpressionAttribute.cs,GetExpression,The length of the statement  "	return new SqlExpression (TypeHelper.GetMemberType (member)' Expression ?? member.Name' Precedence' ConvertArgs (member' args)); " is 128.
Long Statement,BLToolkit.Data.Linq,ReflectionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\ReflectionHelper.cs,MemeberInfo,The length of the statement  "	return ex is MemberExpression ? ((MemberExpression)ex).Member : ex is MethodCallExpression ? ((MethodCallExpression)ex).Method : (MemberInfo)((NewExpression)ex).Constructor; " is 173.
Long Statement,BLToolkit.Data.Linq,SqlFunctionAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\SqlFunctionAttribute.cs,ConvertArgs,The length of the statement  "			args = args.Concat (method.DeclaringType.GetGenericArguments ().Select (t => (ISqlExpression)SqlDataType.GetDataType (t))).ToArray (); " is 134.
Long Statement,BLToolkit.Data.Linq,SqlFunctionAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\SqlFunctionAttribute.cs,ConvertArgs,The length of the statement  "			args = args.Concat (method.GetGenericArguments ().Select (t => (ISqlExpression)SqlDataType.GetDataType (t))).ToArray (); " is 120.
Long Statement,BLToolkit.Data.Linq,TableFunctionAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\TableFunctionAttribute.cs,ConvertArgs,The length of the statement  "			args = args.Concat (method.DeclaringType.GetGenericArguments ().Select (t => (ISqlExpression)SqlDataType.GetDataType (t))).ToArray (); " is 134.
Long Statement,BLToolkit.Data.Linq,TableFunctionAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\TableFunctionAttribute.cs,ConvertArgs,The length of the statement  "			args = args.Concat (method.GetGenericArguments ().Select (t => (ISqlExpression)SqlDataType.GetDataType (t))).ToArray (); " is 120.
Long Statement,BLToolkit.Data.Linq,ExpressionQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\ExpressionQuery.cs,CreateQuery,The length of the statement  "		return (IQueryable)Activator.CreateInstance (typeof(ExpressionQueryImpl<>).MakeGenericType (elementType)' new object[] { " is 120.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The length of the statement  "						return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]); " is 129.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The length of the statement  "						return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120)); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,BuildFunction,The length of the statement  "			BuildFunction (sb' new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms))); " is 139.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,ConvertCase,The length of the statement  "		cond = new SqlQuery.SearchCondition (new SqlQuery.Condition (false' new SqlQuery.Predicate.ExprExpr (cond' SqlQuery.Predicate.Operator.Equal' new SqlValue (1)))); " is 162.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,ConvertCase,The length of the statement  "	return new SqlFunction (systemType' name' cond' parameters [start + 1]' ConvertCase (systemType' parameters' start + 2)); " is 121.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The length of the statement  "		if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) { " is 149.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The length of the statement  "		BuildPredicate (sb' hasNull ? new SqlQuery.Predicate.IsNull (predicate.Expr1' predicate.IsNot) : new SqlQuery.Predicate.Expr (new SqlValue (predicate.IsNot))); " is 159.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildExpression,The length of the statement  "					table = table == null ? GetTablePhysicalName (field.Table' null) : Convert (table' ConvertType.NameToQueryTableAlias).ToString (); " is 130.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildExpression,The length of the statement  "			sb.Append (Convert (tableAlias' ConvertType.NameToQueryTableAlias)).Append ('.').Append (Convert (column.Alias' ConvertType.NameToQueryField)); " is 143.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,FloorBeforeConvert,The length of the statement  "	return TypeHelper.IsFloatType (par1.SystemType) && TypeHelper.IsIntegerType (func.SystemType) ? new SqlFunction (func.SystemType' "Floor"' par1) : par1; " is 152.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,AlternativeConvertToBoolean,The length of the statement  "		sc.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.ExprExpr (par' SqlQuery.Predicate.Operator.Equal' new SqlValue (0)))); " is 143.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetAlternativeDelete,The length of the statement  "	if (sqlQuery.IsDelete && (sqlQuery.From.Tables.Count > 1 || sqlQuery.From.Tables [0].Joins.Count > 0) && sqlQuery.From.Tables [0].Source is SqlTable) { " is 151.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetAlternativeDelete,The length of the statement  "				sc2.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.ExprExpr (copyKeys [i]' SqlQuery.Predicate.Operator.Equal' tableKeys [i]))); " is 150.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetAlternativeUpdate,The length of the statement  "					table = (SqlTable)new QueryVisitor ().Find (sqlQuery.From' ex => ex is SqlTable && ((SqlTable)ex).ObjectType == table.ObjectType) ?? table; " is 139.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertFunctionParameters,The length of the statement  "		return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters.Select ((p' i) => IsBooleanParameter (p' func.Parameters.Length' i) ? ConvertExpression (new SqlFunction (typeof(bool)' "CASE"' p' new SqlValue (true)' new SqlValue (false))) : p).ToArray ()); " is 277.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,Wrap,The length of the statement  "	return precedence == 0 || precedence < parentPrecedence || (precedence == parentPrecedence && (parentPrecedence == Precedence.Subtraction || parentPrecedence == Precedence.LogicalNegation)); " is 190.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The length of the statement  "		var physicalName = tbl.PhysicalName == null ? null : Convert (tbl.PhysicalName' ConvertType.NameToQueryTable).ToString (); " is 122.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The length of the statement  "									return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value))); " is 122.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The length of the statement  "					var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType); " is 134.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence); " is 203.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The length of the statement  "					var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType); " is 134.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence); " is 203.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The length of the statement  "									return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2)); " is 123.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The length of the statement  "				return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1))); " is 332.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0))); " is 148.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The length of the statement  "					if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef) " is 120.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertEqualPredicate,The length of the statement  "		cond.Expr (expr1).IsNull.And.Expr (expr2).IsNull.Or.Expr (expr1).IsNotNull.And.Expr (expr2).IsNotNull.And.Expr (expr1).Equal.Expr (expr2); " is 138.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertEqualPredicate,The length of the statement  "		cond.Expr (expr1).IsNull.And.Expr (expr2).IsNotNull.Or.Expr (expr1).IsNotNull.And.Expr (expr2).IsNull.Or.Expr (expr1).NotEqual.Expr (expr2); " is 140.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The length of the statement  "			if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) { " is 186.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The length of the statement  "							return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2)); " is 207.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The length of the statement  "						if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) { " is 155.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The length of the statement  "							return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2)); " is 148.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The length of the statement  "				if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) { " is 140.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The length of the statement  "				if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) { " is 140.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveSubQueryColumn,The length of the statement  "						query.Select.Columns [i] = new SqlQuery.Column (query' new SqlFunction (oldFunc.SystemType' oldFunc.Name' subQuery.Select.Columns [0])); " is 136.
Long Statement,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveSubQueryColumn,The length of the statement  "						query.Select.Columns [i] = new SqlQuery.Column (query' new SqlFunction (oldFunc.SystemType' oldFunc.Name' subQuery.Select.Columns [idx])); " is 138.
Long Statement,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,BuildAnyAsCount,The length of the statement  "	_selectColumn = new SqlQuery.Column (SqlQuery' new SqlExpression (cond.Conditions [0].IsNot ? "Count(*) = 0" : "Count(*) > 0")' SqlQuery.Select.Columns [0].Alias); " is 163.
Long Statement,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The length of the statement  "				return new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms)); " is 126.
Long Statement,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The length of the statement  "			return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' new SqlValue (1)' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [2]' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)); " is 284.
Long Statement,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertCase,The length of the statement  "	return new SqlFunction (systemType' "Iif"' parameters [start]' parameters [start + 1]' ConvertCase (systemType' parameters' start + 2)); " is 136.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The length of the statement  "						return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]); " is 129.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The length of the statement  "						return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120)); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The length of the statement  "				return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1)); " is 304.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null)); " is 153.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,ConvertExpression,The length of the statement  "				return new SqlBinaryExpression (be.Expr2.SystemType' new SqlFunction (typeof(int)' "Convert"' SqlDataType.Int32' be.Expr1)' be.Operation' be.Expr2); " is 148.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,ConvertExpression,The length of the statement  "			if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(ulong) && TypeHelper.IsFloatType (func.Parameters [1].SystemType)) " is 127.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,ConvertExpression,The length of the statement  "				return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' new SqlFunction (func.SystemType' "Floor"' func.Parameters [1])); " is 155.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,BuildDeleteClause,The length of the statement  "	var table = SqlQuery.Delete.Table != null ? (SqlQuery.From.FindTableSource (SqlQuery.Delete.Table) ?? SqlQuery.Delete.Table) : SqlQuery.From.Tables [0]; " is 152.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,BuildDeleteClause,The length of the statement  "	AppendIndent (sb).Append ("DELETE ").Append (Convert (GetTableAlias (table)' ConvertType.NameToQueryTableAlias)).AppendLine (); " is 127.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,BuildUpdateTableName,The length of the statement  "	var table = SqlQuery.Update.Table != null ? (SqlQuery.From.FindTableSource (SqlQuery.Update.Table) ?? SqlQuery.Update.Table) : SqlQuery.From.Tables [0]; " is 152.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,BuildOffsetLimit,The length of the statement  "		AppendIndent (sb).AppendFormat ("LIMIT {0}'{1}"' BuildExpression (new StringBuilder ()' SqlQuery.Select.SkipValue)' SqlQuery.Select.TakeValue == null ? long.MaxValue.ToString () : BuildExpression (new StringBuilder ()' SqlQuery.Select.TakeValue).ToString ()).AppendLine (); " is 273.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ConvertExpression,The length of the statement  "			if ((ftype == typeof(double) || ftype == typeof(float)) && TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(decimal)) " is 140.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ConvertExpression,The length of the statement  "			return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ConvertExpression,The length of the statement  "			return Inc (new SqlFunction (e.SystemType' "WeekDay"' new SqlFunction (null' "Date_Add"' e.Parameters [0]' new SqlExpression (null' "interval 1 day")))); " is 153.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,BuildDeleteClause,The length of the statement  "	var table = SqlQuery.Delete.Table != null ? (SqlQuery.From.FindTableSource (SqlQuery.Delete.Table) ?? SqlQuery.Delete.Table) : SqlQuery.From.Tables [0]; " is 152.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,BuildDeleteClause,The length of the statement  "	AppendIndent (sb).Append ("DELETE ").Append (Convert (GetTableAlias (table)' ConvertType.NameToQueryTableAlias)).AppendLine (); " is 127.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,Convert,The length of the statement  "		str = (str.Length > 0 && (str [0] == ParameterSymbol || (TryConvertParameterSymbol && ConvertParameterSymbols.Contains (str [0])))) ? str.Substring (1) : str; " is 158.
Long Statement,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,BuildExpression,The length of the statement  "	return base.BuildExpression (sb' expr' buildTableName && SqlQuery.QueryType != QueryType.InsertOrUpdate' checkParentheses' alias' ref addAlias); " is 144.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,ConvertExpression,The length of the statement  "			return TypeHelper.IsIntegerType (be.Expr1.SystemType) ? be : new SqlBinaryExpression (typeof(int)' new SqlFunction (typeof(int)' "Convert"' SqlDataType.Int32' be.Expr1)' be.Operation' be.Expr2' be.Precedence); " is 209.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' new SqlFunction (func.SystemType' "Floor"' func.Parameters [1])); " is 155.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,ConvertExpression,The length of the statement  "						return new SqlExpression (func.SystemType' "Cast(Convert(NChar' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]); " is 130.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,ConvertExpression,The length of the statement  "						return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "			return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr; " is 129.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "			return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlBinaryExpression (be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType); " is 143.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "			return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters [1]' func.Parameters [0]); " is 125.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "			return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3)); " is 139.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "			return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters)); " is 121.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "			return new SqlExpression (e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "				return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]); " is 135.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The length of the statement  "				return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]); " is 133.
Long Statement,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The length of the statement  "		sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)"); " is 301.
Long Statement,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The length of the statement  "			return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr; " is 129.
Long Statement,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The length of the statement  "			return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The length of the statement  "				return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]); " is 139.
Long Statement,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The length of the statement  "				return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]); " is 128.
Long Statement,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The length of the statement  "				return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]); " is 137.
Long Statement,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,BuildCommand,The length of the statement  "	var name = attr != null ? attr.SequenceName : Convert (string.Format ("{0}_{1}_seq"' into.PhysicalName' into.GetIdentityField ().PhysicalName)' ConvertType.NameToQueryField); " is 174.
Long Statement,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The length of the statement  "			return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr; " is 129.
Long Statement,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The length of the statement  "			return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The length of the statement  "			return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1)); " is 526.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildWhereSearchCondition,The length of the statement  "		BuildPredicate (sb' Precedence.LogicalConjunction' new SqlQuery.Predicate.ExprExpr (new SqlExpression (null' "ROWNUM"' Precedence.Primary)' SqlQuery.Predicate.Operator.LessOrEqual' SqlQuery.Select.TakeValue)); " is 209.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "			return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "			return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType); " is 140.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "			return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr; " is 129.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "				if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) { " is 136.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "			return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]); " is 131.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "			return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]); " is 236.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "			return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]); " is 230.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "			return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27)); " is 132.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The length of the statement  "			return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000); " is 127.
Long Statement,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The length of the statement  "		sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))"); " is 303.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "			var expr1 = !TypeHelper.IsIntegerType (be.Expr1.SystemType) ? new SqlFunction (typeof(int)' "Int"' be.Expr1) : be.Expr1; " is 120.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "			return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr; " is 129.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale)); " is 148.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "				return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]); " is 300.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]); " is 203.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]); " is 202.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]); " is 200.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]); " is 187.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]); " is 243.
Long Statement,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The length of the statement  "		sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)"); " is 318.
Long Statement,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The length of the statement  "			return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr; " is 129.
Long Statement,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The length of the statement  "						return new SqlFunction (func.SystemType' "Date"' new SqlFunction (func.SystemType' "To_Date"' func.Parameters [1]' new SqlValue ("%Y-%m-%d"))); " is 143.
Long Statement,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The length of the statement  "					return new SqlExpression (func.SystemType' "Cast(Extend({0}' hour to second) as Char(8))"' Precedence.Primary' func.Parameters [1]); " is 132.
Long Statement,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The length of the statement  "			return Inc (Sub<int> (new SqlFunction (null' "Mdy"' new SqlFunction (null' "Month"' func.Parameters)' new SqlFunction (null' "Day"' func.Parameters)' new SqlFunction (null' "Year"' func.Parameters))' new SqlFunction (null' "Mdy"' new SqlValue (1)' new SqlValue (1)' new SqlFunction (null' "Year"' func.Parameters)))); " is 317.
Long Statement,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The length of the statement  "			return new SqlExpression (func.SystemType' "((Extend({0}' year to day) - (Mdy(12' 31 - WeekDay(Mdy(1' 1' year({0})))' Year({0}) - 1) + Interval(1) day to day)) / 7 + Interval(1) day to day)::char(10)::int"' func.Parameters); " is 224.
Long Statement,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The length of the statement  "			return new SqlExpression (func.SystemType' string.Format ("(({{0}})::datetime {0} to {0})::char(3)::int"' func.Name)' func.Parameters); " is 135.
Long Statement,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,Find,The length of the statement  "		return Find (table.All' find) ?? Find (table.Fields.Values' find) ?? Find (table.Joins' find) ?? Find (table.TableArguments' find); " is 131.
Long Statement,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,Find,The length of the statement  "		return Find (q.Select' find) ?? (q.IsInsert ? Find (q.Insert' find) : null) ?? (q.IsUpdate ? Find (q.Update' find) : null) ?? Find (q.From' find) ?? Find (q.Where' find) ?? Find (q.GroupBy' find) ?? Find (q.Having' find) ?? Find (q.OrderBy' find) ?? (q.HasUnion ? Find (q.Unions' find) : null); " is 294.
Long Statement,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The length of the statement  "			newElement = new SqlBinaryExpression (bexpr.SystemType' expr1 ?? bexpr.Expr1' bexpr.Operation' expr2 ?? bexpr.Expr2' bexpr.Precedence); " is 135.
Long Statement,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The length of the statement  "		if (source != null && !ReferenceEquals (source' table.Source) || joins != null && !ReferenceEquals (table.Joins' joins)) " is 120.
Long Statement,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The length of the statement  "		if (e1 != null && !ReferenceEquals (p.Expr1' e1) || e2 != null && !ReferenceEquals (p.Expr2' e2) || es != null && !ReferenceEquals (p.Escape' es)) " is 146.
Long Statement,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The length of the statement  "		if (e1 != null && !ReferenceEquals (p.Expr1' e1) || e2 != null && !ReferenceEquals (p.Expr2' e2) || e3 != null && !ReferenceEquals (p.Expr3' e3)) " is 145.
Long Statement,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The length of the statement  "		if (t != null && !ReferenceEquals (s.Table' t) || i != null && !ReferenceEquals (s.Items' i) || k != null && !ReferenceEquals (s.Keys' k)) { " is 140.
Long Statement,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The length of the statement  "		if (parent != null || cols != null && !ReferenceEquals (sc.Columns' cols) || take != null && !ReferenceEquals (sc.TakeValue' take) || skip != null && !ReferenceEquals (sc.SkipValue' skip)) { " is 190.
Long Statement,BLToolkit.Data.Sql,SqlDataType,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,CanBeNull,The length of the statement  "	if (type.IsValueType == false || type.IsGenericType && type.GetGenericTypeDefinition () == typeof(Nullable<>) || TypeHelper.IsSameOrParent (typeof(INullable)' type)) " is 165.
Long Statement,BLToolkit.Data.Sql,SqlDataType,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,ToString,The length of the statement  "	return ((IQueryElement)this).ToString (new StringBuilder ()' new Dictionary<IQueryElement' IQueryElement> ()).ToString (); " is 122.
Long Statement,BLToolkit.Data.Sql,SqlBinaryExpression,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlBinaryExpression.cs,ToString,The length of the statement  "	return ((IQueryElement)this).ToString (new StringBuilder ()' new Dictionary<IQueryElement' IQueryElement> ()).ToString (); " is 122.
Long Statement,BLToolkit.Data.Sql,SqlBinaryExpression,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlBinaryExpression.cs,Equals,The length of the statement  "	return expr != null && Operation == expr.Operation && SystemType == expr.SystemType && Expr1.Equals (expr.Expr1' comparer) && Expr2.Equals (expr.Expr2' comparer) && comparer (this' other); " is 188.
Long Statement,BLToolkit.Data.Sql,SqlBinaryExpression,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlBinaryExpression.cs,Clone,The length of the statement  "		objectTree.Add (this' clone = new SqlBinaryExpression (SystemType' (ISqlExpression)Expr1.Clone (objectTree' doClone)' Operation' (ISqlExpression)Expr2.Clone (objectTree' doClone)' Precedence)); " is 193.
Long Statement,BLToolkit.Data.Sql,SqlExpression,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlExpression.cs,ToString,The length of the statement  "	return ((IQueryElement)this).ToString (new StringBuilder ()' new Dictionary<IQueryElement' IQueryElement> ()).ToString (); " is 122.
Long Statement,BLToolkit.Data.Sql,SqlExpression,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlExpression.cs,Clone,The length of the statement  "		objectTree.Add (this' clone = new SqlExpression (SystemType' Expr' Precedence' Parameters.Select (e => (ISqlExpression)e.Clone (objectTree' doClone)).ToArray ())); " is 163.
Long Statement,BLToolkit.Data.Sql,SqlField,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlField.cs,ToString,The length of the statement  "	return ((IQueryElement)this).ToString (new StringBuilder ()' new Dictionary<IQueryElement' IQueryElement> ()).ToString (); " is 122.
Long Statement,BLToolkit.Data.Sql,SqlFunction,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlFunction.cs,ToString,The length of the statement  "	return ((IQueryElement)this).ToString (new StringBuilder ()' new Dictionary<IQueryElement' IQueryElement> ()).ToString (); " is 122.
Long Statement,BLToolkit.Data.Sql,SqlFunction,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlFunction.cs,Clone,The length of the statement  "		objectTree.Add (this' clone = new SqlFunction (SystemType' Name' Precedence' Parameters.Select (e => (ISqlExpression)e.Clone (objectTree' doClone)).ToArray ())); " is 161.
Long Statement,BLToolkit.Data.Sql,Join,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\Join.cs,Clone,The length of the statement  "		objectTree.Add (this' clone = new Join (_tableName' _alias' _joinOns.ConvertAll (j => (JoinOn)j.Clone (objectTree' doClone)))); " is 127.
Long Statement,BLToolkit.Data.Sql,SqlParameter,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlParameter.cs,ToString,The length of the statement  "	return ((IQueryElement)this).ToString (new StringBuilder ()' new Dictionary<IQueryElement' IQueryElement> ()).ToString (); " is 122.
Long Statement,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeUnions,The length of the statement  "		if (sql == null || sql.From.Tables.Count != 1 || !sql.IsSimple || sql._insert != null || sql._update != null || sql._delete != null) " is 132.
Long Statement,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeSubQuery,The length of the statement  "		var table = OptimizeSubQuery (jt.Table' jt.JoinType == JoinType.Inner || jt.JoinType == JoinType.CrossApply' false' isApplySupported' jt.JoinType == JoinType.Inner || jt.JoinType == JoinType.CrossApply' optimizeColumns); " is 220.
Long Statement,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeSubQuery,The length of the statement  "	return source.Source is SqlQuery ? RemoveSubQuery (source' optimizeWhere' allColumns && !isApplySupported' optimizeValues' optimizeColumns) : source; " is 149.
Long Statement,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,RemoveSubQuery,The length of the statement  "	var isColumnsOK = (allColumns && !query.Select.Columns.Exists (c => IsAggregationFunction (c.Expression))) || !query.Select.Columns.Exists (c => CheckColumn (c' c.Expression' query' optimizeValues' optimizeColumns)); " is 216.
Long Statement,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeApply,The length of the statement  "			var table = OptimizeSubQuery (joinTable.Table' joinTable.JoinType == JoinType.Inner || joinTable.JoinType == JoinType.CrossApply' joinTable.JoinType == JoinType.CrossApply' isApplySupported' joinTable.JoinType == JoinType.Inner || joinTable.JoinType == JoinType.CrossApply' optimizeColumns); " is 291.
Long Statement,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ContainsTable,The length of the statement  "	return null != new QueryVisitor ().Find (sql' e => e == table || e.ElementType == QueryElementType.SqlField && table == ((SqlField)e).Table || e.ElementType == QueryElementType.Column && table == ((Column)e).Parent); " is 216.
Long Statement,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ConvertInListPredicate,The length of the statement  "							var cond = value == null ? new Condition (false' new Predicate.IsNull (field' false)) : new Condition (false' new Predicate.ExprExpr (field' Predicate.Operator.Equal' new SqlValue (value))); " is 190.
Long Statement,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ConvertInListPredicate,The length of the statement  "								var cond = value == null ? new Condition (false' new Predicate.IsNull (sql' false)) : new Condition (false' new Predicate.ExprExpr (sql' Predicate.Operator.Equal' new SqlValue (value))); " is 186.
Long Statement,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ToString,The length of the statement  "	return ((IQueryElement)this).ToString (new StringBuilder ()' new Dictionary<IQueryElement' IQueryElement> ()).ToString (); " is 122.
Long Statement,BLToolkit.Data.Sql,SqlTable,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,ToString,The length of the statement  "	return ((IQueryElement)this).ToString (new StringBuilder ()' new Dictionary<IQueryElement' IQueryElement> ()).ToString (); " is 122.
Long Statement,BLToolkit.Data.Sql,SqlValue,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlValue.cs,ToString,The length of the statement  "	return ((IQueryElement)this).ToString (new StringBuilder ()' new Dictionary<IQueryElement' IQueryElement> ()).ToString (); " is 122.
Long Statement,BLToolkit.Data.Sql,SqlValue,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlValue.cs,Equals,The length of the statement  "	return value != null && _systemType == value._systemType && (_value == null && value._value == null || _value != null && _value.Equals (value._value)); " is 151.
Long Statement,BLToolkit.Data.Sql,SqlValue,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlValue.cs,ToString,The length of the statement  "	return Value == null ? sb.Append ("NULL") : Value is string ? sb.Append ('\'').Append (Value.ToString ().Replace ("\'"' "''")).Append ('\'') : sb.Append (Value); " is 161.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The length of the statement  "		return e1.Method == e2.Method && Compare (e1.Conversion' e2.Conversion' visited' queryableAccessorDic) && Compare (e1.Left' e2.Left' visited' queryableAccessorDic) && Compare (e1.Right' e2.Right' visited' queryableAccessorDic); " is 227.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The length of the statement  "		return Compare (e1.Test' e2.Test' visited' queryableAccessorDic) && Compare (e1.IfTrue' e2.IfTrue' visited' queryableAccessorDic) && Compare (e1.IfFalse' e2.IfFalse' visited' queryableAccessorDic); " is 197.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The length of the statement  "		if (e1.Initializers.Count != e2.Initializers.Count || !Compare (e1.NewExpression' e2.NewExpression' visited' queryableAccessorDic)) " is 131.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The length of the statement  "						return Compare (e1.Expression' e2.Expression' visited' queryableAccessorDic) && Compare (qa.Queryable.Expression' qa.Accessor (expr2).Expression' visited' queryableAccessorDic); " is 177.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The length of the statement  "		if (e1.Bindings.Count != e2.Bindings.Count || !Compare (e1.NewExpression' e2.NewExpression' visited' queryableAccessorDic)) " is 123.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The length of the statement  "		Path (((UnaryExpression)expr).Operand' visited' path = ConvertTo (path' typeof(UnaryExpression))' ReflectionHelper.Unary.Operand' func); " is 136.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The length of the statement  "		Path (e.Initializers' visited' path' ReflectionHelper.ListInit.Initializers' (ex' p) => Path (ex.Arguments' visited' p' ReflectionHelper.ElementInit.Arguments' func)); " is 167.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The length of the statement  "		Path (((MemberExpression)expr).Expression' visited' path = ConvertTo (path' typeof(MemberExpression))' ReflectionHelper.Member.Expression' func); " is 145.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The length of the statement  "				Path (((MemberAssignment)b).Expression' visited' ConvertTo (pinf' typeof(MemberAssignment))' ReflectionHelper.MemberAssignmentBind.Expression' func); " is 149.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The length of the statement  "				Path (((MemberListBinding)b).Initializers' visited' ConvertTo (pinf' typeof(MemberListBinding))' ReflectionHelper.MemberListBind.Initializers' (p' psi) => Path (p.Arguments' visited' psi' ReflectionHelper.ElementInit.Arguments' func)); " is 235.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The length of the statement  "				Path (((MemberMemberBinding)b).Bindings' visited' ConvertTo (pinf' typeof(MemberMemberBinding))' ReflectionHelper.MemberMemberBind.Bindings' modify); " is 149.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The length of the statement  "		Path (((NewExpression)expr).Arguments' visited' path = ConvertTo (path' typeof(NewExpression))' ReflectionHelper.New.Arguments' func); " is 134.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The length of the statement  "		Path (((NewArrayExpression)expr).Expressions' visited' path = ConvertTo (path' typeof(NewArrayExpression))' ReflectionHelper.NewArray.Expressions' func); " is 153.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The length of the statement  "		Path (((NewArrayExpression)expr).Expressions' visited' path = ConvertTo (path' typeof(NewArrayExpression))' ReflectionHelper.NewArray.Expressions' func); " is 153.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The length of the statement  "		Path (((TypeBinaryExpression)expr).Expression' visited' path = ConvertTo (path' typeof(TypeBinaryExpression))' ReflectionHelper.TypeBinary.Expression' func); " is 157.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert2,The length of the statement  "		return c != e.Conversion || l != e.Left || r != e.Right ? Expression.MakeBinary (expr.NodeType' l' r' e.IsLiftedToNull' e.Method' (LambdaExpression)c) : expr; " is 158.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert2,The length of the statement  "		return a != e.Arguments ? e.Members == null ? Expression.New (e.Constructor' ConvertMethodArguments (a' e.Constructor)) : Expression.New (e.Constructor' ConvertMethodArguments (a' e.Constructor' e.Members)' e.Members) : expr; " is 225.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert2,The length of the statement  "		var ex = Convert2 (e.Expressions' func).Select (ee => et == typeof(object) && ee.Type.IsValueType ? Expression.Convert (ee' typeof(object)) : ee); " is 146.
Long Statement,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,GetRootObject,The length of the statement  "		if (e.Arguments != null && e.Arguments.Count > 0 && e.Method.GetCustomAttributes (typeof(SqlFunctionAttribute)' true).Length == 0) " is 130.
Long Statement,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetValueMapper,The length of the statement  "		return isSourceNullable ? Expression.Condition (Expression.Equal (source' Expression.Constant (null))' Expression.Constant (null)' Expression.Call (source' "ToString"' Array<Type>.Empty)) as Expression : Expression.Call (source' "ToString"' Array<Type>.Empty); " is 260.
Long Statement,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetValueMapper,The length of the statement  "		if (TypeHelper.GetGenericType (typeof(IEnumerable<>)' dtype) != null && TypeHelper.GetGenericType (typeof(IEnumerable<>)' stype) != null) " is 137.
Long Statement,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetBindings,The length of the statement  "		var bind = Expression.Bind (dma.MemberInfo' GetValueMapper (Expression.PropertyOrField (source' sma.Name)' dma.Type' true' dmm.MapMemberInfo.NullValue' dmm.MapMemberInfo.MapValues' dmm.MapMemberInfo.DefaultValue' smm.MapMemberInfo.MapValues)); " is 243.
Long Statement,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetBindings,The length of the statement  "		var bind = Expression.Bind (dma.MemberInfo' GetValueMapper (Expression.MakeMemberAccess (source' sma.MemberInfo)' dma.Type' true' _parameters.MappingSchema.GetNullValue (dma.Type)' _parameters.MappingSchema.GetMapValues (dma.Type)' _parameters.MappingSchema.GetDefaultValue (dma.Type)' _parameters.MappingSchema.GetMapValues (sma.Type))); " is 338.
Long Statement,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetMemberInit,The length of the statement  "	mapper.Map = Expression.Lambda<Func<TSource' MappingContext' TDest>> (expr' source' _parameters.MappingContext).Compile (); " is 123.
Long Statement,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetMapper,The length of the statement  "	var expr = GetValueMapper (parm' typeof(TDest)' true' _parameters.MappingSchema.GetNullValue (typeof(TDest))' _parameters.MappingSchema.GetMapValues (typeof(TDest))' _parameters.MappingSchema.GetDefaultValue (typeof(TDest))' _parameters.MappingSchema.GetMapValues (typeof(TSource))); " is 283.
Long Statement,BLToolkit.Mapping,TextDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadRecord,The length of the statement  "				_values [i] = value.Length == 0 ? null : value [0] == '*' ? value.Substring (1) : value [0] == '+' ? Encode (value.Substring (1)) : value; " is 138.
Long Statement,BLToolkit.Mapping,DictionaryIndexListMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\DictionaryIndexListMapperT.cs,GetNextObject,The length of the statement  "				_indexValue [i] = _fields [i].ByName ? initContext.DataSource.GetValue (initContext.SourceObject' _fields [i].Name) : initContext.DataSource.GetValue (initContext.SourceObject' _fields [i].Index); " is 196.
Long Statement,BLToolkit.Mapping,DictionaryIndexListMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\DictionaryIndexListMapperT.cs,GetNextObject,The length of the statement  "				_indexValue [i] = _fields [i].ByName ? initContext.DataSource.GetValue (initContext.SourceObject' _fields [i].Name) : initContext.DataSource.GetValue (initContext.SourceObject' _fields [i].Index); " is 196.
Long Statement,BLToolkit.Mapping,DictionaryListMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\DictionaryListMapperT.cs,InitMapping,The length of the statement  "			throw new MappingException (_keyField.ByName ? string.Format ("Field '{0}' not found."' _keyField.Name) : string.Format ("Index '{0}' is invalid."' _keyField.Index)); " is 166.
Long Statement,BLToolkit.Mapping,DictionaryListMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\DictionaryListMapperT.cs,InitMapping,The length of the statement  "		Debug.WriteLineIf (_typeMismatch' string.Format ("Member {0} type '{1}' does not match dictionary key type '{2}'."' mm.Name' mm.Type.Name' (typeof(K).Name))); " is 158.
Long Statement,BLToolkit.Mapping,DictionaryListMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\DictionaryListMapperT.cs,GetNextObject,The length of the statement  "		_keyValue = _keyField.ByName ? initContext.DataSource.GetValue (initContext.SourceObject' _keyField.Name) : initContext.DataSource.GetValue (initContext.SourceObject' _keyField.Index); " is 184.
Long Statement,BLToolkit.Mapping,DataReaderMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\DataReaderMapper.cs,GetDateTimeOffset,The length of the statement  "	return _dataReaderEx != null ? _dataReaderEx.GetDateTimeOffset (index) : _mappingSchema.ConvertToDateTimeOffset (_dataReader.GetValue (index)); " is 143.
Long Statement,BLToolkit.Mapping,DataReaderMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\DataReaderMapper.cs,GetNullableDateTimeOffset,The length of the statement  "	return _dataReader.IsDBNull (index) ? null : _dataReaderEx != null ? _dataReaderEx.GetDateTimeOffset (index) : _mappingSchema.ConvertToNullableDateTimeOffset (_dataReader.GetValue (index)); " is 189.
Long Statement,BLToolkit.Mapping,Map,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Map.cs,DictionaryToDictionary,The length of the statement  "	return _defaultSchema.MapDictionaryToDictionary (sourceDictionary' destDictionary' keyField' destObjectType' parameters); " is 121.
Long Statement,BLToolkit.Mapping,MapIndex,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MapIndex.cs,GetValue,The length of the statement  "	var value = Fields [index].ByName ? source.GetValue (obj' Fields [index].Name) : source.GetValue (obj' Fields [index].Index); " is 125.
Long Statement,BLToolkit.Mapping,MapIndex,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MapIndex.cs,GetValue,The length of the statement  "				throw new MappingException (string.Format (Resources.MapIndex_BadField' objectMapper.TypeAccessor.OriginalType.Name' Fields [index])); " is 134.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSByte,The length of the statement  "	return value is SByte ? (SByte)value : value is Byte ? (SByte)(Byte)value : value == null ? DefaultSByteNullValue : Convert.ToSByte (value); " is 140.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToInt16,The length of the statement  "	return value is Int16 ? (Int16)value : value == null || value is DBNull ? DefaultInt16NullValue : Convert.ToInt16 (value); " is 122.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToInt32,The length of the statement  "	return value is Int32 ? (Int32)value : value == null || value is DBNull ? DefaultInt32NullValue : Convert.ToInt32 (value); " is 122.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToInt64,The length of the statement  "	return value is Int64 ? (Int64)value : value == null || value is DBNull ? DefaultInt64NullValue : Convert.ToInt64 (value); " is 122.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToUInt16,The length of the statement  "	return value is UInt16 ? (UInt16)value : value is Int16 ? (UInt16)(Int16)value : value == null || value is DBNull ? DefaultUInt16NullValue : Convert.ToUInt16 (value); " is 166.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToUInt32,The length of the statement  "	return value is UInt32 ? (UInt32)value : value is Int32 ? (UInt32)(Int32)value : value == null || value is DBNull ? DefaultUInt32NullValue : Convert.ToUInt32 (value); " is 166.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToUInt64,The length of the statement  "	return value is UInt64 ? (UInt64)value : value is Int64 ? (UInt64)(Int64)value : value == null || value is DBNull ? DefaultUInt64NullValue : Convert.ToUInt64 (value); " is 166.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSingle,The length of the statement  "	return value is Single ? (Single)value : value == null || value is DBNull ? DefaultSingleNullValue : Convert.ToSingle (value); " is 126.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToDouble,The length of the statement  "	return value is Double ? (Double)value : value == null || value is DBNull ? DefaultDoubleNullValue : Convert.ToDouble (value); " is 126.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToBoolean,The length of the statement  "	return value is Boolean ? (Boolean)value : value == null || value is DBNull ? DefaultBooleanNullValue : Convert.ToBoolean (value); " is 130.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToString,The length of the statement  "	return value is String ? (String)value : value == null || value is DBNull ? DefaultStringNullValue : Convert.ToString (value); " is 126.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToDateTime,The length of the statement  "	return value is DateTime ? (DateTime)value : value == null || value is DBNull ? DefaultDateTimeNullValue : Convert.ToDateTime (value); " is 134.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToDateTimeOffset,The length of the statement  "	return value is DateTimeOffset ? (DateTimeOffset)value : value == null || value is DBNull ? DefaultDateTimeOffsetNullValue : Convert.ToDateTimeOffset (value); " is 158.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToLinqBinary,The length of the statement  "	return value is Binary ? (Binary)value : value is byte[] ? new Binary ((byte[])value) : value == null || value is DBNull ? DefaultLinqBinaryNullValue : Convert.ToLinqBinary (value); " is 181.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToDecimal,The length of the statement  "	return value is Decimal ? (Decimal)value : value == null || value is DBNull ? DefaultDecimalNullValue : Convert.ToDecimal (value); " is 130.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToStream,The length of the statement  "	return value is Stream ? (Stream)value : value == null || value is DBNull ? DefaultStreamNullValue : Convert.ToStream (value); " is 126.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToXmlReader,The length of the statement  "	return value is XmlReader ? (XmlReader)value : value == null || value is DBNull ? DefaultXmlReaderNullValue : Convert.ToXmlReader (value); " is 138.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToXmlDocument,The length of the statement  "	return value is XmlDocument ? (XmlDocument)value : value == null || value is DBNull ? DefaultXmlDocumentNullValue : Convert.ToXmlDocument (value); " is 146.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToXElement,The length of the statement  "	return value is XElement ? (XElement)value : value == null || value is DBNull ? DefaultXElementNullValue : XElement.Parse (value.ToString ()); " is 142.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToNullableSByte,The length of the statement  "	return value is SByte ? (SByte?)value : value is Byte ? (SByte?)(Byte)value : value == null || value is DBNull ? null : Convert.ToNullableSByte (value); " is 152.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToNullableUInt16,The length of the statement  "	return value is UInt16 ? (UInt16?)value : value is Int16 ? (UInt16?)(Int16)value : value == null || value is DBNull ? null : Convert.ToNullableUInt16 (value); " is 158.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToNullableUInt32,The length of the statement  "	return value is UInt32 ? (UInt32?)value : value is Int32 ? (UInt32?)(Int32)value : value == null || value is DBNull ? null : Convert.ToNullableUInt32 (value); " is 158.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToNullableUInt64,The length of the statement  "	return value is UInt64 ? (UInt64?)value : value is Int64 ? (UInt64?)(Int64)value : value == null || value is DBNull ? null : Convert.ToNullableUInt64 (value); " is 158.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToNullableBoolean,The length of the statement  "	return value is Boolean ? (Boolean?)value : value == null || value is DBNull ? null : Convert.ToNullableBoolean (value); " is 120.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToNullableDateTime,The length of the statement  "	return value is DateTime ? (DateTime?)value : value == null || value is DBNull ? null : Convert.ToNullableDateTime (value); " is 123.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToNullableDateTimeOffset,The length of the statement  "	return value is DateTimeOffset ? (DateTimeOffset?)value : value == null || value is DBNull ? null : Convert.ToNullableDateTimeOffset (value); " is 141.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToNullableDecimal,The length of the statement  "	return value is Decimal ? (Decimal?)value : value == null || value is DBNull ? null : Convert.ToNullableDecimal (value); " is 120.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlInt16,The length of the statement  "	return value == null || value is DBNull ? SqlInt16.Null : value is SqlInt16 ? (SqlInt16)value : Convert.ToSqlInt16 (value); " is 123.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlInt32,The length of the statement  "	return value == null || value is DBNull ? SqlInt32.Null : value is SqlInt32 ? (SqlInt32)value : Convert.ToSqlInt32 (value); " is 123.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlInt64,The length of the statement  "	return value == null || value is DBNull ? SqlInt64.Null : value is SqlInt64 ? (SqlInt64)value : Convert.ToSqlInt64 (value); " is 123.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlSingle,The length of the statement  "	return value == null || value is DBNull ? SqlSingle.Null : value is SqlSingle ? (SqlSingle)value : Convert.ToSqlSingle (value); " is 127.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlBoolean,The length of the statement  "	return value == null || value is DBNull ? SqlBoolean.Null : value is SqlBoolean ? (SqlBoolean)value : Convert.ToSqlBoolean (value); " is 131.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlDouble,The length of the statement  "	return value == null || value is DBNull ? SqlDouble.Null : value is SqlDouble ? (SqlDouble)value : Convert.ToSqlDouble (value); " is 127.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlDateTime,The length of the statement  "	return value == null || value is DBNull ? SqlDateTime.Null : value is SqlDateTime ? (SqlDateTime)value : Convert.ToSqlDateTime (value); " is 135.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlDecimal,The length of the statement  "	return value == null || value is DBNull ? SqlDecimal.Null : value is SqlDecimal ? (SqlDecimal)value : value is SqlMoney ? ((SqlMoney)value).ToSqlDecimal () : Convert.ToSqlDecimal (value); " is 187.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlMoney,The length of the statement  "	return value == null || value is DBNull ? SqlMoney.Null : value is SqlMoney ? (SqlMoney)value : value is SqlDecimal ? ((SqlDecimal)value).ToSqlMoney () : Convert.ToSqlMoney (value); " is 181.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlString,The length of the statement  "	return value == null || value is DBNull ? SqlString.Null : value is SqlString ? (SqlString)value : Convert.ToSqlString (value); " is 127.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlBinary,The length of the statement  "	return value == null || value is DBNull ? SqlBinary.Null : value is SqlBinary ? (SqlBinary)value : Convert.ToSqlBinary (value); " is 127.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlBytes,The length of the statement  "	return value == null || value is DBNull ? SqlBytes.Null : value is SqlBytes ? (SqlBytes)value : Convert.ToSqlBytes (value); " is 123.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertToSqlChars,The length of the statement  "	return value == null || value is DBNull ? SqlChars.Null : value is SqlChars ? (SqlChars)value : Convert.ToSqlChars (value); " is 123.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertChangeType,The length of the statement  "			if (srcElementType.IsArray != dstElementType.IsArray || (srcElementType.IsArray && srcElementType.GetArrayRank () != dstElementType.GetArrayRank ())) { " is 151.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertChangeType,The length of the statement  "				throw new InvalidCastException (string.Format (Resources.MappingSchema_IncompatibleArrayTypes' srcType.FullName' conversionType.FullName)); " is 139.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,GetDataSourceList,The length of the statement  "	return TypeHelper.IsScalar (type) ? (IMapDataSourceList)CreateScalarSourceListMapper ((IList)obj' type) : CreateObjectListMapper ((IList)obj' CreateObjectMapper (type)); " is 169.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,GetDataDestinationList,The length of the statement  "	return TypeHelper.IsScalar (type) ? (IMapDataDestinationList)CreateScalarDestinationListMapper ((IList)obj' type) : CreateObjectListMapper ((IList)obj' CreateObjectMapper (type)); " is 179.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapInternal,The length of the statement  "		MapInternal (initContext' initContext.DataSource' initContext.SourceObject' initContext.ObjectMapper' dest' initContext.Parameters); " is 132.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,The length of the statement  "	return convertToUnderlyingType ? System.Convert.ChangeType (value' Enum.GetUnderlyingType (type)' Thread.CurrentThread.CurrentCulture) : value; " is 143.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,The length of the statement  "	return convertToUnderlyingType ? System.Convert.ChangeType (value' Enum.GetUnderlyingType (memberAccessorType)' Thread.CurrentThread.CurrentCulture) : value; " is 157.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapObjectToObject,The length of the statement  "	MapInternal (null' GetObjectMapper (sourceObject.GetType ())' sourceObject' GetObjectMapper (destObject.GetType ())' destObject' parameters); " is 141.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapObjectToDataRow,The length of the statement  "	MapInternal (null' GetObjectMapper (sourceObject.GetType ())' sourceObject' CreateDataRowMapper (destRow' DataRowVersion.Default)' destRow' null); " is 146.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapObjectToDataRow,The length of the statement  "	MapInternal (null' GetObjectMapper (sourceObject.GetType ())' sourceObject' CreateDataRowMapper (destRow' DataRowVersion.Default)' destRow' null); " is 146.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapObjectToDictionary,The length of the statement  "	MapInternal (null' GetObjectMapper (sourceObject.GetType ())' sourceObject' CreateDictionaryMapper (destDictionary)' destDictionary' null); " is 139.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataRowToObject,The length of the statement  "	MapInternal (null' CreateDataRowMapper (dataRow' DataRowVersion.Default)' dataRow' GetObjectMapper (destObject.GetType ())' destObject' parameters); " is 148.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataRowToObject,The length of the statement  "	MapInternal (null' CreateDataRowMapper (dataRow' version)' dataRow' GetObjectMapper (destObject.GetType ())' destObject' parameters); " is 133.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataRowToDataRow,The length of the statement  "	MapInternal (null' CreateDataRowMapper (sourceRow' DataRowVersion.Default)' sourceRow' CreateDataRowMapper (destRow' DataRowVersion.Default)' destRow' null); " is 157.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataRowToDataRow,The length of the statement  "	MapInternal (null' CreateDataRowMapper (sourceRow' version)' sourceRow' CreateDataRowMapper (destRow' DataRowVersion.Default)' destRow' null); " is 142.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataRowToDataRow,The length of the statement  "	MapInternal (null' CreateDataRowMapper (sourceRow' DataRowVersion.Default)' sourceRow' CreateDataRowMapper (destRow' DataRowVersion.Default)' destRow' null); " is 157.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataRowToDataRow,The length of the statement  "	MapInternal (null' CreateDataRowMapper (sourceRow' version)' sourceRow' CreateDataRowMapper (destRow' DataRowVersion.Default)' destRow' null); " is 142.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataRowToDictionary,The length of the statement  "	MapInternal (null' CreateDataRowMapper (sourceRow' DataRowVersion.Default)' sourceRow' CreateDictionaryMapper (destDictionary)' destDictionary' null); " is 150.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataRowToDictionary,The length of the statement  "	MapInternal (null' CreateDataRowMapper (sourceRow' DataRowVersion.Default)' sourceRow' CreateDictionaryMapper (destDictionary)' destDictionary' null); " is 150.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataRowToDictionary,The length of the statement  "	MapInternal (null' CreateDataRowMapper (sourceRow' version)' sourceRow' CreateDictionaryMapper (destDictionary)' destDictionary' null); " is 135.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataRowToDictionary,The length of the statement  "	MapInternal (null' CreateDataRowMapper (sourceRow' version)' sourceRow' CreateDictionaryMapper (destDictionary)' destDictionary' null); " is 135.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToObject,The length of the statement  "	MapInternal (null' CreateDataReaderMapper (dataReader)' dataReader' GetObjectMapper (destObject.GetType ())' destObject' parameters); " is 133.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDataRow,The length of the statement  "	MapInternal (null' CreateDataReaderMapper (dataReader)' dataReader' CreateDataRowMapper (destRow' DataRowVersion.Default)' destRow' null); " is 138.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDataRow,The length of the statement  "	MapInternal (null' CreateDataReaderMapper (dataReader)' dataReader' CreateDataRowMapper (destRow' DataRowVersion.Default)' destRow' null); " is 138.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The length of the statement  "	MapInternal (null' CreateDataReaderMapper (dataReader)' dataReader' CreateDictionaryMapper (destDictionary)' destDictionary' null); " is 131.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The length of the statement  "	MapInternal (null' CreateDataReaderMapper (dataReader)' dataReader' CreateDictionaryMapper (destDictionary)' destDictionary' null); " is 131.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToObject,The length of the statement  "	MapInternal (null' CreateDictionaryMapper (sourceDictionary)' sourceDictionary' GetObjectMapper (destObject.GetType ())' destObject' parameters); " is 145.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDataRow,The length of the statement  "	MapInternal (null' CreateDictionaryMapper (sourceDictionary)' sourceDictionary' CreateDataRowMapper (destRow' DataRowVersion.Default)' destRow' null); " is 150.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDataRow,The length of the statement  "	MapInternal (null' CreateDictionaryMapper (sourceDictionary)' sourceDictionary' CreateDataRowMapper (destRow' DataRowVersion.Default)' destRow' null); " is 150.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToList,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateObjectListMapper (destList' GetObjectMapper (destObjectType))' parameters); " is 167.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToList,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateObjectListMapper (destList' GetObjectMapper (destObjectType))' parameters); " is 167.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToList,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateObjectListMapper (destList' GetObjectMapper (typeof(T)))' parameters); " is 162.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToList,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateObjectListMapper (destList' GetObjectMapper (typeof(T)))' parameters); " is 162.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDataTable,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateDataTableMapper (destTable' DataRowVersion.Default)' null); " is 151.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDataTable,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateDataTableMapper (destTable' DataRowVersion.Default)' null); " is 151.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateDictionaryListMapper (destDictionary' keyFieldNameOrIndex' GetObjectMapper (destObjectType))' parameters); " is 198.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateDictionaryListMapper (destDictionary' keyFieldNameOrIndex' GetObjectMapper (destObjectType))' parameters); " is 198.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateDictionaryListMapper<TK' T> (destDictionary' keyFieldNameOrIndex' GetObjectMapper (typeof(T)))' parameters); " is 200.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateDictionaryListMapper<TK' T> (destDictionary' keyFieldNameOrIndex' GetObjectMapper (typeof(T)))' parameters); " is 200.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateDictionaryListMapper (destDictionary' index' GetObjectMapper (destObjectType))' parameters); " is 184.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateDictionaryListMapper (destDictionary' index' GetObjectMapper (destObjectType))' parameters); " is 184.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateDictionaryListMapper<T> (destDictionary' index' GetObjectMapper (typeof(T)))' parameters); " is 182.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapListToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceList.GetEnumerator ())' CreateDictionaryListMapper<T> (destDictionary' index' GetObjectMapper (typeof(T)))' parameters); " is 182.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDataTable,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateDataTableMapper (destTable' DataRowVersion.Default)' null); " is 158.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDataTable,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' version)' CreateDataTableMapper (destTable' DataRowVersion.Default)' null); " is 143.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDataTable,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateDataTableMapper (destTable' DataRowVersion.Default)' null); " is 158.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDataTable,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' version)' CreateDataTableMapper (destTable' DataRowVersion.Default)' null); " is 143.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToList,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateObjectListMapper (list' GetObjectMapper (destObjectType))' parameters); " is 170.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToList,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' version)' CreateObjectListMapper (list' GetObjectMapper (destObjectType))' parameters); " is 155.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToList,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateObjectListMapper (list' GetObjectMapper (destObjectType))' parameters); " is 170.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToList,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' version)' CreateObjectListMapper (list' GetObjectMapper (destObjectType))' parameters); " is 155.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToList,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateObjectListMapper (list' GetObjectMapper (typeof(T)))' parameters); " is 165.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToList,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' version)' CreateObjectListMapper (list' GetObjectMapper (typeof(T)))' parameters); " is 150.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToList,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateObjectListMapper (list' GetObjectMapper (typeof(T)))' parameters); " is 165.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToList,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' version)' CreateObjectListMapper (list' GetObjectMapper (typeof(T)))' parameters); " is 150.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateDictionaryListMapper (destDictionary' keyFieldNameOrIndex' GetObjectMapper (destObjectType))' parameters); " is 205.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateDictionaryListMapper (destDictionary' keyFieldNameOrIndex' GetObjectMapper (destObjectType))' parameters); " is 205.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateDictionaryListMapper<TK' T> (destDictionary' keyFieldNameOrIndex' GetObjectMapper (typeof(T)))' parameters); " is 207.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateDictionaryListMapper<TK' T> (destDictionary' keyFieldNameOrIndex' GetObjectMapper (typeof(T)))' parameters); " is 207.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateDictionaryListMapper (destDictionary' index' GetObjectMapper (destObjectType))' parameters); " is 191.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateDictionaryListMapper (destDictionary' index' GetObjectMapper (destObjectType))' parameters); " is 191.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateDictionaryListMapper<T> (destDictionary' index' GetObjectMapper (typeof(T)))' parameters); " is 189.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataTableToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataTableMapper (sourceTable' DataRowVersion.Default)' CreateDictionaryListMapper<T> (destDictionary' index' GetObjectMapper (typeof(T)))' parameters); " is 189.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToList,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateObjectListMapper (list' GetObjectMapper (destObjectType))' parameters); " is 146.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToList,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateObjectListMapper (list' GetObjectMapper (destObjectType))' parameters); " is 146.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToList,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateObjectListMapper ((IList)list' GetObjectMapper (typeof(T)))' parameters); " is 148.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToList,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateObjectListMapper (list' GetObjectMapper (typeof(T)))' parameters); " is 141.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToScalarList,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader' nameOrIndex)' CreateScalarDestinationListMapper (list' type)' null); " is 136.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToScalarList,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader' nameOrIndex)' CreateScalarDestinationListMapper (list' type)' null); " is 136.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToScalarList,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader' nameOrIndex)' CreateScalarDestinationListMapper (list)' null); " is 130.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToScalarList,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader' nameOrIndex)' CreateScalarDestinationListMapper (list)' null); " is 130.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDataTable,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateDataTableMapper (destTable' DataRowVersion.Default)' null); " is 134.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDataTable,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateDataTableMapper (destTable' DataRowVersion.Default)' null); " is 134.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateDictionaryListMapper (destDictionary' keyFieldNameOrIndex' GetObjectMapper (destObjectType))' parameters); " is 181.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateDictionaryListMapper (dest' keyFieldNameOrIndex' GetObjectMapper (destObjectType))' parameters); " is 171.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateDictionaryListMapper<TK' T> (destDictionary' keyFieldNameOrIndex' GetObjectMapper (destObjectType))' parameters); " is 188.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateDictionaryListMapper<TK' T> (destDictionary' keyFieldNameOrIndex' GetObjectMapper (typeof(T)))' parameters); " is 183.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateDictionaryListMapper<TK' T> (dest' keyFieldNameOrIndex' GetObjectMapper (typeof(T)))' parameters); " is 173.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateDictionaryListMapper (destDictionary' index' GetObjectMapper (destObjectType))' parameters); " is 167.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateDictionaryListMapper (destDictionary' index' GetObjectMapper (destObjectType))' parameters); " is 167.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateDictionaryListMapper (destDictionary' index' GetObjectMapper (destObjectType))' parameters); " is 167.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateDictionaryListMapper (destDictionary' index' GetObjectMapper (typeof(T)))' parameters); " is 162.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDataReaderToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateDataReaderListMapper (reader)' CreateDictionaryListMapper<T> (destDictionary' index' GetObjectMapper (typeof(T)))' parameters); " is 165.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToList,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateObjectListMapper (destList' GetObjectMapper (destObjectType))' parameters); " is 180.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToList,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateObjectListMapper (destList' GetObjectMapper (destObjectType))' parameters); " is 180.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToList,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateObjectListMapper (destList' GetObjectMapper (typeof(T)))' parameters); " is 175.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToList,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateObjectListMapper (destList' GetObjectMapper (typeof(T)))' parameters); " is 175.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDataTable,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateDataTableMapper (destTable' DataRowVersion.Default)' null); " is 164.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDataTable,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateDataTableMapper (destTable' DataRowVersion.Default)' null); " is 164.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateDictionaryListMapper (destDictionary' keyFieldNameOrIndex' GetObjectMapper (destObjectType))' parameters); " is 211.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateDictionaryListMapper (dest' keyFieldNameOrIndex' GetObjectMapper (destObjectType))' parameters); " is 201.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateDictionaryListMapper<TK' T> (destDictionary' keyFieldNameOrIndex' GetObjectMapper (typeof(T)))' parameters); " is 213.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateDictionaryListMapper<TK' T> (dest' keyFieldNameOrIndex' GetObjectMapper (typeof(T)))' parameters); " is 203.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateDictionaryListMapper (destDictionary' index' GetObjectMapper (destObjectType))' parameters); " is 197.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateDictionaryListMapper (destDictionary' index' GetObjectMapper (destObjectType))' parameters); " is 197.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateDictionaryListMapper<T> (destDictionary' index' GetObjectMapper (typeof(T)))' parameters); " is 195.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapDictionaryToDictionary,The length of the statement  "	MapSourceListToDestinationList (CreateEnumeratorMapper (sourceDictionary.Values.GetEnumerator ())' CreateDictionaryListMapper<T> (destDictionary' index' GetObjectMapper (typeof(T)))' parameters); " is 195.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapResultSets,The length of the statement  "					throw new MappingException (string.Format (Resources.MapIndex_BadField' masterMapper.TypeAccessor.OriginalType.Name' r.ContainerName)); " is 135.
Long Statement,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,PrepareRelarions,The length of the statement  "			List<MapRelationBase> relations = MetadataProvider.GetRelations (this' Extensions' masterSet.ObjectType' slaveSet.ObjectType' out isSet); " is 137.
Long Statement,BLToolkit.Mapping,ObjectMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ObjectMapperT.cs,CreateMemberMapper,The length of the statement  "		var attrs = TypeHelper.GetAttributes (mapMemberInfo.MemberAccessor.MemberInfo.DeclaringType' typeof(MemberMapperAttribute)); " is 124.
Long Statement,BLToolkit.Mapping,ObjectMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ObjectMapperT.cs,Init,The length of the statement  "			throw new MappingException (string.Format ("Type '{0}' has invalid  extension. MapField MapName='{1}' OrigName='{2}'."' type.FullName' mapName' origName)); " is 155.
Long Statement,BLToolkit.Mapping.Fluent,FluentMap,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Fluent\Attributes.cs,MapFieldOnField,The length of the statement  "		member.Attributes.Add (Attributes.MapField.IsInheritanceDiscriminator' this.ToString (isInheritanceDiscriminator.Value)); " is 121.
Long Statement,BLToolkit.Mapping.Fluent,FluentMap,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Fluent\Attributes.cs,Association,The length of the statement  "	return new MapFieldMap<T' TR>.AssociationMap<TRt> (new MapFieldMap<T' TR> (this._typeExtension' this.Childs' prop)' canBeNull' keys); " is 133.
Long Statement,BLToolkit.Mapping.Fluent,FluentMap,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\Fluent\Attributes.cs,Association,The length of the statement  "	((IFluentMap)this).Association (name' canBeNull' this.KeysToString (thisKeys.ToArray ())' this.KeysToString (otherKeys.ToArray ())); " is 132.
Long Statement,BLToolkit.Mapping.MemberMappers,JSONSerialisationMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MemberMappers\JSONSerialisationMapper.cs,GetSerializer,The length of the statement  "	var serializer = extraType != typeof(object) || extraType2 != typeof(object) ? new DataContractJsonSerializer (type' extraTypes) : new DataContractJsonSerializer (type); " is 169.
Long Statement,BLToolkit.Mapping.MemberMappers,XMLSerialisationMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MemberMappers\XMLSerialisationMapper.cs,GetSerializer,The length of the statement  "	var serializer = extraType != typeof(object) || extraType2 != typeof(object) ? new XmlSerializer (type' extraTypes) : new XmlSerializer (type); " is 143.
Long Statement,BLToolkit.ComponentModel,BindingListImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,GetSortComparer,The length of the statement  "					sorts [i] = new ListSortDescription (((SortSubstitutionPair)_sortSubstitutions [sorts [i].PropertyDescriptor.Name]).Substitute' sorts [i].SortDirection); " is 153.
Long Statement,BLToolkit.ComponentModel,BindingListImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,CreateSortSubstitution,The length of the statement  "		throw new InvalidOperationException ("Can not retrieve PropertyDescriptor for substitute property: " + substituteProperty); " is 123.
Long Statement,BLToolkit.ComponentModel,BindingListImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,GetItemSortedPosition,The length of the statement  "	if ((index > 0 && comparer.Compare (_list [index - 1]' sender) > 0) || (index < _list.Count - 1 && comparer.Compare (_list [index + 1]' sender) < 0)) { " is 151.
Long Statement,BLToolkit.ComponentModel,BindingListImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,OnMoveItem,The length of the statement  "	OnCollectionChanged (new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Move' item' newIndex' oldIndex)); " is 122.
Long Statement,BLToolkit.ComponentModel,BindingListImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,OnChangeItem,The length of the statement  "	OnCollectionChanged (new NotifyCollectionChangedEventArgs (NotifyCollectionChangedAction.Replace' oldValue' newValue' index)); " is 126.
Long Statement,BLToolkit.ComponentModel,CustomTypeDescriptorImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\CustomTypeDescriptorImpl.cs,GetEditor,The length of the statement  "				if (ea.EditorBaseTypeName != null && ea.EditorTypeName != null && editorBaseType == GetTypeByName (ea.EditorBaseTypeName)) { " is 124.
Long Statement,BLToolkit.ComponentModel,TypedListImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\TypedListImpl.cs,GetItemProperties,The length of the statement  "			_pdc = _typeAccessor != null ? _typeAccessor.CreateExtendedPropertyDescriptors (objectViewType' isNull) : new PropertyDescriptorCollection (null); " is 146.
Long Statement,BLToolkit.ComponentModel,ObjectBinder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\ObjectBinder.cs,GetItemProperties,The length of the statement  "	string key = _itemType + "." + (_objectViewType == null ? string.Empty : _objectViewType.ToString ()) + "." + (_isNull == null ? "0" : "1"); " is 140.
Long Statement,BLToolkit.ComponentModel.Design,ObjectViewTypeEditor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\ObjectViewTypeEditor.cs,FilterTypeList,The length of the statement  "	return type.IsPublic && !type.IsInterface && !type.ContainsGenericParameters && TypeHelper.IsSameOrParent (typeof(IObjectView)' type); " is 134.
Long Statement,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,LoadTypes,The length of the statement  "		types.Sort ((a' b) => a.Assembly == b.Assembly ? string.Compare (a.FullName' b.FullName) : string.Compare (a.Assembly.FullName' b.Assembly.FullName)); " is 150.
Long Statement,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The length of the statement  "	System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager (typeof(GetTypeDialog)); " is 134.
Long Statement,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The length of the statement  "	this._treeView.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 233.
Long Statement,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The length of the statement  "	this._systemCheckBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left))); " is 153.
Long Statement,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The length of the statement  "	labelRebuild.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right))); " is 186.
Long Statement,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The length of the statement  "	labelRebuild.Font = new System.Drawing.Font ("Microsoft Sans Serif"' 9.75F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(204))); " is 157.
Long Statement,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The length of the statement  "	labelRebuild.Text = "If your object type does not appear' close the dialog and rebuild the project tha" + "t contains your object.\r\n\r\n"; " is 140.
Long Statement,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The length of the statement  "	this._okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 148.
Long Statement,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The length of the statement  "	this._cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 152.
Long Statement,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The length of the statement  "	this.Font = new System.Drawing.Font ("Tahoma"' 9.75F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(204))); " is 138.
Long Statement,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,AddTypes,The length of the statement  "		string message = "Cant retrieve Data Source Collection: " + ex.Message + "\nCheck the 'Properties\\DataSources' folder of your project."; " is 137.
Long Statement,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,SaveType,The length of the statement  "		const string vs9TypeName = "Microsoft.VSDesigner.VSDesignerPackage.IGenericObjectDataSourcesService' Microsoft.VSDesigner' Version=9.0.0.0' Culture=neutral' PublicKeyToken=b03f5f7f11d50a3a"; " is 190.
Long Statement,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,SaveType,The length of the statement  "		const string vs8TypeName = "Microsoft.VSDesigner.VSDesignerPackage.IGenericObjectDataSourcesService' Microsoft.VSDesigner' Version=8.0.0.0' Culture=neutral' PublicKeyToken=b03f5f7f11d50a3a"; " is 190.
Long Statement,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The length of the statement  "	System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager (typeof(TypePicker)); " is 131.
Long Statement,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The length of the statement  "	this.addNewLinkLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler (this.addNewLinkLabel_LinkClicked); " is 129.
Long Statement,BLToolkit.ComponentModel.Design,TypeEditor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypeEditor.cs,EditValue,The length of the statement  "	DataSourceProviderService dspService = (DataSourceProviderService)provider.GetService (typeof(DataSourceProviderService)); " is 122.
Long Statement,BLToolkit.ComponentModel.Design,TypeEditor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypeEditor.cs,FilterTypeList,The length of the statement  "	!type.ContainsGenericParameters && !typeof(ICollection).IsAssignableFrom (type) && !typeof(Attribute).IsAssignableFrom (type) && !typeof(Exception).IsAssignableFrom (type) && !typeof(EventArgs).IsAssignableFrom (type) && !typeof(Control).IsAssignableFrom (type) && !typeof(DataTable).IsAssignableFrom (type) && !typeof(DataView).IsAssignableFrom (type) && !typeof(DataRow).IsAssignableFrom (type) && !typeof(DataRowView).IsAssignableFrom (type) && !typeof(DataSet).IsAssignableFrom (type); " is 489.
Long Statement,BLToolkit.ComponentModel.Design,TypeEditor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypeEditor.cs,GetEditStyle,The length of the statement  "	return dspService == null || !dspService.SupportsAddNewDataSource ? UITypeEditorEditStyle.Modal : UITypeEditorEditStyle.DropDown; " is 129.
Long Statement,BLToolkit.EditableObjects,EditableXmlDocument,F:\newReposMay17\igor-tkachev_bltoolkit\Source\EditableObjects\EditableXmlDocument.cs,PrintDebugState,The length of the statement  "	str += string.Format ("{0'-20} {1} {2'-80}\r\n"' propertyInfo.Name' IsDirty ? "*" : " "' _current != null ? _current.OuterXml : "(null)"); " is 138.
Long Statement,BLToolkit.EditableObjects,EditableArrayList,F:\newReposMay17\igor-tkachev_bltoolkit\Source\EditableObjects\EditableArrayList.cs,PrintDebugState,The length of the statement  "	str += string.Format ("{0'-20} {1} {2'-40} {3'-40} \r\n"' propertyInfo.Name' IsDirty ? "*" : " "' original' List.Count); " is 120.
Long Statement,BLToolkit.EditableObjects,EditableArrayList,F:\newReposMay17\igor-tkachev_bltoolkit\Source\EditableObjects\EditableArrayList.cs,Reverse,The length of the statement  "		throw new InvalidOperationException ("Reverse is not supported for already sorted arrays. Invoke IBindingList.RemoveSort() first or provide reverse sort direction."); " is 166.
Long Statement,BLToolkit.EditableObjects,EditableArrayList,F:\newReposMay17\igor-tkachev_bltoolkit\Source\EditableObjects\EditableArrayList.cs,Reverse,The length of the statement  "		throw new InvalidOperationException ("Range Reverse is not supported for already sorted arrays. Invoke IBindingList.RemoveSort() first."); " is 138.
Long Statement,BLToolkit.EditableObjects,EditableArrayList,F:\newReposMay17\igor-tkachev_bltoolkit\Source\EditableObjects\EditableArrayList.cs,Sort,The length of the statement  "			throw new InvalidOperationException ("Currently applied sort method is not recognized/supported by EditableArrayList."); " is 120.
Long Statement,BLToolkit.EditableObjects,EditableArrayList,F:\newReposMay17\igor-tkachev_bltoolkit\Source\EditableObjects\EditableArrayList.cs,Sort,The length of the statement  "		throw new InvalidOperationException ("Custom sorting is not supported on already sorted arrays. Invoke IBindingList.RemoveSort first."); " is 136.
Long Statement,BLToolkit.EditableObjects,EditableArrayList,F:\newReposMay17\igor-tkachev_bltoolkit\Source\EditableObjects\EditableArrayList.cs,Sort,The length of the statement  "		throw new InvalidOperationException ("Custom sorting is not supported on already sorted arrays. Invoke IBindingList.RemoveSort first."); " is 136.
Long Statement,BLToolkit.EditableObjects,EditableArrayList,F:\newReposMay17\igor-tkachev_bltoolkit\Source\EditableObjects\EditableArrayList.cs,Adapter,The length of the statement  "	return list is ArrayList ? new EditableArrayList (itemType' (ArrayList)list) : new EditableArrayList (itemType' ArrayList.Adapter (list)); " is 138.
Long Statement,BLToolkit.Patterns,DuckTyping,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Patterns\DuckTyping.cs,Implement,The length of the statement  "		throw new ArgumentException (string.Format (Resources.DuckTyping_NotASubtypeOf' objType.FullName' baseObjectType.FullName)' "obj"); " is 131.
Long Statement,BLToolkit.Patterns,DuckTyping,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Patterns\DuckTyping.cs,GetDuckType,The length of the statement  "			type = TypeFactory.GetType (new CompoundValue (interfaceType' key)' interfaceType' new DuckTypeBuilder (MustImplementAttribute.Aggregate' interfaceType' objectTypes)); " is 167.
Long Statement,BLToolkit.Patterns,DuckTyping,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Patterns\DuckTyping.cs,Aggregate,The length of the statement  "				throw new ArgumentException (string.Format (Resources.DuckTyping_NotASubtypeOf' objType.FullName' baseObjectTypes [i].FullName)' "objs"); " is 137.
Long Statement,BLToolkit.Reflection,ExprTypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\ExprTypeAccessor.cs,ThrowException,The length of the statement  "	throw new TypeBuilderException (string.Format ("The '{0}' type must have default or init constructor."' typeof(TOriginal).FullName)); " is 133.
Long Statement,BLToolkit.Reflection,MemberAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MemberAccessor.cs,GetValue,The length of the statement  "		_defaultValue = Expression.Lambda<Func<object>> (Expression.Call (mi.GetGenericMethodDefinition ().MakeGenericMethod (Type))).Compile () (); " is 140.
Long Statement,BLToolkit.Reflection,TypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessorT.cs,CreateInstance,The length of the statement  "	throw new TypeBuilderException (string.Format ("The '{0}' type must have public default or init constructor."' OriginalType.Name)); " is 131.
Long Statement,BLToolkit.Reflection,TypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessorT.cs,GetAccessor,The length of the statement  "		var accessorType = TypeFactory.GetType (originalType' originalType' new TypeAccessorBuilder (instanceType' originalType)); " is 122.
Long Statement,BLToolkit.Reflection,TypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessorT.cs,GetExtendedProperties,The length of the statement  "		if (!isList && !propertyType.IsValueType && !propertyType.IsArray && (!propertyType.FullName.StartsWith ("System.") || explicitlyBound || propertyType.IsGenericType) && propertyType != typeof(Type) && propertyType != typeof(string) && propertyType != typeof(object) && Array.IndexOf (parentTypes' propertyType) == -1) { " is 319.
Long Statement,BLToolkit.Reflection,TypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessorT.cs,GetExtendedProperties,The length of the statement  "			pdch = GetExtendedProperties (pdch' propertyType' propertyPrefix + pd.Name + "+"' childParentTypes' childParentAccessors' isNull); " is 130.
Long Statement,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetMethod,The length of the statement  "	return Type.GetMethod (methodName' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' types' null); " is 124.
Long Statement,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetPublicMethod,The length of the statement  "	return Type.GetMethod (methodName' BindingFlags.Instance | BindingFlags.Public' generic ? GenericBinder.Generic : GenericBinder.NonGeneric' types' null); " is 153.
Long Statement,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetMethod,The length of the statement  "	return Type.GetMethod (methodName' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' generic ? GenericBinder.Generic : GenericBinder.NonGeneric' types' null); " is 178.
Long Statement,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetDefaultConstructor,The length of the statement  "	return type.GetConstructor (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' Type.EmptyTypes' null); " is 127.
Long Statement,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetPropertyInfo,The length of the statement  "	return type.GetProperty (propertyName' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' returnType' types' null); " is 140.
Long Statement,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,IsScalar,The length of the statement  "	return type.IsValueType || type == typeof(string) || type == typeof(System.Data.Linq.Binary) || type == typeof(Stream) || type == typeof(XmlReader) || type.GetCustomAttributes (typeof(ScalarAttribute)' true).Any () // If the type is a UDT pass it as is " is 252.
Long Statement,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetPropertyByMethod,The length of the statement  "		var attr = BindingFlags.NonPublic | BindingFlags.Public | (method.IsStatic ? BindingFlags.Static : BindingFlags.Instance); " is 122.
Long Statement,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,IsNullableValueMember,The length of the statement  "	return member.Name == "Value" && member.DeclaringType.IsGenericType && member.DeclaringType.GetGenericTypeDefinition () == typeof(Nullable<>); " is 142.
Long Statement,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,IsNullableHasValueMember,The length of the statement  "	return member.Name == "HasValue" && member.DeclaringType.IsGenericType && member.DeclaringType.GetGenericTypeDefinition () == typeof(Nullable<>); " is 145.
Long Statement,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,Equals,The length of the statement  "			var isSubclass = IsSameOrParent (member1.DeclaringType' member2.DeclaringType) || IsSameOrParent (member2.DeclaringType' member1.DeclaringType); " is 144.
Long Statement,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,Equals,The length of the statement  "					if (getter2.Name == map.InterfaceMethods [i].Name && getter2.DeclaringType == map.InterfaceMethods [i].DeclaringType && getter1.Name == map.TargetMethods [i].Name && getter1.DeclaringType == map.TargetMethods [i].DeclaringType) " is 227.
Long Statement,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,Equals,The length of the statement  "					if ((getter2 == null || (getter2.Name == map.InterfaceMethods [i].Name && getter2.DeclaringType == map.InterfaceMethods [i].DeclaringType)) && (getter1 == null || (getter1.Name == map.InterfaceMethods [i].Name && getter1.DeclaringType == map.InterfaceMethods [i].DeclaringType))) { " is 281.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetMapFieldAttributes,The length of the statement  "		return _mapFieldAttributes ?? (_mapFieldAttributes = TypeHelper.GetAttributes (typeAccessor.Type' typeof(MapFieldAttribute))); " is 126.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetNonUpdatableAttributes,The length of the statement  "		return _nonUpdatableAttributes ?? (_nonUpdatableAttributes = TypeHelper.GetAttributes (typeAccessor.Type' typeof(NonUpdatableAttribute))); " is 138.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetMapIgnore,The length of the statement  "	var attr = member.GetAttribute<MapIgnoreAttribute> () ?? (MapIgnoreAttribute)TypeHelper.GetFirstAttribute (member.Type' typeof(MapIgnoreAttribute)); " is 148.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetMapIgnore,The length of the statement  "	if (member.GetAttribute<MapFieldAttribute> () != null || member.GetAttribute<MapImplicitAttribute> () != null || TypeHelper.GetFirstAttribute (member.Type' typeof(MapImplicitAttribute)) != null) { " is 196.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetMapField,The length of the statement  "	var attr = member.GetAttribute<MapFieldAttribute> () ?? (MapFieldAttribute)TypeHelper.GetFirstAttribute (member.Type' typeof(MapFieldAttribute)); " is 145.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetDbType,The length of the statement  "	var attr = member.GetAttribute<DbTypeAttribute> () ?? (DbTypeAttribute)TypeHelper.GetFirstAttribute (member.Type' typeof(DbTypeAttribute)); " is 139.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetPrimaryKey,The length of the statement  "	var attr = member.GetAttribute<PrimaryKeyAttribute> () ?? (PrimaryKeyAttribute)TypeHelper.GetFirstAttribute (member.Type' typeof(PrimaryKeyAttribute)); " is 151.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetMapValues,The length of the statement  "			if (a.Type == null && a.OrigValue != null && a.OrigValue.GetType () == memberType || a.Type is Type && (Type)a.Type == memberType) " is 130.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetDefaultValue,The length of the statement  "		if (a.Type == null && a.Value != null && a.Value.GetType () == member.Type || a.Type != null && a.Type == member.Type) { " is 120.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetLazyInstance,The length of the statement  "	attr1 = (LazyInstanceAttribute)TypeHelper.GetFirstAttribute (member.MemberInfo.DeclaringType' typeof(LazyInstanceAttribute)); " is 125.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetNullValue,The length of the statement  "		if (a.Type == null && a.Value != null && a.Value.GetType () == member.Type || a.Type != null && a.Type == member.Type) { " is 120.
Long Statement,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetRelations,The length of the statement  "			throw new InvalidOperationException ("Destination type should be set for enumerable relations: " + ma.Type.FullName + "." + ma.Name); " is 133.
Long Statement,BLToolkit.Reflection.MetadataProvider,ExtensionMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\ExtensionMetadataProvider.cs,GetRelations,The length of the statement  "				throw new InvalidOperationException ("Destination type should be set for enumerable relations: " + ma.Type.FullName + "." + ma.Name); " is 133.
Long Statement,BLToolkit.Reflection.MetadataProvider,ExtensionMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\ExtensionMetadataProvider.cs,GetRelations,The length of the statement  "				throw new InvalidOperationException ("Unable to load type by name: " + destinationTypeName + "\n may be assembly is not specefied' please see Type.GetType(string typeName) documentation"' ex); " is 192.
Long Statement,BLToolkit.Reflection.MetadataProvider,ExtensionMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\ExtensionMetadataProvider.cs,GetAssociation,The length of the statement  "	return new Association (member' Association.ParseKeys (attrs [0] ["ThisKey"' string.Empty].ToString ())' Association.ParseKeys (attrs [0] ["OtherKey"' string.Empty].ToString ())' attrs [0] ["Storage"' string.Empty].ToString ()' TypeExtension.ToBoolean (attrs [0] ["Storage"' "True"]' true)); " is 291.
Long Statement,BLToolkit.Reflection.MetadataProvider,LinqMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\LinqMetadataProvider.cs,GetAssociation,The length of the statement  "			return new Association (member' Association.ParseKeys (a.ThisKey)' Association.ParseKeys (a.OtherKey)' a.Storage' true); " is 120.
Long Statement,BLToolkit.ServiceModel,RemoteDataContextBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\RemoteDataContextBase.cs,ExecuteNonQuery,The length of the statement  "	var data = LinqServiceSerializer.Serialize (q' q.IsParameterDependent ? q.Parameters.ToArray () : ctx.Query.GetParameters ()); " is 126.
Long Statement,BLToolkit.ServiceModel,RemoteDataContextBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\RemoteDataContextBase.cs,ExecuteScalar,The length of the statement  "	return ctx.Client.ExecuteScalar (LinqServiceSerializer.Serialize (q' q.IsParameterDependent ? q.Parameters.ToArray () : ctx.Query.GetParameters ())); " is 149.
Long Statement,BLToolkit.ServiceModel,RemoteDataContextBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\RemoteDataContextBase.cs,ExecuteReader,The length of the statement  "	var ret = ctx.Client.ExecuteReader (LinqServiceSerializer.Serialize (q' q.IsParameterDependent ? q.Parameters.ToArray () : ctx.Query.GetParameters ())); " is 152.
Long Statement,BLToolkit.ServiceModel,RemoteDataContextBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\RemoteDataContextBase.cs,GetSqlText,The length of the statement  "	sb.Append ("-- ").Append ("ServiceModel").Append (' ').Append (((IDataContext)this).ContextID).Append (' ').Append (sqlProvider.Name).AppendLine (); " is 148.
Long Statement,BLToolkit.ServiceModel,RemoteDataContextBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\RemoteDataContextBase.cs,GetSqlText,The length of the statement  "			sb.Append ("-- DECLARE ").Append (p.Name).Append (' ').Append (p.Value == null ? p.SystemType.ToString () : p.Value.GetType ().Name).AppendLine (); " is 147.
Long Statement,BLToolkit.TypeBuilder,GenerateAttributeAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\GenerateAttributeAttribute.cs,GetValue,The length of the statement  "	return _namedArgumentNames == null || Array.IndexOf (_namedArgumentNames' name) < 0 ? defaultValue : GetValue<T> (name); " is 120.
Long Statement,BLToolkit.TypeBuilder,TypeFactory,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,SubscribeAssemblyResolver,The length of the statement  "	emit.call (typeof(AppDomain).GetProperty ("CurrentDomain").GetGetMethod ()).ldnull.ldftn (typeof(TypeFactory).GetMethod ("AssemblyResolver")).newobj (typeof(ResolveEventHandler).GetConstructor (new[] { " is 201.
Long Statement,BLToolkit.TypeBuilder,TypeFactory,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,GetAssemblyBuilder,The length of the statement  "		if (!(type.Module is _ModuleBuilder) && type.Module.FullyQualifiedName != null && type.Module.FullyQualifiedName.IndexOf ('<') < 0) " is 131.
Long Statement,BLToolkit.TypeBuilder,TypeFactory,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,GetType,The length of the statement  "	return TypeHelper.IsScalar (sourceType) || sourceType.IsSealed || (!sourceType.IsAbstract && sourceType.IsDefined (typeof(BLToolkitGeneratedAttribute)' true)) ? sourceType : GetType (sourceType' sourceType' new AbstractClassBuilder (sourceType)); " is 246.
Long Statement,BLToolkit.TypeBuilder,TypeFactory,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,LoadExtensionAssembly,The length of the statement  "		Debug.WriteLineIf (File.Exists (extensionAssemblyLocation)' string.Format ("Extension assembly '{0}' is out of date. Please rebuild."' extensionAssemblyLocation)' typeof(TypeAccessor).FullName); " is 194.
Long Statement,BLToolkit.TypeBuilder.Builders,DuckTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DuckTypeBuilder.cs,BuildMembers,The length of the statement  "	BindingFlags flags = BindingFlags.Public | BindingFlags.Instance | (DuckTyping.AllowStaticMembers ? BindingFlags.Static | BindingFlags.FlattenHierarchy : 0); " is 157.
Long Statement,BLToolkit.TypeBuilder.Builders,DuckTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DuckTypeBuilder.cs,BuildMembers,The length of the statement  "			MustImplementAttribute attr = (MustImplementAttribute)Attribute.GetCustomAttribute (interfaceMethod' typeof(MustImplementAttribute)); " is 133.
Long Statement,BLToolkit.TypeBuilder.Builders,DuckTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DuckTypeBuilder.cs,BuildMembers,The length of the statement  "				attr = (MustImplementAttribute)Attribute.GetCustomAttribute (interfaceMethod.DeclaringType' typeof(MustImplementAttribute)); " is 124.
Long Statement,BLToolkit.TypeBuilder.Builders,DuckTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DuckTypeBuilder.cs,BuildMembers,The length of the statement  "					throw new TypeBuilderException (string.Format (Resources.TypeBuilder_PublicMethodMustBeImplemented' _objectTypes.Length > 0 && _objectTypes [0] != null ? _objectTypes [0].FullName : "???"' interfaceMethod)); " is 207.
Long Statement,BLToolkit.TypeBuilder.Builders,DuckTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DuckTypeBuilder.cs,BuildMembers,The length of the statement  "					message = string.Format (Resources.TypeBuilder_PublicMethodNotImplemented' _objectTypes.Length > 0 && _objectTypes [0] != null ? _objectTypes [0].FullName : "???"' interfaceMethod); " is 181.
Long Statement,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,DefineNonAbstractType,The length of the statement  "	_context.TypeBuilder = _context.AssemblyBuilder.DefineType (typeName' TypeAttributes.Public | TypeAttributes.BeforeFieldInit | (TypeFactory.SealTypes ? TypeAttributes.Sealed : 0)' _context.Type.IsInterface ? typeof(object) : (Type)_context.Type' interfaces.ToArray ()); " is 269.
Long Statement,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,DefineAbstractGetter,The length of the statement  "	var builders = Combine (GetBuilders (getter.GetParameters ())' GetBuilders (getter.ReturnParameter)' GetBuilders (getter)' propertyBuilders' _builders); " is 152.
Long Statement,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,DefineAbstractSetter,The length of the statement  "	var builders = Combine (GetBuilders (setter.GetParameters ())' GetBuilders (setter.ReturnParameter)' GetBuilders (setter)' propertyBuilders' _builders); " is 152.
Long Statement,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,DefineAbstractMethods,The length of the statement  "			var builders = Combine (GetBuilders (method.GetParameters ())' GetBuilders (method.ReturnParameter)' GetBuilders (method)' _builders); " is 134.
Long Statement,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,OverrideGetter,The length of the statement  "	var builders = Combine (GetBuilders (getter.GetParameters ())' GetBuilders (getter.ReturnParameter)' GetBuilders (getter)' propertyBuilders' _builders); " is 152.
Long Statement,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,OverrideSetter,The length of the statement  "	var builders = Combine (GetBuilders (setter.GetParameters ())' GetBuilders (setter.ReturnParameter)' GetBuilders (setter)' propertyBuilders' _builders); " is 152.
Long Statement,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,OverrideVirtualMethods,The length of the statement  "		if (method.IsVirtual && method.IsAbstract == false && method.IsFinal == false && (method.Attributes & MethodAttributes.SpecialName) == 0 && method.DeclaringType != typeof(object)) { " is 181.
Long Statement,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,OverrideVirtualMethods,The length of the statement  "			var builders = Combine (GetBuilders (method.GetParameters ())' GetBuilders (method.ReturnParameter)' GetBuilders (method)' _builders); " is 134.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,BuildAbstractGetter,The length of the statement  "		Context.MethodBuilder.Emitter.ldarg_0.ldfld (field).ldarg_1.boxIfValueType (index [0].ParameterType).callvirt (typeof(Dictionary<object' object>)' "get_Item"' typeof(object)).castType (Context.CurrentProperty.PropertyType).stloc (Context.ReturnValue); " is 251.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,BuildAbstractSetter,The length of the statement  "		Context.MethodBuilder.Emitter.ldarg_0.ldfld (field).ldarg_1.boxIfValueType (index [0].ParameterType).ldarg_2.boxIfValueType (Context.CurrentProperty.PropertyType).callvirt (typeof(Dictionary<object' object>)' "set_Item"' typeof(object)' typeof(object)); " is 253.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateDefaultInstance,The length of the statement  "			var message = string.Format (Resources.TypeBuilder_PropertyTypeHasNoPublicDefaultCtor' Context.CurrentProperty.Name' Context.Type.FullName' objectType.FullName); " is 161.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateParametrizedInstance,The length of the statement  "					genericNestedConstructors = GetGenericNestedConstructors (objectType' typeHelper => typeHelper.IsValueType == false || (typeHelper.Type.IsGenericType && typeHelper.Type.GetGenericTypeDefinition () == typeof(Nullable<>))' typeHelper => { " is 236.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateParametrizedInstance,The length of the statement  "		throw new TypeBuilderException (string.Format (types.Length == 0 ? Resources.TypeBuilder_PropertyTypeHasNoPublicDefaultCtor : Resources.TypeBuilder_PropertyTypeHasNoPublicCtor' Context.CurrentProperty.Name' Context.Type.FullName' objectType.FullName)); " is 252.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,GetGenericNestedConstructors,The length of the statement  "			throw new TypeBuilderException (string.Format (Resources.TypeBuilder_GenericShouldBeSingleTyped' Context.CurrentProperty.Name' Context.Type.FullName' objectType.FullName)); " is 172.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateAbstractInitContextInstance,The length of the statement  "		emit.ldarg_1.brtrue_s (label).newobj (InitContextType.GetPublicDefaultConstructor ()).starg (1).ldarg_1.ldc_i4_1.callvirt (InitContextType.GetProperty ("IsInternal").GetSetMethod ()).MarkLabel (label).ldarg_1.callvirt (InitContextType.GetProperty ("Parent").GetGetMethod ()).stloc (parentField); " is 295.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateAbstractInitContextInstance,The length of the statement  "		emit.ldarg_0.ldsfld (GetTypeAccessorField ()).ldarg_1.callvirtNoGenerics (typeof(TypeAccessor)' "CreateInstanceEx"' _initContextType).isinst (objectType); " is 154.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CheckObjectHolderCtor,The length of the statement  "			var message = string.Format (Resources.TypeBuilder_PropertyTypeHasNoCtorWithParamType' Context.CurrentProperty.Name' Context.Type.FullName' fieldType.FullName' objectType.FullName); " is 181.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CheckObjectHolderCtor,The length of the statement  "			Context.TypeBuilder.DefaultConstructor.Emitter.ldstr (message).newobj (typeof(TypeBuilderException)' typeof(string)).@throw.end (); " is 131.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateInitContextDefaultInstance,The length of the statement  "		emit.ldarg_0.ldsfld (GetTypeAccessorField ()).ldloc (initField).callvirtNoGenerics (typeof(TypeAccessor)' "CreateInstanceEx"' _initContextType).isinst (objectType); " is 164.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,GetInitContextBuilder,The length of the statement  "		emit.newobj (InitContextType.GetPublicDefaultConstructor ()).dup.ldarg_0.callvirt (InitContextType.GetProperty ("Parent").GetSetMethod ()).dup.ldc_i4_1.callvirt (InitContextType.GetProperty ("IsInternal").GetSetMethod ()).stloc (initField); " is 240.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,BuildLazyInstanceEnsurer,The length of the statement  "	var ensurer = Context.TypeBuilder.DefineMethod (string.Format ("$EnsureInstance{0}"' fieldName)' MethodAttributes.Private | MethodAttributes.HideBySig); " is 152.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateInitContextLazyInstance,The length of the statement  "	emit.newobj (InitContextType.GetPublicDefaultConstructor ()).dup.ldarg_0.callvirt (InitContextType.GetProperty ("Parent").GetSetMethod ()).dup.ldc_i4_1.callvirt (InitContextType.GetProperty ("IsInternal").GetSetMethod ()).dup.ldc_i4_1.callvirt (InitContextType.GetProperty ("IsLazyInstance").GetSetMethod ()); " is 309.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,CreateInitContextLazyInstance,The length of the statement  "		emit.ldarg_0.ldsfld (GetTypeAccessorField ()).ldloc (initField).callvirtNoGenerics (typeof(TypeAccessor)' "CreateInstanceEx"' _initContextType).isinst (objectType); " is 164.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,AfterBuildType,The length of the statement  "		Context.TypeBuilder.InitConstructor.Emitter.ldarg_1.ldnull.callvirt (InitContextType.GetProperty ("MemberParameters").GetSetMethod ()); " is 135.
Long Statement,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,AfterBuildType,The length of the statement  "		Context.TypeBuilder.InitConstructor.Emitter.ldarg_1.ldloc (localBuilder).callvirt (InitContextType.GetProperty ("Parent").GetSetMethod ()); " is 139.
Long Statement,BLToolkit.TypeBuilder.Builders,PropertyChangedBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\PropertyChangedBuilder.cs,GenerateIsSameValueComparison,The length of the statement  "				emit.ldarg_0.callvirt (Context.CurrentProperty.GetGetMethod (true)).stloc (currentValue).ldarg_1.stloc (newValue).ldloca (currentValue).call (Context.CurrentProperty.PropertyType' "GetValueOrDefault").ldloca (newValue).call (Context.CurrentProperty.PropertyType' "GetValueOrDefault"); " is 284.
Long Statement,BLToolkit.TypeBuilder.Builders,PropertyChangedBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\PropertyChangedBuilder.cs,GenerateIsSameValueComparison,The length of the statement  "				emit.ldloca (currentValue).call (hasValueGetMethod).ldloca (newValue).call (hasValueGetMethod).ceq.ldc_bool (true).ceq.br (comparedLabel).MarkLabel (notEqualLabel).ldc_bool (false).MarkLabel (comparedLabel).end (); " is 214.
Long Statement,BLToolkit.TypeBuilder.Builders,PropertyChangedBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\PropertyChangedBuilder.cs,GenerateIsSameValueComparison,The length of the statement  "				emit.ldarg_0.callvirt (Context.CurrentProperty.GetGetMethod (true)).stloc (currentValue).ldloca (currentValue).ldarg_1.box (Context.CurrentProperty.PropertyType).constrained (Context.CurrentProperty.PropertyType).callvirt (typeof(object)' "Equals"' new[] { " is 256.
Long Statement,BLToolkit.TypeBuilder.Builders,PropertyChangedBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\PropertyChangedBuilder.cs,GenerateIsSameValueComparison,The length of the statement  "			emit.ldarg_0.callvirt (Context.CurrentProperty.GetGetMethod (true)).ldarg_1.call (typeof(object)' "ReferenceEquals"' typeof(object)' typeof(object)).end (); " is 156.
Long Statement,BLToolkit.TypeBuilder.Builders,PropertyChangedBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\PropertyChangedBuilder.cs,GenerateIsSameValueComparison,The length of the statement  "		emit.ldarg_0.callvirt (Context.CurrentProperty.GetGetMethod (true)).ldarg_1.call (op_InequalityMethod).ldc_i4_0.ceq.end (); " is 123.
Long Statement,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,Build,The length of the statement  "	if (!_originalType.Type.IsVisible && !_friendlyAssembly || (from p in _originalType.GetProperties (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) " is 168.
Long Statement,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildMembers,The length of the statement  "	var interfaceMethods = _originalType.Type.IsClass && !_originalType.Type.IsArray ? _originalType.Type.GetInterfaces ().SelectMany (ti => _originalType.GetInterfaceMap (ti).TargetMethods).ToList () : new List<MethodInfo> (); " is 223.
Long Statement,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildMembers,The length of the statement  "			if (getter != null && (getter.IsAbstract || interfaceMethods.Contains (getter)) || setter != null && (setter.IsAbstract || interfaceMethods.Contains (setter))) " is 159.
Long Statement,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildInitMember,The length of the statement  "	_typeBuilder.DefaultConstructor.Emitter.ldarg_0.ldarg_0.ldarg_0.ldc_i4 (mi is FieldInfo ? 1 : 2).ldstr (mi.Name).call (_accessorType.GetMethod ("GetMember"' typeof(int)' typeof(string))).newobj (ctorBuilder).call (_accessorType.GetMethod ("AddMember"' typeof(MemberAccessor))); " is 277.
Long Statement,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildNestedTypeConstructor,The length of the statement  "	ctorBuilder.Emitter.ldarg_0.ldarg_1.ldarg_2.call (TypeHelper.GetConstructor (typeof(MemberAccessor)' parameters)).ret (); " is 121.
Long Statement,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildObjectFactory,The length of the statement  "		_typeBuilder.DefaultConstructor.Emitter.ldarg_0.LoadType (_type).LoadType (typeof(ObjectFactoryAttribute)).call (typeof(TypeHelper)' "GetFirstAttribute"' typeof(Type)' typeof(Type)).castclass (typeof(ObjectFactoryAttribute)).call (typeof(ObjectFactoryAttribute).GetProperty ("ObjectFactory").GetGetMethod ()).call (typeof(TypeAccessor).GetProperty ("ObjectFactory").GetSetMethod ()); " is 383.
Long Statement,BLToolkit.TypeBuilder.Builders,InstanceTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\InstanceTypeBuilder.cs,IsApplied,The length of the statement  "	return base.IsApplied (context' builders) && context.CurrentProperty != null && context.CurrentProperty.GetIndexParameters ().Length == 0 && (PropertyType == null || TypeHelper.IsSameOrParent (PropertyType' context.CurrentProperty.PropertyType)); " is 246.
Long Statement,BLToolkit.TypeBuilder.Builders,InstanceTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\InstanceTypeBuilder.cs,BuildAbstractGetter,The length of the statement  "				throw new TypeBuilderException (string.Format (Resources.TypeBuilder_UnknownParameterType' mi.Name' mi.DeclaringType.FullName' p.Name)); " is 136.
Long Statement,BLToolkit.TypeBuilder.Builders,InstanceTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\InstanceTypeBuilder.cs,BuildAbstractSetter,The length of the statement  "				throw new TypeBuilderException (string.Format (Resources.TypeBuilder_UnknownParameterType' mi.Name' mi.DeclaringType.FullName' p.Name)); " is 136.
Long Statement,BLToolkit.TypeBuilder.Builders,InstanceTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\InstanceTypeBuilder.cs,GetGetter,The length of the statement  "	throw new TypeBuilderException (string.Format (Resources.TypeBuilder_CannotGetGetter' InstanceType.FullName' propertyType.FullName' Context.CurrentProperty.Name' Context.Type.FullName)); " is 186.
Long Statement,BLToolkit.TypeBuilder.Builders,InstanceTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\InstanceTypeBuilder.cs,GetSetter,The length of the statement  "	throw new TypeBuilderException (string.Format (Resources.TypeBuilder_CannotGetSetter' InstanceType.FullName' propertyType.FullName' Context.CurrentProperty.Name' Context.Type.FullName)); " is 186.
Long Statement,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,callvirt,The length of the statement  "	MethodInfo methodInfo = optionalParameterTypes == null ? type.GetMethod (methodName' flags) : type.GetMethod (methodName' flags' null' optionalParameterTypes' null); " is 165.
Long Statement,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,callvirtNoGenerics,The length of the statement  "	MethodInfo methodInfo = type.GetMethod (methodName' BindingFlags.Instance | BindingFlags.Public' GenericBinder.NonGeneric' optionalParameterTypes' null); " is 153.
Long Statement,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldNameOrIndex,The length of the statement  "	return nameOrIndex.ByName ? ldstr (nameOrIndex.Name).call (typeof(NameOrIndexParameter)' "op_Implicit"' typeof(string)) : ldc_i4_ (nameOrIndex.Index).call (typeof(NameOrIndexParameter)' "op_Implicit"' typeof(int)); " is 214.
Long Statement,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,Init,The length of the statement  "		return type.IsValueType && type.IsPrimitive == false ? ldarg (index).initobj (type) : ldarg (index).LoadInitValue (type).stind (type); " is 134.
Long Statement,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,Init,The length of the statement  "		return type.IsValueType && type.IsPrimitive == false ? ldarga (index).initobj (type) : LoadInitValue (type).starg (index); " is 122.
Long Statement,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,Init,The length of the statement  "	return type.IsValueType && type.IsPrimitive == false ? ldloca (localBuilder).initobj (type) : LoadInitValue (type).stloc (localBuilder); " is 136.
Long Statement,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,CastIfNecessary,The length of the statement  "	return TypeHelper.IsSameOrParent (expectedType' actualType) ? this : actualType.IsValueType ? unbox_any (expectedType) : castclass (expectedType); " is 146.
Long Statement,BLToolkit.Reflection.Emit,TypeBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineMethod,The length of the statement  "	return new MethodBuilderHelper (this' _typeBuilder.DefineMethod (name' attributes' callingConvention' returnType' parameterTypes)); " is 131.
Long Statement,BLToolkit.Reflection.Emit,TypeBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineGenericMethod,The length of the statement  "	return new MethodBuilderHelper (this' _typeBuilder.DefineMethod (name' attributes' callingConvention)' genericArguments' returnType' parameterTypes); " is 149.
Long Statement,BLToolkit.Reflection.Emit,TypeBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineMethod,The length of the statement  "		method = DefineGenericMethod (name' attributes' methodInfoDeclaration.CallingConvention' methodInfoDeclaration.GetGenericArguments ()' methodInfoDeclaration.ReturnType' parameters); " is 181.
Long Statement,BLToolkit.Reflection.Emit,TypeBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineMethod,The length of the statement  "		method = DefineMethod (name' attributes' methodInfoDeclaration.CallingConvention' methodInfoDeclaration.ReturnType' parameters); " is 128.
Long Statement,BLToolkit.Reflection.Emit,TypeBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineMethod,The length of the statement  "	var name = isInterface && !isFake ? methodInfoDeclaration.DeclaringType.FullName + "." + methodInfoDeclaration.Name : methodInfoDeclaration.Name; " is 145.
Long Statement,BLToolkit.Reflection.Emit,TypeBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineMethod,The length of the statement  "	var attributes = MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.PrivateScope | methodInfoDeclaration.Attributes & MethodAttributes.SpecialName; " is 169.
Long Statement,BLToolkit.Reflection.Emit,TypeBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefinePublicConstructor,The length of the statement  "	return new ConstructorBuilderHelper (this' _typeBuilder.DefineConstructor (MethodAttributes.Public' CallingConventions.Standard' parameterTypes)); " is 146.
Long Statement,BLToolkit.Reflection.Emit,TypeBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineConstructor,The length of the statement  "	return new ConstructorBuilderHelper (this' _typeBuilder.DefineConstructor (attributes' callingConvention' parameterTypes)); " is 123.
Long Statement,BLToolkit.Reflection.Emit,TypeBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\TypeBuilderHelper.cs,DefineNestedType,The length of the statement  "	return new TypeBuilderHelper (_assembly' _typeBuilder.DefineNestedType (name' TypeAttributes.NestedPublic' parent' interfaces)); " is 128.
Long Statement,BLToolkit.Validation,MaxValueAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Validation\MaxValueAttribute.cs,GetErrorMessage,The length of the statement  "	return string.Format (ErrorMessage' GetPropertyFriendlyName (context)' GetValue (context)' IsExclusive ? " exclusive" : string.Empty); " is 134.
Long Statement,BLToolkit.Validation,MinValueAttribute,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Validation\MinValueAttribute.cs,GetErrorMessage,The length of the statement  "	return string.Format (ErrorMessage' GetPropertyFriendlyName (context)' GetValue (context)' IsExclusive ? " exclusive" : string.Empty); " is 134.
Long Statement,BLToolkit.Net,HttpReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Net\HttpReader.cs,Post,The length of the statement  "	return Post (requestUri' new DefaultRequestStreamProcessor (postData).Process' new DefaultResponseStreamProcessor (this).Process); " is 130.
Long Statement,BLToolkit.Net,HttpReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Net\HttpReader.cs,Post,The length of the statement  "	return Post (requestUri' new ProcessStream (new DefaultRequestStreamProcessor (postData).Process)' responseStreamProcessor); " is 124.
Long Statement,BLToolkit.Net,HttpReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Net\HttpReader.cs,Soap,The length of the statement  "	return Soap (soapAction' new DefaultRequestStreamProcessor (postData).Process' new DefaultResponseStreamProcessor (this).Process); " is 130.
Complex Conditional,BLToolkit.Aspects,LoggingAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\LoggingAspect.cs,LogOperationInternal,The conditional expression  "info.Exception != null && parameters.LogExceptions || info.Exception == null && time >= parameters.MinCallTime"  is complex.
Complex Conditional,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,FindTypeCastOperator,The conditional expression  "mi.IsSpecialName && mi.ReturnType == typeof(T) && (mi.Name == "op_Implicit" || mi.Name == "op_Explicit")"  is complex.
Complex Conditional,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,GetReturnType,The conditional expression  "!returnType.IsArray && (IsInterfaceOf (returnType' typeof(IList)) || returnType.IsGenericType && returnType.GetGenericTypeDefinition () == typeof(IList<>))"  is complex.
Complex Conditional,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,CreateSpParameters,The conditional expression  "parameterValues == null || parameterValues.Length == 0 || parameterValues [0] is IDbDataParameter || parameterValues [0] is IDbDataParameter[]"  is complex.
Complex Conditional,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The conditional expression  "(value == null || value == DBNull.Value) && (dbType == DbType.Binary || type == typeof(byte[])) || type == typeof(System.Data.Linq.Binary)"  is complex.
Complex Conditional,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,PrepareCommand,The conditional expression  "val == null || !val.GetType ().IsArray || val is byte[] || val is char[]"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildType,The conditional expression  "type.Namespace != null && type.Namespace.StartsWith ("System") || IsAnonymous (type) || type.Assembly == GetType ().Assembly || type.IsGenericType && type.GetGenericTypeDefinition () != type"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,AddType,The conditional expression  "type == null || type == typeof(object) || type.IsGenericParameter || _usedTypes.Contains (type)"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,AggregationBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\AggregationBuilder.cs,BuildMethodCall,The conditional expression  "sequence.SqlQuery.Select.IsDistinct || sequence.SqlQuery.Select.TakeValue != null || sequence.SqlQuery.Select.SkipValue != null || !sequence.SqlQuery.GroupBy.IsEmpty"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,CountBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\CountBuilder.cs,BuildMethodCall,The conditional expression  "sequence.SqlQuery.Select.IsDistinct || sequence.SqlQuery.Select.TakeValue != null || sequence.SqlQuery.Select.SkipValue != null || !sequence.SqlQuery.GroupBy.IsEmpty"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertExpressionTree,The conditional expression  "call.IsQueryable () && call.Object == null && call.Arguments.Count > 0 && call.Type.IsGenericType"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,SubQueryToSql,The conditional expression  "subQuery.Select.Columns.Count == 1 && subQuery.Select.Columns [0].Expression.ElementType == QueryElementType.SqlFunction && subQuery.GroupBy.IsEmpty && !subQuery.Select.HasModifier && !subQuery.HasUnion && subQuery.Where.SearchCondition.Conditions.Count == 1"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,SubQueryToSql,The conditional expression  "cond.Predicate.ElementType == QueryElementType.ExprExprPredicate && query.GroupBy.Items.Count == 1 || cond.Predicate.ElementType == QueryElementType.SearchCondition && query.GroupBy.Items.Count == ((SqlQuery.SearchCondition)cond.Predicate).Conditions.Count"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The conditional expression  "e.Type == t || t.IsEnum && Enum.GetUnderlyingType (t) == e.Type || e.Type.IsEnum && Enum.GetUnderlyingType (e.Type) == t"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The conditional expression  "left.NodeType == ExpressionType.Convert || right.NodeType == ExpressionType.Convert || left.NodeType == ExpressionType.MemberAccess || right.NodeType == ExpressionType.MemberAccess"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The conditional expression  "!context.SqlQuery.IsParameterDependent && (l is SqlParameter && l.CanBeNull () || r is SqlParameter && r.CanBeNull ())"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertObjectNullComparison,The conditional expression  "ctx != null && ctx.IsExpression (left' 0' RequestFor.Object).Result || left.NodeType == ExpressionType.Parameter && ctx.IsExpression (left' 0' RequestFor.Field).Result"  is complex.
Complex Conditional,BLToolkit.Data.Linq.Builder,GroupByBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\GroupByBuilder.cs,BuildMethodCall,The conditional expression  "sequence.SqlQuery.Select.IsDistinct || sequence.SqlQuery.GroupBy.Items.Count > 0 || groupSql.Any (_ => !(_.Sql is SqlField || _.Sql is SqlQuery.Column))"  is complex.
Complex Conditional,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,SetParameters,The conditional expression  "etype == null || etype == typeof(object) || etype.IsEnum || (TypeHelper.IsNullableType (etype) && etype.GetGenericArguments () [0].IsEnum)"  is complex.
Complex Conditional,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,GetParameter,The conditional expression  "!mm.Type.IsClass && !mm.Type.IsInterface && mm.MapMemberInfo.Nullable && !TypeHelper.IsNullableType (mm.Type)"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The conditional expression  "p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildAlternativeOrderBy,The conditional expression  "ascending && SqlQuery.OrderBy.Items [i].IsDescending || !ascending && !SqlQuery.OrderBy.Items [i].IsDescending"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetAlternativeDelete,The conditional expression  "sqlQuery.IsDelete && (sqlQuery.From.Tables.Count > 1 || sqlQuery.From.Tables [0].Joins.Count > 0) && sqlQuery.From.Tables [0].Source is SqlTable"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,IsBooleanParameter,The conditional expression  "(i % 2 == 1 || i == count - 1) && expr.SystemType == typeof(bool) || expr.SystemType == typeof(bool?)"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,SetAlias,The conditional expression  "c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c == '_'"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The conditional expression  "v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == """  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The conditional expression  "c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The conditional expression  "ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The conditional expression  "ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The conditional expression  "c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The conditional expression  "bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The conditional expression  "bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The conditional expression  "name.Length > 28 || name.Length > 0 && (name [0] == '[' || name [0] == '#')"  is complex.
Complex Conditional,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildWhereSearchCondition,The conditional expression  "NeedTake && !NeedSkip && SqlQuery.OrderBy.IsEmpty && SqlQuery.Having.IsEmpty"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "expr1 != null && !ReferenceEquals (expr1' bexpr.Expr1) || expr2 != null && !ReferenceEquals (expr2' bexpr.Expr2)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "source != null && !ReferenceEquals (source' table.Source) || joins != null && !ReferenceEquals (table.Joins' joins)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "table != null && !ReferenceEquals (table' join.Table) || cond != null && !ReferenceEquals (cond' join.Condition)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "e1 != null && !ReferenceEquals (p.Expr1' e1) || e2 != null && !ReferenceEquals (p.Expr2' e2)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "e1 != null && !ReferenceEquals (p.Expr1' e1) || e2 != null && !ReferenceEquals (p.Expr2' e2) || es != null && !ReferenceEquals (p.Escape' es)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "e1 != null && !ReferenceEquals (p.Expr1' e1) || e2 != null && !ReferenceEquals (p.Expr2' e2) || e3 != null && !ReferenceEquals (p.Expr3' e3)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "e != null && !ReferenceEquals (p.Expr1' e) || q != null && !ReferenceEquals (p.SubQuery' q)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "e != null && !ReferenceEquals (p.Expr1' e) || v != null && !ReferenceEquals (p.Values' v)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "c != null && !ReferenceEquals (s.Column' c) || e != null && !ReferenceEquals (s.Expression' e)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "t != null && !ReferenceEquals (s.Into' t) || i != null && !ReferenceEquals (s.Items' i)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "t != null && !ReferenceEquals (s.Table' t) || i != null && !ReferenceEquals (s.Items' i) || k != null && !ReferenceEquals (s.Keys' k)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The conditional expression  "parent != null || cols != null && !ReferenceEquals (sc.Columns' cols) || take != null && !ReferenceEquals (sc.TakeValue' take) || skip != null && !ReferenceEquals (sc.SkipValue' skip)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,SqlDataType,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,CanBeNull,The conditional expression  "type.IsValueType == false || type.IsGenericType && type.GetGenericTypeDefinition () == typeof(Nullable<>) || TypeHelper.IsSameOrParent (typeof(INullable)' type)"  is complex.
Complex Conditional,BLToolkit.Data.Sql,SqlExpression,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlExpression.cs,Equals,The conditional expression  "expr == null || SystemType != expr.SystemType || Expr != expr.Expr || Parameters.Length != expr.Parameters.Length"  is complex.
Complex Conditional,BLToolkit.Data.Sql,SqlFunction,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlFunction.cs,Equals,The conditional expression  "func == null || Name != func.Name || Parameters.Length != func.Parameters.Length && SystemType != func.SystemType"  is complex.
Complex Conditional,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeUnions,The conditional expression  "sql == null || sql.From.Tables.Count != 1 || !sql.IsSimple || sql._insert != null || sql._update != null || sql._delete != null"  is complex.
Complex Conditional,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,OptimizeApply,The conditional expression  "isApplySupported && (isAgg || sql.Select.TakeValue != null || sql.Select.SkipValue != null)"  is complex.
Complex Conditional,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The conditional expression  "expr1 == null || expr2 == null || expr1.NodeType != expr2.NodeType || expr1.Type != expr2.Type"  is complex.
Complex Conditional,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The conditional expression  "b1 == null || b2 == null || b1.BindingType != b2.BindingType || b1.Member != b2.Member"  is complex.
Complex Conditional,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetValueMapper,The conditional expression  "dtype == typeof(object) || dtype == stype && (!DeepCopy || isSourceScalar)"  is complex.
Complex Conditional,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetValueMapper,The conditional expression  "checkNull && isSourceNullable && !TypeHelper.IsNullableType (dtype) && (isDestScalar || isSourceScalar)"  is complex.
Complex Conditional,BLToolkit.ComponentModel,BindingListImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\BindingListImpl.cs,GetItemSortedPosition,The conditional expression  "(index > 0 && comparer.Compare (_list [index - 1]' sender) > 0) || (index < _list.Count - 1 && comparer.Compare (_list [index + 1]' sender) < 0)"  is complex.
Complex Conditional,BLToolkit.Reflection,ExprTypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\ExprTypeAccessor.cs,ExprTypeAccessor,The conditional expression  "(getMethod == null || interfaceMethods.Contains (getMethod)) && (setMethod == null || interfaceMethods.Contains (setMethod))"  is complex.
Complex Conditional,BLToolkit.Reflection,TypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessorT.cs,MapTypeName,The conditional expression  "type.IsPrimitive || type == typeof(string) || type == typeof(object) || type == typeof(decimal)"  is complex.
Complex Conditional,BLToolkit.Reflection,TypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessorT.cs,GetExtendedProperties,The conditional expression  "!isList && !propertyType.IsValueType && !propertyType.IsArray && (!propertyType.FullName.StartsWith ("System.") || explicitlyBound || propertyType.IsGenericType) && propertyType != typeof(Type) && propertyType != typeof(string) && propertyType != typeof(object) && Array.IndexOf (parentTypes' propertyType) == -1"  is complex.
Complex Conditional,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,IsSameOrParent,The conditional expression  "parent == child || child.IsEnum && Enum.GetUnderlyingType (child) == parent || child.IsSubclassOf (parent)"  is complex.
Complex Conditional,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,Equals,The conditional expression  "getter2.Name == map.InterfaceMethods [i].Name && getter2.DeclaringType == map.InterfaceMethods [i].DeclaringType && getter1.Name == map.TargetMethods [i].Name && getter1.DeclaringType == map.TargetMethods [i].DeclaringType"  is complex.
Complex Conditional,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,Equals,The conditional expression  "(getter2 == null || (getter2.Name == map.InterfaceMethods [i].Name && getter2.DeclaringType == map.InterfaceMethods [i].DeclaringType)) && (getter1 == null || (getter1.Name == map.InterfaceMethods [i].Name && getter1.DeclaringType == map.InterfaceMethods [i].DeclaringType))"  is complex.
Complex Conditional,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetMapValues,The conditional expression  "a.Type == null && a.OrigValue != null && a.OrigValue.GetType () == memberType || a.Type is Type && (Type)a.Type == memberType"  is complex.
Complex Conditional,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetDefaultValue,The conditional expression  "a.Type == null && a.Value != null && a.Value.GetType () == member.Type || a.Type != null && a.Type == member.Type"  is complex.
Complex Conditional,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetNullable,The conditional expression  "a.Type == null && a.Value != null && a.Value.GetType () == member.Type || a.Type != null && a.Type == member.Type"  is complex.
Complex Conditional,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetNullValue,The conditional expression  "a.Type == null && a.Value != null && a.Value.GetType () == member.Type || a.Type != null && a.Type == member.Type"  is complex.
Complex Conditional,BLToolkit.Reflection.MetadataProvider,AttributeMetadataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\MetadataProvider\AttributeMetadataProvider.cs,GetRelations,The conditional expression  "attr == null || (slave != null && attr.Destination != slave && ma.Type != slave)"  is complex.
Complex Conditional,BLToolkit.TypeBuilder,TypeFactory,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,AssemblyResolver,The conditional expression  "!(  #if FW4  a.IsDynamic ||   #endif  a is _AssemblyBuilder) && (a.CodeBase.IndexOf ("Microsoft.NET/Framework") > 0 || a.FullName.StartsWith ("System."))"  is complex.
Complex Conditional,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,DefineAbstractProperties,The conditional expression  "getter != null && getter.IsAbstract || setter != null && setter.IsAbstract"  is complex.
Complex Conditional,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,OverrideVirtualProperties,The conditional expression  "getter != null && getter.IsVirtual && !getter.IsAbstract && !getter.IsFinal"  is complex.
Complex Conditional,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,OverrideVirtualProperties,The conditional expression  "setter != null && setter.IsVirtual && !setter.IsAbstract && !setter.IsFinal"  is complex.
Complex Conditional,BLToolkit.TypeBuilder.Builders,AbstractClassBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractClassBuilder.cs,OverrideVirtualMethods,The conditional expression  "method.IsVirtual && method.IsAbstract == false && method.IsFinal == false && (method.Attributes & MethodAttributes.SpecialName) == 0 && method.DeclaringType != typeof(object)"  is complex.
Complex Conditional,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildMembers,The conditional expression  "getter != null && (getter.IsAbstract || interfaceMethods.Contains (getter)) || setter != null && (setter.IsAbstract || interfaceMethods.Contains (setter))"  is complex.
Virtual Method Call from Constructor,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DbManager,The constructor "DbManager" calls a virtual method "CreateConnectionObject".
Virtual Method Call from Constructor,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DbManager,The constructor "DbManager" calls a virtual method "InitDbManager".
Virtual Method Call from Constructor,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DbManager,The constructor "DbManager" calls a virtual method "InitDbManager".
Virtual Method Call from Constructor,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,DbManager,The constructor "DbManager" calls a virtual method "InitDbManager".
Virtual Method Call from Constructor,BLToolkit.Data.Sql,SqlTable,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,The constructor "SqlTable" calls a virtual method "GetDatabaseName".
Virtual Method Call from Constructor,BLToolkit.Data.Sql,SqlTable,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,The constructor "SqlTable" calls a virtual method "GetOwnerName".
Virtual Method Call from Constructor,BLToolkit.Data.Sql,SqlTable,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,The constructor "SqlTable" calls a virtual method "GetTableName".
Virtual Method Call from Constructor,BLToolkit.Data.Sql,SqlTable,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,The constructor "SqlTable" calls a virtual method "GetNonUpdatableAttribute".
Virtual Method Call from Constructor,BLToolkit.Data.Sql,SqlTable,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlTable.cs,SqlTable,The constructor "SqlTable" calls a virtual method "GetPrimaryKeyOrder".
Virtual Method Call from Constructor,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MappingSchema,The constructor "MappingSchema" calls a virtual method "InitNullValues".
Virtual Method Call from Constructor,BLToolkit.ComponentModel,CustomTypeDescriptorImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\CustomTypeDescriptorImpl.cs,CustomTypeDescriptorImpl,The constructor "CustomTypeDescriptorImpl" calls a virtual method "CreateTypeDescriptionProvider".
Virtual Method Call from Constructor,BLToolkit.ComponentModel,CustomTypeDescriptorImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\CustomTypeDescriptorImpl.cs,CustomTypeDescriptorImpl,The constructor "CustomTypeDescriptorImpl" calls a virtual method "CreateTypeDescriptionProvider".
Empty Catch Block,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetValueMapper,The method has an empty catch block.
Empty Catch Block,BLToolkit.Mapping,MemberMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,MapTo,The method has an empty catch block.
Empty Catch Block,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,The method has an empty catch block.
Empty Catch Block,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,The method has an empty catch block.
Empty Catch Block,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,The method has an empty catch block.
Empty Catch Block,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,MapEnumToValue,The method has an empty catch block.
Empty Catch Block,BLToolkit.Mapping.MemberMappers,JSONSerialisationMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MemberMappers\JSONSerialisationMapper.cs,Deserialize,The method has an empty catch block.
Empty Catch Block,BLToolkit.Mapping.MemberMappers,XMLSerialisationMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MemberMappers\XMLSerialisationMapper.cs,Deserialize,The method has an empty catch block.
Empty Catch Block,BLToolkit.ComponentModel,TypedListImpl,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\TypedListImpl.cs,GetItemProperties,The method has an empty catch block.
Empty Catch Block,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetListItemType,The method has an empty catch block.
Empty Catch Block,BLToolkit.TypeBuilder,TypeFactory,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,TypeFactory,The method has an empty catch block.
Magic Number,BLToolkit.Aspects.Builders,AsyncAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\AsyncAspectBuilder.cs,EnsureDelegateType,The following statement contains a magic number: if (delegateType == null) {  	var pi = method.GetParameters ();  	var parameters = new Type[pi.Length];  	for (var i = 0; i < pi.Length; i++)  		parameters [i] = pi [i].ParameterType;  	const MethodImplAttributes mia = MethodImplAttributes.Runtime | MethodImplAttributes.Managed;  	const MethodAttributes ma = MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Virtual;  	var delegateBuilder = context.AssemblyBuilder.DefineType (delegateName' TypeAttributes.Class | TypeAttributes.NotPublic | TypeAttributes.Sealed | TypeAttributes.AnsiClass | TypeAttributes.AutoClass' typeof(MulticastDelegate));  	// Create constructor  	//  	var ctorBuilder = delegateBuilder.DefineConstructor (MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.RTSpecialName' CallingConventions.Standard' typeof(object)' typeof(IntPtr));  	ctorBuilder.ConstructorBuilder.SetImplementationFlags (mia);  	// Define the BeginInvoke method for the delegate  	//  	var beginParameters = new Type[parameters.Length + 2];  	Array.Copy (parameters' 0' beginParameters' 0' parameters.Length);  	beginParameters [parameters.Length] = typeof(AsyncCallback);  	beginParameters [parameters.Length + 1] = typeof(object);  	var methodBuilder = delegateBuilder.DefineMethod ("BeginInvoke"' ma' typeof(IAsyncResult)' beginParameters);  	methodBuilder.MethodBuilder.SetImplementationFlags (mia);  	// Define the EndInvoke method for the delegate  	//  	methodBuilder = delegateBuilder.DefineMethod ("EndInvoke"' ma' method.ReturnType' typeof(IAsyncResult));  	methodBuilder.MethodBuilder.SetImplementationFlags (mia);  	// Define the Invoke method for the delegate  	//  	methodBuilder = delegateBuilder.DefineMethod ("Invoke"' ma' method.ReturnType' parameters);  	methodBuilder.MethodBuilder.SetImplementationFlags (mia);  	context.Items.Add (delegateName' delegateType = delegateBuilder.Create ());  }  
Magic Number,BLToolkit.Aspects,CacheAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,Init,The following statement contains a magic number: foreach (var p in ps) {  	var vs = p.Split ('=');  	if (vs.Length == 2) {  		switch (vs [0].ToLower ().Trim ()) {  		case "maxcachetime":  			_instanceMaxCacheTime = int.Parse (vs [1].Trim ());  			break;  		case "isweak":  			_instanceIsWeak = bool.Parse (vs [1].Trim ());  			break;  		}  	}  }  
Magic Number,BLToolkit.Aspects,CacheAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,Init,The following statement contains a magic number: if (vs.Length == 2) {  	switch (vs [0].ToLower ().Trim ()) {  	case "maxcachetime":  		_instanceMaxCacheTime = int.Parse (vs [1].Trim ());  		break;  	case "isweak":  		_instanceIsWeak = bool.Parse (vs [1].Trim ());  		break;  	}  }  
Magic Number,BLToolkit.Aspects,LoggingAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\LoggingAspect.cs,Init,The following statement contains a magic number: foreach (string p in ps) {  	string[] vs = p.Split ('=');  	if (vs.Length == 2) {  		switch (vs [0].ToLower ().Trim ()) {  		case "filename":  			_instanceFileName = vs [1].Trim ();  			break;  		case "mincalltime":  			_instanceMinCallTime = int.Parse (vs [1].Trim ());  			break;  		case "logexceptions":  			_instanceLogExceptions = bool.Parse (vs [1].Trim ());  			break;  		case "logparameters":  			_instanceLogParameters = bool.Parse (vs [1].Trim ());  			break;  		}  	}  }  
Magic Number,BLToolkit.Aspects,LoggingAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\LoggingAspect.cs,Init,The following statement contains a magic number: if (vs.Length == 2) {  	switch (vs [0].ToLower ().Trim ()) {  	case "filename":  		_instanceFileName = vs [1].Trim ();  		break;  	case "mincalltime":  		_instanceMinCallTime = int.Parse (vs [1].Trim ());  		break;  	case "logexceptions":  		_instanceLogExceptions = bool.Parse (vs [1].Trim ());  		break;  	case "logparameters":  		_instanceLogParameters = bool.Parse (vs [1].Trim ());  		break;  	}  }  
Magic Number,BLToolkit.Common,Tuple,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,GetHashCode,The following statement contains a magic number: return ((hash1 << 5) + hash1) ^ hash2;  
Magic Number,BLToolkit.Common,Tuple,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,GetHashCode,The following statement contains a magic number: hash1 = ((hash1 << 5) + hash1) ^ hash2;  
Magic Number,BLToolkit.Common,Tuple,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,GetHashCode,The following statement contains a magic number: return ((hash1 << 5) + hash1) ^ hash2;  
Magic Number,BLToolkit.Common,Tuple,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,GetHashCode,The following statement contains a magic number: hash1 = ((hash1 << 5) + hash1) ^ hash2;  
Magic Number,BLToolkit.Common,Tuple,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,GetHashCode,The following statement contains a magic number: hash1 = ((hash1 << 5) + hash1) ^ hash2;  
Magic Number,BLToolkit.Common,Tuple,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Tuple.cs,GetHashCode,The following statement contains a magic number: return ((hash1 << 5) + hash1) ^ hash2;  
Magic Number,BLToolkit.Common,CompoundValue,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\CompoundValue.cs,CalcHashCode,The following statement contains a magic number: for (int i = 1; i < values.Length; i++) {  	o = values [i];  	hash = ((hash << 5) + hash) ^ (o == null ? 0 : o.GetHashCode ());  }  
Magic Number,BLToolkit.Common,CompoundValue,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\CompoundValue.cs,CalcHashCode,The following statement contains a magic number: hash = ((hash << 5) + hash) ^ (o == null ? 0 : o.GetHashCode ());  
Magic Number,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildAbstractMethod,The following statement contains a magic number: switch (rt) {  case ReturnType.DataReader:  	ExecuteReader ();  	break;  case ReturnType.DataSet:  	ExecuteDataSet (returnType);  	break;  case ReturnType.DataTable:  	ExecuteDataTable ();  	break;  case ReturnType.Void:  	ExecuteNonQuery ();  	break;  case ReturnType.Scalar:  	ExecuteScalar ();  	break;  case ReturnType.Enumerable:  	ExecuteEnumerable ();  	break;  case ReturnType.List:  	if (!_explicitObjectType) {  		Type elementType = TypeHelper.GetListItemType (returnType);  		if (elementType == typeof(object) && _destination != null)  			elementType = TypeHelper.GetListItemType (Context.CurrentMethod.ReturnType);  		if (elementType != typeof(object))  			_objectType = elementType;  		if (ActualTypes.ContainsKey (_objectType))  			_objectType = ActualTypes [_objectType];  	}  	if (_objectType == null || _objectType == typeof(object))  		ThrowTypeBuilderException (Resources.DataAccessorBuilder_BadListItemType);  	if (TypeHelper.IsScalar (_objectType))  		ExecuteScalarList ();  	else  		ExecuteList ();  	break;  case ReturnType.Dictionary:  	{  		Type elementType = null;  		Type keyType = typeof(object);  		Type[] gTypes = TypeHelper.GetGenericArguments (returnType' typeof(IDictionary));  		if ((gTypes == null || gTypes.Length != 2) && _destination != null)  			gTypes = TypeHelper.GetGenericArguments (_destination.ParameterType' typeof(IDictionary));  		if (gTypes != null && gTypes.Length == 2) {  			keyType = gTypes [0];  			elementType = gTypes [1];  		}  		if (elementType == null || _explicitObjectType)  			elementType = _objectType;  		if (elementType == null || elementType == typeof(object))  			ThrowTypeBuilderException (Resources.DataAccessorBuilder_BadListItemType);  		bool isIndex = TypeHelper.IsSameOrParent (typeof(CompoundValue)' keyType);  		if (keyType != typeof(object) && !isIndex && !TypeHelper.IsScalar (keyType))  			ThrowTypeBuilderException (Resources.DataAccessorBuilder_BadKeyType);  		MethodInfo mi = Context.CurrentMethod;  		object[] attrs = mi.GetCustomAttributes (typeof(IndexAttribute)' true);  		NameOrIndexParameter[] fields = new NameOrIndexParameter[0];  		if (attrs.Length != 0)  			fields = ((IndexAttribute)attrs [0]).Fields;  		if (fields.Length > 1 && keyType != typeof(object) && !isIndex)  			ThrowTypeBuilderException (Resources.DataAccessor_InvalidKeyType);  		if (TypeHelper.IsScalar (elementType)) {  			attrs = mi.GetCustomAttributes (typeof(ScalarFieldNameAttribute)' true);  			if (attrs.Length == 0)  				ThrowTypeBuilderException (Resources.DataAccessorBuilder_ScalarFieldNameMissing);  			NameOrIndexParameter scalarField = ((ScalarFieldNameAttribute)attrs [0]).NameOrIndex;  			if (fields.Length == 0)  				ExecuteScalarDictionaryWithPK (keyType' scalarField' elementType);  			else if (isIndex || fields.Length > 1)  				ExecuteScalarDictionaryWithMapIndex (fields' scalarField' elementType);  			else  				ExecuteScalarDictionaryWithScalarKey (fields [0]' keyType' scalarField' elementType);  		} else {  			if (!_explicitObjectType && ActualTypes.ContainsKey (elementType))  				elementType = ActualTypes [elementType];  			if (fields.Length == 0)  				ExecuteDictionaryWithPK (keyType' elementType);  			else if (isIndex || fields.Length > 1)  				ExecuteDictionaryWithMapIndex (fields' elementType);  			else  				ExecuteDictionaryWithScalarKey (fields [0]' elementType);  		}  	}  	break;  default:  	if (_objectType == null || !TypeHelper.IsSameOrParent (returnType' _objectType))  		_objectType = returnType;  	if (!_explicitObjectType && ActualTypes.ContainsKey (_objectType))  		_objectType = ActualTypes [_objectType];  	ExecuteObject ();  	break;  }  
Magic Number,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildAbstractMethod,The following statement contains a magic number: switch (rt) {  case ReturnType.DataReader:  	ExecuteReader ();  	break;  case ReturnType.DataSet:  	ExecuteDataSet (returnType);  	break;  case ReturnType.DataTable:  	ExecuteDataTable ();  	break;  case ReturnType.Void:  	ExecuteNonQuery ();  	break;  case ReturnType.Scalar:  	ExecuteScalar ();  	break;  case ReturnType.Enumerable:  	ExecuteEnumerable ();  	break;  case ReturnType.List:  	if (!_explicitObjectType) {  		Type elementType = TypeHelper.GetListItemType (returnType);  		if (elementType == typeof(object) && _destination != null)  			elementType = TypeHelper.GetListItemType (Context.CurrentMethod.ReturnType);  		if (elementType != typeof(object))  			_objectType = elementType;  		if (ActualTypes.ContainsKey (_objectType))  			_objectType = ActualTypes [_objectType];  	}  	if (_objectType == null || _objectType == typeof(object))  		ThrowTypeBuilderException (Resources.DataAccessorBuilder_BadListItemType);  	if (TypeHelper.IsScalar (_objectType))  		ExecuteScalarList ();  	else  		ExecuteList ();  	break;  case ReturnType.Dictionary:  	{  		Type elementType = null;  		Type keyType = typeof(object);  		Type[] gTypes = TypeHelper.GetGenericArguments (returnType' typeof(IDictionary));  		if ((gTypes == null || gTypes.Length != 2) && _destination != null)  			gTypes = TypeHelper.GetGenericArguments (_destination.ParameterType' typeof(IDictionary));  		if (gTypes != null && gTypes.Length == 2) {  			keyType = gTypes [0];  			elementType = gTypes [1];  		}  		if (elementType == null || _explicitObjectType)  			elementType = _objectType;  		if (elementType == null || elementType == typeof(object))  			ThrowTypeBuilderException (Resources.DataAccessorBuilder_BadListItemType);  		bool isIndex = TypeHelper.IsSameOrParent (typeof(CompoundValue)' keyType);  		if (keyType != typeof(object) && !isIndex && !TypeHelper.IsScalar (keyType))  			ThrowTypeBuilderException (Resources.DataAccessorBuilder_BadKeyType);  		MethodInfo mi = Context.CurrentMethod;  		object[] attrs = mi.GetCustomAttributes (typeof(IndexAttribute)' true);  		NameOrIndexParameter[] fields = new NameOrIndexParameter[0];  		if (attrs.Length != 0)  			fields = ((IndexAttribute)attrs [0]).Fields;  		if (fields.Length > 1 && keyType != typeof(object) && !isIndex)  			ThrowTypeBuilderException (Resources.DataAccessor_InvalidKeyType);  		if (TypeHelper.IsScalar (elementType)) {  			attrs = mi.GetCustomAttributes (typeof(ScalarFieldNameAttribute)' true);  			if (attrs.Length == 0)  				ThrowTypeBuilderException (Resources.DataAccessorBuilder_ScalarFieldNameMissing);  			NameOrIndexParameter scalarField = ((ScalarFieldNameAttribute)attrs [0]).NameOrIndex;  			if (fields.Length == 0)  				ExecuteScalarDictionaryWithPK (keyType' scalarField' elementType);  			else if (isIndex || fields.Length > 1)  				ExecuteScalarDictionaryWithMapIndex (fields' scalarField' elementType);  			else  				ExecuteScalarDictionaryWithScalarKey (fields [0]' keyType' scalarField' elementType);  		} else {  			if (!_explicitObjectType && ActualTypes.ContainsKey (elementType))  				elementType = ActualTypes [elementType];  			if (fields.Length == 0)  				ExecuteDictionaryWithPK (keyType' elementType);  			else if (isIndex || fields.Length > 1)  				ExecuteDictionaryWithMapIndex (fields' elementType);  			else  				ExecuteDictionaryWithScalarKey (fields [0]' elementType);  		}  	}  	break;  default:  	if (_objectType == null || !TypeHelper.IsSameOrParent (returnType' _objectType))  		_objectType = returnType;  	if (!_explicitObjectType && ActualTypes.ContainsKey (_objectType))  		_objectType = ActualTypes [_objectType];  	ExecuteObject ();  	break;  }  
Magic Number,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildAbstractMethod,The following statement contains a magic number: if ((gTypes == null || gTypes.Length != 2) && _destination != null)  	gTypes = TypeHelper.GetGenericArguments (_destination.ParameterType' typeof(IDictionary));  
Magic Number,BLToolkit.DataAccess,DataAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\DataAccessorBuilder.cs,BuildAbstractMethod,The following statement contains a magic number: if (gTypes != null && gTypes.Length == 2) {  	keyType = gTypes [0];  	elementType = gTypes [1];  }  
Magic Number,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,AddWherePK,The following statement contains a magic number: sb.Remove (sb.Length - 5' 5);  
Magic Number,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,AddWherePK,The following statement contains a magic number: sb.Remove (sb.Length - 5' 5);  
Magic Number,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateSelectByKeySqlText,The following statement contains a magic number: sb.Remove (sb.Length - 2' 1);  
Magic Number,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateSelectAllSqlText,The following statement contains a magic number: sb.Remove (sb.Length - 2' 1);  
Magic Number,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateInsertSqlText,The following statement contains a magic number: sb.Remove (sb.Length - 2' 1);  
Magic Number,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateInsertSqlText,The following statement contains a magic number: sb.Remove (sb.Length - 2' 1);  
Magic Number,BLToolkit.DataAccess,SqlQueryBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\DataAccess\SqlQueryBase.cs,CreateUpdateSqlText,The following statement contains a magic number: sb.Remove (sb.Length - 2' 1);  
Magic Number,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The following statement contains a magic number: foreach (var obj in collection) {  	if (initParameters) {  		initParameters = false;  		baseParameters = getParameters (obj);  		if (maxRows != 1) {  			var n = 0;  			foreach (var p in baseParameters)  				n += p.ParameterName.Length + 3 - "{0}".Length + _dataProvider.EndOfSql.Length;  			maxRows = Math.Max (1' Math.Min (maxRows' _dataProvider.MaxBatchSize / (baseSql.Length + n)));  		}  		if (maxRows != 1)  			baseSql += _dataProvider.EndOfSql;  	}  	if (rowSql.Count < maxRows) {  		// ReSharper disable AccessToModifiedClosure  		Converter<IDbDataParameter' string> c1 = p => p.ParameterName + nRows;  		// ReSharper restore AccessToModifiedClosure  		Converter<IDbDataParameter' string> c2 = p => p.ParameterName;  		sb.Append ("\n").AppendFormat (baseSql' Array.ConvertAll (baseParameters' baseParameters.Length > 0 && baseParameters [0].ParameterName != paramName ? c1 : c2));  		rowSql.Add (sb.Length);  		for (var i = 0; i < members.Length; i++) {  			var value = members [i].GetValue (obj);  			var type = members [i].MemberAccessor.Type;  			var dbType = members [i].GetDbType ();  			IDbDataParameter p;  			if ((value == null || value == DBNull.Value) && (dbType == DbType.Binary || type == typeof(byte[])) || type == typeof(System.Data.Linq.Binary)) {  				p = Parameter (baseParameters [i].ParameterName + nRows' DBNull.Value' DbType.Binary);  			} else {  				if (value != null && value.GetType ().IsEnum)  					value = MappingSchema.MapEnumToValue (value' true);  				p = value != null ? Parameter (baseParameters [i].ParameterName + nRows' value) : Parameter (baseParameters [i].ParameterName + nRows' DBNull.Value' members [i].GetDbType ());  			}  			parameters.Add (p);  			hasValue.Add (value != null);  		}  	} else {  		var n = nRows * members.Length;  		for (var i = 0; i < members.Length; i++) {  			var value = members [i].GetValue (obj);  			if (!hasValue [n + i] && value != null) {  				isPrepared = false;  				var type = members [i].MemberAccessor.Type;  				var dbType = members [i].GetDbType ();  				if (value.GetType ().IsEnum)  					value = MappingSchema.MapEnumToValue (value' true);  				IDbDataParameter p;  				if (dbType != DbType.Object)  					p = Parameter (baseParameters [i].ParameterName + nRows' value ?? DBNull.Value' dbType);  				else  					p = Parameter (baseParameters [i].ParameterName + nRows' value ?? DBNull.Value/*' dbType*/);  				parameters [n + i] = p;  				hasValue [n + i] = true;  			} else {  				if (value != null && value.GetType ().IsEnum)  					value = MappingSchema.MapEnumToValue (value' true);  				_dataProvider.SetParameterValue (parameters [n + i]' value ?? DBNull.Value);  				//value == null || members[i].MapMemberInfo.Nullable && _mappingSchema.IsNull(value)  				//	? DBNull.Value  				//	: value);  			}  		}  	}  	nRows++;  	if (nRows >= maxRows) {  		if (!isPrepared) {  			SetCommand (sb.ToString ()' parameters.ToArray ());  			Prepare ();  			isPrepared = true;  		} else {  			InitParameters (CommandAction.Select);  		}  		var n = ExecuteNonQueryInternal ();  		if (n > 0)  			rowsTotal += n;  		nRows = 0;  	}  }  
Magic Number,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The following statement contains a magic number: if (initParameters) {  	initParameters = false;  	baseParameters = getParameters (obj);  	if (maxRows != 1) {  		var n = 0;  		foreach (var p in baseParameters)  			n += p.ParameterName.Length + 3 - "{0}".Length + _dataProvider.EndOfSql.Length;  		maxRows = Math.Max (1' Math.Min (maxRows' _dataProvider.MaxBatchSize / (baseSql.Length + n)));  	}  	if (maxRows != 1)  		baseSql += _dataProvider.EndOfSql;  }  
Magic Number,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The following statement contains a magic number: if (maxRows != 1) {  	var n = 0;  	foreach (var p in baseParameters)  		n += p.ParameterName.Length + 3 - "{0}".Length + _dataProvider.EndOfSql.Length;  	maxRows = Math.Max (1' Math.Min (maxRows' _dataProvider.MaxBatchSize / (baseSql.Length + n)));  }  
Magic Number,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The following statement contains a magic number: foreach (var p in baseParameters)  	n += p.ParameterName.Length + 3 - "{0}".Length + _dataProvider.EndOfSql.Length;  
Magic Number,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,ExecuteForEach,The following statement contains a magic number: n += p.ParameterName.Length + 3 - "{0}".Length + _dataProvider.EndOfSql.Length;  
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderVersionResolver,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderVersionResolver.cs,GetVersionFromConnection,The following statement contains a magic number: if (serverVersionDetails.Length > 0 && int.TryParse (serverVersionDetails [0]' out versionNumber))  	return versionNumber * 10;  
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderVersionResolver,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderVersionResolver.cs,GetVersionFromConnection,The following statement contains a magic number: return versionNumber * 10;  
Magic Number,BLToolkit.Data.DataProvider,AccessDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,DeriveParameters,The following statement contains a magic number: if (dt.Rows.Count == 0) {  	// Jet does convert parameretless procedures to views.  	//  	dt = conn.GetOleDbSchemaTable (OleDbSchemaGuid.Views' new object[] {  		null'  		null'  		command.CommandText  	});  	if (dt.Rows.Count == 0)  		throw new DataException (string.Format ("Stored procedure '{0}' not found"' command.CommandText));  	// Do nothing. There is no parameters.  	//  } else {  	var col = dt.Columns ["PROCEDURE_DEFINITION"];  	if (col == null) {  		// Not really possible  		//  		return false;  	}  	if (_paramsExp == null)  		_paramsExp = new Regex (@"PARAMETERS ((\[(?<name>[^\]]+)\]|(?<name>[^\s]+))\s(?<type>[^';\s]+(\s\([^\)]+\))?)[';]\s)*"' RegexOptions.Compiled | RegexOptions.ExplicitCapture);  	var match = _paramsExp.Match ((string)dt.Rows [0] [col.Ordinal]);  	var names = match.Groups ["name"].Captures;  	var types = match.Groups ["type"].Captures;  	if (names.Count != types.Count) {  		// Not really possible  		//  		return false;  	}  	var separators = new[] {  		' ''  		'(''  		''''  		')'  	};  	for (var i = 0; i < names.Count; ++i) {  		var paramName = names [i].Value;  		var rawType = types [i].Value.Split (separators' StringSplitOptions.RemoveEmptyEntries);  		var p = new OleDbParameter (paramName' GetOleDbType (rawType [0]));  		if (rawType.Length > 2) {  			p.Precision = Common.Convert.ToByte (rawType [1]);  			p.Scale = Common.Convert.ToByte (rawType [2]);  		} else if (rawType.Length > 1) {  			p.Size = Common.Convert.ToInt32 (rawType [1]);  		}  		command.Parameters.Add (p);  	}  }  
Magic Number,BLToolkit.Data.DataProvider,AccessDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,DeriveParameters,The following statement contains a magic number: if (dt.Rows.Count == 0) {  	// Jet does convert parameretless procedures to views.  	//  	dt = conn.GetOleDbSchemaTable (OleDbSchemaGuid.Views' new object[] {  		null'  		null'  		command.CommandText  	});  	if (dt.Rows.Count == 0)  		throw new DataException (string.Format ("Stored procedure '{0}' not found"' command.CommandText));  	// Do nothing. There is no parameters.  	//  } else {  	var col = dt.Columns ["PROCEDURE_DEFINITION"];  	if (col == null) {  		// Not really possible  		//  		return false;  	}  	if (_paramsExp == null)  		_paramsExp = new Regex (@"PARAMETERS ((\[(?<name>[^\]]+)\]|(?<name>[^\s]+))\s(?<type>[^';\s]+(\s\([^\)]+\))?)[';]\s)*"' RegexOptions.Compiled | RegexOptions.ExplicitCapture);  	var match = _paramsExp.Match ((string)dt.Rows [0] [col.Ordinal]);  	var names = match.Groups ["name"].Captures;  	var types = match.Groups ["type"].Captures;  	if (names.Count != types.Count) {  		// Not really possible  		//  		return false;  	}  	var separators = new[] {  		' ''  		'(''  		''''  		')'  	};  	for (var i = 0; i < names.Count; ++i) {  		var paramName = names [i].Value;  		var rawType = types [i].Value.Split (separators' StringSplitOptions.RemoveEmptyEntries);  		var p = new OleDbParameter (paramName' GetOleDbType (rawType [0]));  		if (rawType.Length > 2) {  			p.Precision = Common.Convert.ToByte (rawType [1]);  			p.Scale = Common.Convert.ToByte (rawType [2]);  		} else if (rawType.Length > 1) {  			p.Size = Common.Convert.ToInt32 (rawType [1]);  		}  		command.Parameters.Add (p);  	}  }  
Magic Number,BLToolkit.Data.DataProvider,AccessDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,DeriveParameters,The following statement contains a magic number: for (var i = 0; i < names.Count; ++i) {  	var paramName = names [i].Value;  	var rawType = types [i].Value.Split (separators' StringSplitOptions.RemoveEmptyEntries);  	var p = new OleDbParameter (paramName' GetOleDbType (rawType [0]));  	if (rawType.Length > 2) {  		p.Precision = Common.Convert.ToByte (rawType [1]);  		p.Scale = Common.Convert.ToByte (rawType [2]);  	} else if (rawType.Length > 1) {  		p.Size = Common.Convert.ToInt32 (rawType [1]);  	}  	command.Parameters.Add (p);  }  
Magic Number,BLToolkit.Data.DataProvider,AccessDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,DeriveParameters,The following statement contains a magic number: for (var i = 0; i < names.Count; ++i) {  	var paramName = names [i].Value;  	var rawType = types [i].Value.Split (separators' StringSplitOptions.RemoveEmptyEntries);  	var p = new OleDbParameter (paramName' GetOleDbType (rawType [0]));  	if (rawType.Length > 2) {  		p.Precision = Common.Convert.ToByte (rawType [1]);  		p.Scale = Common.Convert.ToByte (rawType [2]);  	} else if (rawType.Length > 1) {  		p.Size = Common.Convert.ToInt32 (rawType [1]);  	}  	command.Parameters.Add (p);  }  
Magic Number,BLToolkit.Data.DataProvider,AccessDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,DeriveParameters,The following statement contains a magic number: if (rawType.Length > 2) {  	p.Precision = Common.Convert.ToByte (rawType [1]);  	p.Scale = Common.Convert.ToByte (rawType [2]);  } else if (rawType.Length > 1) {  	p.Size = Common.Convert.ToInt32 (rawType [1]);  }  
Magic Number,BLToolkit.Data.DataProvider,AccessDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,DeriveParameters,The following statement contains a magic number: if (rawType.Length > 2) {  	p.Precision = Common.Convert.ToByte (rawType [1]);  	p.Scale = Common.Convert.ToByte (rawType [2]);  } else if (rawType.Length > 1) {  	p.Size = Common.Convert.ToInt32 (rawType [1]);  }  
Magic Number,BLToolkit.Data.DataProvider,AccessDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,DeriveParameters,The following statement contains a magic number: p.Scale = Common.Convert.ToByte (rawType [2]);  
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,ConvertErrorNumberToDataExceptionType,The following statement contains a magic number: switch (number) {  case 1205:  	return DataExceptionType.Deadlock;  case -2:  	return DataExceptionType.Timeout;  case 547:  	return DataExceptionType.ForeignKeyViolation;  case 2601:  	return DataExceptionType.UniqueIndexViolation;  case 2627:  	return DataExceptionType.ConstraintViolation;  }  
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,ConvertErrorNumberToDataExceptionType,The following statement contains a magic number: switch (number) {  case 1205:  	return DataExceptionType.Deadlock;  case -2:  	return DataExceptionType.Timeout;  case 547:  	return DataExceptionType.ForeignKeyViolation;  case 2601:  	return DataExceptionType.UniqueIndexViolation;  case 2627:  	return DataExceptionType.ConstraintViolation;  }  
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,ConvertErrorNumberToDataExceptionType,The following statement contains a magic number: switch (number) {  case 1205:  	return DataExceptionType.Deadlock;  case -2:  	return DataExceptionType.Timeout;  case 547:  	return DataExceptionType.ForeignKeyViolation;  case 2601:  	return DataExceptionType.UniqueIndexViolation;  case 2627:  	return DataExceptionType.ConstraintViolation;  }  
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,ConvertErrorNumberToDataExceptionType,The following statement contains a magic number: switch (number) {  case 1205:  	return DataExceptionType.Deadlock;  case -2:  	return DataExceptionType.Timeout;  case 547:  	return DataExceptionType.ForeignKeyViolation;  case 2601:  	return DataExceptionType.UniqueIndexViolation;  case 2627:  	return DataExceptionType.ConstraintViolation;  }  
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,ConvertErrorNumberToDataExceptionType,The following statement contains a magic number: switch (number) {  case 1205:  	return DataExceptionType.Deadlock;  case -2:  	return DataExceptionType.Timeout;  case 547:  	return DataExceptionType.ForeignKeyViolation;  case 2601:  	return DataExceptionType.UniqueIndexViolation;  case 2627:  	return DataExceptionType.ConstraintViolation;  }  
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,IsMarsEnabled,The following statement contains a magic number: if (conn.ConnectionString != null) {  	return conn.ConnectionString.Split (';').Select (s => s.Split ('=')).Where (s => s.Length == 2 && s [0].Trim ().ToLower () == "multipleactiveresultsets").Select (s => s [1].Trim ().ToLower ()).Any (s => s == "true" || s == "1" || s == "yes");  }  
Magic Number,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,IsMarsEnabled,The following statement contains a magic number: return conn.ConnectionString.Split (';').Select (s => s.Split ('=')).Where (s => s.Length == 2 && s [0].Trim ().ToLower () == "multipleactiveresultsets").Select (s => s [1].Trim ().ToLower ()).Any (s => s == "true" || s == "1" || s == "yes");  
Magic Number,BLToolkit.Data.Linq.Builder,ConcatUnionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ConcatUnionBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: return methodCall.Arguments.Count == 2 && methodCall.IsQueryable ("Concat"' "Union");  
Magic Number,BLToolkit.Data.Linq.Builder,ContainsBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ContainsBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: return methodCall.IsQueryable ("Contains") && methodCall.Arguments.Count == 2;  
Magic Number,BLToolkit.Data.Linq.Builder,AllAnyBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\AllAnyBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (methodCall.Arguments.Count == 2) {  	var condition = (LambdaExpression)ExpressionBuilder.GetPredicate (methodCall.Arguments [1]);  	if (methodCall.Method.Name == "All")  		#if FW4 || SILVERLIGHT  		condition = Expression.Lambda (Expression.Not (condition.Body)' condition.Name' condition.Parameters);  	#else  						condition = Expression.Lambda(Expression.Not(condition.Body)' condition.Parameters.ToArray()); #endif  	sequence = builder.BuildWhere (buildInfo.Parent' sequence' condition' true);  	sequence.SetAlias (condition.Parameters [0].Name);  }  
Magic Number,BLToolkit.Data.Linq.Builder,AllAnyBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\AllAnyBuilder.cs,Convert,The following statement contains a magic number: if (methodCall.Arguments.Count == 2) {  	var predicate = (LambdaExpression)ExpressionBuilder.GetPredicate (methodCall.Arguments [1]);  	var info = builder.ConvertSequence (new BuildInfo (buildInfo' methodCall.Arguments [0])' predicate.Parameters [0]);  	if (info != null) {  		info.Expression = methodCall.Convert (ex => ConvertMethod (methodCall' 0' info' predicate.Parameters [0]' ex));  		info.Parameter = param;  		return info;  	}  } else {  	var info = builder.ConvertSequence (new BuildInfo (buildInfo' methodCall.Arguments [0])' null);  	if (info != null) {  		info.Expression = methodCall.Convert (ex => ConvertMethod (methodCall' 0' info' null' ex));  		info.Parameter = param;  		return info;  	}  }  
Magic Number,BLToolkit.Data.Linq.Builder,InsertOrUpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertOrUpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  
Magic Number,BLToolkit.Data.Linq.Builder,InsertOrUpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertOrUpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (methodCall.Arguments.Count == 3) {  	var table = sequence.SqlQuery.Insert.Into;  	var keys = table.GetKeys (false);  	if (keys.Count == 0)  		throw new LinqException ("InsertOrUpdate method requires the '{0}' table to have a primary key."' table.Name);  	var q = (from k in keys  	join i in sequence.SqlQuery.Insert.Items on k equals i.Column  	select new {  		k'  		i  	}).ToList ();  	var missedKey = keys.Except (q.Select (i => i.k)).FirstOrDefault ();  	if (missedKey != null)  		throw new LinqException ("InsertOrUpdate method requires the '{0}.{1}' field to be included in the insert setter."' table.Name' ((SqlField)missedKey).Name);  	sequence.SqlQuery.Update.Keys.AddRange (q.Select (i => i.i));  } else {  	UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [3].Unwrap ()' sequence' sequence.SqlQuery.Update.Keys' sequence);  }  
Magic Number,BLToolkit.Data.Linq.Builder,InsertOrUpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertOrUpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (methodCall.Arguments.Count == 3) {  	var table = sequence.SqlQuery.Insert.Into;  	var keys = table.GetKeys (false);  	if (keys.Count == 0)  		throw new LinqException ("InsertOrUpdate method requires the '{0}' table to have a primary key."' table.Name);  	var q = (from k in keys  	join i in sequence.SqlQuery.Insert.Items on k equals i.Column  	select new {  		k'  		i  	}).ToList ();  	var missedKey = keys.Except (q.Select (i => i.k)).FirstOrDefault ();  	if (missedKey != null)  		throw new LinqException ("InsertOrUpdate method requires the '{0}.{1}' field to be included in the insert setter."' table.Name' ((SqlField)missedKey).Name);  	sequence.SqlQuery.Update.Keys.AddRange (q.Select (i => i.i));  } else {  	UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [3].Unwrap ()' sequence' sequence.SqlQuery.Update.Keys' sequence);  }  
Magic Number,BLToolkit.Data.Linq.Builder,InsertOrUpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertOrUpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [3].Unwrap ()' sequence' sequence.SqlQuery.Update.Keys' sequence);  
Magic Number,BLToolkit.Data.Linq.Builder,IntersectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\IntersectBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: return methodCall.Arguments.Count == 2 && methodCall.IsQueryable ("Except"' "Intersect");  
Magic Number,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count) {  case 1:  	// int Update<T>(this IUpdateable<T> source)  	CheckAssociation (sequence);  	break;  case 2:// int Update<T>(this IQueryable<T> source' Expression<Func<T'T>> setter)   {  	CheckAssociation (sequence);  	BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  	break;  }  case 3: {  	var expr = methodCall.Arguments [1].Unwrap ();  	if (expr is LambdaExpression) {  		// int Update<T>(this IQueryable<T> source' Expression<Func<T'bool>> predicate' Expression<Func<T'T>> setter)  		//  		sequence = builder.BuildWhere (buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' false);  		CheckAssociation (sequence);  		BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  	} else {  		// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  		//  		var into = builder.BuildSequence (new BuildInfo (buildInfo' expr' new SqlQuery ()));  		sequence.ConvertToIndex (null' 0' ConvertFlags.All);  		sequence.SqlQuery.ResolveWeakJoins (new List<ISqlTableSource> ());  		sequence.SqlQuery.Select.Columns.Clear ();  		BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Update.Items' sequence);  		var sql = sequence.SqlQuery;  		sql.Select.Columns.Clear ();  		foreach (var item in sql.Update.Items)  			sql.Select.Columns.Add (new SqlQuery.Column (sql' item.Expression));  		sql.Update.Table = ((TableBuilder.TableContext)into).SqlTable;  	}  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count) {  case 1:  	// int Update<T>(this IUpdateable<T> source)  	CheckAssociation (sequence);  	break;  case 2:// int Update<T>(this IQueryable<T> source' Expression<Func<T'T>> setter)   {  	CheckAssociation (sequence);  	BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  	break;  }  case 3: {  	var expr = methodCall.Arguments [1].Unwrap ();  	if (expr is LambdaExpression) {  		// int Update<T>(this IQueryable<T> source' Expression<Func<T'bool>> predicate' Expression<Func<T'T>> setter)  		//  		sequence = builder.BuildWhere (buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' false);  		CheckAssociation (sequence);  		BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  	} else {  		// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  		//  		var into = builder.BuildSequence (new BuildInfo (buildInfo' expr' new SqlQuery ()));  		sequence.ConvertToIndex (null' 0' ConvertFlags.All);  		sequence.SqlQuery.ResolveWeakJoins (new List<ISqlTableSource> ());  		sequence.SqlQuery.Select.Columns.Clear ();  		BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Update.Items' sequence);  		var sql = sequence.SqlQuery;  		sql.Select.Columns.Clear ();  		foreach (var item in sql.Update.Items)  			sql.Select.Columns.Add (new SqlQuery.Column (sql' item.Expression));  		sql.Update.Table = ((TableBuilder.TableContext)into).SqlTable;  	}  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count) {  case 1:  	// int Update<T>(this IUpdateable<T> source)  	CheckAssociation (sequence);  	break;  case 2:// int Update<T>(this IQueryable<T> source' Expression<Func<T'T>> setter)   {  	CheckAssociation (sequence);  	BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  	break;  }  case 3: {  	var expr = methodCall.Arguments [1].Unwrap ();  	if (expr is LambdaExpression) {  		// int Update<T>(this IQueryable<T> source' Expression<Func<T'bool>> predicate' Expression<Func<T'T>> setter)  		//  		sequence = builder.BuildWhere (buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' false);  		CheckAssociation (sequence);  		BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  	} else {  		// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  		//  		var into = builder.BuildSequence (new BuildInfo (buildInfo' expr' new SqlQuery ()));  		sequence.ConvertToIndex (null' 0' ConvertFlags.All);  		sequence.SqlQuery.ResolveWeakJoins (new List<ISqlTableSource> ());  		sequence.SqlQuery.Select.Columns.Clear ();  		BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Update.Items' sequence);  		var sql = sequence.SqlQuery;  		sql.Select.Columns.Clear ();  		foreach (var item in sql.Update.Items)  			sql.Select.Columns.Add (new SqlQuery.Column (sql' item.Expression));  		sql.Update.Table = ((TableBuilder.TableContext)into).SqlTable;  	}  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count) {  case 1:  	// int Update<T>(this IUpdateable<T> source)  	CheckAssociation (sequence);  	break;  case 2:// int Update<T>(this IQueryable<T> source' Expression<Func<T'T>> setter)   {  	CheckAssociation (sequence);  	BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  	break;  }  case 3: {  	var expr = methodCall.Arguments [1].Unwrap ();  	if (expr is LambdaExpression) {  		// int Update<T>(this IQueryable<T> source' Expression<Func<T'bool>> predicate' Expression<Func<T'T>> setter)  		//  		sequence = builder.BuildWhere (buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' false);  		CheckAssociation (sequence);  		BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  	} else {  		// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  		//  		var into = builder.BuildSequence (new BuildInfo (buildInfo' expr' new SqlQuery ()));  		sequence.ConvertToIndex (null' 0' ConvertFlags.All);  		sequence.SqlQuery.ResolveWeakJoins (new List<ISqlTableSource> ());  		sequence.SqlQuery.Select.Columns.Clear ();  		BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Update.Items' sequence);  		var sql = sequence.SqlQuery;  		sql.Select.Columns.Clear ();  		foreach (var item in sql.Update.Items)  			sql.Select.Columns.Add (new SqlQuery.Column (sql' item.Expression));  		sql.Update.Table = ((TableBuilder.TableContext)into).SqlTable;  	}  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (expr is LambdaExpression) {  	// int Update<T>(this IQueryable<T> source' Expression<Func<T'bool>> predicate' Expression<Func<T'T>> setter)  	//  	sequence = builder.BuildWhere (buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' false);  	CheckAssociation (sequence);  	BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  } else {  	// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  	//  	var into = builder.BuildSequence (new BuildInfo (buildInfo' expr' new SqlQuery ()));  	sequence.ConvertToIndex (null' 0' ConvertFlags.All);  	sequence.SqlQuery.ResolveWeakJoins (new List<ISqlTableSource> ());  	sequence.SqlQuery.Select.Columns.Clear ();  	BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Update.Items' sequence);  	var sql = sequence.SqlQuery;  	sql.Select.Columns.Clear ();  	foreach (var item in sql.Update.Items)  		sql.Select.Columns.Add (new SqlQuery.Column (sql' item.Expression));  	sql.Update.Table = ((TableBuilder.TableContext)into).SqlTable;  }  
Magic Number,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (expr is LambdaExpression) {  	// int Update<T>(this IQueryable<T> source' Expression<Func<T'bool>> predicate' Expression<Func<T'T>> setter)  	//  	sequence = builder.BuildWhere (buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' false);  	CheckAssociation (sequence);  	BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  } else {  	// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  	//  	var into = builder.BuildSequence (new BuildInfo (buildInfo' expr' new SqlQuery ()));  	sequence.ConvertToIndex (null' 0' ConvertFlags.All);  	sequence.SqlQuery.ResolveWeakJoins (new List<ISqlTableSource> ());  	sequence.SqlQuery.Select.Columns.Clear ();  	BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Update.Items' sequence);  	var sql = sequence.SqlQuery;  	sql.Select.Columns.Clear ();  	foreach (var item in sql.Update.Items)  		sql.Select.Columns.Add (new SqlQuery.Column (sql' item.Expression));  	sql.Update.Table = ((TableBuilder.TableContext)into).SqlTable;  }  
Magic Number,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  
Magic Number,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following statement contains a magic number: BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Update.Items' sequence);  
Magic Number,BLToolkit.Data.Linq.Builder,DeleteBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\DeleteBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (methodCall.Arguments.Count == 2)  	sequence = builder.BuildWhere (buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' false);  
Magic Number,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count) {  case 1:// static int Insert<T>              (this IValueInsertable<T> source)  // static int Insert<TSource'TTarget>(this ISelectInsertable<TSource'TTarget> source)   {  	foreach (var item in sequence.SqlQuery.Insert.Items)  		sequence.SqlQuery.Select.Expr (item.Expression);  	break;  }  case 2:// static int Insert<T>(this Table<T> target' Expression<Func<T>> setter)   {  	UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' sequence' sequence.SqlQuery.Insert.Items' sequence);  	sequence.SqlQuery.Insert.Into = ((TableBuilder.TableContext)sequence).SqlTable;  	sequence.SqlQuery.From.Tables.Clear ();  	break;  }  case 3:// static int Insert<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)   {  	var into = builder.BuildSequence (new BuildInfo (buildInfo' methodCall.Arguments [1]' new SqlQuery ()));  	UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Insert.Items' sequence);  	sequence.SqlQuery.Select.Columns.Clear ();  	foreach (var item in sequence.SqlQuery.Insert.Items)  		sequence.SqlQuery.Select.Columns.Add (new SqlQuery.Column (sequence.SqlQuery' item.Expression));  	sequence.SqlQuery.Insert.Into = ((TableBuilder.TableContext)into).SqlTable;  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count) {  case 1:// static int Insert<T>              (this IValueInsertable<T> source)  // static int Insert<TSource'TTarget>(this ISelectInsertable<TSource'TTarget> source)   {  	foreach (var item in sequence.SqlQuery.Insert.Items)  		sequence.SqlQuery.Select.Expr (item.Expression);  	break;  }  case 2:// static int Insert<T>(this Table<T> target' Expression<Func<T>> setter)   {  	UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' sequence' sequence.SqlQuery.Insert.Items' sequence);  	sequence.SqlQuery.Insert.Into = ((TableBuilder.TableContext)sequence).SqlTable;  	sequence.SqlQuery.From.Tables.Clear ();  	break;  }  case 3:// static int Insert<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)   {  	var into = builder.BuildSequence (new BuildInfo (buildInfo' methodCall.Arguments [1]' new SqlQuery ()));  	UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Insert.Items' sequence);  	sequence.SqlQuery.Select.Columns.Clear ();  	foreach (var item in sequence.SqlQuery.Insert.Items)  		sequence.SqlQuery.Select.Columns.Add (new SqlQuery.Column (sequence.SqlQuery' item.Expression));  	sequence.SqlQuery.Insert.Into = ((TableBuilder.TableContext)into).SqlTable;  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Arguments.Count) {  case 1:// static int Insert<T>              (this IValueInsertable<T> source)  // static int Insert<TSource'TTarget>(this ISelectInsertable<TSource'TTarget> source)   {  	foreach (var item in sequence.SqlQuery.Insert.Items)  		sequence.SqlQuery.Select.Expr (item.Expression);  	break;  }  case 2:// static int Insert<T>(this Table<T> target' Expression<Func<T>> setter)   {  	UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' sequence' sequence.SqlQuery.Insert.Items' sequence);  	sequence.SqlQuery.Insert.Into = ((TableBuilder.TableContext)sequence).SqlTable;  	sequence.SqlQuery.From.Tables.Clear ();  	break;  }  case 3:// static int Insert<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)   {  	var into = builder.BuildSequence (new BuildInfo (buildInfo' methodCall.Arguments [1]' new SqlQuery ()));  	UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Insert.Items' sequence);  	sequence.SqlQuery.Select.Columns.Clear ();  	foreach (var item in sequence.SqlQuery.Insert.Items)  		sequence.SqlQuery.Select.Columns.Add (new SqlQuery.Column (sequence.SqlQuery' item.Expression));  	sequence.SqlQuery.Insert.Into = ((TableBuilder.TableContext)into).SqlTable;  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following statement contains a magic number: UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Insert.Items' sequence);  
Magic Number,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following statement contains a magic number: foreach (var field in q) {  	var expr = builder.SqlProvider.GetIdentityExpression (insert.Into' field' false);  	if (expr != null) {  		insert.Items.Insert (0' new SqlQuery.SetExpression (field' expr));  		if (methodCall.Arguments.Count == 3) {  			sequence.SqlQuery.Select.Columns.Insert (0' new SqlQuery.Column (sequence.SqlQuery' insert.Items [0].Expression));  		}  	}  }  
Magic Number,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (expr != null) {  	insert.Items.Insert (0' new SqlQuery.SetExpression (field' expr));  	if (methodCall.Arguments.Count == 3) {  		sequence.SqlQuery.Select.Columns.Insert (0' new SqlQuery.Column (sequence.SqlQuery' insert.Items [0].Expression));  	}  }  
Magic Number,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (methodCall.Arguments.Count == 3) {  	sequence.SqlQuery.Select.Columns.Insert (0' new SqlQuery.Column (sequence.SqlQuery' insert.Items [0].Expression));  }  
Magic Number,BLToolkit.Data.Linq.Builder,SelectManyBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectManyBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: return methodCall.IsQueryable ("SelectMany") && methodCall.Arguments.Count == 3 && ((LambdaExpression)methodCall.Arguments [1].Unwrap ()).Parameters.Count == 1;  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSelectMany,The following statement contains a magic number: if (method.Arguments.Count != 2 || ((LambdaExpression)method.Arguments [1].Unwrap ()).Parameters.Count != 1)  	return method;  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: if (method.Arguments.Count != 2)  	return method;  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSelector,The following statement contains a magic number: if (method.Arguments.Count != 2)  	return method;  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetMethodInfo,The following statement contains a magic number: return method.Method.DeclaringType == typeof(Enumerable) ? EnumerableMethods.Where (m => m.Name == name && m.GetParameters ().Length == 2).First (m => m.GetParameters () [1].ParameterType.GetGenericArguments ().Length == 2) : QueryableMethods.Where (m => m.Name == name && m.GetParameters ().Length == 2).First (m => m.GetParameters () [1].ParameterType.GetGenericArguments () [0].GetGenericArguments ().Length == 2);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetMethodInfo,The following statement contains a magic number: return method.Method.DeclaringType == typeof(Enumerable) ? EnumerableMethods.Where (m => m.Name == name && m.GetParameters ().Length == 2).First (m => m.GetParameters () [1].ParameterType.GetGenericArguments ().Length == 2) : QueryableMethods.Where (m => m.Name == name && m.GetParameters ().Length == 2).First (m => m.GetParameters () [1].ParameterType.GetGenericArguments () [0].GetGenericArguments ().Length == 2);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetMethodInfo,The following statement contains a magic number: return method.Method.DeclaringType == typeof(Enumerable) ? EnumerableMethods.Where (m => m.Name == name && m.GetParameters ().Length == 2).First (m => m.GetParameters () [1].ParameterType.GetGenericArguments ().Length == 2) : QueryableMethods.Where (m => m.Name == name && m.GetParameters ().Length == 2).First (m => m.GetParameters () [1].ParameterType.GetGenericArguments () [0].GetGenericArguments ().Length == 2);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetMethodInfo,The following statement contains a magic number: return method.Method.DeclaringType == typeof(Enumerable) ? EnumerableMethods.Where (m => m.Name == name && m.GetParameters ().Length == 2).First (m => m.GetParameters () [1].ParameterType.GetGenericArguments ().Length == 2) : QueryableMethods.Where (m => m.Name == name && m.GetParameters ().Length == 2).First (m => m.GetParameters () [1].ParameterType.GetGenericArguments () [0].GetGenericArguments ().Length == 2);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following statement contains a magic number: switch (expression.NodeType) {  case ExpressionType.AndAlso:  case ExpressionType.OrElse:  case ExpressionType.Not:  case ExpressionType.Equal:  case ExpressionType.NotEqual:  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual: {  	var condition = new SqlQuery.SearchCondition ();  	BuildSearchCondition (context' expression' condition.Conditions);  	return condition;  }  case ExpressionType.And:  case ExpressionType.Or: {  	if (expression.Type == typeof(bool))  		goto case ExpressionType.AndAlso;  	goto case ExpressionType.Add;  }  case ExpressionType.Add:  case ExpressionType.AddChecked:  case ExpressionType.Divide:  case ExpressionType.ExclusiveOr:  case ExpressionType.Modulo:  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  case ExpressionType.Power:  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked:  case ExpressionType.Coalesce: {  	var e = (BinaryExpression)expression;  	var l = ConvertToSql (context' e.Left' false);  	var r = ConvertToSql (context' e.Right' false);  	var t = e.Type;  	switch (expression.NodeType) {  	case ExpressionType.Add:  	case ExpressionType.AddChecked:  		return Convert (context' new SqlBinaryExpression (t' l' "+"' r' Precedence.Additive));  	case ExpressionType.And:  		return Convert (context' new SqlBinaryExpression (t' l' "&"' r' Precedence.Bitwise));  	case ExpressionType.Divide:  		return Convert (context' new SqlBinaryExpression (t' l' "/"' r' Precedence.Multiplicative));  	case ExpressionType.ExclusiveOr:  		return Convert (context' new SqlBinaryExpression (t' l' "^"' r' Precedence.Bitwise));  	case ExpressionType.Modulo:  		return Convert (context' new SqlBinaryExpression (t' l' "%"' r' Precedence.Multiplicative));  	case ExpressionType.Multiply:  	case ExpressionType.MultiplyChecked:  		return Convert (context' new SqlBinaryExpression (t' l' "*"' r' Precedence.Multiplicative));  	case ExpressionType.Or:  		return Convert (context' new SqlBinaryExpression (t' l' "|"' r' Precedence.Bitwise));  	case ExpressionType.Power:  		return Convert (context' new SqlFunction (t' "Power"' l' r));  	case ExpressionType.Subtract:  	case ExpressionType.SubtractChecked:  		return Convert (context' new SqlBinaryExpression (t' l' "-"' r' Precedence.Subtraction));  	case ExpressionType.Coalesce: {  		if (r is SqlFunction) {  			var c = (SqlFunction)r;  			if (c.Name == "Coalesce") {  				var parms = new ISqlExpression[c.Parameters.Length + 1];  				parms [0] = l;  				c.Parameters.CopyTo (parms' 1);  				return Convert (context' new SqlFunction (t' "Coalesce"' parms));  			}  		}  		return Convert (context' new SqlFunction (t' "Coalesce"' l' r));  	}  	}  	break;  }  case ExpressionType.UnaryPlus:  case ExpressionType.Negate:  case ExpressionType.NegateChecked: {  	var e = (UnaryExpression)expression;  	var o = ConvertToSql (context' e.Operand' false);  	var t = e.Type;  	switch (expression.NodeType) {  	case ExpressionType.UnaryPlus:  		return o;  	case ExpressionType.Negate:  	case ExpressionType.NegateChecked:  		return Convert (context' new SqlBinaryExpression (t' new SqlValue (-1)' "*"' o' Precedence.Multiplicative));  	}  	break;  }  case ExpressionType.Convert:  case ExpressionType.ConvertChecked: {  	var e = (UnaryExpression)expression;  	var o = ConvertToSql (context' e.Operand' false);  	if (e.Method == null && e.IsLifted)  		return o;  	var t = e.Operand.Type;  	var s = SqlDataType.GetDataType (t);  	if (o.SystemType != null && s.Type == typeof(object)) {  		t = o.SystemType;  		s = SqlDataType.GetDataType (t);  	}  	if (e.Type == t || t.IsEnum && Enum.GetUnderlyingType (t) == e.Type || e.Type.IsEnum && Enum.GetUnderlyingType (e.Type) == t)  		return o;  	return Convert (context' new SqlFunction (e.Type' "$Convert$"' SqlDataType.GetDataType (e.Type)' s' o));  }  case ExpressionType.Conditional: {  	var e = (ConditionalExpression)expression;  	var s = ConvertToSql (context' e.Test' false);  	var t = ConvertToSql (context' e.IfTrue' false);  	var f = ConvertToSql (context' e.IfFalse' false);  	if (f is SqlFunction) {  		var c = (SqlFunction)f;  		if (c.Name == "CASE") {  			var parms = new ISqlExpression[c.Parameters.Length + 2];  			parms [0] = s;  			parms [1] = t;  			c.Parameters.CopyTo (parms' 2);  			return Convert (context' new SqlFunction (e.Type' "CASE"' parms));  		}  	}  	return Convert (context' new SqlFunction (e.Type' "CASE"' s' t' f));  }  case ExpressionType.MemberAccess: {  	var ma = (MemberExpression)expression;  	var attr = GetFunctionAttribute (ma.Member);  	if (attr != null)  		return Convert (context' attr.GetExpression (ma.Member));  	var ctx = GetContext (context' expression);  	if (ctx != null) {  		var sql = ctx.ConvertToSql (expression' 0' ConvertFlags.Field);  		switch (sql.Length) {  		case 0:  			break;  		case 1:  			return sql [0].Sql;  		default:  			throw new InvalidOperationException ();  		}  	}  	break;  }  case ExpressionType.Parameter: {  	var ctx = GetContext (context' expression);  	if (ctx != null) {  		var sql = ctx.ConvertToSql (expression' 0' ConvertFlags.Field);  		switch (sql.Length) {  		case 0:  			break;  		case 1:  			return sql [0].Sql;  		default:  			throw new InvalidOperationException ();  		}  	}  	break;  }  case ExpressionType.Call: {  	var e = (MethodCallExpression)expression;  	if (e.IsQueryable ()) {  		if (IsSubQuery (context' e))  			return SubQueryToSql (context' e);  		if (CountBuilder.MethodNames.Concat (AggregationBuilder.MethodNames).Contains (e.Method.Name)) {  			var ctx = GetContext (context' expression);  			if (ctx != null) {  				var sql = ctx.ConvertToSql (expression' 0' ConvertFlags.Field);  				if (sql.Length != 1)  					throw new InvalidOperationException ();  				return sql [0].Sql;  			}  			break;  		}  		return SubQueryToSql (context' e);  	}  	var attr = GetFunctionAttribute (e.Method);  	if (attr != null) {  		var parms = new List<ISqlExpression> ();  		if (e.Object != null)  			parms.Add (ConvertToSql (context' e.Object' false));  		parms.AddRange (e.Arguments.Select (t => ConvertToSql (context' t' false)));  		return Convert (context' attr.GetExpression (e.Method' parms.ToArray ()));  	}  	break;  }  case ExpressionType.Invoke: {  	var pi = (InvocationExpression)expression;  	var ex = pi.Expression;  	if (ex.NodeType == ExpressionType.Quote)  		ex = ((UnaryExpression)ex).Operand;  	if (ex.NodeType == ExpressionType.Lambda) {  		var l = (LambdaExpression)ex;  		var dic = new Dictionary<Expression' Expression> ();  		for (var i = 0; i < l.Parameters.Count; i++)  			dic.Add (l.Parameters [i]' pi.Arguments [i]);  		var pie = l.Body.Convert (wpi => {  			Expression ppi;  			return dic.TryGetValue (wpi' out ppi) ? ppi : wpi;  		});  		return ConvertToSql (context' pie' false);  	}  	break;  }  case ExpressionType.TypeIs: {  	var condition = new SqlQuery.SearchCondition ();  	BuildSearchCondition (context' expression' condition.Conditions);  	return condition;  }  case (ExpressionType)ChangeTypeExpression.ChangeTypeType:  	return ConvertToSql (context' ((ChangeTypeExpression)expression).Expression' false);  }  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following statement contains a magic number: switch (expression.NodeType) {  case ExpressionType.AndAlso:  case ExpressionType.OrElse:  case ExpressionType.Not:  case ExpressionType.Equal:  case ExpressionType.NotEqual:  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual: {  	var condition = new SqlQuery.SearchCondition ();  	BuildSearchCondition (context' expression' condition.Conditions);  	return condition;  }  case ExpressionType.And:  case ExpressionType.Or: {  	if (expression.Type == typeof(bool))  		goto case ExpressionType.AndAlso;  	goto case ExpressionType.Add;  }  case ExpressionType.Add:  case ExpressionType.AddChecked:  case ExpressionType.Divide:  case ExpressionType.ExclusiveOr:  case ExpressionType.Modulo:  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  case ExpressionType.Power:  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked:  case ExpressionType.Coalesce: {  	var e = (BinaryExpression)expression;  	var l = ConvertToSql (context' e.Left' false);  	var r = ConvertToSql (context' e.Right' false);  	var t = e.Type;  	switch (expression.NodeType) {  	case ExpressionType.Add:  	case ExpressionType.AddChecked:  		return Convert (context' new SqlBinaryExpression (t' l' "+"' r' Precedence.Additive));  	case ExpressionType.And:  		return Convert (context' new SqlBinaryExpression (t' l' "&"' r' Precedence.Bitwise));  	case ExpressionType.Divide:  		return Convert (context' new SqlBinaryExpression (t' l' "/"' r' Precedence.Multiplicative));  	case ExpressionType.ExclusiveOr:  		return Convert (context' new SqlBinaryExpression (t' l' "^"' r' Precedence.Bitwise));  	case ExpressionType.Modulo:  		return Convert (context' new SqlBinaryExpression (t' l' "%"' r' Precedence.Multiplicative));  	case ExpressionType.Multiply:  	case ExpressionType.MultiplyChecked:  		return Convert (context' new SqlBinaryExpression (t' l' "*"' r' Precedence.Multiplicative));  	case ExpressionType.Or:  		return Convert (context' new SqlBinaryExpression (t' l' "|"' r' Precedence.Bitwise));  	case ExpressionType.Power:  		return Convert (context' new SqlFunction (t' "Power"' l' r));  	case ExpressionType.Subtract:  	case ExpressionType.SubtractChecked:  		return Convert (context' new SqlBinaryExpression (t' l' "-"' r' Precedence.Subtraction));  	case ExpressionType.Coalesce: {  		if (r is SqlFunction) {  			var c = (SqlFunction)r;  			if (c.Name == "Coalesce") {  				var parms = new ISqlExpression[c.Parameters.Length + 1];  				parms [0] = l;  				c.Parameters.CopyTo (parms' 1);  				return Convert (context' new SqlFunction (t' "Coalesce"' parms));  			}  		}  		return Convert (context' new SqlFunction (t' "Coalesce"' l' r));  	}  	}  	break;  }  case ExpressionType.UnaryPlus:  case ExpressionType.Negate:  case ExpressionType.NegateChecked: {  	var e = (UnaryExpression)expression;  	var o = ConvertToSql (context' e.Operand' false);  	var t = e.Type;  	switch (expression.NodeType) {  	case ExpressionType.UnaryPlus:  		return o;  	case ExpressionType.Negate:  	case ExpressionType.NegateChecked:  		return Convert (context' new SqlBinaryExpression (t' new SqlValue (-1)' "*"' o' Precedence.Multiplicative));  	}  	break;  }  case ExpressionType.Convert:  case ExpressionType.ConvertChecked: {  	var e = (UnaryExpression)expression;  	var o = ConvertToSql (context' e.Operand' false);  	if (e.Method == null && e.IsLifted)  		return o;  	var t = e.Operand.Type;  	var s = SqlDataType.GetDataType (t);  	if (o.SystemType != null && s.Type == typeof(object)) {  		t = o.SystemType;  		s = SqlDataType.GetDataType (t);  	}  	if (e.Type == t || t.IsEnum && Enum.GetUnderlyingType (t) == e.Type || e.Type.IsEnum && Enum.GetUnderlyingType (e.Type) == t)  		return o;  	return Convert (context' new SqlFunction (e.Type' "$Convert$"' SqlDataType.GetDataType (e.Type)' s' o));  }  case ExpressionType.Conditional: {  	var e = (ConditionalExpression)expression;  	var s = ConvertToSql (context' e.Test' false);  	var t = ConvertToSql (context' e.IfTrue' false);  	var f = ConvertToSql (context' e.IfFalse' false);  	if (f is SqlFunction) {  		var c = (SqlFunction)f;  		if (c.Name == "CASE") {  			var parms = new ISqlExpression[c.Parameters.Length + 2];  			parms [0] = s;  			parms [1] = t;  			c.Parameters.CopyTo (parms' 2);  			return Convert (context' new SqlFunction (e.Type' "CASE"' parms));  		}  	}  	return Convert (context' new SqlFunction (e.Type' "CASE"' s' t' f));  }  case ExpressionType.MemberAccess: {  	var ma = (MemberExpression)expression;  	var attr = GetFunctionAttribute (ma.Member);  	if (attr != null)  		return Convert (context' attr.GetExpression (ma.Member));  	var ctx = GetContext (context' expression);  	if (ctx != null) {  		var sql = ctx.ConvertToSql (expression' 0' ConvertFlags.Field);  		switch (sql.Length) {  		case 0:  			break;  		case 1:  			return sql [0].Sql;  		default:  			throw new InvalidOperationException ();  		}  	}  	break;  }  case ExpressionType.Parameter: {  	var ctx = GetContext (context' expression);  	if (ctx != null) {  		var sql = ctx.ConvertToSql (expression' 0' ConvertFlags.Field);  		switch (sql.Length) {  		case 0:  			break;  		case 1:  			return sql [0].Sql;  		default:  			throw new InvalidOperationException ();  		}  	}  	break;  }  case ExpressionType.Call: {  	var e = (MethodCallExpression)expression;  	if (e.IsQueryable ()) {  		if (IsSubQuery (context' e))  			return SubQueryToSql (context' e);  		if (CountBuilder.MethodNames.Concat (AggregationBuilder.MethodNames).Contains (e.Method.Name)) {  			var ctx = GetContext (context' expression);  			if (ctx != null) {  				var sql = ctx.ConvertToSql (expression' 0' ConvertFlags.Field);  				if (sql.Length != 1)  					throw new InvalidOperationException ();  				return sql [0].Sql;  			}  			break;  		}  		return SubQueryToSql (context' e);  	}  	var attr = GetFunctionAttribute (e.Method);  	if (attr != null) {  		var parms = new List<ISqlExpression> ();  		if (e.Object != null)  			parms.Add (ConvertToSql (context' e.Object' false));  		parms.AddRange (e.Arguments.Select (t => ConvertToSql (context' t' false)));  		return Convert (context' attr.GetExpression (e.Method' parms.ToArray ()));  	}  	break;  }  case ExpressionType.Invoke: {  	var pi = (InvocationExpression)expression;  	var ex = pi.Expression;  	if (ex.NodeType == ExpressionType.Quote)  		ex = ((UnaryExpression)ex).Operand;  	if (ex.NodeType == ExpressionType.Lambda) {  		var l = (LambdaExpression)ex;  		var dic = new Dictionary<Expression' Expression> ();  		for (var i = 0; i < l.Parameters.Count; i++)  			dic.Add (l.Parameters [i]' pi.Arguments [i]);  		var pie = l.Body.Convert (wpi => {  			Expression ppi;  			return dic.TryGetValue (wpi' out ppi) ? ppi : wpi;  		});  		return ConvertToSql (context' pie' false);  	}  	break;  }  case ExpressionType.TypeIs: {  	var condition = new SqlQuery.SearchCondition ();  	BuildSearchCondition (context' expression' condition.Conditions);  	return condition;  }  case (ExpressionType)ChangeTypeExpression.ChangeTypeType:  	return ConvertToSql (context' ((ChangeTypeExpression)expression).Expression' false);  }  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following statement contains a magic number: if (f is SqlFunction) {  	var c = (SqlFunction)f;  	if (c.Name == "CASE") {  		var parms = new ISqlExpression[c.Parameters.Length + 2];  		parms [0] = s;  		parms [1] = t;  		c.Parameters.CopyTo (parms' 2);  		return Convert (context' new SqlFunction (e.Type' "CASE"' parms));  	}  }  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following statement contains a magic number: if (f is SqlFunction) {  	var c = (SqlFunction)f;  	if (c.Name == "CASE") {  		var parms = new ISqlExpression[c.Parameters.Length + 2];  		parms [0] = s;  		parms [1] = t;  		c.Parameters.CopyTo (parms' 2);  		return Convert (context' new SqlFunction (e.Type' "CASE"' parms));  	}  }  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following statement contains a magic number: if (c.Name == "CASE") {  	var parms = new ISqlExpression[c.Parameters.Length + 2];  	parms [0] = s;  	parms [1] = t;  	c.Parameters.CopyTo (parms' 2);  	return Convert (context' new SqlFunction (e.Type' "CASE"' parms));  }  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following statement contains a magic number: if (c.Name == "CASE") {  	var parms = new ISqlExpression[c.Parameters.Length + 2];  	parms [0] = s;  	parms [1] = t;  	c.Parameters.CopyTo (parms' 2);  	return Convert (context' new SqlFunction (e.Type' "CASE"' parms));  }  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following statement contains a magic number: c.Parameters.CopyTo (parms' 2);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: switch (expression.NodeType) {  case ExpressionType.Equal:  case ExpressionType.NotEqual:  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual: {  	var e = (BinaryExpression)expression;  	return ConvertCompare (context' expression.NodeType' e.Left' e.Right);  }  case ExpressionType.Call: {  	var e = (MethodCallExpression)expression;  	ISqlPredicate predicate = null;  	if (e.Method.Name == "Equals" && e.Object != null && e.Arguments.Count == 1)  		return ConvertCompare (context' ExpressionType.Equal' e.Object' e.Arguments [0]);  	if (e.Method.DeclaringType == typeof(string)) {  		switch (e.Method.Name) {  		case "Contains":  			predicate = ConvertLikePredicate (context' e' "%"' "%");  			break;  		case "StartsWith":  			predicate = ConvertLikePredicate (context' e' ""' "%");  			break;  		case "EndsWith":  			predicate = ConvertLikePredicate (context' e' "%"' "");  			break;  		}  	} else if (e.Method.Name == "Contains") {  		if (e.Method.DeclaringType == typeof(Enumerable) || TypeHelper.IsSameOrParent (typeof(IList)' e.Method.DeclaringType) || TypeHelper.IsSameOrParent (typeof(ICollection<>)' e.Method.DeclaringType)) {  			predicate = ConvertInPredicate (context' e);  		}  	} else if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent (typeof(Dictionary<' >)' e.Method.DeclaringType)) {  		var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(Dictionary<' >));  		var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [1]);  		var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Values")' e.Arguments [0]);  		predicate = ConvertInPredicate (context' expr);  	} else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent (typeof(IDictionary<' >)' e.Method.DeclaringType)) {  		var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(IDictionary<' >));  		var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [0]);  		var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Keys")' e.Arguments [0]);  		predicate = ConvertInPredicate (context' expr);  	}   	#if !SILVERLIGHT  	else if (e.Method == ReflectionHelper.Functions.String.Like11)  		predicate = ConvertLikePredicate (context' e);  	else if (e.Method == ReflectionHelper.Functions.String.Like12)  		predicate = ConvertLikePredicate (context' e);  	#endif  	else if (e.Method == ReflectionHelper.Functions.String.Like21)  		predicate = ConvertLikePredicate (context' e);  	else if (e.Method == ReflectionHelper.Functions.String.Like22)  		predicate = ConvertLikePredicate (context' e);  	if (predicate != null)  		return Convert (context' predicate);  	break;  }  case ExpressionType.Conditional:  	return Convert (context' new SqlQuery.Predicate.ExprExpr (ConvertToSql (context' expression' false)' SqlQuery.Predicate.Operator.Equal' new SqlValue (true)));  case ExpressionType.MemberAccess: {  	var e = (MemberExpression)expression;  	if (e.Member.Name == "HasValue" && e.Member.DeclaringType.IsGenericType && e.Member.DeclaringType.GetGenericTypeDefinition () == typeof(Nullable<>)) {  		var expr = ConvertToSql (context' e.Expression' false);  		return Convert (context' new SqlQuery.Predicate.IsNull (expr' true));  	}  	break;  }  case ExpressionType.TypeIs: {  	var e = (TypeBinaryExpression)expression;  	var ctx = GetContext (context' e.Expression);  	if (ctx != null && ctx.IsExpression (e.Expression' 0' RequestFor.Table).Result)  		return MakeIsPredicate (ctx' e);  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: switch (expression.NodeType) {  case ExpressionType.Equal:  case ExpressionType.NotEqual:  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual: {  	var e = (BinaryExpression)expression;  	return ConvertCompare (context' expression.NodeType' e.Left' e.Right);  }  case ExpressionType.Call: {  	var e = (MethodCallExpression)expression;  	ISqlPredicate predicate = null;  	if (e.Method.Name == "Equals" && e.Object != null && e.Arguments.Count == 1)  		return ConvertCompare (context' ExpressionType.Equal' e.Object' e.Arguments [0]);  	if (e.Method.DeclaringType == typeof(string)) {  		switch (e.Method.Name) {  		case "Contains":  			predicate = ConvertLikePredicate (context' e' "%"' "%");  			break;  		case "StartsWith":  			predicate = ConvertLikePredicate (context' e' ""' "%");  			break;  		case "EndsWith":  			predicate = ConvertLikePredicate (context' e' "%"' "");  			break;  		}  	} else if (e.Method.Name == "Contains") {  		if (e.Method.DeclaringType == typeof(Enumerable) || TypeHelper.IsSameOrParent (typeof(IList)' e.Method.DeclaringType) || TypeHelper.IsSameOrParent (typeof(ICollection<>)' e.Method.DeclaringType)) {  			predicate = ConvertInPredicate (context' e);  		}  	} else if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent (typeof(Dictionary<' >)' e.Method.DeclaringType)) {  		var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(Dictionary<' >));  		var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [1]);  		var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Values")' e.Arguments [0]);  		predicate = ConvertInPredicate (context' expr);  	} else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent (typeof(IDictionary<' >)' e.Method.DeclaringType)) {  		var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(IDictionary<' >));  		var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [0]);  		var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Keys")' e.Arguments [0]);  		predicate = ConvertInPredicate (context' expr);  	}   	#if !SILVERLIGHT  	else if (e.Method == ReflectionHelper.Functions.String.Like11)  		predicate = ConvertLikePredicate (context' e);  	else if (e.Method == ReflectionHelper.Functions.String.Like12)  		predicate = ConvertLikePredicate (context' e);  	#endif  	else if (e.Method == ReflectionHelper.Functions.String.Like21)  		predicate = ConvertLikePredicate (context' e);  	else if (e.Method == ReflectionHelper.Functions.String.Like22)  		predicate = ConvertLikePredicate (context' e);  	if (predicate != null)  		return Convert (context' predicate);  	break;  }  case ExpressionType.Conditional:  	return Convert (context' new SqlQuery.Predicate.ExprExpr (ConvertToSql (context' expression' false)' SqlQuery.Predicate.Operator.Equal' new SqlValue (true)));  case ExpressionType.MemberAccess: {  	var e = (MemberExpression)expression;  	if (e.Member.Name == "HasValue" && e.Member.DeclaringType.IsGenericType && e.Member.DeclaringType.GetGenericTypeDefinition () == typeof(Nullable<>)) {  		var expr = ConvertToSql (context' e.Expression' false);  		return Convert (context' new SqlQuery.Predicate.IsNull (expr' true));  	}  	break;  }  case ExpressionType.TypeIs: {  	var e = (TypeBinaryExpression)expression;  	var ctx = GetContext (context' e.Expression);  	if (ctx != null && ctx.IsExpression (e.Expression' 0' RequestFor.Table).Result)  		return MakeIsPredicate (ctx' e);  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: if (e.Method.DeclaringType == typeof(string)) {  	switch (e.Method.Name) {  	case "Contains":  		predicate = ConvertLikePredicate (context' e' "%"' "%");  		break;  	case "StartsWith":  		predicate = ConvertLikePredicate (context' e' ""' "%");  		break;  	case "EndsWith":  		predicate = ConvertLikePredicate (context' e' "%"' "");  		break;  	}  } else if (e.Method.Name == "Contains") {  	if (e.Method.DeclaringType == typeof(Enumerable) || TypeHelper.IsSameOrParent (typeof(IList)' e.Method.DeclaringType) || TypeHelper.IsSameOrParent (typeof(ICollection<>)' e.Method.DeclaringType)) {  		predicate = ConvertInPredicate (context' e);  	}  } else if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent (typeof(Dictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(Dictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [1]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Values")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  } else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent (typeof(IDictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(IDictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [0]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Keys")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  }   #if !SILVERLIGHT  else if (e.Method == ReflectionHelper.Functions.String.Like11)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like12)  	predicate = ConvertLikePredicate (context' e);  #endif  else if (e.Method == ReflectionHelper.Functions.String.Like21)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like22)  	predicate = ConvertLikePredicate (context' e);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: if (e.Method.DeclaringType == typeof(string)) {  	switch (e.Method.Name) {  	case "Contains":  		predicate = ConvertLikePredicate (context' e' "%"' "%");  		break;  	case "StartsWith":  		predicate = ConvertLikePredicate (context' e' ""' "%");  		break;  	case "EndsWith":  		predicate = ConvertLikePredicate (context' e' "%"' "");  		break;  	}  } else if (e.Method.Name == "Contains") {  	if (e.Method.DeclaringType == typeof(Enumerable) || TypeHelper.IsSameOrParent (typeof(IList)' e.Method.DeclaringType) || TypeHelper.IsSameOrParent (typeof(ICollection<>)' e.Method.DeclaringType)) {  		predicate = ConvertInPredicate (context' e);  	}  } else if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent (typeof(Dictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(Dictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [1]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Values")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  } else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent (typeof(IDictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(IDictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [0]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Keys")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  }   #if !SILVERLIGHT  else if (e.Method == ReflectionHelper.Functions.String.Like11)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like12)  	predicate = ConvertLikePredicate (context' e);  #endif  else if (e.Method == ReflectionHelper.Functions.String.Like21)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like22)  	predicate = ConvertLikePredicate (context' e);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: if (e.Method.Name == "Contains") {  	if (e.Method.DeclaringType == typeof(Enumerable) || TypeHelper.IsSameOrParent (typeof(IList)' e.Method.DeclaringType) || TypeHelper.IsSameOrParent (typeof(ICollection<>)' e.Method.DeclaringType)) {  		predicate = ConvertInPredicate (context' e);  	}  } else if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent (typeof(Dictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(Dictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [1]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Values")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  } else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent (typeof(IDictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(IDictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [0]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Keys")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  }   #if !SILVERLIGHT  else if (e.Method == ReflectionHelper.Functions.String.Like11)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like12)  	predicate = ConvertLikePredicate (context' e);  #endif  else if (e.Method == ReflectionHelper.Functions.String.Like21)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like22)  	predicate = ConvertLikePredicate (context' e);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: if (e.Method.Name == "Contains") {  	if (e.Method.DeclaringType == typeof(Enumerable) || TypeHelper.IsSameOrParent (typeof(IList)' e.Method.DeclaringType) || TypeHelper.IsSameOrParent (typeof(ICollection<>)' e.Method.DeclaringType)) {  		predicate = ConvertInPredicate (context' e);  	}  } else if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent (typeof(Dictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(Dictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [1]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Values")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  } else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent (typeof(IDictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(IDictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [0]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Keys")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  }   #if !SILVERLIGHT  else if (e.Method == ReflectionHelper.Functions.String.Like11)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like12)  	predicate = ConvertLikePredicate (context' e);  #endif  else if (e.Method == ReflectionHelper.Functions.String.Like21)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like22)  	predicate = ConvertLikePredicate (context' e);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent (typeof(Dictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(Dictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [1]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Values")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  } else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent (typeof(IDictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(IDictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [0]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Keys")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  }   #if !SILVERLIGHT  else if (e.Method == ReflectionHelper.Functions.String.Like11)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like12)  	predicate = ConvertLikePredicate (context' e);  #endif  else if (e.Method == ReflectionHelper.Functions.String.Like21)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like22)  	predicate = ConvertLikePredicate (context' e);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent (typeof(Dictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(Dictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [1]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Values")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  } else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent (typeof(IDictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(IDictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [0]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Keys")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  }   #if !SILVERLIGHT  else if (e.Method == ReflectionHelper.Functions.String.Like11)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like12)  	predicate = ConvertLikePredicate (context' e);  #endif  else if (e.Method == ReflectionHelper.Functions.String.Like21)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like22)  	predicate = ConvertLikePredicate (context' e);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following statement contains a magic number: if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent (typeof(IDictionary<' >)' e.Method.DeclaringType)) {  	var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(IDictionary<' >));  	var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [0]);  	var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Keys")' e.Arguments [0]);  	predicate = ConvertInPredicate (context' expr);  }   #if !SILVERLIGHT  else if (e.Method == ReflectionHelper.Functions.String.Like11)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like12)  	predicate = ConvertLikePredicate (context' e);  #endif  else if (e.Method == ReflectionHelper.Functions.String.Like21)  	predicate = ConvertLikePredicate (context' e);  else if (e.Method == ReflectionHelper.Functions.String.Like22)  	predicate = ConvertLikePredicate (context' e);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertLikePredicate,The following statement contains a magic number: if (e.Arguments.Count == 3)  	a3 = ConvertToSql (context' e.Arguments [2]' false);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertLikePredicate,The following statement contains a magic number: if (e.Arguments.Count == 3)  	a3 = ConvertToSql (context' e.Arguments [2]' false);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertLikePredicate,The following statement contains a magic number: a3 = ConvertToSql (context' e.Arguments [2]' false);  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ProcessProjection,The following statement contains a magic number: switch (expression.NodeType) {  // new { ... }  //  case ExpressionType.New: {  	var expr = (NewExpression)expression;  	// ReSharper disable ConditionIsAlwaysTrueOrFalse  	// ReSharper disable HeuristicUnreachableCode  	if (expr.Members == null)  		return false;  	// ReSharper restore HeuristicUnreachableCode  	// ReSharper restore ConditionIsAlwaysTrueOrFalse  	for (var i = 0; i < expr.Members.Count; i++) {  		var member = expr.Members [i];  		members.Add (member' expr.Arguments [i]);  		if (member is MethodInfo)  			members.Add (TypeHelper.GetPropertyByMethod ((MethodInfo)member)' expr.Arguments [i]);  	}  	return true;  }  // new MyObject { ... }  //  case ExpressionType.MemberInit: {  	var expr = (MemberInitExpression)expression;  	var dic = TypeAccessor.GetAccessor (expr.Type).Select ((m' i) => new {  		m'  		i  	}).ToDictionary (_ => _.m.MemberInfo.Name' _ => _.i);  	foreach (var binding in expr.Bindings.Cast<MemberAssignment> ().OrderBy (b => dic.ContainsKey (b.Member.Name) ? dic [b.Member.Name] : 1000000)) {  		members.Add (binding.Member' binding.Expression);  		if (binding.Member is MethodInfo)  			members.Add (TypeHelper.GetPropertyByMethod ((MethodInfo)binding.Member)' binding.Expression);  	}  	return true;  }  // .Select(p => everything else)  //  default:  	return false;  }  
Magic Number,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ProcessProjection,The following statement contains a magic number: foreach (var binding in expr.Bindings.Cast<MemberAssignment> ().OrderBy (b => dic.ContainsKey (b.Member.Name) ? dic [b.Member.Name] : 1000000)) {  	members.Add (binding.Member' binding.Expression);  	if (binding.Member is MethodInfo)  		members.Add (TypeHelper.GetPropertyByMethod ((MethodInfo)binding.Member)' binding.Expression);  }  
Magic Number,BLToolkit.Data.Linq.Builder,FirstSingleBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (!buildInfo.IsSubQuery || builder.SqlProvider.IsSubQueryTakeSupported)  	switch (methodCall.Method.Name) {  	case "First":  	case "FirstOrDefault":  		take = 1;  		break;  	case "Single":  	case "SingleOrDefault":  		if (!buildInfo.IsSubQuery)  			take = 2;  		break;  	}  
Magic Number,BLToolkit.Data.Linq.Builder,FirstSingleBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,BuildMethodCall,The following statement contains a magic number: switch (methodCall.Method.Name) {  case "First":  case "FirstOrDefault":  	take = 1;  	break;  case "Single":  case "SingleOrDefault":  	if (!buildInfo.IsSubQuery)  		take = 2;  	break;  }  
Magic Number,BLToolkit.Data.Linq.Builder,FirstSingleBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,BuildMethodCall,The following statement contains a magic number: if (!buildInfo.IsSubQuery)  	take = 2;  
Magic Number,BLToolkit.Data.Linq.Builder,FirstSingleBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,BuildMethodCall,The following statement contains a magic number: take = 2;  
Magic Number,BLToolkit.Data.Linq.Builder,FirstSingleBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,Convert,The following statement contains a magic number: if (methodCall.Arguments.Count == 2) {  	var predicate = (LambdaExpression)ExpressionBuilder.GetPredicate (methodCall.Arguments [1]);  	var info = builder.ConvertSequence (new BuildInfo (buildInfo' methodCall.Arguments [0])' predicate.Parameters [0]);  	if (info != null) {  		info.Expression = methodCall.Convert (ex => ConvertMethod (methodCall' 0' info' predicate.Parameters [0]' ex));  		info.Parameter = param;  		return info;  	}  } else {  	var info = builder.ConvertSequence (new BuildInfo (buildInfo' methodCall.Arguments [0])' null);  	if (info != null) {  		info.Expression = methodCall.Convert (ex => ConvertMethod (methodCall' 0' info' null' ex));  		info.Parameter = param;  		return info;  	}  }  
Magic Number,BLToolkit.Data.Linq.Builder,JoinBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\JoinBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: if (!methodCall.IsQueryable ("Join"' "GroupJoin") || methodCall.Arguments.Count != 5)  	return false;  
Magic Number,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ProcessMemberAccess,The following statement contains a magic number: switch (memberExpression.NodeType) {  case ExpressionType.MemberAccess:  case ExpressionType.Parameter:  	if (sequence != null)  		return action (2' sequence' newExpression' nextLevel' memberExpression);  	break;  //throw new InvalidOperationException();  case ExpressionType.New:  case ExpressionType.MemberInit: {  	var mmExpresion = GetMemberExpression (memberExpression' expression' level + 1);  	return action (3' this' mmExpresion' 0' memberExpression);  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ProcessMemberAccess,The following statement contains a magic number: switch (memberExpression.NodeType) {  case ExpressionType.MemberAccess:  case ExpressionType.Parameter:  	if (sequence != null)  		return action (2' sequence' newExpression' nextLevel' memberExpression);  	break;  //throw new InvalidOperationException();  case ExpressionType.New:  case ExpressionType.MemberInit: {  	var mmExpresion = GetMemberExpression (memberExpression' expression' level + 1);  	return action (3' this' mmExpresion' 0' memberExpression);  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ProcessMemberAccess,The following statement contains a magic number: if (sequence != null)  	return action (2' sequence' newExpression' nextLevel' memberExpression);  
Magic Number,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ProcessMemberAccess,The following statement contains a magic number: return action (2' sequence' newExpression' nextLevel' memberExpression);  
Magic Number,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ProcessMemberAccess,The following statement contains a magic number: return action (3' this' mmExpresion' 0' memberExpression);  
Magic Number,BLToolkit.Data.Linq.Builder,SelectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: if (methodCall.IsQueryable ("Select")) {  	switch (((LambdaExpression)methodCall.Arguments [1].Unwrap ()).Parameters.Count) {  	case 1:  	case 2:  		return true;  	default:  		break;  	}  }  
Magic Number,BLToolkit.Data.Linq.Builder,SelectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,CanBuildMethodCall,The following statement contains a magic number: switch (((LambdaExpression)methodCall.Arguments [1].Unwrap ()).Parameters.Count) {  case 1:  case 2:  	return true;  default:  	break;  }  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: switch (expression.NodeType) {  case ExpressionType.Constant: {  	var c = (ConstantExpression)expression;  	if (c.Value is IQueryable)  		return action (1' null);  	break;  }  case ExpressionType.Call: {  	var mc = (MethodCallExpression)expression;  	if (mc.Method.Name == "GetTable")  		if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  			return action (2' null);  	var attr = builder.GetTableFunctionAttribute (mc.Method);  	if (attr != null)  		return action (5' null);  	break;  }  case ExpressionType.MemberAccess:  	if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  		return action (3' null);  	// Looking for association.  	//  	if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  		var ctx = builder.GetContext (buildInfo.Parent' expression);  		if (ctx != null)  			return action (4' ctx);  	}  	break;  case ExpressionType.Parameter: {  	if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  		var ctx = builder.GetContext (buildInfo.Parent' expression);  		if (ctx != null)  			return action (4' ctx);  	}  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: switch (expression.NodeType) {  case ExpressionType.Constant: {  	var c = (ConstantExpression)expression;  	if (c.Value is IQueryable)  		return action (1' null);  	break;  }  case ExpressionType.Call: {  	var mc = (MethodCallExpression)expression;  	if (mc.Method.Name == "GetTable")  		if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  			return action (2' null);  	var attr = builder.GetTableFunctionAttribute (mc.Method);  	if (attr != null)  		return action (5' null);  	break;  }  case ExpressionType.MemberAccess:  	if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  		return action (3' null);  	// Looking for association.  	//  	if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  		var ctx = builder.GetContext (buildInfo.Parent' expression);  		if (ctx != null)  			return action (4' ctx);  	}  	break;  case ExpressionType.Parameter: {  	if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  		var ctx = builder.GetContext (buildInfo.Parent' expression);  		if (ctx != null)  			return action (4' ctx);  	}  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: switch (expression.NodeType) {  case ExpressionType.Constant: {  	var c = (ConstantExpression)expression;  	if (c.Value is IQueryable)  		return action (1' null);  	break;  }  case ExpressionType.Call: {  	var mc = (MethodCallExpression)expression;  	if (mc.Method.Name == "GetTable")  		if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  			return action (2' null);  	var attr = builder.GetTableFunctionAttribute (mc.Method);  	if (attr != null)  		return action (5' null);  	break;  }  case ExpressionType.MemberAccess:  	if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  		return action (3' null);  	// Looking for association.  	//  	if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  		var ctx = builder.GetContext (buildInfo.Parent' expression);  		if (ctx != null)  			return action (4' ctx);  	}  	break;  case ExpressionType.Parameter: {  	if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  		var ctx = builder.GetContext (buildInfo.Parent' expression);  		if (ctx != null)  			return action (4' ctx);  	}  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: switch (expression.NodeType) {  case ExpressionType.Constant: {  	var c = (ConstantExpression)expression;  	if (c.Value is IQueryable)  		return action (1' null);  	break;  }  case ExpressionType.Call: {  	var mc = (MethodCallExpression)expression;  	if (mc.Method.Name == "GetTable")  		if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  			return action (2' null);  	var attr = builder.GetTableFunctionAttribute (mc.Method);  	if (attr != null)  		return action (5' null);  	break;  }  case ExpressionType.MemberAccess:  	if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  		return action (3' null);  	// Looking for association.  	//  	if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  		var ctx = builder.GetContext (buildInfo.Parent' expression);  		if (ctx != null)  			return action (4' ctx);  	}  	break;  case ExpressionType.Parameter: {  	if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  		var ctx = builder.GetContext (buildInfo.Parent' expression);  		if (ctx != null)  			return action (4' ctx);  	}  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: switch (expression.NodeType) {  case ExpressionType.Constant: {  	var c = (ConstantExpression)expression;  	if (c.Value is IQueryable)  		return action (1' null);  	break;  }  case ExpressionType.Call: {  	var mc = (MethodCallExpression)expression;  	if (mc.Method.Name == "GetTable")  		if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  			return action (2' null);  	var attr = builder.GetTableFunctionAttribute (mc.Method);  	if (attr != null)  		return action (5' null);  	break;  }  case ExpressionType.MemberAccess:  	if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  		return action (3' null);  	// Looking for association.  	//  	if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  		var ctx = builder.GetContext (buildInfo.Parent' expression);  		if (ctx != null)  			return action (4' ctx);  	}  	break;  case ExpressionType.Parameter: {  	if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  		var ctx = builder.GetContext (buildInfo.Parent' expression);  		if (ctx != null)  			return action (4' ctx);  	}  	break;  }  }  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: if (mc.Method.Name == "GetTable")  	if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  		return action (2' null);  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  	return action (2' null);  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: return action (2' null);  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: if (attr != null)  	return action (5' null);  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: return action (5' null);  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  	return action (3' null);  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: return action (3' null);  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  	var ctx = builder.GetContext (buildInfo.Parent' expression);  	if (ctx != null)  		return action (4' ctx);  }  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: if (ctx != null)  	return action (4' ctx);  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: return action (4' ctx);  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  	var ctx = builder.GetContext (buildInfo.Parent' expression);  	if (ctx != null)  		return action (4' ctx);  }  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: if (ctx != null)  	return action (4' ctx);  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following statement contains a magic number: return action (4' ctx);  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following statement contains a magic number: return Find (builder' buildInfo' (n' ctx) => {  	switch (n) {  	case 0:  		return null;  	case 1:  		return new TableContext (builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  	case 2:  	case 3:  		return new TableContext (builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments () [0]);  	case 4:  		return ctx.GetContext (buildInfo.Expression' 0' buildInfo);  	case 5:  		return new TableContext (builder' buildInfo);  	}  	throw new InvalidOperationException ();  });  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following statement contains a magic number: return Find (builder' buildInfo' (n' ctx) => {  	switch (n) {  	case 0:  		return null;  	case 1:  		return new TableContext (builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  	case 2:  	case 3:  		return new TableContext (builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments () [0]);  	case 4:  		return ctx.GetContext (buildInfo.Expression' 0' buildInfo);  	case 5:  		return new TableContext (builder' buildInfo);  	}  	throw new InvalidOperationException ();  });  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following statement contains a magic number: return Find (builder' buildInfo' (n' ctx) => {  	switch (n) {  	case 0:  		return null;  	case 1:  		return new TableContext (builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  	case 2:  	case 3:  		return new TableContext (builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments () [0]);  	case 4:  		return ctx.GetContext (buildInfo.Expression' 0' buildInfo);  	case 5:  		return new TableContext (builder' buildInfo);  	}  	throw new InvalidOperationException ();  });  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following statement contains a magic number: return Find (builder' buildInfo' (n' ctx) => {  	switch (n) {  	case 0:  		return null;  	case 1:  		return new TableContext (builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  	case 2:  	case 3:  		return new TableContext (builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments () [0]);  	case 4:  		return ctx.GetContext (buildInfo.Expression' 0' buildInfo);  	case 5:  		return new TableContext (builder' buildInfo);  	}  	throw new InvalidOperationException ();  });  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following statement contains a magic number: switch (n) {  case 0:  	return null;  case 1:  	return new TableContext (builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  case 2:  case 3:  	return new TableContext (builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments () [0]);  case 4:  	return ctx.GetContext (buildInfo.Expression' 0' buildInfo);  case 5:  	return new TableContext (builder' buildInfo);  }  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following statement contains a magic number: switch (n) {  case 0:  	return null;  case 1:  	return new TableContext (builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  case 2:  case 3:  	return new TableContext (builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments () [0]);  case 4:  	return ctx.GetContext (buildInfo.Expression' 0' buildInfo);  case 5:  	return new TableContext (builder' buildInfo);  }  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following statement contains a magic number: switch (n) {  case 0:  	return null;  case 1:  	return new TableContext (builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  case 2:  case 3:  	return new TableContext (builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments () [0]);  case 4:  	return ctx.GetContext (buildInfo.Expression' 0' buildInfo);  case 5:  	return new TableContext (builder' buildInfo);  }  
Magic Number,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following statement contains a magic number: switch (n) {  case 0:  	return null;  case 1:  	return new TableContext (builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  case 2:  case 3:  	return new TableContext (builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments () [0]);  case 4:  	return ctx.GetContext (buildInfo.Expression' 0' buildInfo);  case 5:  	return new TableContext (builder' buildInfo);  }  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DateAdd,The following statement contains a magic number: switch (part) {  case DateParts.Year:  	return date.Value.AddYears ((int)number);  case DateParts.Quarter:  	return date.Value.AddMonths ((int)number * 3);  case DateParts.Month:  	return date.Value.AddMonths ((int)number);  case DateParts.DayOfYear:  	return date.Value.AddDays (number.Value);  case DateParts.Day:  	return date.Value.AddDays (number.Value);  case DateParts.Week:  	return date.Value.AddDays (number.Value * 7);  case DateParts.WeekDay:  	return date.Value.AddDays (number.Value);  case DateParts.Hour:  	return date.Value.AddHours (number.Value);  case DateParts.Minute:  	return date.Value.AddMinutes (number.Value);  case DateParts.Second:  	return date.Value.AddSeconds (number.Value);  case DateParts.Millisecond:  	return date.Value.AddMilliseconds (number.Value);  }  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DateAdd,The following statement contains a magic number: switch (part) {  case DateParts.Year:  	return date.Value.AddYears ((int)number);  case DateParts.Quarter:  	return date.Value.AddMonths ((int)number * 3);  case DateParts.Month:  	return date.Value.AddMonths ((int)number);  case DateParts.DayOfYear:  	return date.Value.AddDays (number.Value);  case DateParts.Day:  	return date.Value.AddDays (number.Value);  case DateParts.Week:  	return date.Value.AddDays (number.Value * 7);  case DateParts.WeekDay:  	return date.Value.AddDays (number.Value);  case DateParts.Hour:  	return date.Value.AddHours (number.Value);  case DateParts.Minute:  	return date.Value.AddMinutes (number.Value);  case DateParts.Second:  	return date.Value.AddSeconds (number.Value);  case DateParts.Millisecond:  	return date.Value.AddMilliseconds (number.Value);  }  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DateAdd,The following statement contains a magic number: return date.Value.AddMonths ((int)number * 3);  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DateAdd,The following statement contains a magic number: return date.Value.AddDays (number.Value * 7);  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,The following statement contains a magic number: switch (part) {  case DateParts.Year:  	return date.Value.Year;  case DateParts.Quarter:  	return (date.Value.Month - 1) / 3 + 1;  case DateParts.Month:  	return date.Value.Month;  case DateParts.DayOfYear:  	return date.Value.DayOfYear;  case DateParts.Day:  	return date.Value.Day;  case DateParts.Week:  	return CultureInfo.CurrentCulture.Calendar.GetWeekOfYear (date.Value' CalendarWeekRule.FirstDay' DayOfWeek.Sunday);  case DateParts.WeekDay:  	return ((int)date.Value.DayOfWeek + 1 + DateFirst + 6) % 7 + 1;  case DateParts.Hour:  	return date.Value.Hour;  case DateParts.Minute:  	return date.Value.Minute;  case DateParts.Second:  	return date.Value.Second;  case DateParts.Millisecond:  	return date.Value.Millisecond;  }  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,The following statement contains a magic number: switch (part) {  case DateParts.Year:  	return date.Value.Year;  case DateParts.Quarter:  	return (date.Value.Month - 1) / 3 + 1;  case DateParts.Month:  	return date.Value.Month;  case DateParts.DayOfYear:  	return date.Value.DayOfYear;  case DateParts.Day:  	return date.Value.Day;  case DateParts.Week:  	return CultureInfo.CurrentCulture.Calendar.GetWeekOfYear (date.Value' CalendarWeekRule.FirstDay' DayOfWeek.Sunday);  case DateParts.WeekDay:  	return ((int)date.Value.DayOfWeek + 1 + DateFirst + 6) % 7 + 1;  case DateParts.Hour:  	return date.Value.Hour;  case DateParts.Minute:  	return date.Value.Minute;  case DateParts.Second:  	return date.Value.Second;  case DateParts.Millisecond:  	return date.Value.Millisecond;  }  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,The following statement contains a magic number: switch (part) {  case DateParts.Year:  	return date.Value.Year;  case DateParts.Quarter:  	return (date.Value.Month - 1) / 3 + 1;  case DateParts.Month:  	return date.Value.Month;  case DateParts.DayOfYear:  	return date.Value.DayOfYear;  case DateParts.Day:  	return date.Value.Day;  case DateParts.Week:  	return CultureInfo.CurrentCulture.Calendar.GetWeekOfYear (date.Value' CalendarWeekRule.FirstDay' DayOfWeek.Sunday);  case DateParts.WeekDay:  	return ((int)date.Value.DayOfWeek + 1 + DateFirst + 6) % 7 + 1;  case DateParts.Hour:  	return date.Value.Hour;  case DateParts.Minute:  	return date.Value.Minute;  case DateParts.Second:  	return date.Value.Second;  case DateParts.Millisecond:  	return date.Value.Millisecond;  }  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,The following statement contains a magic number: return (date.Value.Month - 1) / 3 + 1;  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,The following statement contains a magic number: return ((int)date.Value.DayOfWeek + 1 + DateFirst + 6) % 7 + 1;  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,The following statement contains a magic number: return ((int)date.Value.DayOfWeek + 1 + DateFirst + 6) % 7 + 1;  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Degrees,The following statement contains a magic number: return value == null ? null : (Double?)(value * 180 / Math.PI);  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Degrees,The following statement contains a magic number: return value == null ? null : (Int16?)(value * 180 / Math.PI);  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Degrees,The following statement contains a magic number: return value == null ? null : (Int32?)(value * 180 / Math.PI);  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Degrees,The following statement contains a magic number: return value == null ? null : (Int64?)(value * 180 / Math.PI);  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Degrees,The following statement contains a magic number: return value == null ? null : (SByte?)(value * 180 / Math.PI);  
Magic Number,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,Degrees,The following statement contains a magic number: return value == null ? null : (Single?)(value * 180 / Math.PI);  
Magic Number,BLToolkit.Data.Linq,Expressions,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Expressions.cs,DateAdd,The following statement contains a magic number: return days == null ? null : Sql.DateAdd (part' number' new DateTime (1900' 1' days.Value + 1));  
Magic Number,BLToolkit.Data.Linq,Query,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Query.cs,SetNonQueryQuery2,The following statement contains a magic number: if (Queries.Count != 2)  	throw new InvalidOperationException ();  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  	case TypeCode.DateTime:  		if (func.Name == "Convert") {  			var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  			if (IsTimeDataType (func.Parameters [0])) {  				if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  					return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  			}  			if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  				if (IsDateDataType (func.Parameters [0]' "Datetime"))  					return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  			}  			if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  				return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  	case TypeCode.DateTime:  		if (func.Name == "Convert") {  			var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  			if (IsTimeDataType (func.Parameters [0])) {  				if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  					return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  			}  			if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  				if (IsDateDataType (func.Parameters [0]' "Datetime"))  					return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  			}  			if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  				return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  case TypeCode.DateTime:  	if (func.Name == "Convert") {  		var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  		if (IsTimeDataType (func.Parameters [0])) {  			if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  				return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  		}  		if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Datetime"))  				return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  		}  		if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  case TypeCode.DateTime:  	if (func.Name == "Convert") {  		var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  		if (IsTimeDataType (func.Parameters [0])) {  			if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  				return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  		}  		if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Datetime"))  				return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  		}  		if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Name == "Convert") {  	var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  	if (IsTimeDataType (func.Parameters [0])) {  		if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  			return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  		if (func.Parameters [1].SystemType == typeof(string))  			return func.Parameters [1];  		return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  	}  	if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  		if (IsDateDataType (func.Parameters [0]' "Datetime"))  			return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  	}  	if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  		return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Name == "Convert") {  	var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  	if (IsTimeDataType (func.Parameters [0])) {  		if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  			return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  		if (func.Parameters [1].SystemType == typeof(string))  			return func.Parameters [1];  		return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  	}  	if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  		if (IsDateDataType (func.Parameters [0]' "Datetime"))  			return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  	}  	if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  		return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  	return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  	return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,BuildFunction,The following statement contains a magic number: switch (func.Name) {  case "CASE":  	func = ConvertCase (func.SystemType' func.Parameters' 0);  	break;  case "Coalesce":  	if (func.Parameters.Length > 2) {  		var parms = new ISqlExpression[func.Parameters.Length - 1];  		Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  		BuildFunction (sb' new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms)));  		return;  	}  	var sc = new SqlQuery.SearchCondition ();  	sc.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.IsNull (func.Parameters [0]' false)));  	func = new SqlFunction (func.SystemType' "IIF"' sc' func.Parameters [1]' func.Parameters [0]);  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,BuildFunction,The following statement contains a magic number: if (func.Parameters.Length > 2) {  	var parms = new ISqlExpression[func.Parameters.Length - 1];  	Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  	BuildFunction (sb' new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms)));  	return;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,ConvertCase,The following statement contains a magic number: if (len == 3)  	return new SqlFunction (systemType' name' cond' parameters [start + 1]' parameters [start + 2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,ConvertCase,The following statement contains a magic number: if (len == 3)  	return new SqlFunction (systemType' name' cond' parameters [start + 1]' parameters [start + 2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,ConvertCase,The following statement contains a magic number: return new SqlFunction (systemType' name' cond' parameters [start + 1]' parameters [start + 2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,ConvertCase,The following statement contains a magic number: return new SqlFunction (systemType' name' cond' parameters [start + 1]' ConvertCase (systemType' parameters' start + 2));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSearchCondition,The following statement contains a magic number: foreach (var cond in condition.Conditions) {  	if (isOr != null) {  		sb.Append (isOr.Value ? " OR" : " AND");  		if (condition.Conditions.Count < 4 && sb.Length - len < 50 || condition != SqlQuery.Where.SearchCondition) {  			sb.Append (' ');  		} else {  			sb.AppendLine ();  			AppendIndent (sb);  			len = sb.Length;  		}  	}  	if (cond.IsNot)  		sb.Append ("NOT ");  	var precedence = GetPrecedence (cond.Predicate);  	BuildPredicate (sb' cond.IsNot ? Precedence.LogicalNegation : parentPrecedence' precedence' cond.Predicate);  	isOr = cond.IsOr;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSearchCondition,The following statement contains a magic number: foreach (var cond in condition.Conditions) {  	if (isOr != null) {  		sb.Append (isOr.Value ? " OR" : " AND");  		if (condition.Conditions.Count < 4 && sb.Length - len < 50 || condition != SqlQuery.Where.SearchCondition) {  			sb.Append (' ');  		} else {  			sb.AppendLine ();  			AppendIndent (sb);  			len = sb.Length;  		}  	}  	if (cond.IsNot)  		sb.Append ("NOT ");  	var precedence = GetPrecedence (cond.Predicate);  	BuildPredicate (sb' cond.IsNot ? Precedence.LogicalNegation : parentPrecedence' precedence' cond.Predicate);  	isOr = cond.IsOr;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSearchCondition,The following statement contains a magic number: if (isOr != null) {  	sb.Append (isOr.Value ? " OR" : " AND");  	if (condition.Conditions.Count < 4 && sb.Length - len < 50 || condition != SqlQuery.Where.SearchCondition) {  		sb.Append (' ');  	} else {  		sb.AppendLine ();  		AppendIndent (sb);  		len = sb.Length;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSearchCondition,The following statement contains a magic number: if (isOr != null) {  	sb.Append (isOr.Value ? " OR" : " AND");  	if (condition.Conditions.Count < 4 && sb.Length - len < 50 || condition != SqlQuery.Where.SearchCondition) {  		sb.Append (' ');  	} else {  		sb.AppendLine ();  		AppendIndent (sb);  		len = sb.Length;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSearchCondition,The following statement contains a magic number: if (condition.Conditions.Count < 4 && sb.Length - len < 50 || condition != SqlQuery.Where.SearchCondition) {  	sb.Append (' ');  } else {  	sb.AppendLine ();  	AppendIndent (sb);  	len = sb.Length;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildSearchCondition,The following statement contains a magic number: if (condition.Conditions.Count < 4 && sb.Length - len < 50 || condition != SqlQuery.Where.SearchCondition) {  	sb.Append (' ');  } else {  	sb.AppendLine ();  	AppendIndent (sb);  	len = sb.Length;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values == null || p.Values.Count == 0) {  	BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  } else {  	ICollection values = p.Values;  	if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) {  		var pr = (SqlParameter)p.Values [0];  		if (pr.Value == null) {  			BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  			return;  		}  		if (pr.Value is IEnumerable) {  			var items = (IEnumerable)pr.Value;  			if (p.Expr1 is ISqlTableSource) {  				var firstValue = true;  				var table = (ISqlTableSource)p.Expr1;  				var keys = table.GetKeys (true);  				if (keys == null || keys.Count == 0)  					throw new SqlException ("Cannot create IN expression.");  				if (keys.Count == 1) {  					foreach (var item in items) {  						if (firstValue) {  							firstValue = false;  							BuildExpression (sb' GetPrecedence (p)' keys [0]);  							sb.Append (p.IsNot ? " NOT IN (" : " IN (");  						}  						var field = GetUnderlayingField (keys [0]);  						var value = field.MemberMapper.GetValue (item);  						if (value is ISqlExpression)  							BuildExpression (sb' (ISqlExpression)value);  						else  							BuildValue (sb' value);  						sb.Append ("' ");  					}  				} else {  					var len = sb.Length;  					var rem = 1;  					foreach (var item in items) {  						if (firstValue) {  							firstValue = false;  							sb.Append ('(');  						}  						foreach (var key in keys) {  							var field = GetUnderlayingField (key);  							var value = field.MemberMapper.GetValue (item);  							BuildExpression (sb' GetPrecedence (p)' key);  							if (value == null) {  								sb.Append (" IS NULL");  							} else {  								sb.Append (" = ");  								BuildValue (sb' value);  							}  							sb.Append (" AND ");  						}  						sb.Remove (sb.Length - 4' 4).Append ("OR ");  						if (sb.Length - len >= 50) {  							sb.AppendLine ();  							AppendIndent (sb);  							sb.Append (' ');  							len = sb.Length;  							rem = 5 + Indent;  						}  					}  					if (!firstValue)  						sb.Remove (sb.Length - rem' rem);  				}  				if (firstValue)  					BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  				else  					sb.Remove (sb.Length - 2' 2).Append (')');  			} else {  				BuildInListValues (sb' p' items);  			}  			return;  		}  	}  	BuildInListValues (sb' p' values);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values == null || p.Values.Count == 0) {  	BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  } else {  	ICollection values = p.Values;  	if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) {  		var pr = (SqlParameter)p.Values [0];  		if (pr.Value == null) {  			BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  			return;  		}  		if (pr.Value is IEnumerable) {  			var items = (IEnumerable)pr.Value;  			if (p.Expr1 is ISqlTableSource) {  				var firstValue = true;  				var table = (ISqlTableSource)p.Expr1;  				var keys = table.GetKeys (true);  				if (keys == null || keys.Count == 0)  					throw new SqlException ("Cannot create IN expression.");  				if (keys.Count == 1) {  					foreach (var item in items) {  						if (firstValue) {  							firstValue = false;  							BuildExpression (sb' GetPrecedence (p)' keys [0]);  							sb.Append (p.IsNot ? " NOT IN (" : " IN (");  						}  						var field = GetUnderlayingField (keys [0]);  						var value = field.MemberMapper.GetValue (item);  						if (value is ISqlExpression)  							BuildExpression (sb' (ISqlExpression)value);  						else  							BuildValue (sb' value);  						sb.Append ("' ");  					}  				} else {  					var len = sb.Length;  					var rem = 1;  					foreach (var item in items) {  						if (firstValue) {  							firstValue = false;  							sb.Append ('(');  						}  						foreach (var key in keys) {  							var field = GetUnderlayingField (key);  							var value = field.MemberMapper.GetValue (item);  							BuildExpression (sb' GetPrecedence (p)' key);  							if (value == null) {  								sb.Append (" IS NULL");  							} else {  								sb.Append (" = ");  								BuildValue (sb' value);  							}  							sb.Append (" AND ");  						}  						sb.Remove (sb.Length - 4' 4).Append ("OR ");  						if (sb.Length - len >= 50) {  							sb.AppendLine ();  							AppendIndent (sb);  							sb.Append (' ');  							len = sb.Length;  							rem = 5 + Indent;  						}  					}  					if (!firstValue)  						sb.Remove (sb.Length - rem' rem);  				}  				if (firstValue)  					BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  				else  					sb.Remove (sb.Length - 2' 2).Append (')');  			} else {  				BuildInListValues (sb' p' items);  			}  			return;  		}  	}  	BuildInListValues (sb' p' values);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values == null || p.Values.Count == 0) {  	BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  } else {  	ICollection values = p.Values;  	if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) {  		var pr = (SqlParameter)p.Values [0];  		if (pr.Value == null) {  			BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  			return;  		}  		if (pr.Value is IEnumerable) {  			var items = (IEnumerable)pr.Value;  			if (p.Expr1 is ISqlTableSource) {  				var firstValue = true;  				var table = (ISqlTableSource)p.Expr1;  				var keys = table.GetKeys (true);  				if (keys == null || keys.Count == 0)  					throw new SqlException ("Cannot create IN expression.");  				if (keys.Count == 1) {  					foreach (var item in items) {  						if (firstValue) {  							firstValue = false;  							BuildExpression (sb' GetPrecedence (p)' keys [0]);  							sb.Append (p.IsNot ? " NOT IN (" : " IN (");  						}  						var field = GetUnderlayingField (keys [0]);  						var value = field.MemberMapper.GetValue (item);  						if (value is ISqlExpression)  							BuildExpression (sb' (ISqlExpression)value);  						else  							BuildValue (sb' value);  						sb.Append ("' ");  					}  				} else {  					var len = sb.Length;  					var rem = 1;  					foreach (var item in items) {  						if (firstValue) {  							firstValue = false;  							sb.Append ('(');  						}  						foreach (var key in keys) {  							var field = GetUnderlayingField (key);  							var value = field.MemberMapper.GetValue (item);  							BuildExpression (sb' GetPrecedence (p)' key);  							if (value == null) {  								sb.Append (" IS NULL");  							} else {  								sb.Append (" = ");  								BuildValue (sb' value);  							}  							sb.Append (" AND ");  						}  						sb.Remove (sb.Length - 4' 4).Append ("OR ");  						if (sb.Length - len >= 50) {  							sb.AppendLine ();  							AppendIndent (sb);  							sb.Append (' ');  							len = sb.Length;  							rem = 5 + Indent;  						}  					}  					if (!firstValue)  						sb.Remove (sb.Length - rem' rem);  				}  				if (firstValue)  					BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  				else  					sb.Remove (sb.Length - 2' 2).Append (')');  			} else {  				BuildInListValues (sb' p' items);  			}  			return;  		}  	}  	BuildInListValues (sb' p' values);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values == null || p.Values.Count == 0) {  	BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  } else {  	ICollection values = p.Values;  	if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) {  		var pr = (SqlParameter)p.Values [0];  		if (pr.Value == null) {  			BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  			return;  		}  		if (pr.Value is IEnumerable) {  			var items = (IEnumerable)pr.Value;  			if (p.Expr1 is ISqlTableSource) {  				var firstValue = true;  				var table = (ISqlTableSource)p.Expr1;  				var keys = table.GetKeys (true);  				if (keys == null || keys.Count == 0)  					throw new SqlException ("Cannot create IN expression.");  				if (keys.Count == 1) {  					foreach (var item in items) {  						if (firstValue) {  							firstValue = false;  							BuildExpression (sb' GetPrecedence (p)' keys [0]);  							sb.Append (p.IsNot ? " NOT IN (" : " IN (");  						}  						var field = GetUnderlayingField (keys [0]);  						var value = field.MemberMapper.GetValue (item);  						if (value is ISqlExpression)  							BuildExpression (sb' (ISqlExpression)value);  						else  							BuildValue (sb' value);  						sb.Append ("' ");  					}  				} else {  					var len = sb.Length;  					var rem = 1;  					foreach (var item in items) {  						if (firstValue) {  							firstValue = false;  							sb.Append ('(');  						}  						foreach (var key in keys) {  							var field = GetUnderlayingField (key);  							var value = field.MemberMapper.GetValue (item);  							BuildExpression (sb' GetPrecedence (p)' key);  							if (value == null) {  								sb.Append (" IS NULL");  							} else {  								sb.Append (" = ");  								BuildValue (sb' value);  							}  							sb.Append (" AND ");  						}  						sb.Remove (sb.Length - 4' 4).Append ("OR ");  						if (sb.Length - len >= 50) {  							sb.AppendLine ();  							AppendIndent (sb);  							sb.Append (' ');  							len = sb.Length;  							rem = 5 + Indent;  						}  					}  					if (!firstValue)  						sb.Remove (sb.Length - rem' rem);  				}  				if (firstValue)  					BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  				else  					sb.Remove (sb.Length - 2' 2).Append (')');  			} else {  				BuildInListValues (sb' p' items);  			}  			return;  		}  	}  	BuildInListValues (sb' p' values);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values == null || p.Values.Count == 0) {  	BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  } else {  	ICollection values = p.Values;  	if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) {  		var pr = (SqlParameter)p.Values [0];  		if (pr.Value == null) {  			BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  			return;  		}  		if (pr.Value is IEnumerable) {  			var items = (IEnumerable)pr.Value;  			if (p.Expr1 is ISqlTableSource) {  				var firstValue = true;  				var table = (ISqlTableSource)p.Expr1;  				var keys = table.GetKeys (true);  				if (keys == null || keys.Count == 0)  					throw new SqlException ("Cannot create IN expression.");  				if (keys.Count == 1) {  					foreach (var item in items) {  						if (firstValue) {  							firstValue = false;  							BuildExpression (sb' GetPrecedence (p)' keys [0]);  							sb.Append (p.IsNot ? " NOT IN (" : " IN (");  						}  						var field = GetUnderlayingField (keys [0]);  						var value = field.MemberMapper.GetValue (item);  						if (value is ISqlExpression)  							BuildExpression (sb' (ISqlExpression)value);  						else  							BuildValue (sb' value);  						sb.Append ("' ");  					}  				} else {  					var len = sb.Length;  					var rem = 1;  					foreach (var item in items) {  						if (firstValue) {  							firstValue = false;  							sb.Append ('(');  						}  						foreach (var key in keys) {  							var field = GetUnderlayingField (key);  							var value = field.MemberMapper.GetValue (item);  							BuildExpression (sb' GetPrecedence (p)' key);  							if (value == null) {  								sb.Append (" IS NULL");  							} else {  								sb.Append (" = ");  								BuildValue (sb' value);  							}  							sb.Append (" AND ");  						}  						sb.Remove (sb.Length - 4' 4).Append ("OR ");  						if (sb.Length - len >= 50) {  							sb.AppendLine ();  							AppendIndent (sb);  							sb.Append (' ');  							len = sb.Length;  							rem = 5 + Indent;  						}  					}  					if (!firstValue)  						sb.Remove (sb.Length - rem' rem);  				}  				if (firstValue)  					BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  				else  					sb.Remove (sb.Length - 2' 2).Append (')');  			} else {  				BuildInListValues (sb' p' items);  			}  			return;  		}  	}  	BuildInListValues (sb' p' values);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values == null || p.Values.Count == 0) {  	BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  } else {  	ICollection values = p.Values;  	if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) {  		var pr = (SqlParameter)p.Values [0];  		if (pr.Value == null) {  			BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  			return;  		}  		if (pr.Value is IEnumerable) {  			var items = (IEnumerable)pr.Value;  			if (p.Expr1 is ISqlTableSource) {  				var firstValue = true;  				var table = (ISqlTableSource)p.Expr1;  				var keys = table.GetKeys (true);  				if (keys == null || keys.Count == 0)  					throw new SqlException ("Cannot create IN expression.");  				if (keys.Count == 1) {  					foreach (var item in items) {  						if (firstValue) {  							firstValue = false;  							BuildExpression (sb' GetPrecedence (p)' keys [0]);  							sb.Append (p.IsNot ? " NOT IN (" : " IN (");  						}  						var field = GetUnderlayingField (keys [0]);  						var value = field.MemberMapper.GetValue (item);  						if (value is ISqlExpression)  							BuildExpression (sb' (ISqlExpression)value);  						else  							BuildValue (sb' value);  						sb.Append ("' ");  					}  				} else {  					var len = sb.Length;  					var rem = 1;  					foreach (var item in items) {  						if (firstValue) {  							firstValue = false;  							sb.Append ('(');  						}  						foreach (var key in keys) {  							var field = GetUnderlayingField (key);  							var value = field.MemberMapper.GetValue (item);  							BuildExpression (sb' GetPrecedence (p)' key);  							if (value == null) {  								sb.Append (" IS NULL");  							} else {  								sb.Append (" = ");  								BuildValue (sb' value);  							}  							sb.Append (" AND ");  						}  						sb.Remove (sb.Length - 4' 4).Append ("OR ");  						if (sb.Length - len >= 50) {  							sb.AppendLine ();  							AppendIndent (sb);  							sb.Append (' ');  							len = sb.Length;  							rem = 5 + Indent;  						}  					}  					if (!firstValue)  						sb.Remove (sb.Length - rem' rem);  				}  				if (firstValue)  					BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  				else  					sb.Remove (sb.Length - 2' 2).Append (')');  			} else {  				BuildInListValues (sb' p' items);  			}  			return;  		}  	}  	BuildInListValues (sb' p' values);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) {  	var pr = (SqlParameter)p.Values [0];  	if (pr.Value == null) {  		BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  		return;  	}  	if (pr.Value is IEnumerable) {  		var items = (IEnumerable)pr.Value;  		if (p.Expr1 is ISqlTableSource) {  			var firstValue = true;  			var table = (ISqlTableSource)p.Expr1;  			var keys = table.GetKeys (true);  			if (keys == null || keys.Count == 0)  				throw new SqlException ("Cannot create IN expression.");  			if (keys.Count == 1) {  				foreach (var item in items) {  					if (firstValue) {  						firstValue = false;  						BuildExpression (sb' GetPrecedence (p)' keys [0]);  						sb.Append (p.IsNot ? " NOT IN (" : " IN (");  					}  					var field = GetUnderlayingField (keys [0]);  					var value = field.MemberMapper.GetValue (item);  					if (value is ISqlExpression)  						BuildExpression (sb' (ISqlExpression)value);  					else  						BuildValue (sb' value);  					sb.Append ("' ");  				}  			} else {  				var len = sb.Length;  				var rem = 1;  				foreach (var item in items) {  					if (firstValue) {  						firstValue = false;  						sb.Append ('(');  					}  					foreach (var key in keys) {  						var field = GetUnderlayingField (key);  						var value = field.MemberMapper.GetValue (item);  						BuildExpression (sb' GetPrecedence (p)' key);  						if (value == null) {  							sb.Append (" IS NULL");  						} else {  							sb.Append (" = ");  							BuildValue (sb' value);  						}  						sb.Append (" AND ");  					}  					sb.Remove (sb.Length - 4' 4).Append ("OR ");  					if (sb.Length - len >= 50) {  						sb.AppendLine ();  						AppendIndent (sb);  						sb.Append (' ');  						len = sb.Length;  						rem = 5 + Indent;  					}  				}  				if (!firstValue)  					sb.Remove (sb.Length - rem' rem);  			}  			if (firstValue)  				BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  			else  				sb.Remove (sb.Length - 2' 2).Append (')');  		} else {  			BuildInListValues (sb' p' items);  		}  		return;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) {  	var pr = (SqlParameter)p.Values [0];  	if (pr.Value == null) {  		BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  		return;  	}  	if (pr.Value is IEnumerable) {  		var items = (IEnumerable)pr.Value;  		if (p.Expr1 is ISqlTableSource) {  			var firstValue = true;  			var table = (ISqlTableSource)p.Expr1;  			var keys = table.GetKeys (true);  			if (keys == null || keys.Count == 0)  				throw new SqlException ("Cannot create IN expression.");  			if (keys.Count == 1) {  				foreach (var item in items) {  					if (firstValue) {  						firstValue = false;  						BuildExpression (sb' GetPrecedence (p)' keys [0]);  						sb.Append (p.IsNot ? " NOT IN (" : " IN (");  					}  					var field = GetUnderlayingField (keys [0]);  					var value = field.MemberMapper.GetValue (item);  					if (value is ISqlExpression)  						BuildExpression (sb' (ISqlExpression)value);  					else  						BuildValue (sb' value);  					sb.Append ("' ");  				}  			} else {  				var len = sb.Length;  				var rem = 1;  				foreach (var item in items) {  					if (firstValue) {  						firstValue = false;  						sb.Append ('(');  					}  					foreach (var key in keys) {  						var field = GetUnderlayingField (key);  						var value = field.MemberMapper.GetValue (item);  						BuildExpression (sb' GetPrecedence (p)' key);  						if (value == null) {  							sb.Append (" IS NULL");  						} else {  							sb.Append (" = ");  							BuildValue (sb' value);  						}  						sb.Append (" AND ");  					}  					sb.Remove (sb.Length - 4' 4).Append ("OR ");  					if (sb.Length - len >= 50) {  						sb.AppendLine ();  						AppendIndent (sb);  						sb.Append (' ');  						len = sb.Length;  						rem = 5 + Indent;  					}  				}  				if (!firstValue)  					sb.Remove (sb.Length - rem' rem);  			}  			if (firstValue)  				BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  			else  				sb.Remove (sb.Length - 2' 2).Append (')');  		} else {  			BuildInListValues (sb' p' items);  		}  		return;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) {  	var pr = (SqlParameter)p.Values [0];  	if (pr.Value == null) {  		BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  		return;  	}  	if (pr.Value is IEnumerable) {  		var items = (IEnumerable)pr.Value;  		if (p.Expr1 is ISqlTableSource) {  			var firstValue = true;  			var table = (ISqlTableSource)p.Expr1;  			var keys = table.GetKeys (true);  			if (keys == null || keys.Count == 0)  				throw new SqlException ("Cannot create IN expression.");  			if (keys.Count == 1) {  				foreach (var item in items) {  					if (firstValue) {  						firstValue = false;  						BuildExpression (sb' GetPrecedence (p)' keys [0]);  						sb.Append (p.IsNot ? " NOT IN (" : " IN (");  					}  					var field = GetUnderlayingField (keys [0]);  					var value = field.MemberMapper.GetValue (item);  					if (value is ISqlExpression)  						BuildExpression (sb' (ISqlExpression)value);  					else  						BuildValue (sb' value);  					sb.Append ("' ");  				}  			} else {  				var len = sb.Length;  				var rem = 1;  				foreach (var item in items) {  					if (firstValue) {  						firstValue = false;  						sb.Append ('(');  					}  					foreach (var key in keys) {  						var field = GetUnderlayingField (key);  						var value = field.MemberMapper.GetValue (item);  						BuildExpression (sb' GetPrecedence (p)' key);  						if (value == null) {  							sb.Append (" IS NULL");  						} else {  							sb.Append (" = ");  							BuildValue (sb' value);  						}  						sb.Append (" AND ");  					}  					sb.Remove (sb.Length - 4' 4).Append ("OR ");  					if (sb.Length - len >= 50) {  						sb.AppendLine ();  						AppendIndent (sb);  						sb.Append (' ');  						len = sb.Length;  						rem = 5 + Indent;  					}  				}  				if (!firstValue)  					sb.Remove (sb.Length - rem' rem);  			}  			if (firstValue)  				BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  			else  				sb.Remove (sb.Length - 2' 2).Append (')');  		} else {  			BuildInListValues (sb' p' items);  		}  		return;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) {  	var pr = (SqlParameter)p.Values [0];  	if (pr.Value == null) {  		BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  		return;  	}  	if (pr.Value is IEnumerable) {  		var items = (IEnumerable)pr.Value;  		if (p.Expr1 is ISqlTableSource) {  			var firstValue = true;  			var table = (ISqlTableSource)p.Expr1;  			var keys = table.GetKeys (true);  			if (keys == null || keys.Count == 0)  				throw new SqlException ("Cannot create IN expression.");  			if (keys.Count == 1) {  				foreach (var item in items) {  					if (firstValue) {  						firstValue = false;  						BuildExpression (sb' GetPrecedence (p)' keys [0]);  						sb.Append (p.IsNot ? " NOT IN (" : " IN (");  					}  					var field = GetUnderlayingField (keys [0]);  					var value = field.MemberMapper.GetValue (item);  					if (value is ISqlExpression)  						BuildExpression (sb' (ISqlExpression)value);  					else  						BuildValue (sb' value);  					sb.Append ("' ");  				}  			} else {  				var len = sb.Length;  				var rem = 1;  				foreach (var item in items) {  					if (firstValue) {  						firstValue = false;  						sb.Append ('(');  					}  					foreach (var key in keys) {  						var field = GetUnderlayingField (key);  						var value = field.MemberMapper.GetValue (item);  						BuildExpression (sb' GetPrecedence (p)' key);  						if (value == null) {  							sb.Append (" IS NULL");  						} else {  							sb.Append (" = ");  							BuildValue (sb' value);  						}  						sb.Append (" AND ");  					}  					sb.Remove (sb.Length - 4' 4).Append ("OR ");  					if (sb.Length - len >= 50) {  						sb.AppendLine ();  						AppendIndent (sb);  						sb.Append (' ');  						len = sb.Length;  						rem = 5 + Indent;  					}  				}  				if (!firstValue)  					sb.Remove (sb.Length - rem' rem);  			}  			if (firstValue)  				BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  			else  				sb.Remove (sb.Length - 2' 2).Append (')');  		} else {  			BuildInListValues (sb' p' items);  		}  		return;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) {  	var pr = (SqlParameter)p.Values [0];  	if (pr.Value == null) {  		BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  		return;  	}  	if (pr.Value is IEnumerable) {  		var items = (IEnumerable)pr.Value;  		if (p.Expr1 is ISqlTableSource) {  			var firstValue = true;  			var table = (ISqlTableSource)p.Expr1;  			var keys = table.GetKeys (true);  			if (keys == null || keys.Count == 0)  				throw new SqlException ("Cannot create IN expression.");  			if (keys.Count == 1) {  				foreach (var item in items) {  					if (firstValue) {  						firstValue = false;  						BuildExpression (sb' GetPrecedence (p)' keys [0]);  						sb.Append (p.IsNot ? " NOT IN (" : " IN (");  					}  					var field = GetUnderlayingField (keys [0]);  					var value = field.MemberMapper.GetValue (item);  					if (value is ISqlExpression)  						BuildExpression (sb' (ISqlExpression)value);  					else  						BuildValue (sb' value);  					sb.Append ("' ");  				}  			} else {  				var len = sb.Length;  				var rem = 1;  				foreach (var item in items) {  					if (firstValue) {  						firstValue = false;  						sb.Append ('(');  					}  					foreach (var key in keys) {  						var field = GetUnderlayingField (key);  						var value = field.MemberMapper.GetValue (item);  						BuildExpression (sb' GetPrecedence (p)' key);  						if (value == null) {  							sb.Append (" IS NULL");  						} else {  							sb.Append (" = ");  							BuildValue (sb' value);  						}  						sb.Append (" AND ");  					}  					sb.Remove (sb.Length - 4' 4).Append ("OR ");  					if (sb.Length - len >= 50) {  						sb.AppendLine ();  						AppendIndent (sb);  						sb.Append (' ');  						len = sb.Length;  						rem = 5 + Indent;  					}  				}  				if (!firstValue)  					sb.Remove (sb.Length - rem' rem);  			}  			if (firstValue)  				BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  			else  				sb.Remove (sb.Length - 2' 2).Append (')');  		} else {  			BuildInListValues (sb' p' items);  		}  		return;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Values.Count == 1 && p.Values [0] is SqlParameter && !(p.Expr1.SystemType == typeof(string) && ((SqlParameter)p.Values [0]).Value is string)) {  	var pr = (SqlParameter)p.Values [0];  	if (pr.Value == null) {  		BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (false)));  		return;  	}  	if (pr.Value is IEnumerable) {  		var items = (IEnumerable)pr.Value;  		if (p.Expr1 is ISqlTableSource) {  			var firstValue = true;  			var table = (ISqlTableSource)p.Expr1;  			var keys = table.GetKeys (true);  			if (keys == null || keys.Count == 0)  				throw new SqlException ("Cannot create IN expression.");  			if (keys.Count == 1) {  				foreach (var item in items) {  					if (firstValue) {  						firstValue = false;  						BuildExpression (sb' GetPrecedence (p)' keys [0]);  						sb.Append (p.IsNot ? " NOT IN (" : " IN (");  					}  					var field = GetUnderlayingField (keys [0]);  					var value = field.MemberMapper.GetValue (item);  					if (value is ISqlExpression)  						BuildExpression (sb' (ISqlExpression)value);  					else  						BuildValue (sb' value);  					sb.Append ("' ");  				}  			} else {  				var len = sb.Length;  				var rem = 1;  				foreach (var item in items) {  					if (firstValue) {  						firstValue = false;  						sb.Append ('(');  					}  					foreach (var key in keys) {  						var field = GetUnderlayingField (key);  						var value = field.MemberMapper.GetValue (item);  						BuildExpression (sb' GetPrecedence (p)' key);  						if (value == null) {  							sb.Append (" IS NULL");  						} else {  							sb.Append (" = ");  							BuildValue (sb' value);  						}  						sb.Append (" AND ");  					}  					sb.Remove (sb.Length - 4' 4).Append ("OR ");  					if (sb.Length - len >= 50) {  						sb.AppendLine ();  						AppendIndent (sb);  						sb.Append (' ');  						len = sb.Length;  						rem = 5 + Indent;  					}  				}  				if (!firstValue)  					sb.Remove (sb.Length - rem' rem);  			}  			if (firstValue)  				BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  			else  				sb.Remove (sb.Length - 2' 2).Append (')');  		} else {  			BuildInListValues (sb' p' items);  		}  		return;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (pr.Value is IEnumerable) {  	var items = (IEnumerable)pr.Value;  	if (p.Expr1 is ISqlTableSource) {  		var firstValue = true;  		var table = (ISqlTableSource)p.Expr1;  		var keys = table.GetKeys (true);  		if (keys == null || keys.Count == 0)  			throw new SqlException ("Cannot create IN expression.");  		if (keys.Count == 1) {  			foreach (var item in items) {  				if (firstValue) {  					firstValue = false;  					BuildExpression (sb' GetPrecedence (p)' keys [0]);  					sb.Append (p.IsNot ? " NOT IN (" : " IN (");  				}  				var field = GetUnderlayingField (keys [0]);  				var value = field.MemberMapper.GetValue (item);  				if (value is ISqlExpression)  					BuildExpression (sb' (ISqlExpression)value);  				else  					BuildValue (sb' value);  				sb.Append ("' ");  			}  		} else {  			var len = sb.Length;  			var rem = 1;  			foreach (var item in items) {  				if (firstValue) {  					firstValue = false;  					sb.Append ('(');  				}  				foreach (var key in keys) {  					var field = GetUnderlayingField (key);  					var value = field.MemberMapper.GetValue (item);  					BuildExpression (sb' GetPrecedence (p)' key);  					if (value == null) {  						sb.Append (" IS NULL");  					} else {  						sb.Append (" = ");  						BuildValue (sb' value);  					}  					sb.Append (" AND ");  				}  				sb.Remove (sb.Length - 4' 4).Append ("OR ");  				if (sb.Length - len >= 50) {  					sb.AppendLine ();  					AppendIndent (sb);  					sb.Append (' ');  					len = sb.Length;  					rem = 5 + Indent;  				}  			}  			if (!firstValue)  				sb.Remove (sb.Length - rem' rem);  		}  		if (firstValue)  			BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  		else  			sb.Remove (sb.Length - 2' 2).Append (')');  	} else {  		BuildInListValues (sb' p' items);  	}  	return;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (pr.Value is IEnumerable) {  	var items = (IEnumerable)pr.Value;  	if (p.Expr1 is ISqlTableSource) {  		var firstValue = true;  		var table = (ISqlTableSource)p.Expr1;  		var keys = table.GetKeys (true);  		if (keys == null || keys.Count == 0)  			throw new SqlException ("Cannot create IN expression.");  		if (keys.Count == 1) {  			foreach (var item in items) {  				if (firstValue) {  					firstValue = false;  					BuildExpression (sb' GetPrecedence (p)' keys [0]);  					sb.Append (p.IsNot ? " NOT IN (" : " IN (");  				}  				var field = GetUnderlayingField (keys [0]);  				var value = field.MemberMapper.GetValue (item);  				if (value is ISqlExpression)  					BuildExpression (sb' (ISqlExpression)value);  				else  					BuildValue (sb' value);  				sb.Append ("' ");  			}  		} else {  			var len = sb.Length;  			var rem = 1;  			foreach (var item in items) {  				if (firstValue) {  					firstValue = false;  					sb.Append ('(');  				}  				foreach (var key in keys) {  					var field = GetUnderlayingField (key);  					var value = field.MemberMapper.GetValue (item);  					BuildExpression (sb' GetPrecedence (p)' key);  					if (value == null) {  						sb.Append (" IS NULL");  					} else {  						sb.Append (" = ");  						BuildValue (sb' value);  					}  					sb.Append (" AND ");  				}  				sb.Remove (sb.Length - 4' 4).Append ("OR ");  				if (sb.Length - len >= 50) {  					sb.AppendLine ();  					AppendIndent (sb);  					sb.Append (' ');  					len = sb.Length;  					rem = 5 + Indent;  				}  			}  			if (!firstValue)  				sb.Remove (sb.Length - rem' rem);  		}  		if (firstValue)  			BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  		else  			sb.Remove (sb.Length - 2' 2).Append (')');  	} else {  		BuildInListValues (sb' p' items);  	}  	return;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (pr.Value is IEnumerable) {  	var items = (IEnumerable)pr.Value;  	if (p.Expr1 is ISqlTableSource) {  		var firstValue = true;  		var table = (ISqlTableSource)p.Expr1;  		var keys = table.GetKeys (true);  		if (keys == null || keys.Count == 0)  			throw new SqlException ("Cannot create IN expression.");  		if (keys.Count == 1) {  			foreach (var item in items) {  				if (firstValue) {  					firstValue = false;  					BuildExpression (sb' GetPrecedence (p)' keys [0]);  					sb.Append (p.IsNot ? " NOT IN (" : " IN (");  				}  				var field = GetUnderlayingField (keys [0]);  				var value = field.MemberMapper.GetValue (item);  				if (value is ISqlExpression)  					BuildExpression (sb' (ISqlExpression)value);  				else  					BuildValue (sb' value);  				sb.Append ("' ");  			}  		} else {  			var len = sb.Length;  			var rem = 1;  			foreach (var item in items) {  				if (firstValue) {  					firstValue = false;  					sb.Append ('(');  				}  				foreach (var key in keys) {  					var field = GetUnderlayingField (key);  					var value = field.MemberMapper.GetValue (item);  					BuildExpression (sb' GetPrecedence (p)' key);  					if (value == null) {  						sb.Append (" IS NULL");  					} else {  						sb.Append (" = ");  						BuildValue (sb' value);  					}  					sb.Append (" AND ");  				}  				sb.Remove (sb.Length - 4' 4).Append ("OR ");  				if (sb.Length - len >= 50) {  					sb.AppendLine ();  					AppendIndent (sb);  					sb.Append (' ');  					len = sb.Length;  					rem = 5 + Indent;  				}  			}  			if (!firstValue)  				sb.Remove (sb.Length - rem' rem);  		}  		if (firstValue)  			BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  		else  			sb.Remove (sb.Length - 2' 2).Append (')');  	} else {  		BuildInListValues (sb' p' items);  	}  	return;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (pr.Value is IEnumerable) {  	var items = (IEnumerable)pr.Value;  	if (p.Expr1 is ISqlTableSource) {  		var firstValue = true;  		var table = (ISqlTableSource)p.Expr1;  		var keys = table.GetKeys (true);  		if (keys == null || keys.Count == 0)  			throw new SqlException ("Cannot create IN expression.");  		if (keys.Count == 1) {  			foreach (var item in items) {  				if (firstValue) {  					firstValue = false;  					BuildExpression (sb' GetPrecedence (p)' keys [0]);  					sb.Append (p.IsNot ? " NOT IN (" : " IN (");  				}  				var field = GetUnderlayingField (keys [0]);  				var value = field.MemberMapper.GetValue (item);  				if (value is ISqlExpression)  					BuildExpression (sb' (ISqlExpression)value);  				else  					BuildValue (sb' value);  				sb.Append ("' ");  			}  		} else {  			var len = sb.Length;  			var rem = 1;  			foreach (var item in items) {  				if (firstValue) {  					firstValue = false;  					sb.Append ('(');  				}  				foreach (var key in keys) {  					var field = GetUnderlayingField (key);  					var value = field.MemberMapper.GetValue (item);  					BuildExpression (sb' GetPrecedence (p)' key);  					if (value == null) {  						sb.Append (" IS NULL");  					} else {  						sb.Append (" = ");  						BuildValue (sb' value);  					}  					sb.Append (" AND ");  				}  				sb.Remove (sb.Length - 4' 4).Append ("OR ");  				if (sb.Length - len >= 50) {  					sb.AppendLine ();  					AppendIndent (sb);  					sb.Append (' ');  					len = sb.Length;  					rem = 5 + Indent;  				}  			}  			if (!firstValue)  				sb.Remove (sb.Length - rem' rem);  		}  		if (firstValue)  			BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  		else  			sb.Remove (sb.Length - 2' 2).Append (')');  	} else {  		BuildInListValues (sb' p' items);  	}  	return;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (pr.Value is IEnumerable) {  	var items = (IEnumerable)pr.Value;  	if (p.Expr1 is ISqlTableSource) {  		var firstValue = true;  		var table = (ISqlTableSource)p.Expr1;  		var keys = table.GetKeys (true);  		if (keys == null || keys.Count == 0)  			throw new SqlException ("Cannot create IN expression.");  		if (keys.Count == 1) {  			foreach (var item in items) {  				if (firstValue) {  					firstValue = false;  					BuildExpression (sb' GetPrecedence (p)' keys [0]);  					sb.Append (p.IsNot ? " NOT IN (" : " IN (");  				}  				var field = GetUnderlayingField (keys [0]);  				var value = field.MemberMapper.GetValue (item);  				if (value is ISqlExpression)  					BuildExpression (sb' (ISqlExpression)value);  				else  					BuildValue (sb' value);  				sb.Append ("' ");  			}  		} else {  			var len = sb.Length;  			var rem = 1;  			foreach (var item in items) {  				if (firstValue) {  					firstValue = false;  					sb.Append ('(');  				}  				foreach (var key in keys) {  					var field = GetUnderlayingField (key);  					var value = field.MemberMapper.GetValue (item);  					BuildExpression (sb' GetPrecedence (p)' key);  					if (value == null) {  						sb.Append (" IS NULL");  					} else {  						sb.Append (" = ");  						BuildValue (sb' value);  					}  					sb.Append (" AND ");  				}  				sb.Remove (sb.Length - 4' 4).Append ("OR ");  				if (sb.Length - len >= 50) {  					sb.AppendLine ();  					AppendIndent (sb);  					sb.Append (' ');  					len = sb.Length;  					rem = 5 + Indent;  				}  			}  			if (!firstValue)  				sb.Remove (sb.Length - rem' rem);  		}  		if (firstValue)  			BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  		else  			sb.Remove (sb.Length - 2' 2).Append (')');  	} else {  		BuildInListValues (sb' p' items);  	}  	return;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (pr.Value is IEnumerable) {  	var items = (IEnumerable)pr.Value;  	if (p.Expr1 is ISqlTableSource) {  		var firstValue = true;  		var table = (ISqlTableSource)p.Expr1;  		var keys = table.GetKeys (true);  		if (keys == null || keys.Count == 0)  			throw new SqlException ("Cannot create IN expression.");  		if (keys.Count == 1) {  			foreach (var item in items) {  				if (firstValue) {  					firstValue = false;  					BuildExpression (sb' GetPrecedence (p)' keys [0]);  					sb.Append (p.IsNot ? " NOT IN (" : " IN (");  				}  				var field = GetUnderlayingField (keys [0]);  				var value = field.MemberMapper.GetValue (item);  				if (value is ISqlExpression)  					BuildExpression (sb' (ISqlExpression)value);  				else  					BuildValue (sb' value);  				sb.Append ("' ");  			}  		} else {  			var len = sb.Length;  			var rem = 1;  			foreach (var item in items) {  				if (firstValue) {  					firstValue = false;  					sb.Append ('(');  				}  				foreach (var key in keys) {  					var field = GetUnderlayingField (key);  					var value = field.MemberMapper.GetValue (item);  					BuildExpression (sb' GetPrecedence (p)' key);  					if (value == null) {  						sb.Append (" IS NULL");  					} else {  						sb.Append (" = ");  						BuildValue (sb' value);  					}  					sb.Append (" AND ");  				}  				sb.Remove (sb.Length - 4' 4).Append ("OR ");  				if (sb.Length - len >= 50) {  					sb.AppendLine ();  					AppendIndent (sb);  					sb.Append (' ');  					len = sb.Length;  					rem = 5 + Indent;  				}  			}  			if (!firstValue)  				sb.Remove (sb.Length - rem' rem);  		}  		if (firstValue)  			BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  		else  			sb.Remove (sb.Length - 2' 2).Append (')');  	} else {  		BuildInListValues (sb' p' items);  	}  	return;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Expr1 is ISqlTableSource) {  	var firstValue = true;  	var table = (ISqlTableSource)p.Expr1;  	var keys = table.GetKeys (true);  	if (keys == null || keys.Count == 0)  		throw new SqlException ("Cannot create IN expression.");  	if (keys.Count == 1) {  		foreach (var item in items) {  			if (firstValue) {  				firstValue = false;  				BuildExpression (sb' GetPrecedence (p)' keys [0]);  				sb.Append (p.IsNot ? " NOT IN (" : " IN (");  			}  			var field = GetUnderlayingField (keys [0]);  			var value = field.MemberMapper.GetValue (item);  			if (value is ISqlExpression)  				BuildExpression (sb' (ISqlExpression)value);  			else  				BuildValue (sb' value);  			sb.Append ("' ");  		}  	} else {  		var len = sb.Length;  		var rem = 1;  		foreach (var item in items) {  			if (firstValue) {  				firstValue = false;  				sb.Append ('(');  			}  			foreach (var key in keys) {  				var field = GetUnderlayingField (key);  				var value = field.MemberMapper.GetValue (item);  				BuildExpression (sb' GetPrecedence (p)' key);  				if (value == null) {  					sb.Append (" IS NULL");  				} else {  					sb.Append (" = ");  					BuildValue (sb' value);  				}  				sb.Append (" AND ");  			}  			sb.Remove (sb.Length - 4' 4).Append ("OR ");  			if (sb.Length - len >= 50) {  				sb.AppendLine ();  				AppendIndent (sb);  				sb.Append (' ');  				len = sb.Length;  				rem = 5 + Indent;  			}  		}  		if (!firstValue)  			sb.Remove (sb.Length - rem' rem);  	}  	if (firstValue)  		BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  	else  		sb.Remove (sb.Length - 2' 2).Append (')');  } else {  	BuildInListValues (sb' p' items);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Expr1 is ISqlTableSource) {  	var firstValue = true;  	var table = (ISqlTableSource)p.Expr1;  	var keys = table.GetKeys (true);  	if (keys == null || keys.Count == 0)  		throw new SqlException ("Cannot create IN expression.");  	if (keys.Count == 1) {  		foreach (var item in items) {  			if (firstValue) {  				firstValue = false;  				BuildExpression (sb' GetPrecedence (p)' keys [0]);  				sb.Append (p.IsNot ? " NOT IN (" : " IN (");  			}  			var field = GetUnderlayingField (keys [0]);  			var value = field.MemberMapper.GetValue (item);  			if (value is ISqlExpression)  				BuildExpression (sb' (ISqlExpression)value);  			else  				BuildValue (sb' value);  			sb.Append ("' ");  		}  	} else {  		var len = sb.Length;  		var rem = 1;  		foreach (var item in items) {  			if (firstValue) {  				firstValue = false;  				sb.Append ('(');  			}  			foreach (var key in keys) {  				var field = GetUnderlayingField (key);  				var value = field.MemberMapper.GetValue (item);  				BuildExpression (sb' GetPrecedence (p)' key);  				if (value == null) {  					sb.Append (" IS NULL");  				} else {  					sb.Append (" = ");  					BuildValue (sb' value);  				}  				sb.Append (" AND ");  			}  			sb.Remove (sb.Length - 4' 4).Append ("OR ");  			if (sb.Length - len >= 50) {  				sb.AppendLine ();  				AppendIndent (sb);  				sb.Append (' ');  				len = sb.Length;  				rem = 5 + Indent;  			}  		}  		if (!firstValue)  			sb.Remove (sb.Length - rem' rem);  	}  	if (firstValue)  		BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  	else  		sb.Remove (sb.Length - 2' 2).Append (')');  } else {  	BuildInListValues (sb' p' items);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Expr1 is ISqlTableSource) {  	var firstValue = true;  	var table = (ISqlTableSource)p.Expr1;  	var keys = table.GetKeys (true);  	if (keys == null || keys.Count == 0)  		throw new SqlException ("Cannot create IN expression.");  	if (keys.Count == 1) {  		foreach (var item in items) {  			if (firstValue) {  				firstValue = false;  				BuildExpression (sb' GetPrecedence (p)' keys [0]);  				sb.Append (p.IsNot ? " NOT IN (" : " IN (");  			}  			var field = GetUnderlayingField (keys [0]);  			var value = field.MemberMapper.GetValue (item);  			if (value is ISqlExpression)  				BuildExpression (sb' (ISqlExpression)value);  			else  				BuildValue (sb' value);  			sb.Append ("' ");  		}  	} else {  		var len = sb.Length;  		var rem = 1;  		foreach (var item in items) {  			if (firstValue) {  				firstValue = false;  				sb.Append ('(');  			}  			foreach (var key in keys) {  				var field = GetUnderlayingField (key);  				var value = field.MemberMapper.GetValue (item);  				BuildExpression (sb' GetPrecedence (p)' key);  				if (value == null) {  					sb.Append (" IS NULL");  				} else {  					sb.Append (" = ");  					BuildValue (sb' value);  				}  				sb.Append (" AND ");  			}  			sb.Remove (sb.Length - 4' 4).Append ("OR ");  			if (sb.Length - len >= 50) {  				sb.AppendLine ();  				AppendIndent (sb);  				sb.Append (' ');  				len = sb.Length;  				rem = 5 + Indent;  			}  		}  		if (!firstValue)  			sb.Remove (sb.Length - rem' rem);  	}  	if (firstValue)  		BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  	else  		sb.Remove (sb.Length - 2' 2).Append (')');  } else {  	BuildInListValues (sb' p' items);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Expr1 is ISqlTableSource) {  	var firstValue = true;  	var table = (ISqlTableSource)p.Expr1;  	var keys = table.GetKeys (true);  	if (keys == null || keys.Count == 0)  		throw new SqlException ("Cannot create IN expression.");  	if (keys.Count == 1) {  		foreach (var item in items) {  			if (firstValue) {  				firstValue = false;  				BuildExpression (sb' GetPrecedence (p)' keys [0]);  				sb.Append (p.IsNot ? " NOT IN (" : " IN (");  			}  			var field = GetUnderlayingField (keys [0]);  			var value = field.MemberMapper.GetValue (item);  			if (value is ISqlExpression)  				BuildExpression (sb' (ISqlExpression)value);  			else  				BuildValue (sb' value);  			sb.Append ("' ");  		}  	} else {  		var len = sb.Length;  		var rem = 1;  		foreach (var item in items) {  			if (firstValue) {  				firstValue = false;  				sb.Append ('(');  			}  			foreach (var key in keys) {  				var field = GetUnderlayingField (key);  				var value = field.MemberMapper.GetValue (item);  				BuildExpression (sb' GetPrecedence (p)' key);  				if (value == null) {  					sb.Append (" IS NULL");  				} else {  					sb.Append (" = ");  					BuildValue (sb' value);  				}  				sb.Append (" AND ");  			}  			sb.Remove (sb.Length - 4' 4).Append ("OR ");  			if (sb.Length - len >= 50) {  				sb.AppendLine ();  				AppendIndent (sb);  				sb.Append (' ');  				len = sb.Length;  				rem = 5 + Indent;  			}  		}  		if (!firstValue)  			sb.Remove (sb.Length - rem' rem);  	}  	if (firstValue)  		BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  	else  		sb.Remove (sb.Length - 2' 2).Append (')');  } else {  	BuildInListValues (sb' p' items);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Expr1 is ISqlTableSource) {  	var firstValue = true;  	var table = (ISqlTableSource)p.Expr1;  	var keys = table.GetKeys (true);  	if (keys == null || keys.Count == 0)  		throw new SqlException ("Cannot create IN expression.");  	if (keys.Count == 1) {  		foreach (var item in items) {  			if (firstValue) {  				firstValue = false;  				BuildExpression (sb' GetPrecedence (p)' keys [0]);  				sb.Append (p.IsNot ? " NOT IN (" : " IN (");  			}  			var field = GetUnderlayingField (keys [0]);  			var value = field.MemberMapper.GetValue (item);  			if (value is ISqlExpression)  				BuildExpression (sb' (ISqlExpression)value);  			else  				BuildValue (sb' value);  			sb.Append ("' ");  		}  	} else {  		var len = sb.Length;  		var rem = 1;  		foreach (var item in items) {  			if (firstValue) {  				firstValue = false;  				sb.Append ('(');  			}  			foreach (var key in keys) {  				var field = GetUnderlayingField (key);  				var value = field.MemberMapper.GetValue (item);  				BuildExpression (sb' GetPrecedence (p)' key);  				if (value == null) {  					sb.Append (" IS NULL");  				} else {  					sb.Append (" = ");  					BuildValue (sb' value);  				}  				sb.Append (" AND ");  			}  			sb.Remove (sb.Length - 4' 4).Append ("OR ");  			if (sb.Length - len >= 50) {  				sb.AppendLine ();  				AppendIndent (sb);  				sb.Append (' ');  				len = sb.Length;  				rem = 5 + Indent;  			}  		}  		if (!firstValue)  			sb.Remove (sb.Length - rem' rem);  	}  	if (firstValue)  		BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  	else  		sb.Remove (sb.Length - 2' 2).Append (')');  } else {  	BuildInListValues (sb' p' items);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (p.Expr1 is ISqlTableSource) {  	var firstValue = true;  	var table = (ISqlTableSource)p.Expr1;  	var keys = table.GetKeys (true);  	if (keys == null || keys.Count == 0)  		throw new SqlException ("Cannot create IN expression.");  	if (keys.Count == 1) {  		foreach (var item in items) {  			if (firstValue) {  				firstValue = false;  				BuildExpression (sb' GetPrecedence (p)' keys [0]);  				sb.Append (p.IsNot ? " NOT IN (" : " IN (");  			}  			var field = GetUnderlayingField (keys [0]);  			var value = field.MemberMapper.GetValue (item);  			if (value is ISqlExpression)  				BuildExpression (sb' (ISqlExpression)value);  			else  				BuildValue (sb' value);  			sb.Append ("' ");  		}  	} else {  		var len = sb.Length;  		var rem = 1;  		foreach (var item in items) {  			if (firstValue) {  				firstValue = false;  				sb.Append ('(');  			}  			foreach (var key in keys) {  				var field = GetUnderlayingField (key);  				var value = field.MemberMapper.GetValue (item);  				BuildExpression (sb' GetPrecedence (p)' key);  				if (value == null) {  					sb.Append (" IS NULL");  				} else {  					sb.Append (" = ");  					BuildValue (sb' value);  				}  				sb.Append (" AND ");  			}  			sb.Remove (sb.Length - 4' 4).Append ("OR ");  			if (sb.Length - len >= 50) {  				sb.AppendLine ();  				AppendIndent (sb);  				sb.Append (' ');  				len = sb.Length;  				rem = 5 + Indent;  			}  		}  		if (!firstValue)  			sb.Remove (sb.Length - rem' rem);  	}  	if (firstValue)  		BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  	else  		sb.Remove (sb.Length - 2' 2).Append (')');  } else {  	BuildInListValues (sb' p' items);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (keys.Count == 1) {  	foreach (var item in items) {  		if (firstValue) {  			firstValue = false;  			BuildExpression (sb' GetPrecedence (p)' keys [0]);  			sb.Append (p.IsNot ? " NOT IN (" : " IN (");  		}  		var field = GetUnderlayingField (keys [0]);  		var value = field.MemberMapper.GetValue (item);  		if (value is ISqlExpression)  			BuildExpression (sb' (ISqlExpression)value);  		else  			BuildValue (sb' value);  		sb.Append ("' ");  	}  } else {  	var len = sb.Length;  	var rem = 1;  	foreach (var item in items) {  		if (firstValue) {  			firstValue = false;  			sb.Append ('(');  		}  		foreach (var key in keys) {  			var field = GetUnderlayingField (key);  			var value = field.MemberMapper.GetValue (item);  			BuildExpression (sb' GetPrecedence (p)' key);  			if (value == null) {  				sb.Append (" IS NULL");  			} else {  				sb.Append (" = ");  				BuildValue (sb' value);  			}  			sb.Append (" AND ");  		}  		sb.Remove (sb.Length - 4' 4).Append ("OR ");  		if (sb.Length - len >= 50) {  			sb.AppendLine ();  			AppendIndent (sb);  			sb.Append (' ');  			len = sb.Length;  			rem = 5 + Indent;  		}  	}  	if (!firstValue)  		sb.Remove (sb.Length - rem' rem);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (keys.Count == 1) {  	foreach (var item in items) {  		if (firstValue) {  			firstValue = false;  			BuildExpression (sb' GetPrecedence (p)' keys [0]);  			sb.Append (p.IsNot ? " NOT IN (" : " IN (");  		}  		var field = GetUnderlayingField (keys [0]);  		var value = field.MemberMapper.GetValue (item);  		if (value is ISqlExpression)  			BuildExpression (sb' (ISqlExpression)value);  		else  			BuildValue (sb' value);  		sb.Append ("' ");  	}  } else {  	var len = sb.Length;  	var rem = 1;  	foreach (var item in items) {  		if (firstValue) {  			firstValue = false;  			sb.Append ('(');  		}  		foreach (var key in keys) {  			var field = GetUnderlayingField (key);  			var value = field.MemberMapper.GetValue (item);  			BuildExpression (sb' GetPrecedence (p)' key);  			if (value == null) {  				sb.Append (" IS NULL");  			} else {  				sb.Append (" = ");  				BuildValue (sb' value);  			}  			sb.Append (" AND ");  		}  		sb.Remove (sb.Length - 4' 4).Append ("OR ");  		if (sb.Length - len >= 50) {  			sb.AppendLine ();  			AppendIndent (sb);  			sb.Append (' ');  			len = sb.Length;  			rem = 5 + Indent;  		}  	}  	if (!firstValue)  		sb.Remove (sb.Length - rem' rem);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (keys.Count == 1) {  	foreach (var item in items) {  		if (firstValue) {  			firstValue = false;  			BuildExpression (sb' GetPrecedence (p)' keys [0]);  			sb.Append (p.IsNot ? " NOT IN (" : " IN (");  		}  		var field = GetUnderlayingField (keys [0]);  		var value = field.MemberMapper.GetValue (item);  		if (value is ISqlExpression)  			BuildExpression (sb' (ISqlExpression)value);  		else  			BuildValue (sb' value);  		sb.Append ("' ");  	}  } else {  	var len = sb.Length;  	var rem = 1;  	foreach (var item in items) {  		if (firstValue) {  			firstValue = false;  			sb.Append ('(');  		}  		foreach (var key in keys) {  			var field = GetUnderlayingField (key);  			var value = field.MemberMapper.GetValue (item);  			BuildExpression (sb' GetPrecedence (p)' key);  			if (value == null) {  				sb.Append (" IS NULL");  			} else {  				sb.Append (" = ");  				BuildValue (sb' value);  			}  			sb.Append (" AND ");  		}  		sb.Remove (sb.Length - 4' 4).Append ("OR ");  		if (sb.Length - len >= 50) {  			sb.AppendLine ();  			AppendIndent (sb);  			sb.Append (' ');  			len = sb.Length;  			rem = 5 + Indent;  		}  	}  	if (!firstValue)  		sb.Remove (sb.Length - rem' rem);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (keys.Count == 1) {  	foreach (var item in items) {  		if (firstValue) {  			firstValue = false;  			BuildExpression (sb' GetPrecedence (p)' keys [0]);  			sb.Append (p.IsNot ? " NOT IN (" : " IN (");  		}  		var field = GetUnderlayingField (keys [0]);  		var value = field.MemberMapper.GetValue (item);  		if (value is ISqlExpression)  			BuildExpression (sb' (ISqlExpression)value);  		else  			BuildValue (sb' value);  		sb.Append ("' ");  	}  } else {  	var len = sb.Length;  	var rem = 1;  	foreach (var item in items) {  		if (firstValue) {  			firstValue = false;  			sb.Append ('(');  		}  		foreach (var key in keys) {  			var field = GetUnderlayingField (key);  			var value = field.MemberMapper.GetValue (item);  			BuildExpression (sb' GetPrecedence (p)' key);  			if (value == null) {  				sb.Append (" IS NULL");  			} else {  				sb.Append (" = ");  				BuildValue (sb' value);  			}  			sb.Append (" AND ");  		}  		sb.Remove (sb.Length - 4' 4).Append ("OR ");  		if (sb.Length - len >= 50) {  			sb.AppendLine ();  			AppendIndent (sb);  			sb.Append (' ');  			len = sb.Length;  			rem = 5 + Indent;  		}  	}  	if (!firstValue)  		sb.Remove (sb.Length - rem' rem);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: foreach (var item in items) {  	if (firstValue) {  		firstValue = false;  		sb.Append ('(');  	}  	foreach (var key in keys) {  		var field = GetUnderlayingField (key);  		var value = field.MemberMapper.GetValue (item);  		BuildExpression (sb' GetPrecedence (p)' key);  		if (value == null) {  			sb.Append (" IS NULL");  		} else {  			sb.Append (" = ");  			BuildValue (sb' value);  		}  		sb.Append (" AND ");  	}  	sb.Remove (sb.Length - 4' 4).Append ("OR ");  	if (sb.Length - len >= 50) {  		sb.AppendLine ();  		AppendIndent (sb);  		sb.Append (' ');  		len = sb.Length;  		rem = 5 + Indent;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: foreach (var item in items) {  	if (firstValue) {  		firstValue = false;  		sb.Append ('(');  	}  	foreach (var key in keys) {  		var field = GetUnderlayingField (key);  		var value = field.MemberMapper.GetValue (item);  		BuildExpression (sb' GetPrecedence (p)' key);  		if (value == null) {  			sb.Append (" IS NULL");  		} else {  			sb.Append (" = ");  			BuildValue (sb' value);  		}  		sb.Append (" AND ");  	}  	sb.Remove (sb.Length - 4' 4).Append ("OR ");  	if (sb.Length - len >= 50) {  		sb.AppendLine ();  		AppendIndent (sb);  		sb.Append (' ');  		len = sb.Length;  		rem = 5 + Indent;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: foreach (var item in items) {  	if (firstValue) {  		firstValue = false;  		sb.Append ('(');  	}  	foreach (var key in keys) {  		var field = GetUnderlayingField (key);  		var value = field.MemberMapper.GetValue (item);  		BuildExpression (sb' GetPrecedence (p)' key);  		if (value == null) {  			sb.Append (" IS NULL");  		} else {  			sb.Append (" = ");  			BuildValue (sb' value);  		}  		sb.Append (" AND ");  	}  	sb.Remove (sb.Length - 4' 4).Append ("OR ");  	if (sb.Length - len >= 50) {  		sb.AppendLine ();  		AppendIndent (sb);  		sb.Append (' ');  		len = sb.Length;  		rem = 5 + Indent;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: foreach (var item in items) {  	if (firstValue) {  		firstValue = false;  		sb.Append ('(');  	}  	foreach (var key in keys) {  		var field = GetUnderlayingField (key);  		var value = field.MemberMapper.GetValue (item);  		BuildExpression (sb' GetPrecedence (p)' key);  		if (value == null) {  			sb.Append (" IS NULL");  		} else {  			sb.Append (" = ");  			BuildValue (sb' value);  		}  		sb.Append (" AND ");  	}  	sb.Remove (sb.Length - 4' 4).Append ("OR ");  	if (sb.Length - len >= 50) {  		sb.AppendLine ();  		AppendIndent (sb);  		sb.Append (' ');  		len = sb.Length;  		rem = 5 + Indent;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: sb.Remove (sb.Length - 4' 4).Append ("OR ");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: sb.Remove (sb.Length - 4' 4).Append ("OR ");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (sb.Length - len >= 50) {  	sb.AppendLine ();  	AppendIndent (sb);  	sb.Append (' ');  	len = sb.Length;  	rem = 5 + Indent;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (sb.Length - len >= 50) {  	sb.AppendLine ();  	AppendIndent (sb);  	sb.Append (' ');  	len = sb.Length;  	rem = 5 + Indent;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: rem = 5 + Indent;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (firstValue)  	BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  else  	sb.Remove (sb.Length - 2' 2).Append (')');  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: if (firstValue)  	BuildPredicate (sb' new SqlQuery.Predicate.Expr (new SqlValue (p.IsNot)));  else  	sb.Remove (sb.Length - 2' 2).Append (')');  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2).Append (')');  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListPredicate,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2).Append (')');  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: foreach (var value in values) {  	if (count++ >= MaxInListValuesCount) {  		count = 1;  		longList = true;  		// start building next bucked  		firstValue = true;  		sb.Remove (sb.Length - 2' 2).Append (')');  		sb.Append (" OR ");  	}  	var val = value;  	if (val is IValueContainer)  		val = ((IValueContainer)value).Value;  	if (val == null) {  		hasNull = true;  		continue;  	}  	if (firstValue) {  		firstValue = false;  		BuildExpression (sb' GetPrecedence (predicate)' predicate.Expr1);  		sb.Append (predicate.IsNot ? " NOT IN (" : " IN (");  	}  	if (value is ISqlExpression)  		BuildExpression (sb' (ISqlExpression)value);  	else  		BuildValue (sb' value);  	sb.Append ("' ");  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: foreach (var value in values) {  	if (count++ >= MaxInListValuesCount) {  		count = 1;  		longList = true;  		// start building next bucked  		firstValue = true;  		sb.Remove (sb.Length - 2' 2).Append (')');  		sb.Append (" OR ");  	}  	var val = value;  	if (val is IValueContainer)  		val = ((IValueContainer)value).Value;  	if (val == null) {  		hasNull = true;  		continue;  	}  	if (firstValue) {  		firstValue = false;  		BuildExpression (sb' GetPrecedence (predicate)' predicate.Expr1);  		sb.Append (predicate.IsNot ? " NOT IN (" : " IN (");  	}  	if (value is ISqlExpression)  		BuildExpression (sb' (ISqlExpression)value);  	else  		BuildValue (sb' value);  	sb.Append ("' ");  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: if (count++ >= MaxInListValuesCount) {  	count = 1;  	longList = true;  	// start building next bucked  	firstValue = true;  	sb.Remove (sb.Length - 2' 2).Append (')');  	sb.Append (" OR ");  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: if (count++ >= MaxInListValuesCount) {  	count = 1;  	longList = true;  	// start building next bucked  	firstValue = true;  	sb.Remove (sb.Length - 2' 2).Append (')');  	sb.Append (" OR ");  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2).Append (')');  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2).Append (')');  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: if (firstValue) {  	BuildPredicate (sb' hasNull ? new SqlQuery.Predicate.IsNull (predicate.Expr1' predicate.IsNot) : new SqlQuery.Predicate.Expr (new SqlValue (predicate.IsNot)));  } else {  	sb.Remove (sb.Length - 2' 2).Append (')');  	if (hasNull) {  		sb.Insert (len' "(");  		sb.Append (" OR ");  		BuildPredicate (sb' new SqlQuery.Predicate.IsNull (predicate.Expr1' predicate.IsNot));  		sb.Append (")");  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: if (firstValue) {  	BuildPredicate (sb' hasNull ? new SqlQuery.Predicate.IsNull (predicate.Expr1' predicate.IsNot) : new SqlQuery.Predicate.Expr (new SqlValue (predicate.IsNot)));  } else {  	sb.Remove (sb.Length - 2' 2).Append (')');  	if (hasNull) {  		sb.Insert (len' "(");  		sb.Append (" OR ");  		BuildPredicate (sb' new SqlQuery.Predicate.IsNull (predicate.Expr1' predicate.IsNot));  		sb.Append (")");  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2).Append (')');  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildInListValues,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2).Append (')');  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildFunction,The following statement contains a magic number: if (func.Name == "CASE") {  	sb.Append (func.Name).AppendLine ();  	Indent++;  	var i = 0;  	for (; i < func.Parameters.Length - 1; i += 2) {  		AppendIndent (sb).Append ("WHEN ");  		var len = sb.Length;  		BuildExpression (sb' func.Parameters [i]);  		if (SqlExpression.NeedsEqual (func.Parameters [i])) {  			sb.Append (" = ");  			BuildValue (sb' true);  		}  		if (sb.Length - len > 20) {  			sb.AppendLine ();  			AppendIndent (sb).Append ("\tTHEN ");  		} else  			sb.Append (" THEN ");  		BuildExpression (sb' func.Parameters [i + 1]);  		sb.AppendLine ();  	}  	if (i < func.Parameters.Length) {  		AppendIndent (sb).Append ("ELSE ");  		BuildExpression (sb' func.Parameters [i]);  		sb.AppendLine ();  	}  	Indent--;  	AppendIndent (sb).Append ("END");  } else  	BuildFunction (sb' func.Name' func.Parameters);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildFunction,The following statement contains a magic number: if (func.Name == "CASE") {  	sb.Append (func.Name).AppendLine ();  	Indent++;  	var i = 0;  	for (; i < func.Parameters.Length - 1; i += 2) {  		AppendIndent (sb).Append ("WHEN ");  		var len = sb.Length;  		BuildExpression (sb' func.Parameters [i]);  		if (SqlExpression.NeedsEqual (func.Parameters [i])) {  			sb.Append (" = ");  			BuildValue (sb' true);  		}  		if (sb.Length - len > 20) {  			sb.AppendLine ();  			AppendIndent (sb).Append ("\tTHEN ");  		} else  			sb.Append (" THEN ");  		BuildExpression (sb' func.Parameters [i + 1]);  		sb.AppendLine ();  	}  	if (i < func.Parameters.Length) {  		AppendIndent (sb).Append ("ELSE ");  		BuildExpression (sb' func.Parameters [i]);  		sb.AppendLine ();  	}  	Indent--;  	AppendIndent (sb).Append ("END");  } else  	BuildFunction (sb' func.Name' func.Parameters);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildFunction,The following statement contains a magic number: for (; i < func.Parameters.Length - 1; i += 2) {  	AppendIndent (sb).Append ("WHEN ");  	var len = sb.Length;  	BuildExpression (sb' func.Parameters [i]);  	if (SqlExpression.NeedsEqual (func.Parameters [i])) {  		sb.Append (" = ");  		BuildValue (sb' true);  	}  	if (sb.Length - len > 20) {  		sb.AppendLine ();  		AppendIndent (sb).Append ("\tTHEN ");  	} else  		sb.Append (" THEN ");  	BuildExpression (sb' func.Parameters [i + 1]);  	sb.AppendLine ();  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildFunction,The following statement contains a magic number: for (; i < func.Parameters.Length - 1; i += 2) {  	AppendIndent (sb).Append ("WHEN ");  	var len = sb.Length;  	BuildExpression (sb' func.Parameters [i]);  	if (SqlExpression.NeedsEqual (func.Parameters [i])) {  		sb.Append (" = ");  		BuildValue (sb' true);  	}  	if (sb.Length - len > 20) {  		sb.AppendLine ();  		AppendIndent (sb).Append ("\tTHEN ");  	} else  		sb.Append (" THEN ");  	BuildExpression (sb' func.Parameters [i + 1]);  	sb.AppendLine ();  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildFunction,The following statement contains a magic number: i += 2
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildFunction,The following statement contains a magic number: if (sb.Length - len > 20) {  	sb.AppendLine ();  	AppendIndent (sb).Append ("\tTHEN ");  } else  	sb.Append (" THEN ");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,AlternativeBuildSql,The following statement contains a magic number: if (NeedSkip) {  	var aliases = GetTempAliases (2' "t");  	var rnaliase = GetTempAliases (1' "rn") [0];  	AppendIndent (sb).Append ("SELECT *").AppendLine ();  	AppendIndent (sb).Append ("FROM").AppendLine ();  	AppendIndent (sb).Append ("(").AppendLine ();  	Indent++;  	AppendIndent (sb).Append ("SELECT").AppendLine ();  	Indent++;  	AppendIndent (sb).AppendFormat ("{0}.*'"' aliases [0]).AppendLine ();  	AppendIndent (sb).Append ("ROW_NUMBER() OVER");  	if (!SqlQuery.OrderBy.IsEmpty && !implementOrderBy)  		sb.Append ("()");  	else {  		sb.AppendLine ();  		AppendIndent (sb).Append ("(").AppendLine ();  		Indent++;  		if (SqlQuery.OrderBy.IsEmpty) {  			AppendIndent (sb).Append ("ORDER BY").AppendLine ();  			BuildAliases (sb' aliases [0]' SqlQuery.Select.Columns.Take (1).ToList ()' null);  		} else  			BuildAlternativeOrderBy (sb' true);  		Indent--;  		AppendIndent (sb).Append (")");  	}  	sb.Append (" as ").Append (rnaliase).AppendLine ();  	Indent--;  	AppendIndent (sb).Append ("FROM").AppendLine ();  	AppendIndent (sb).Append ("(").AppendLine ();  	Indent++;  	buildSql (sb);  	Indent--;  	AppendIndent (sb).AppendFormat (") {0}"' aliases [0]).AppendLine ();  	Indent--;  	AppendIndent (sb).AppendFormat (") {0}"' aliases [1]).AppendLine ();  	AppendIndent (sb).Append ("WHERE").AppendLine ();  	Indent++;  	if (NeedTake) {  		var expr1 = Add (SqlQuery.Select.SkipValue' 1);  		var expr2 = Add<int> (SqlQuery.Select.SkipValue' SqlQuery.Select.TakeValue);  		if (expr1 is SqlValue && expr2 is SqlValue && Equals (((SqlValue)expr1).Value' ((SqlValue)expr2).Value)) {  			AppendIndent (sb).AppendFormat ("{0}.{1} = "' aliases [1]' rnaliase);  			BuildExpression (sb' expr1);  		} else {  			AppendIndent (sb).AppendFormat ("{0}.{1} BETWEEN "' aliases [1]' rnaliase);  			BuildExpression (sb' expr1);  			sb.Append (" AND ");  			BuildExpression (sb' expr2);  		}  	} else {  		AppendIndent (sb).AppendFormat ("{0}.{1} > "' aliases [1]' rnaliase);  		BuildExpression (sb' SqlQuery.Select.SkipValue);  	}  	sb.AppendLine ();  	Indent--;  } else  	buildSql (sb);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,AlternativeBuildSql2,The following statement contains a magic number: if (SqlQuery.OrderBy.IsEmpty) {  	Indent--;  	AppendIndent (sb).AppendFormat (") {0}"' aliases [2]).AppendLine ();  	AppendIndent (sb).Append ("ORDER BY").AppendLine ();  	BuildAliases (sb' aliases [2]' SqlQuery.Select.Columns' null);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,AlternativeBuildSql2,The following statement contains a magic number: if (SqlQuery.OrderBy.IsEmpty) {  	Indent--;  	AppendIndent (sb).AppendFormat (") {0}"' aliases [2]).AppendLine ();  	AppendIndent (sb).Append ("ORDER BY").AppendLine ();  	BuildAliases (sb' aliases [2]' SqlQuery.Select.Columns' null);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,AlternativeBuildSql2,The following statement contains a magic number: AppendIndent (sb).AppendFormat (") {0}"' aliases [2]).AppendLine ();  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,AlternativeBuildSql2,The following statement contains a magic number: BuildAliases (sb' aliases [2]' SqlQuery.Select.Columns' null);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,IsBooleanParameter,The following statement contains a magic number: if ((i % 2 == 1 || i == count - 1) && expr.SystemType == typeof(bool) || expr.SystemType == typeof(bool?)) {  	switch (expr.ElementType) {  	case QueryElementType.SearchCondition:  		return true;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: switch (table.ElementType) {  case QueryElementType.SqlTable: {  	var tbl = (SqlTable)table;  	var database = tbl.Database == null ? null : Convert (tbl.Database' ConvertType.NameToDatabase).ToString ();  	var owner = tbl.Owner == null ? null : Convert (tbl.Owner' ConvertType.NameToOwner).ToString ();  	var physicalName = tbl.PhysicalName == null ? null : Convert (tbl.PhysicalName' ConvertType.NameToQueryTable).ToString ();  	var sb = new StringBuilder ();  	if (tbl.SqlTableType == SqlTableType.Expression) {  		if (tbl.TableArguments == null)  			physicalName = tbl.PhysicalName;  		else {  			var values = new object[tbl.TableArguments.Length + 2];  			values [0] = physicalName;  			values [1] = Convert (alias' ConvertType.NameToQueryTableAlias);  			for (var i = 2; i < values.Length; i++) {  				var value = tbl.TableArguments [i - 2];  				sb.Length = 0;  				BuildExpression (sb' Precedence.Primary' value);  				values [i] = sb.ToString ();  			}  			physicalName = string.Format (tbl.Name' values);  			sb.Length = 0;  		}  	}  	BuildTableName (sb' database' owner' physicalName);  	if (tbl.SqlTableType == SqlTableType.Function) {  		sb.Append ('(');  		if (tbl.TableArguments != null && tbl.TableArguments.Length > 0) {  			var first = true;  			foreach (var arg in tbl.TableArguments) {  				if (!first)  					sb.Append ("' ");  				BuildExpression (sb' arg' true' !first);  				first = false;  			}  		}  		sb.Append (')');  	}  	return sb.ToString ();  }  case QueryElementType.TableSource:  	return GetTablePhysicalName (((SqlQuery.TableSource)table).Source' alias);  default:  	throw new InvalidOperationException ();  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: switch (table.ElementType) {  case QueryElementType.SqlTable: {  	var tbl = (SqlTable)table;  	var database = tbl.Database == null ? null : Convert (tbl.Database' ConvertType.NameToDatabase).ToString ();  	var owner = tbl.Owner == null ? null : Convert (tbl.Owner' ConvertType.NameToOwner).ToString ();  	var physicalName = tbl.PhysicalName == null ? null : Convert (tbl.PhysicalName' ConvertType.NameToQueryTable).ToString ();  	var sb = new StringBuilder ();  	if (tbl.SqlTableType == SqlTableType.Expression) {  		if (tbl.TableArguments == null)  			physicalName = tbl.PhysicalName;  		else {  			var values = new object[tbl.TableArguments.Length + 2];  			values [0] = physicalName;  			values [1] = Convert (alias' ConvertType.NameToQueryTableAlias);  			for (var i = 2; i < values.Length; i++) {  				var value = tbl.TableArguments [i - 2];  				sb.Length = 0;  				BuildExpression (sb' Precedence.Primary' value);  				values [i] = sb.ToString ();  			}  			physicalName = string.Format (tbl.Name' values);  			sb.Length = 0;  		}  	}  	BuildTableName (sb' database' owner' physicalName);  	if (tbl.SqlTableType == SqlTableType.Function) {  		sb.Append ('(');  		if (tbl.TableArguments != null && tbl.TableArguments.Length > 0) {  			var first = true;  			foreach (var arg in tbl.TableArguments) {  				if (!first)  					sb.Append ("' ");  				BuildExpression (sb' arg' true' !first);  				first = false;  			}  		}  		sb.Append (')');  	}  	return sb.ToString ();  }  case QueryElementType.TableSource:  	return GetTablePhysicalName (((SqlQuery.TableSource)table).Source' alias);  default:  	throw new InvalidOperationException ();  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: switch (table.ElementType) {  case QueryElementType.SqlTable: {  	var tbl = (SqlTable)table;  	var database = tbl.Database == null ? null : Convert (tbl.Database' ConvertType.NameToDatabase).ToString ();  	var owner = tbl.Owner == null ? null : Convert (tbl.Owner' ConvertType.NameToOwner).ToString ();  	var physicalName = tbl.PhysicalName == null ? null : Convert (tbl.PhysicalName' ConvertType.NameToQueryTable).ToString ();  	var sb = new StringBuilder ();  	if (tbl.SqlTableType == SqlTableType.Expression) {  		if (tbl.TableArguments == null)  			physicalName = tbl.PhysicalName;  		else {  			var values = new object[tbl.TableArguments.Length + 2];  			values [0] = physicalName;  			values [1] = Convert (alias' ConvertType.NameToQueryTableAlias);  			for (var i = 2; i < values.Length; i++) {  				var value = tbl.TableArguments [i - 2];  				sb.Length = 0;  				BuildExpression (sb' Precedence.Primary' value);  				values [i] = sb.ToString ();  			}  			physicalName = string.Format (tbl.Name' values);  			sb.Length = 0;  		}  	}  	BuildTableName (sb' database' owner' physicalName);  	if (tbl.SqlTableType == SqlTableType.Function) {  		sb.Append ('(');  		if (tbl.TableArguments != null && tbl.TableArguments.Length > 0) {  			var first = true;  			foreach (var arg in tbl.TableArguments) {  				if (!first)  					sb.Append ("' ");  				BuildExpression (sb' arg' true' !first);  				first = false;  			}  		}  		sb.Append (')');  	}  	return sb.ToString ();  }  case QueryElementType.TableSource:  	return GetTablePhysicalName (((SqlQuery.TableSource)table).Source' alias);  default:  	throw new InvalidOperationException ();  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: if (tbl.SqlTableType == SqlTableType.Expression) {  	if (tbl.TableArguments == null)  		physicalName = tbl.PhysicalName;  	else {  		var values = new object[tbl.TableArguments.Length + 2];  		values [0] = physicalName;  		values [1] = Convert (alias' ConvertType.NameToQueryTableAlias);  		for (var i = 2; i < values.Length; i++) {  			var value = tbl.TableArguments [i - 2];  			sb.Length = 0;  			BuildExpression (sb' Precedence.Primary' value);  			values [i] = sb.ToString ();  		}  		physicalName = string.Format (tbl.Name' values);  		sb.Length = 0;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: if (tbl.SqlTableType == SqlTableType.Expression) {  	if (tbl.TableArguments == null)  		physicalName = tbl.PhysicalName;  	else {  		var values = new object[tbl.TableArguments.Length + 2];  		values [0] = physicalName;  		values [1] = Convert (alias' ConvertType.NameToQueryTableAlias);  		for (var i = 2; i < values.Length; i++) {  			var value = tbl.TableArguments [i - 2];  			sb.Length = 0;  			BuildExpression (sb' Precedence.Primary' value);  			values [i] = sb.ToString ();  		}  		physicalName = string.Format (tbl.Name' values);  		sb.Length = 0;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: if (tbl.SqlTableType == SqlTableType.Expression) {  	if (tbl.TableArguments == null)  		physicalName = tbl.PhysicalName;  	else {  		var values = new object[tbl.TableArguments.Length + 2];  		values [0] = physicalName;  		values [1] = Convert (alias' ConvertType.NameToQueryTableAlias);  		for (var i = 2; i < values.Length; i++) {  			var value = tbl.TableArguments [i - 2];  			sb.Length = 0;  			BuildExpression (sb' Precedence.Primary' value);  			values [i] = sb.ToString ();  		}  		physicalName = string.Format (tbl.Name' values);  		sb.Length = 0;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: if (tbl.TableArguments == null)  	physicalName = tbl.PhysicalName;  else {  	var values = new object[tbl.TableArguments.Length + 2];  	values [0] = physicalName;  	values [1] = Convert (alias' ConvertType.NameToQueryTableAlias);  	for (var i = 2; i < values.Length; i++) {  		var value = tbl.TableArguments [i - 2];  		sb.Length = 0;  		BuildExpression (sb' Precedence.Primary' value);  		values [i] = sb.ToString ();  	}  	physicalName = string.Format (tbl.Name' values);  	sb.Length = 0;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: if (tbl.TableArguments == null)  	physicalName = tbl.PhysicalName;  else {  	var values = new object[tbl.TableArguments.Length + 2];  	values [0] = physicalName;  	values [1] = Convert (alias' ConvertType.NameToQueryTableAlias);  	for (var i = 2; i < values.Length; i++) {  		var value = tbl.TableArguments [i - 2];  		sb.Length = 0;  		BuildExpression (sb' Precedence.Primary' value);  		values [i] = sb.ToString ();  	}  	physicalName = string.Format (tbl.Name' values);  	sb.Length = 0;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: if (tbl.TableArguments == null)  	physicalName = tbl.PhysicalName;  else {  	var values = new object[tbl.TableArguments.Length + 2];  	values [0] = physicalName;  	values [1] = Convert (alias' ConvertType.NameToQueryTableAlias);  	for (var i = 2; i < values.Length; i++) {  		var value = tbl.TableArguments [i - 2];  		sb.Length = 0;  		BuildExpression (sb' Precedence.Primary' value);  		values [i] = sb.ToString ();  	}  	physicalName = string.Format (tbl.Name' values);  	sb.Length = 0;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: for (var i = 2; i < values.Length; i++) {  	var value = tbl.TableArguments [i - 2];  	sb.Length = 0;  	BuildExpression (sb' Precedence.Primary' value);  	values [i] = sb.ToString ();  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetTablePhysicalName,The following statement contains a magic number: for (var i = 2; i < values.Length; i++) {  	var value = tbl.TableArguments [i - 2];  	sb.Length = 0;  	BuildExpression (sb' Precedence.Primary' value);  	values [i] = sb.ToString ();  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertConvertion,The following statement contains a magic number: if (to.Type == typeof(object))  	return func.Parameters [2];  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertConvertion,The following statement contains a magic number: return func.Parameters [2];  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertConvertion,The following statement contains a magic number: if (to.Precision > 0) {  	var maxPrecision = GetMaxPrecision (from);  	var maxScale = GetMaxScale (from);  	var newPrecision = maxPrecision >= 0 ? Math.Min (to.Precision' maxPrecision) : to.Precision;  	var newScale = maxScale >= 0 ? Math.Min (to.Scale' maxScale) : to.Scale;  	if (to.Precision != newPrecision || to.Scale != newScale)  		to = new SqlDataType (to.SqlDbType' to.Type' newPrecision' newScale);  } else if (to.Length > 0) {  	var maxLength = to.Type == typeof(string) ? GetMaxDisplaySize (from) : GetMaxLength (from);  	var newLength = maxLength >= 0 ? Math.Min (to.Length' maxLength) : to.Length;  	if (to.Length != newLength)  		to = new SqlDataType (to.SqlDbType' to.Type' newLength);  } else if (from.Type == typeof(short) && to.Type == typeof(int))  	return func.Parameters [2];  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertConvertion,The following statement contains a magic number: if (to.Length > 0) {  	var maxLength = to.Type == typeof(string) ? GetMaxDisplaySize (from) : GetMaxLength (from);  	var newLength = maxLength >= 0 ? Math.Min (to.Length' maxLength) : to.Length;  	if (to.Length != newLength)  		to = new SqlDataType (to.SqlDbType' to.Type' newLength);  } else if (from.Type == typeof(short) && to.Type == typeof(int))  	return func.Parameters [2];  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertConvertion,The following statement contains a magic number: if (from.Type == typeof(short) && to.Type == typeof(int))  	return func.Parameters [2];  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertConvertion,The following statement contains a magic number: return func.Parameters [2];  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertConvertion,The following statement contains a magic number: return ConvertExpression (new SqlFunction (func.SystemType' "Convert"' to' func.Parameters [2]));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType) {  case QueryElementType.SqlBinaryExpression:  	#region SqlBinaryExpression  	{  		var be = (SqlBinaryExpression)expression;  		switch (be.Operation) {  		case "+":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  					return be.Expr2;  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				} else if (v2.Value is string) {  					if ((string)v2.Value == "")  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var value = ((SqlValue)be1.Expr2).Value;  							if (value is string)  								return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value + (int)v2.Value);  				if (v1.Value is string || v2.Value is string)  					return new SqlValue (v1.Value.ToString () + v2.Value);  			}  			if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  				var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  			}  			if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  				var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  			}  			break;  		case "-":  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value - (int)v2.Value);  			}  			break;  		case "*":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int) {  					var v1v = (int)v1.Value;  					switch (v1v) {  					case 0:  						return new SqlValue (0);  					case 1:  						return be.Expr2;  					default: {  						var be2 = be.Expr2 as SqlBinaryExpression;  						if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  							var be2v1 = be2.Expr1 as SqlValue;  							if (be2v1.Value is int)  								return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  						}  						break;  					}  					}  				}  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int && (int)v2.Value == 1)  					return be.Expr1;  				if (v2.Value is int && (int)v2.Value == 0)  					return new SqlValue (0);  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int) {  					if (v2.Value is int)  						return new SqlValue ((int)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((int)v1.Value * (double)v2.Value);  				} else if (v1.Value is double) {  					if (v2.Value is int)  						return new SqlValue ((double)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((double)v1.Value * (double)v2.Value);  				}  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SqlFunction:  	#region SqlFunction  	{  		var func = (SqlFunction)expression;  		switch (func.Name) {  		case "ConvertToCaseCompareTo":  			return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  		case "$Convert$":  			return ConvertConvertion (func);  		case "Average":  			return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  		case "Max":  		case "Min": {  			if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  				return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  			}  			break;  		}  		case "CASE":  			{  				var parms = func.Parameters;  				var len = parms.Length;  				for (var i = 0; i < parms.Length - 1; i += 2) {  					var value = parms [i] as SqlValue;  					if (value != null) {  						if ((bool)value.Value == false) {  							var newParms = new ISqlExpression[parms.Length - 2];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  							parms = newParms;  							i -= 2;  						} else {  							var newParms = new ISqlExpression[i + 1];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							newParms [i] = parms [i + 1];  							parms = newParms;  							break;  						}  					}  				}  				if (parms.Length == 1)  					return parms [0];  				if (parms.Length != len)  					return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  			}  			break;  		case "Convert":  			{  				var from = func.Parameters [1] as SqlFunction;  				var typef = TypeHelper.GetUnderlyingType (func.SystemType);  				if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  					return from.Parameters [1];  				var fe = func.Parameters [1] as SqlExpression;  				if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  					return fe.Parameters [0];  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SearchCondition:  	SqlQuery.OptimizeSearchCondition ((SqlQuery.SearchCondition)expression);  	break;  case QueryElementType.SqlExpression:  	{  		var se = (SqlExpression)expression;  		if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters [0] != null)  			return se.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType) {  case QueryElementType.SqlBinaryExpression:  	#region SqlBinaryExpression  	{  		var be = (SqlBinaryExpression)expression;  		switch (be.Operation) {  		case "+":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  					return be.Expr2;  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				} else if (v2.Value is string) {  					if ((string)v2.Value == "")  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var value = ((SqlValue)be1.Expr2).Value;  							if (value is string)  								return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value + (int)v2.Value);  				if (v1.Value is string || v2.Value is string)  					return new SqlValue (v1.Value.ToString () + v2.Value);  			}  			if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  				var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  			}  			if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  				var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  			}  			break;  		case "-":  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value - (int)v2.Value);  			}  			break;  		case "*":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int) {  					var v1v = (int)v1.Value;  					switch (v1v) {  					case 0:  						return new SqlValue (0);  					case 1:  						return be.Expr2;  					default: {  						var be2 = be.Expr2 as SqlBinaryExpression;  						if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  							var be2v1 = be2.Expr1 as SqlValue;  							if (be2v1.Value is int)  								return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  						}  						break;  					}  					}  				}  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int && (int)v2.Value == 1)  					return be.Expr1;  				if (v2.Value is int && (int)v2.Value == 0)  					return new SqlValue (0);  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int) {  					if (v2.Value is int)  						return new SqlValue ((int)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((int)v1.Value * (double)v2.Value);  				} else if (v1.Value is double) {  					if (v2.Value is int)  						return new SqlValue ((double)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((double)v1.Value * (double)v2.Value);  				}  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SqlFunction:  	#region SqlFunction  	{  		var func = (SqlFunction)expression;  		switch (func.Name) {  		case "ConvertToCaseCompareTo":  			return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  		case "$Convert$":  			return ConvertConvertion (func);  		case "Average":  			return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  		case "Max":  		case "Min": {  			if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  				return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  			}  			break;  		}  		case "CASE":  			{  				var parms = func.Parameters;  				var len = parms.Length;  				for (var i = 0; i < parms.Length - 1; i += 2) {  					var value = parms [i] as SqlValue;  					if (value != null) {  						if ((bool)value.Value == false) {  							var newParms = new ISqlExpression[parms.Length - 2];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  							parms = newParms;  							i -= 2;  						} else {  							var newParms = new ISqlExpression[i + 1];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							newParms [i] = parms [i + 1];  							parms = newParms;  							break;  						}  					}  				}  				if (parms.Length == 1)  					return parms [0];  				if (parms.Length != len)  					return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  			}  			break;  		case "Convert":  			{  				var from = func.Parameters [1] as SqlFunction;  				var typef = TypeHelper.GetUnderlyingType (func.SystemType);  				if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  					return from.Parameters [1];  				var fe = func.Parameters [1] as SqlExpression;  				if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  					return fe.Parameters [0];  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SearchCondition:  	SqlQuery.OptimizeSearchCondition ((SqlQuery.SearchCondition)expression);  	break;  case QueryElementType.SqlExpression:  	{  		var se = (SqlExpression)expression;  		if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters [0] != null)  			return se.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType) {  case QueryElementType.SqlBinaryExpression:  	#region SqlBinaryExpression  	{  		var be = (SqlBinaryExpression)expression;  		switch (be.Operation) {  		case "+":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  					return be.Expr2;  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				} else if (v2.Value is string) {  					if ((string)v2.Value == "")  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var value = ((SqlValue)be1.Expr2).Value;  							if (value is string)  								return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value + (int)v2.Value);  				if (v1.Value is string || v2.Value is string)  					return new SqlValue (v1.Value.ToString () + v2.Value);  			}  			if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  				var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  			}  			if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  				var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  			}  			break;  		case "-":  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value - (int)v2.Value);  			}  			break;  		case "*":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int) {  					var v1v = (int)v1.Value;  					switch (v1v) {  					case 0:  						return new SqlValue (0);  					case 1:  						return be.Expr2;  					default: {  						var be2 = be.Expr2 as SqlBinaryExpression;  						if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  							var be2v1 = be2.Expr1 as SqlValue;  							if (be2v1.Value is int)  								return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  						}  						break;  					}  					}  				}  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int && (int)v2.Value == 1)  					return be.Expr1;  				if (v2.Value is int && (int)v2.Value == 0)  					return new SqlValue (0);  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int) {  					if (v2.Value is int)  						return new SqlValue ((int)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((int)v1.Value * (double)v2.Value);  				} else if (v1.Value is double) {  					if (v2.Value is int)  						return new SqlValue ((double)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((double)v1.Value * (double)v2.Value);  				}  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SqlFunction:  	#region SqlFunction  	{  		var func = (SqlFunction)expression;  		switch (func.Name) {  		case "ConvertToCaseCompareTo":  			return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  		case "$Convert$":  			return ConvertConvertion (func);  		case "Average":  			return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  		case "Max":  		case "Min": {  			if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  				return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  			}  			break;  		}  		case "CASE":  			{  				var parms = func.Parameters;  				var len = parms.Length;  				for (var i = 0; i < parms.Length - 1; i += 2) {  					var value = parms [i] as SqlValue;  					if (value != null) {  						if ((bool)value.Value == false) {  							var newParms = new ISqlExpression[parms.Length - 2];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  							parms = newParms;  							i -= 2;  						} else {  							var newParms = new ISqlExpression[i + 1];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							newParms [i] = parms [i + 1];  							parms = newParms;  							break;  						}  					}  				}  				if (parms.Length == 1)  					return parms [0];  				if (parms.Length != len)  					return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  			}  			break;  		case "Convert":  			{  				var from = func.Parameters [1] as SqlFunction;  				var typef = TypeHelper.GetUnderlyingType (func.SystemType);  				if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  					return from.Parameters [1];  				var fe = func.Parameters [1] as SqlExpression;  				if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  					return fe.Parameters [0];  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SearchCondition:  	SqlQuery.OptimizeSearchCondition ((SqlQuery.SearchCondition)expression);  	break;  case QueryElementType.SqlExpression:  	{  		var se = (SqlExpression)expression;  		if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters [0] != null)  			return se.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType) {  case QueryElementType.SqlBinaryExpression:  	#region SqlBinaryExpression  	{  		var be = (SqlBinaryExpression)expression;  		switch (be.Operation) {  		case "+":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  					return be.Expr2;  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				} else if (v2.Value is string) {  					if ((string)v2.Value == "")  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var value = ((SqlValue)be1.Expr2).Value;  							if (value is string)  								return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value + (int)v2.Value);  				if (v1.Value is string || v2.Value is string)  					return new SqlValue (v1.Value.ToString () + v2.Value);  			}  			if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  				var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  			}  			if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  				var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  			}  			break;  		case "-":  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value - (int)v2.Value);  			}  			break;  		case "*":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int) {  					var v1v = (int)v1.Value;  					switch (v1v) {  					case 0:  						return new SqlValue (0);  					case 1:  						return be.Expr2;  					default: {  						var be2 = be.Expr2 as SqlBinaryExpression;  						if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  							var be2v1 = be2.Expr1 as SqlValue;  							if (be2v1.Value is int)  								return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  						}  						break;  					}  					}  				}  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int && (int)v2.Value == 1)  					return be.Expr1;  				if (v2.Value is int && (int)v2.Value == 0)  					return new SqlValue (0);  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int) {  					if (v2.Value is int)  						return new SqlValue ((int)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((int)v1.Value * (double)v2.Value);  				} else if (v1.Value is double) {  					if (v2.Value is int)  						return new SqlValue ((double)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((double)v1.Value * (double)v2.Value);  				}  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SqlFunction:  	#region SqlFunction  	{  		var func = (SqlFunction)expression;  		switch (func.Name) {  		case "ConvertToCaseCompareTo":  			return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  		case "$Convert$":  			return ConvertConvertion (func);  		case "Average":  			return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  		case "Max":  		case "Min": {  			if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  				return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  			}  			break;  		}  		case "CASE":  			{  				var parms = func.Parameters;  				var len = parms.Length;  				for (var i = 0; i < parms.Length - 1; i += 2) {  					var value = parms [i] as SqlValue;  					if (value != null) {  						if ((bool)value.Value == false) {  							var newParms = new ISqlExpression[parms.Length - 2];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  							parms = newParms;  							i -= 2;  						} else {  							var newParms = new ISqlExpression[i + 1];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							newParms [i] = parms [i + 1];  							parms = newParms;  							break;  						}  					}  				}  				if (parms.Length == 1)  					return parms [0];  				if (parms.Length != len)  					return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  			}  			break;  		case "Convert":  			{  				var from = func.Parameters [1] as SqlFunction;  				var typef = TypeHelper.GetUnderlyingType (func.SystemType);  				if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  					return from.Parameters [1];  				var fe = func.Parameters [1] as SqlExpression;  				if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  					return fe.Parameters [0];  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SearchCondition:  	SqlQuery.OptimizeSearchCondition ((SqlQuery.SearchCondition)expression);  	break;  case QueryElementType.SqlExpression:  	{  		var se = (SqlExpression)expression;  		if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters [0] != null)  			return se.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType) {  case QueryElementType.SqlBinaryExpression:  	#region SqlBinaryExpression  	{  		var be = (SqlBinaryExpression)expression;  		switch (be.Operation) {  		case "+":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  					return be.Expr2;  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				} else if (v2.Value is string) {  					if ((string)v2.Value == "")  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var value = ((SqlValue)be1.Expr2).Value;  							if (value is string)  								return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value + (int)v2.Value);  				if (v1.Value is string || v2.Value is string)  					return new SqlValue (v1.Value.ToString () + v2.Value);  			}  			if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  				var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  			}  			if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  				var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  			}  			break;  		case "-":  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value - (int)v2.Value);  			}  			break;  		case "*":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int) {  					var v1v = (int)v1.Value;  					switch (v1v) {  					case 0:  						return new SqlValue (0);  					case 1:  						return be.Expr2;  					default: {  						var be2 = be.Expr2 as SqlBinaryExpression;  						if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  							var be2v1 = be2.Expr1 as SqlValue;  							if (be2v1.Value is int)  								return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  						}  						break;  					}  					}  				}  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int && (int)v2.Value == 1)  					return be.Expr1;  				if (v2.Value is int && (int)v2.Value == 0)  					return new SqlValue (0);  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int) {  					if (v2.Value is int)  						return new SqlValue ((int)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((int)v1.Value * (double)v2.Value);  				} else if (v1.Value is double) {  					if (v2.Value is int)  						return new SqlValue ((double)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((double)v1.Value * (double)v2.Value);  				}  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SqlFunction:  	#region SqlFunction  	{  		var func = (SqlFunction)expression;  		switch (func.Name) {  		case "ConvertToCaseCompareTo":  			return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  		case "$Convert$":  			return ConvertConvertion (func);  		case "Average":  			return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  		case "Max":  		case "Min": {  			if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  				return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  			}  			break;  		}  		case "CASE":  			{  				var parms = func.Parameters;  				var len = parms.Length;  				for (var i = 0; i < parms.Length - 1; i += 2) {  					var value = parms [i] as SqlValue;  					if (value != null) {  						if ((bool)value.Value == false) {  							var newParms = new ISqlExpression[parms.Length - 2];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  							parms = newParms;  							i -= 2;  						} else {  							var newParms = new ISqlExpression[i + 1];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							newParms [i] = parms [i + 1];  							parms = newParms;  							break;  						}  					}  				}  				if (parms.Length == 1)  					return parms [0];  				if (parms.Length != len)  					return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  			}  			break;  		case "Convert":  			{  				var from = func.Parameters [1] as SqlFunction;  				var typef = TypeHelper.GetUnderlyingType (func.SystemType);  				if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  					return from.Parameters [1];  				var fe = func.Parameters [1] as SqlExpression;  				if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  					return fe.Parameters [0];  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SearchCondition:  	SqlQuery.OptimizeSearchCondition ((SqlQuery.SearchCondition)expression);  	break;  case QueryElementType.SqlExpression:  	{  		var se = (SqlExpression)expression;  		if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters [0] != null)  			return se.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType) {  case QueryElementType.SqlBinaryExpression:  	#region SqlBinaryExpression  	{  		var be = (SqlBinaryExpression)expression;  		switch (be.Operation) {  		case "+":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  					return be.Expr2;  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				} else if (v2.Value is string) {  					if ((string)v2.Value == "")  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var value = ((SqlValue)be1.Expr2).Value;  							if (value is string)  								return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value + (int)v2.Value);  				if (v1.Value is string || v2.Value is string)  					return new SqlValue (v1.Value.ToString () + v2.Value);  			}  			if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  				var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  			}  			if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  				var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  			}  			break;  		case "-":  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value - (int)v2.Value);  			}  			break;  		case "*":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int) {  					var v1v = (int)v1.Value;  					switch (v1v) {  					case 0:  						return new SqlValue (0);  					case 1:  						return be.Expr2;  					default: {  						var be2 = be.Expr2 as SqlBinaryExpression;  						if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  							var be2v1 = be2.Expr1 as SqlValue;  							if (be2v1.Value is int)  								return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  						}  						break;  					}  					}  				}  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int && (int)v2.Value == 1)  					return be.Expr1;  				if (v2.Value is int && (int)v2.Value == 0)  					return new SqlValue (0);  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int) {  					if (v2.Value is int)  						return new SqlValue ((int)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((int)v1.Value * (double)v2.Value);  				} else if (v1.Value is double) {  					if (v2.Value is int)  						return new SqlValue ((double)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((double)v1.Value * (double)v2.Value);  				}  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SqlFunction:  	#region SqlFunction  	{  		var func = (SqlFunction)expression;  		switch (func.Name) {  		case "ConvertToCaseCompareTo":  			return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  		case "$Convert$":  			return ConvertConvertion (func);  		case "Average":  			return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  		case "Max":  		case "Min": {  			if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  				return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  			}  			break;  		}  		case "CASE":  			{  				var parms = func.Parameters;  				var len = parms.Length;  				for (var i = 0; i < parms.Length - 1; i += 2) {  					var value = parms [i] as SqlValue;  					if (value != null) {  						if ((bool)value.Value == false) {  							var newParms = new ISqlExpression[parms.Length - 2];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  							parms = newParms;  							i -= 2;  						} else {  							var newParms = new ISqlExpression[i + 1];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							newParms [i] = parms [i + 1];  							parms = newParms;  							break;  						}  					}  				}  				if (parms.Length == 1)  					return parms [0];  				if (parms.Length != len)  					return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  			}  			break;  		case "Convert":  			{  				var from = func.Parameters [1] as SqlFunction;  				var typef = TypeHelper.GetUnderlyingType (func.SystemType);  				if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  					return from.Parameters [1];  				var fe = func.Parameters [1] as SqlExpression;  				if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  					return fe.Parameters [0];  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SearchCondition:  	SqlQuery.OptimizeSearchCondition ((SqlQuery.SearchCondition)expression);  	break;  case QueryElementType.SqlExpression:  	{  		var se = (SqlExpression)expression;  		if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters [0] != null)  			return se.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType) {  case QueryElementType.SqlBinaryExpression:  	#region SqlBinaryExpression  	{  		var be = (SqlBinaryExpression)expression;  		switch (be.Operation) {  		case "+":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  					return be.Expr2;  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				} else if (v2.Value is string) {  					if ((string)v2.Value == "")  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var value = ((SqlValue)be1.Expr2).Value;  							if (value is string)  								return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value + (int)v2.Value);  				if (v1.Value is string || v2.Value is string)  					return new SqlValue (v1.Value.ToString () + v2.Value);  			}  			if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  				var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  			}  			if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  				var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  			}  			break;  		case "-":  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value - (int)v2.Value);  			}  			break;  		case "*":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int) {  					var v1v = (int)v1.Value;  					switch (v1v) {  					case 0:  						return new SqlValue (0);  					case 1:  						return be.Expr2;  					default: {  						var be2 = be.Expr2 as SqlBinaryExpression;  						if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  							var be2v1 = be2.Expr1 as SqlValue;  							if (be2v1.Value is int)  								return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  						}  						break;  					}  					}  				}  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int && (int)v2.Value == 1)  					return be.Expr1;  				if (v2.Value is int && (int)v2.Value == 0)  					return new SqlValue (0);  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int) {  					if (v2.Value is int)  						return new SqlValue ((int)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((int)v1.Value * (double)v2.Value);  				} else if (v1.Value is double) {  					if (v2.Value is int)  						return new SqlValue ((double)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((double)v1.Value * (double)v2.Value);  				}  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SqlFunction:  	#region SqlFunction  	{  		var func = (SqlFunction)expression;  		switch (func.Name) {  		case "ConvertToCaseCompareTo":  			return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  		case "$Convert$":  			return ConvertConvertion (func);  		case "Average":  			return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  		case "Max":  		case "Min": {  			if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  				return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  			}  			break;  		}  		case "CASE":  			{  				var parms = func.Parameters;  				var len = parms.Length;  				for (var i = 0; i < parms.Length - 1; i += 2) {  					var value = parms [i] as SqlValue;  					if (value != null) {  						if ((bool)value.Value == false) {  							var newParms = new ISqlExpression[parms.Length - 2];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  							parms = newParms;  							i -= 2;  						} else {  							var newParms = new ISqlExpression[i + 1];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							newParms [i] = parms [i + 1];  							parms = newParms;  							break;  						}  					}  				}  				if (parms.Length == 1)  					return parms [0];  				if (parms.Length != len)  					return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  			}  			break;  		case "Convert":  			{  				var from = func.Parameters [1] as SqlFunction;  				var typef = TypeHelper.GetUnderlyingType (func.SystemType);  				if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  					return from.Parameters [1];  				var fe = func.Parameters [1] as SqlExpression;  				if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  					return fe.Parameters [0];  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SearchCondition:  	SqlQuery.OptimizeSearchCondition ((SqlQuery.SearchCondition)expression);  	break;  case QueryElementType.SqlExpression:  	{  		var se = (SqlExpression)expression;  		if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters [0] != null)  			return se.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType) {  case QueryElementType.SqlBinaryExpression:  	#region SqlBinaryExpression  	{  		var be = (SqlBinaryExpression)expression;  		switch (be.Operation) {  		case "+":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  					return be.Expr2;  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				} else if (v2.Value is string) {  					if ((string)v2.Value == "")  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var value = ((SqlValue)be1.Expr2).Value;  							if (value is string)  								return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value + (int)v2.Value);  				if (v1.Value is string || v2.Value is string)  					return new SqlValue (v1.Value.ToString () + v2.Value);  			}  			if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  				var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  			}  			if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  				var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  			}  			break;  		case "-":  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value - (int)v2.Value);  			}  			break;  		case "*":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int) {  					var v1v = (int)v1.Value;  					switch (v1v) {  					case 0:  						return new SqlValue (0);  					case 1:  						return be.Expr2;  					default: {  						var be2 = be.Expr2 as SqlBinaryExpression;  						if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  							var be2v1 = be2.Expr1 as SqlValue;  							if (be2v1.Value is int)  								return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  						}  						break;  					}  					}  				}  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int && (int)v2.Value == 1)  					return be.Expr1;  				if (v2.Value is int && (int)v2.Value == 0)  					return new SqlValue (0);  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int) {  					if (v2.Value is int)  						return new SqlValue ((int)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((int)v1.Value * (double)v2.Value);  				} else if (v1.Value is double) {  					if (v2.Value is int)  						return new SqlValue ((double)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((double)v1.Value * (double)v2.Value);  				}  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SqlFunction:  	#region SqlFunction  	{  		var func = (SqlFunction)expression;  		switch (func.Name) {  		case "ConvertToCaseCompareTo":  			return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  		case "$Convert$":  			return ConvertConvertion (func);  		case "Average":  			return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  		case "Max":  		case "Min": {  			if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  				return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  			}  			break;  		}  		case "CASE":  			{  				var parms = func.Parameters;  				var len = parms.Length;  				for (var i = 0; i < parms.Length - 1; i += 2) {  					var value = parms [i] as SqlValue;  					if (value != null) {  						if ((bool)value.Value == false) {  							var newParms = new ISqlExpression[parms.Length - 2];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  							parms = newParms;  							i -= 2;  						} else {  							var newParms = new ISqlExpression[i + 1];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							newParms [i] = parms [i + 1];  							parms = newParms;  							break;  						}  					}  				}  				if (parms.Length == 1)  					return parms [0];  				if (parms.Length != len)  					return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  			}  			break;  		case "Convert":  			{  				var from = func.Parameters [1] as SqlFunction;  				var typef = TypeHelper.GetUnderlyingType (func.SystemType);  				if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  					return from.Parameters [1];  				var fe = func.Parameters [1] as SqlExpression;  				if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  					return fe.Parameters [0];  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SearchCondition:  	SqlQuery.OptimizeSearchCondition ((SqlQuery.SearchCondition)expression);  	break;  case QueryElementType.SqlExpression:  	{  		var se = (SqlExpression)expression;  		if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters [0] != null)  			return se.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (expression.ElementType) {  case QueryElementType.SqlBinaryExpression:  	#region SqlBinaryExpression  	{  		var be = (SqlBinaryExpression)expression;  		switch (be.Operation) {  		case "+":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  					return be.Expr2;  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				} else if (v2.Value is string) {  					if ((string)v2.Value == "")  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var value = ((SqlValue)be1.Expr2).Value;  							if (value is string)  								return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value + (int)v2.Value);  				if (v1.Value is string || v2.Value is string)  					return new SqlValue (v1.Value.ToString () + v2.Value);  			}  			if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  				var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  			}  			if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  				var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  				if (len <= 0)  					len = 100;  				return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  			}  			break;  		case "-":  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int) {  					if ((int)v2.Value == 0)  						return be.Expr1;  					if (be.Expr1 is SqlBinaryExpression) {  						var be1 = (SqlBinaryExpression)be.Expr1;  						if (be1.Expr2 is SqlValue) {  							var be1v2 = (SqlValue)be1.Expr2;  							if (be1v2.Value is int) {  								switch (be1.Operation) {  								case "+": {  									var value = (int)be1v2.Value - (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "-";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								case "-": {  									var value = (int)be1v2.Value + (int)v2.Value;  									var oper = be1.Operation;  									if (value < 0) {  										value = -value;  										oper = "+";  									}  									return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  								}  								}  							}  						}  					}  				}  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int && v2.Value is int)  					return new SqlValue ((int)v1.Value - (int)v2.Value);  			}  			break;  		case "*":  			if (be.Expr1 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				if (v1.Value is int) {  					var v1v = (int)v1.Value;  					switch (v1v) {  					case 0:  						return new SqlValue (0);  					case 1:  						return be.Expr2;  					default: {  						var be2 = be.Expr2 as SqlBinaryExpression;  						if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  							var be2v1 = be2.Expr1 as SqlValue;  							if (be2v1.Value is int)  								return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  						}  						break;  					}  					}  				}  			}  			if (be.Expr2 is SqlValue) {  				var v2 = (SqlValue)be.Expr2;  				if (v2.Value is int && (int)v2.Value == 1)  					return be.Expr1;  				if (v2.Value is int && (int)v2.Value == 0)  					return new SqlValue (0);  			}  			if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  				var v1 = (SqlValue)be.Expr1;  				var v2 = (SqlValue)be.Expr2;  				if (v1.Value is int) {  					if (v2.Value is int)  						return new SqlValue ((int)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((int)v1.Value * (double)v2.Value);  				} else if (v1.Value is double) {  					if (v2.Value is int)  						return new SqlValue ((double)v1.Value * (int)v2.Value);  					if (v2.Value is double)  						return new SqlValue ((double)v1.Value * (double)v2.Value);  				}  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SqlFunction:  	#region SqlFunction  	{  		var func = (SqlFunction)expression;  		switch (func.Name) {  		case "ConvertToCaseCompareTo":  			return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  		case "$Convert$":  			return ConvertConvertion (func);  		case "Average":  			return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  		case "Max":  		case "Min": {  			if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  				return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  			}  			break;  		}  		case "CASE":  			{  				var parms = func.Parameters;  				var len = parms.Length;  				for (var i = 0; i < parms.Length - 1; i += 2) {  					var value = parms [i] as SqlValue;  					if (value != null) {  						if ((bool)value.Value == false) {  							var newParms = new ISqlExpression[parms.Length - 2];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  							parms = newParms;  							i -= 2;  						} else {  							var newParms = new ISqlExpression[i + 1];  							if (i != 0)  								Array.Copy (parms' 0' newParms' 0' i);  							newParms [i] = parms [i + 1];  							parms = newParms;  							break;  						}  					}  				}  				if (parms.Length == 1)  					return parms [0];  				if (parms.Length != len)  					return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  			}  			break;  		case "Convert":  			{  				var from = func.Parameters [1] as SqlFunction;  				var typef = TypeHelper.GetUnderlyingType (func.SystemType);  				if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  					return from.Parameters [1];  				var fe = func.Parameters [1] as SqlExpression;  				if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  					return fe.Parameters [0];  			}  			break;  		}  	}  	#endregion  	break;  case QueryElementType.SearchCondition:  	SqlQuery.OptimizeSearchCondition ((SqlQuery.SearchCondition)expression);  	break;  case QueryElementType.SqlExpression:  	{  		var se = (SqlExpression)expression;  		if (se.Expr == "{0}" && se.Parameters.Length == 1 && se.Parameters [0] != null)  			return se.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (be.Operation) {  case "+":  	if (be.Expr1 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  			return be.Expr2;  	}  	if (be.Expr2 is SqlValue) {  		var v2 = (SqlValue)be.Expr2;  		if (v2.Value is int) {  			if ((int)v2.Value == 0)  				return be.Expr1;  			if (be.Expr1 is SqlBinaryExpression) {  				var be1 = (SqlBinaryExpression)be.Expr1;  				if (be1.Expr2 is SqlValue) {  					var be1v2 = (SqlValue)be1.Expr2;  					if (be1v2.Value is int) {  						switch (be1.Operation) {  						case "+": {  							var value = (int)be1v2.Value + (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "-";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						case "-": {  							var value = (int)be1v2.Value - (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "+";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						}  					}  				}  			}  		} else if (v2.Value is string) {  			if ((string)v2.Value == "")  				return be.Expr1;  			if (be.Expr1 is SqlBinaryExpression) {  				var be1 = (SqlBinaryExpression)be.Expr1;  				if (be1.Expr2 is SqlValue) {  					var value = ((SqlValue)be1.Expr2).Value;  					if (value is string)  						return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  				}  			}  		}  	}  	if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		var v2 = (SqlValue)be.Expr2;  		if (v1.Value is int && v2.Value is int)  			return new SqlValue ((int)v1.Value + (int)v2.Value);  		if (v1.Value is string || v2.Value is string)  			return new SqlValue (v1.Value.ToString () + v2.Value);  	}  	if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  		var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  		if (len <= 0)  			len = 100;  		return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  	}  	if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  		var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  		if (len <= 0)  			len = 100;  		return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  	}  	break;  case "-":  	if (be.Expr2 is SqlValue) {  		var v2 = (SqlValue)be.Expr2;  		if (v2.Value is int) {  			if ((int)v2.Value == 0)  				return be.Expr1;  			if (be.Expr1 is SqlBinaryExpression) {  				var be1 = (SqlBinaryExpression)be.Expr1;  				if (be1.Expr2 is SqlValue) {  					var be1v2 = (SqlValue)be1.Expr2;  					if (be1v2.Value is int) {  						switch (be1.Operation) {  						case "+": {  							var value = (int)be1v2.Value - (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "-";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						case "-": {  							var value = (int)be1v2.Value + (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "+";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						}  					}  				}  			}  		}  	}  	if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		var v2 = (SqlValue)be.Expr2;  		if (v1.Value is int && v2.Value is int)  			return new SqlValue ((int)v1.Value - (int)v2.Value);  	}  	break;  case "*":  	if (be.Expr1 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		if (v1.Value is int) {  			var v1v = (int)v1.Value;  			switch (v1v) {  			case 0:  				return new SqlValue (0);  			case 1:  				return be.Expr2;  			default: {  				var be2 = be.Expr2 as SqlBinaryExpression;  				if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  					var be2v1 = be2.Expr1 as SqlValue;  					if (be2v1.Value is int)  						return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  				}  				break;  			}  			}  		}  	}  	if (be.Expr2 is SqlValue) {  		var v2 = (SqlValue)be.Expr2;  		if (v2.Value is int && (int)v2.Value == 1)  			return be.Expr1;  		if (v2.Value is int && (int)v2.Value == 0)  			return new SqlValue (0);  	}  	if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		var v2 = (SqlValue)be.Expr2;  		if (v1.Value is int) {  			if (v2.Value is int)  				return new SqlValue ((int)v1.Value * (int)v2.Value);  			if (v2.Value is double)  				return new SqlValue ((int)v1.Value * (double)v2.Value);  		} else if (v1.Value is double) {  			if (v2.Value is int)  				return new SqlValue ((double)v1.Value * (int)v2.Value);  			if (v2.Value is double)  				return new SqlValue ((double)v1.Value * (double)v2.Value);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (be.Operation) {  case "+":  	if (be.Expr1 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  			return be.Expr2;  	}  	if (be.Expr2 is SqlValue) {  		var v2 = (SqlValue)be.Expr2;  		if (v2.Value is int) {  			if ((int)v2.Value == 0)  				return be.Expr1;  			if (be.Expr1 is SqlBinaryExpression) {  				var be1 = (SqlBinaryExpression)be.Expr1;  				if (be1.Expr2 is SqlValue) {  					var be1v2 = (SqlValue)be1.Expr2;  					if (be1v2.Value is int) {  						switch (be1.Operation) {  						case "+": {  							var value = (int)be1v2.Value + (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "-";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						case "-": {  							var value = (int)be1v2.Value - (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "+";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						}  					}  				}  			}  		} else if (v2.Value is string) {  			if ((string)v2.Value == "")  				return be.Expr1;  			if (be.Expr1 is SqlBinaryExpression) {  				var be1 = (SqlBinaryExpression)be.Expr1;  				if (be1.Expr2 is SqlValue) {  					var value = ((SqlValue)be1.Expr2).Value;  					if (value is string)  						return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  				}  			}  		}  	}  	if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		var v2 = (SqlValue)be.Expr2;  		if (v1.Value is int && v2.Value is int)  			return new SqlValue ((int)v1.Value + (int)v2.Value);  		if (v1.Value is string || v2.Value is string)  			return new SqlValue (v1.Value.ToString () + v2.Value);  	}  	if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  		var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  		if (len <= 0)  			len = 100;  		return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  	}  	if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  		var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  		if (len <= 0)  			len = 100;  		return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  	}  	break;  case "-":  	if (be.Expr2 is SqlValue) {  		var v2 = (SqlValue)be.Expr2;  		if (v2.Value is int) {  			if ((int)v2.Value == 0)  				return be.Expr1;  			if (be.Expr1 is SqlBinaryExpression) {  				var be1 = (SqlBinaryExpression)be.Expr1;  				if (be1.Expr2 is SqlValue) {  					var be1v2 = (SqlValue)be1.Expr2;  					if (be1v2.Value is int) {  						switch (be1.Operation) {  						case "+": {  							var value = (int)be1v2.Value - (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "-";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						case "-": {  							var value = (int)be1v2.Value + (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "+";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						}  					}  				}  			}  		}  	}  	if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		var v2 = (SqlValue)be.Expr2;  		if (v1.Value is int && v2.Value is int)  			return new SqlValue ((int)v1.Value - (int)v2.Value);  	}  	break;  case "*":  	if (be.Expr1 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		if (v1.Value is int) {  			var v1v = (int)v1.Value;  			switch (v1v) {  			case 0:  				return new SqlValue (0);  			case 1:  				return be.Expr2;  			default: {  				var be2 = be.Expr2 as SqlBinaryExpression;  				if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  					var be2v1 = be2.Expr1 as SqlValue;  					if (be2v1.Value is int)  						return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  				}  				break;  			}  			}  		}  	}  	if (be.Expr2 is SqlValue) {  		var v2 = (SqlValue)be.Expr2;  		if (v2.Value is int && (int)v2.Value == 1)  			return be.Expr1;  		if (v2.Value is int && (int)v2.Value == 0)  			return new SqlValue (0);  	}  	if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		var v2 = (SqlValue)be.Expr2;  		if (v1.Value is int) {  			if (v2.Value is int)  				return new SqlValue ((int)v1.Value * (int)v2.Value);  			if (v2.Value is double)  				return new SqlValue ((int)v1.Value * (double)v2.Value);  		} else if (v1.Value is double) {  			if (v2.Value is int)  				return new SqlValue ((double)v1.Value * (int)v2.Value);  			if (v2.Value is double)  				return new SqlValue ((double)v1.Value * (double)v2.Value);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (be.Operation) {  case "+":  	if (be.Expr1 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  			return be.Expr2;  	}  	if (be.Expr2 is SqlValue) {  		var v2 = (SqlValue)be.Expr2;  		if (v2.Value is int) {  			if ((int)v2.Value == 0)  				return be.Expr1;  			if (be.Expr1 is SqlBinaryExpression) {  				var be1 = (SqlBinaryExpression)be.Expr1;  				if (be1.Expr2 is SqlValue) {  					var be1v2 = (SqlValue)be1.Expr2;  					if (be1v2.Value is int) {  						switch (be1.Operation) {  						case "+": {  							var value = (int)be1v2.Value + (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "-";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						case "-": {  							var value = (int)be1v2.Value - (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "+";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						}  					}  				}  			}  		} else if (v2.Value is string) {  			if ((string)v2.Value == "")  				return be.Expr1;  			if (be.Expr1 is SqlBinaryExpression) {  				var be1 = (SqlBinaryExpression)be.Expr1;  				if (be1.Expr2 is SqlValue) {  					var value = ((SqlValue)be1.Expr2).Value;  					if (value is string)  						return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  				}  			}  		}  	}  	if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		var v2 = (SqlValue)be.Expr2;  		if (v1.Value is int && v2.Value is int)  			return new SqlValue ((int)v1.Value + (int)v2.Value);  		if (v1.Value is string || v2.Value is string)  			return new SqlValue (v1.Value.ToString () + v2.Value);  	}  	if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  		var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  		if (len <= 0)  			len = 100;  		return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  	}  	if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  		var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  		if (len <= 0)  			len = 100;  		return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  	}  	break;  case "-":  	if (be.Expr2 is SqlValue) {  		var v2 = (SqlValue)be.Expr2;  		if (v2.Value is int) {  			if ((int)v2.Value == 0)  				return be.Expr1;  			if (be.Expr1 is SqlBinaryExpression) {  				var be1 = (SqlBinaryExpression)be.Expr1;  				if (be1.Expr2 is SqlValue) {  					var be1v2 = (SqlValue)be1.Expr2;  					if (be1v2.Value is int) {  						switch (be1.Operation) {  						case "+": {  							var value = (int)be1v2.Value - (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "-";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						case "-": {  							var value = (int)be1v2.Value + (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "+";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						}  					}  				}  			}  		}  	}  	if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		var v2 = (SqlValue)be.Expr2;  		if (v1.Value is int && v2.Value is int)  			return new SqlValue ((int)v1.Value - (int)v2.Value);  	}  	break;  case "*":  	if (be.Expr1 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		if (v1.Value is int) {  			var v1v = (int)v1.Value;  			switch (v1v) {  			case 0:  				return new SqlValue (0);  			case 1:  				return be.Expr2;  			default: {  				var be2 = be.Expr2 as SqlBinaryExpression;  				if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  					var be2v1 = be2.Expr1 as SqlValue;  					if (be2v1.Value is int)  						return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  				}  				break;  			}  			}  		}  	}  	if (be.Expr2 is SqlValue) {  		var v2 = (SqlValue)be.Expr2;  		if (v2.Value is int && (int)v2.Value == 1)  			return be.Expr1;  		if (v2.Value is int && (int)v2.Value == 0)  			return new SqlValue (0);  	}  	if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		var v2 = (SqlValue)be.Expr2;  		if (v1.Value is int) {  			if (v2.Value is int)  				return new SqlValue ((int)v1.Value * (int)v2.Value);  			if (v2.Value is double)  				return new SqlValue ((int)v1.Value * (double)v2.Value);  		} else if (v1.Value is double) {  			if (v2.Value is int)  				return new SqlValue ((double)v1.Value * (int)v2.Value);  			if (v2.Value is double)  				return new SqlValue ((double)v1.Value * (double)v2.Value);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (be.Operation) {  case "+":  	if (be.Expr1 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		if (v1.Value is int && (int)v1.Value == 0 || v1.Value is string && (string)v1.Value == "")  			return be.Expr2;  	}  	if (be.Expr2 is SqlValue) {  		var v2 = (SqlValue)be.Expr2;  		if (v2.Value is int) {  			if ((int)v2.Value == 0)  				return be.Expr1;  			if (be.Expr1 is SqlBinaryExpression) {  				var be1 = (SqlBinaryExpression)be.Expr1;  				if (be1.Expr2 is SqlValue) {  					var be1v2 = (SqlValue)be1.Expr2;  					if (be1v2.Value is int) {  						switch (be1.Operation) {  						case "+": {  							var value = (int)be1v2.Value + (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "-";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						case "-": {  							var value = (int)be1v2.Value - (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "+";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						}  					}  				}  			}  		} else if (v2.Value is string) {  			if ((string)v2.Value == "")  				return be.Expr1;  			if (be.Expr1 is SqlBinaryExpression) {  				var be1 = (SqlBinaryExpression)be.Expr1;  				if (be1.Expr2 is SqlValue) {  					var value = ((SqlValue)be1.Expr2).Value;  					if (value is string)  						return new SqlBinaryExpression (be1.SystemType' be1.Expr1' be1.Operation' new SqlValue (string.Concat (value' v2.Value)));  				}  			}  		}  	}  	if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		var v2 = (SqlValue)be.Expr2;  		if (v1.Value is int && v2.Value is int)  			return new SqlValue ((int)v1.Value + (int)v2.Value);  		if (v1.Value is string || v2.Value is string)  			return new SqlValue (v1.Value.ToString () + v2.Value);  	}  	if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  		var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  		if (len <= 0)  			len = 100;  		return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  	}  	if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  		var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  		if (len <= 0)  			len = 100;  		return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  	}  	break;  case "-":  	if (be.Expr2 is SqlValue) {  		var v2 = (SqlValue)be.Expr2;  		if (v2.Value is int) {  			if ((int)v2.Value == 0)  				return be.Expr1;  			if (be.Expr1 is SqlBinaryExpression) {  				var be1 = (SqlBinaryExpression)be.Expr1;  				if (be1.Expr2 is SqlValue) {  					var be1v2 = (SqlValue)be1.Expr2;  					if (be1v2.Value is int) {  						switch (be1.Operation) {  						case "+": {  							var value = (int)be1v2.Value - (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "-";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						case "-": {  							var value = (int)be1v2.Value + (int)v2.Value;  							var oper = be1.Operation;  							if (value < 0) {  								value = -value;  								oper = "+";  							}  							return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  						}  						}  					}  				}  			}  		}  	}  	if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		var v2 = (SqlValue)be.Expr2;  		if (v1.Value is int && v2.Value is int)  			return new SqlValue ((int)v1.Value - (int)v2.Value);  	}  	break;  case "*":  	if (be.Expr1 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		if (v1.Value is int) {  			var v1v = (int)v1.Value;  			switch (v1v) {  			case 0:  				return new SqlValue (0);  			case 1:  				return be.Expr2;  			default: {  				var be2 = be.Expr2 as SqlBinaryExpression;  				if (be2 != null && be2.Operation == "*" && be2.Expr1 is SqlValue) {  					var be2v1 = be2.Expr1 as SqlValue;  					if (be2v1.Value is int)  						return ConvertExpression (new SqlBinaryExpression (be2.SystemType' new SqlValue (v1v * (int)be2v1.Value)' "*"' be2.Expr2));  				}  				break;  			}  			}  		}  	}  	if (be.Expr2 is SqlValue) {  		var v2 = (SqlValue)be.Expr2;  		if (v2.Value is int && (int)v2.Value == 1)  			return be.Expr1;  		if (v2.Value is int && (int)v2.Value == 0)  			return new SqlValue (0);  	}  	if (be.Expr1 is SqlValue && be.Expr2 is SqlValue) {  		var v1 = (SqlValue)be.Expr1;  		var v2 = (SqlValue)be.Expr2;  		if (v1.Value is int) {  			if (v2.Value is int)  				return new SqlValue ((int)v1.Value * (int)v2.Value);  			if (v2.Value is double)  				return new SqlValue ((int)v1.Value * (double)v2.Value);  		} else if (v1.Value is double) {  			if (v2.Value is int)  				return new SqlValue ((double)v1.Value * (int)v2.Value);  			if (v2.Value is double)  				return new SqlValue ((double)v1.Value * (double)v2.Value);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  	var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  	if (len <= 0)  		len = 100;  	return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (be.Expr1.SystemType == typeof(string) && be.Expr2.SystemType != typeof(string)) {  	var len = be.Expr2.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr2.SystemType).SqlDbType);  	if (len <= 0)  		len = 100;  	return new SqlBinaryExpression (be.SystemType' be.Expr1' be.Operation' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr2))' be.Precedence);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (len <= 0)  	len = 100;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: len = 100;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  	var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  	if (len <= 0)  		len = 100;  	return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (be.Expr1.SystemType != typeof(string) && be.Expr2.SystemType == typeof(string)) {  	var len = be.Expr1.SystemType == null ? 100 : SqlDataType.GetMaxDisplaySize (SqlDataType.GetDataType (be.Expr1.SystemType).SqlDbType);  	if (len <= 0)  		len = 100;  	return new SqlBinaryExpression (be.SystemType' ConvertExpression (new SqlFunction (typeof(string)' "Convert"' new SqlDataType (SqlDbType.VarChar' len)' be.Expr1))' be.Operation' be.Expr2' be.Precedence);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (len <= 0)  	len = 100;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: len = 100;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "ConvertToCaseCompareTo":  	return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  case "$Convert$":  	return ConvertConvertion (func);  case "Average":  	return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  case "Max":  case "Min": {  	if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  		return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  	}  	break;  }  case "CASE":  	{  		var parms = func.Parameters;  		var len = parms.Length;  		for (var i = 0; i < parms.Length - 1; i += 2) {  			var value = parms [i] as SqlValue;  			if (value != null) {  				if ((bool)value.Value == false) {  					var newParms = new ISqlExpression[parms.Length - 2];  					if (i != 0)  						Array.Copy (parms' 0' newParms' 0' i);  					Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  					parms = newParms;  					i -= 2;  				} else {  					var newParms = new ISqlExpression[i + 1];  					if (i != 0)  						Array.Copy (parms' 0' newParms' 0' i);  					newParms [i] = parms [i + 1];  					parms = newParms;  					break;  				}  			}  		}  		if (parms.Length == 1)  			return parms [0];  		if (parms.Length != len)  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  	}  	break;  case "Convert":  	{  		var from = func.Parameters [1] as SqlFunction;  		var typef = TypeHelper.GetUnderlyingType (func.SystemType);  		if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  			return from.Parameters [1];  		var fe = func.Parameters [1] as SqlExpression;  		if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  			return fe.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "ConvertToCaseCompareTo":  	return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  case "$Convert$":  	return ConvertConvertion (func);  case "Average":  	return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  case "Max":  case "Min": {  	if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  		return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  	}  	break;  }  case "CASE":  	{  		var parms = func.Parameters;  		var len = parms.Length;  		for (var i = 0; i < parms.Length - 1; i += 2) {  			var value = parms [i] as SqlValue;  			if (value != null) {  				if ((bool)value.Value == false) {  					var newParms = new ISqlExpression[parms.Length - 2];  					if (i != 0)  						Array.Copy (parms' 0' newParms' 0' i);  					Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  					parms = newParms;  					i -= 2;  				} else {  					var newParms = new ISqlExpression[i + 1];  					if (i != 0)  						Array.Copy (parms' 0' newParms' 0' i);  					newParms [i] = parms [i + 1];  					parms = newParms;  					break;  				}  			}  		}  		if (parms.Length == 1)  			return parms [0];  		if (parms.Length != len)  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  	}  	break;  case "Convert":  	{  		var from = func.Parameters [1] as SqlFunction;  		var typef = TypeHelper.GetUnderlyingType (func.SystemType);  		if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  			return from.Parameters [1];  		var fe = func.Parameters [1] as SqlExpression;  		if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  			return fe.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "ConvertToCaseCompareTo":  	return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  case "$Convert$":  	return ConvertConvertion (func);  case "Average":  	return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  case "Max":  case "Min": {  	if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  		return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  	}  	break;  }  case "CASE":  	{  		var parms = func.Parameters;  		var len = parms.Length;  		for (var i = 0; i < parms.Length - 1; i += 2) {  			var value = parms [i] as SqlValue;  			if (value != null) {  				if ((bool)value.Value == false) {  					var newParms = new ISqlExpression[parms.Length - 2];  					if (i != 0)  						Array.Copy (parms' 0' newParms' 0' i);  					Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  					parms = newParms;  					i -= 2;  				} else {  					var newParms = new ISqlExpression[i + 1];  					if (i != 0)  						Array.Copy (parms' 0' newParms' 0' i);  					newParms [i] = parms [i + 1];  					parms = newParms;  					break;  				}  			}  		}  		if (parms.Length == 1)  			return parms [0];  		if (parms.Length != len)  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  	}  	break;  case "Convert":  	{  		var from = func.Parameters [1] as SqlFunction;  		var typef = TypeHelper.GetUnderlyingType (func.SystemType);  		if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  			return from.Parameters [1];  		var fe = func.Parameters [1] as SqlExpression;  		if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  			return fe.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "ConvertToCaseCompareTo":  	return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  case "$Convert$":  	return ConvertConvertion (func);  case "Average":  	return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  case "Max":  case "Min": {  	if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  		return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  	}  	break;  }  case "CASE":  	{  		var parms = func.Parameters;  		var len = parms.Length;  		for (var i = 0; i < parms.Length - 1; i += 2) {  			var value = parms [i] as SqlValue;  			if (value != null) {  				if ((bool)value.Value == false) {  					var newParms = new ISqlExpression[parms.Length - 2];  					if (i != 0)  						Array.Copy (parms' 0' newParms' 0' i);  					Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  					parms = newParms;  					i -= 2;  				} else {  					var newParms = new ISqlExpression[i + 1];  					if (i != 0)  						Array.Copy (parms' 0' newParms' 0' i);  					newParms [i] = parms [i + 1];  					parms = newParms;  					break;  				}  			}  		}  		if (parms.Length == 1)  			return parms [0];  		if (parms.Length != len)  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  	}  	break;  case "Convert":  	{  		var from = func.Parameters [1] as SqlFunction;  		var typef = TypeHelper.GetUnderlyingType (func.SystemType);  		if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  			return from.Parameters [1];  		var fe = func.Parameters [1] as SqlExpression;  		if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  			return fe.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "ConvertToCaseCompareTo":  	return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  case "$Convert$":  	return ConvertConvertion (func);  case "Average":  	return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  case "Max":  case "Min": {  	if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  		return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  	}  	break;  }  case "CASE":  	{  		var parms = func.Parameters;  		var len = parms.Length;  		for (var i = 0; i < parms.Length - 1; i += 2) {  			var value = parms [i] as SqlValue;  			if (value != null) {  				if ((bool)value.Value == false) {  					var newParms = new ISqlExpression[parms.Length - 2];  					if (i != 0)  						Array.Copy (parms' 0' newParms' 0' i);  					Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  					parms = newParms;  					i -= 2;  				} else {  					var newParms = new ISqlExpression[i + 1];  					if (i != 0)  						Array.Copy (parms' 0' newParms' 0' i);  					newParms [i] = parms [i + 1];  					parms = newParms;  					break;  				}  			}  		}  		if (parms.Length == 1)  			return parms [0];  		if (parms.Length != len)  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  	}  	break;  case "Convert":  	{  		var from = func.Parameters [1] as SqlFunction;  		var typef = TypeHelper.GetUnderlyingType (func.SystemType);  		if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  			return from.Parameters [1];  		var fe = func.Parameters [1] as SqlExpression;  		if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  			return fe.Parameters [0];  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: for (var i = 0; i < parms.Length - 1; i += 2) {  	var value = parms [i] as SqlValue;  	if (value != null) {  		if ((bool)value.Value == false) {  			var newParms = new ISqlExpression[parms.Length - 2];  			if (i != 0)  				Array.Copy (parms' 0' newParms' 0' i);  			Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  			parms = newParms;  			i -= 2;  		} else {  			var newParms = new ISqlExpression[i + 1];  			if (i != 0)  				Array.Copy (parms' 0' newParms' 0' i);  			newParms [i] = parms [i + 1];  			parms = newParms;  			break;  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: for (var i = 0; i < parms.Length - 1; i += 2) {  	var value = parms [i] as SqlValue;  	if (value != null) {  		if ((bool)value.Value == false) {  			var newParms = new ISqlExpression[parms.Length - 2];  			if (i != 0)  				Array.Copy (parms' 0' newParms' 0' i);  			Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  			parms = newParms;  			i -= 2;  		} else {  			var newParms = new ISqlExpression[i + 1];  			if (i != 0)  				Array.Copy (parms' 0' newParms' 0' i);  			newParms [i] = parms [i + 1];  			parms = newParms;  			break;  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: for (var i = 0; i < parms.Length - 1; i += 2) {  	var value = parms [i] as SqlValue;  	if (value != null) {  		if ((bool)value.Value == false) {  			var newParms = new ISqlExpression[parms.Length - 2];  			if (i != 0)  				Array.Copy (parms' 0' newParms' 0' i);  			Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  			parms = newParms;  			i -= 2;  		} else {  			var newParms = new ISqlExpression[i + 1];  			if (i != 0)  				Array.Copy (parms' 0' newParms' 0' i);  			newParms [i] = parms [i + 1];  			parms = newParms;  			break;  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: for (var i = 0; i < parms.Length - 1; i += 2) {  	var value = parms [i] as SqlValue;  	if (value != null) {  		if ((bool)value.Value == false) {  			var newParms = new ISqlExpression[parms.Length - 2];  			if (i != 0)  				Array.Copy (parms' 0' newParms' 0' i);  			Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  			parms = newParms;  			i -= 2;  		} else {  			var newParms = new ISqlExpression[i + 1];  			if (i != 0)  				Array.Copy (parms' 0' newParms' 0' i);  			newParms [i] = parms [i + 1];  			parms = newParms;  			break;  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: for (var i = 0; i < parms.Length - 1; i += 2) {  	var value = parms [i] as SqlValue;  	if (value != null) {  		if ((bool)value.Value == false) {  			var newParms = new ISqlExpression[parms.Length - 2];  			if (i != 0)  				Array.Copy (parms' 0' newParms' 0' i);  			Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  			parms = newParms;  			i -= 2;  		} else {  			var newParms = new ISqlExpression[i + 1];  			if (i != 0)  				Array.Copy (parms' 0' newParms' 0' i);  			newParms [i] = parms [i + 1];  			parms = newParms;  			break;  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: i += 2
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (value != null) {  	if ((bool)value.Value == false) {  		var newParms = new ISqlExpression[parms.Length - 2];  		if (i != 0)  			Array.Copy (parms' 0' newParms' 0' i);  		Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  		parms = newParms;  		i -= 2;  	} else {  		var newParms = new ISqlExpression[i + 1];  		if (i != 0)  			Array.Copy (parms' 0' newParms' 0' i);  		newParms [i] = parms [i + 1];  		parms = newParms;  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (value != null) {  	if ((bool)value.Value == false) {  		var newParms = new ISqlExpression[parms.Length - 2];  		if (i != 0)  			Array.Copy (parms' 0' newParms' 0' i);  		Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  		parms = newParms;  		i -= 2;  	} else {  		var newParms = new ISqlExpression[i + 1];  		if (i != 0)  			Array.Copy (parms' 0' newParms' 0' i);  		newParms [i] = parms [i + 1];  		parms = newParms;  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (value != null) {  	if ((bool)value.Value == false) {  		var newParms = new ISqlExpression[parms.Length - 2];  		if (i != 0)  			Array.Copy (parms' 0' newParms' 0' i);  		Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  		parms = newParms;  		i -= 2;  	} else {  		var newParms = new ISqlExpression[i + 1];  		if (i != 0)  			Array.Copy (parms' 0' newParms' 0' i);  		newParms [i] = parms [i + 1];  		parms = newParms;  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (value != null) {  	if ((bool)value.Value == false) {  		var newParms = new ISqlExpression[parms.Length - 2];  		if (i != 0)  			Array.Copy (parms' 0' newParms' 0' i);  		Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  		parms = newParms;  		i -= 2;  	} else {  		var newParms = new ISqlExpression[i + 1];  		if (i != 0)  			Array.Copy (parms' 0' newParms' 0' i);  		newParms [i] = parms [i + 1];  		parms = newParms;  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if ((bool)value.Value == false) {  	var newParms = new ISqlExpression[parms.Length - 2];  	if (i != 0)  		Array.Copy (parms' 0' newParms' 0' i);  	Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  	parms = newParms;  	i -= 2;  } else {  	var newParms = new ISqlExpression[i + 1];  	if (i != 0)  		Array.Copy (parms' 0' newParms' 0' i);  	newParms [i] = parms [i + 1];  	parms = newParms;  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if ((bool)value.Value == false) {  	var newParms = new ISqlExpression[parms.Length - 2];  	if (i != 0)  		Array.Copy (parms' 0' newParms' 0' i);  	Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  	parms = newParms;  	i -= 2;  } else {  	var newParms = new ISqlExpression[i + 1];  	if (i != 0)  		Array.Copy (parms' 0' newParms' 0' i);  	newParms [i] = parms [i + 1];  	parms = newParms;  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if ((bool)value.Value == false) {  	var newParms = new ISqlExpression[parms.Length - 2];  	if (i != 0)  		Array.Copy (parms' 0' newParms' 0' i);  	Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  	parms = newParms;  	i -= 2;  } else {  	var newParms = new ISqlExpression[i + 1];  	if (i != 0)  		Array.Copy (parms' 0' newParms' 0' i);  	newParms [i] = parms [i + 1];  	parms = newParms;  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if ((bool)value.Value == false) {  	var newParms = new ISqlExpression[parms.Length - 2];  	if (i != 0)  		Array.Copy (parms' 0' newParms' 0' i);  	Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  	parms = newParms;  	i -= 2;  } else {  	var newParms = new ISqlExpression[i + 1];  	if (i != 0)  		Array.Copy (parms' 0' newParms' 0' i);  	newParms [i] = parms [i + 1];  	parms = newParms;  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following statement contains a magic number: i -= 2;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE") {  	if (value.Value is int && func.Parameters.Length == 5) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  		var v2 = func.Parameters [3] as SqlValue;  		var v3 = func.Parameters [4] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  			var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  				int e = 0' g = 0' l = 0;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  					e = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  					g = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  					l = 1;  				if (e + g + l == 2) {  					var n = (int)value.Value;  					var i1 = (int)v1.Value;  					var i2 = (int)v2.Value;  					var i3 = (int)v3.Value;  					var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  					var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  					var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  					if (n1 + n2 + n3 == 1) {  						if (n1 == 1)  							return ee1;  						if (n2 == 1)  							return ee2;  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  					}  					//	CASE  					//		WHEN [p].[FirstName] > 'John'  					//			THEN 1  					//		WHEN [p].[FirstName] = 'John'  					//			THEN 0  					//		ELSE -1  					//	END <= 0  					if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  					}  				}  			}  		}  	} else if (value.Value is bool && func.Parameters.Length == 3) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  			var bv = (bool)value.Value;  			var bv1 = (bool)v1.Value;  			var bv2 = (bool)v2.Value;  			if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  				return c1;  			}  			if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  				var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  				if (ee != null) {  					var op = InvertOperator (ee.Operator' false);  					return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  				}  				var sc = new SqlQuery.SearchCondition ();  				sc.Conditions.Add (new SqlQuery.Condition (true' c1));  				return sc;  			}  		}  	} else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  		var sc = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (sc != null && v1 != null && v2 != null) {  			if (Equals (value.Value' v1.Value))  				return sc;  			if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  				return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE") {  	if (value.Value is int && func.Parameters.Length == 5) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  		var v2 = func.Parameters [3] as SqlValue;  		var v3 = func.Parameters [4] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  			var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  				int e = 0' g = 0' l = 0;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  					e = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  					g = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  					l = 1;  				if (e + g + l == 2) {  					var n = (int)value.Value;  					var i1 = (int)v1.Value;  					var i2 = (int)v2.Value;  					var i3 = (int)v3.Value;  					var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  					var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  					var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  					if (n1 + n2 + n3 == 1) {  						if (n1 == 1)  							return ee1;  						if (n2 == 1)  							return ee2;  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  					}  					//	CASE  					//		WHEN [p].[FirstName] > 'John'  					//			THEN 1  					//		WHEN [p].[FirstName] = 'John'  					//			THEN 0  					//		ELSE -1  					//	END <= 0  					if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  					}  				}  			}  		}  	} else if (value.Value is bool && func.Parameters.Length == 3) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  			var bv = (bool)value.Value;  			var bv1 = (bool)v1.Value;  			var bv2 = (bool)v2.Value;  			if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  				return c1;  			}  			if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  				var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  				if (ee != null) {  					var op = InvertOperator (ee.Operator' false);  					return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  				}  				var sc = new SqlQuery.SearchCondition ();  				sc.Conditions.Add (new SqlQuery.Condition (true' c1));  				return sc;  			}  		}  	} else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  		var sc = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (sc != null && v1 != null && v2 != null) {  			if (Equals (value.Value' v1.Value))  				return sc;  			if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  				return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE") {  	if (value.Value is int && func.Parameters.Length == 5) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  		var v2 = func.Parameters [3] as SqlValue;  		var v3 = func.Parameters [4] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  			var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  				int e = 0' g = 0' l = 0;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  					e = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  					g = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  					l = 1;  				if (e + g + l == 2) {  					var n = (int)value.Value;  					var i1 = (int)v1.Value;  					var i2 = (int)v2.Value;  					var i3 = (int)v3.Value;  					var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  					var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  					var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  					if (n1 + n2 + n3 == 1) {  						if (n1 == 1)  							return ee1;  						if (n2 == 1)  							return ee2;  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  					}  					//	CASE  					//		WHEN [p].[FirstName] > 'John'  					//			THEN 1  					//		WHEN [p].[FirstName] = 'John'  					//			THEN 0  					//		ELSE -1  					//	END <= 0  					if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  					}  				}  			}  		}  	} else if (value.Value is bool && func.Parameters.Length == 3) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  			var bv = (bool)value.Value;  			var bv1 = (bool)v1.Value;  			var bv2 = (bool)v2.Value;  			if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  				return c1;  			}  			if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  				var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  				if (ee != null) {  					var op = InvertOperator (ee.Operator' false);  					return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  				}  				var sc = new SqlQuery.SearchCondition ();  				sc.Conditions.Add (new SqlQuery.Condition (true' c1));  				return sc;  			}  		}  	} else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  		var sc = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (sc != null && v1 != null && v2 != null) {  			if (Equals (value.Value' v1.Value))  				return sc;  			if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  				return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE") {  	if (value.Value is int && func.Parameters.Length == 5) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  		var v2 = func.Parameters [3] as SqlValue;  		var v3 = func.Parameters [4] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  			var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  				int e = 0' g = 0' l = 0;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  					e = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  					g = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  					l = 1;  				if (e + g + l == 2) {  					var n = (int)value.Value;  					var i1 = (int)v1.Value;  					var i2 = (int)v2.Value;  					var i3 = (int)v3.Value;  					var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  					var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  					var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  					if (n1 + n2 + n3 == 1) {  						if (n1 == 1)  							return ee1;  						if (n2 == 1)  							return ee2;  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  					}  					//	CASE  					//		WHEN [p].[FirstName] > 'John'  					//			THEN 1  					//		WHEN [p].[FirstName] = 'John'  					//			THEN 0  					//		ELSE -1  					//	END <= 0  					if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  					}  				}  			}  		}  	} else if (value.Value is bool && func.Parameters.Length == 3) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  			var bv = (bool)value.Value;  			var bv1 = (bool)v1.Value;  			var bv2 = (bool)v2.Value;  			if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  				return c1;  			}  			if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  				var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  				if (ee != null) {  					var op = InvertOperator (ee.Operator' false);  					return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  				}  				var sc = new SqlQuery.SearchCondition ();  				sc.Conditions.Add (new SqlQuery.Condition (true' c1));  				return sc;  			}  		}  	} else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  		var sc = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (sc != null && v1 != null && v2 != null) {  			if (Equals (value.Value' v1.Value))  				return sc;  			if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  				return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE") {  	if (value.Value is int && func.Parameters.Length == 5) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  		var v2 = func.Parameters [3] as SqlValue;  		var v3 = func.Parameters [4] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  			var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  				int e = 0' g = 0' l = 0;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  					e = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  					g = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  					l = 1;  				if (e + g + l == 2) {  					var n = (int)value.Value;  					var i1 = (int)v1.Value;  					var i2 = (int)v2.Value;  					var i3 = (int)v3.Value;  					var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  					var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  					var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  					if (n1 + n2 + n3 == 1) {  						if (n1 == 1)  							return ee1;  						if (n2 == 1)  							return ee2;  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  					}  					//	CASE  					//		WHEN [p].[FirstName] > 'John'  					//			THEN 1  					//		WHEN [p].[FirstName] = 'John'  					//			THEN 0  					//		ELSE -1  					//	END <= 0  					if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  					}  				}  			}  		}  	} else if (value.Value is bool && func.Parameters.Length == 3) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  			var bv = (bool)value.Value;  			var bv1 = (bool)v1.Value;  			var bv2 = (bool)v2.Value;  			if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  				return c1;  			}  			if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  				var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  				if (ee != null) {  					var op = InvertOperator (ee.Operator' false);  					return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  				}  				var sc = new SqlQuery.SearchCondition ();  				sc.Conditions.Add (new SqlQuery.Condition (true' c1));  				return sc;  			}  		}  	} else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  		var sc = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (sc != null && v1 != null && v2 != null) {  			if (Equals (value.Value' v1.Value))  				return sc;  			if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  				return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE") {  	if (value.Value is int && func.Parameters.Length == 5) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  		var v2 = func.Parameters [3] as SqlValue;  		var v3 = func.Parameters [4] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  			var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  				int e = 0' g = 0' l = 0;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  					e = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  					g = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  					l = 1;  				if (e + g + l == 2) {  					var n = (int)value.Value;  					var i1 = (int)v1.Value;  					var i2 = (int)v2.Value;  					var i3 = (int)v3.Value;  					var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  					var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  					var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  					if (n1 + n2 + n3 == 1) {  						if (n1 == 1)  							return ee1;  						if (n2 == 1)  							return ee2;  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  					}  					//	CASE  					//		WHEN [p].[FirstName] > 'John'  					//			THEN 1  					//		WHEN [p].[FirstName] = 'John'  					//			THEN 0  					//		ELSE -1  					//	END <= 0  					if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  					}  				}  			}  		}  	} else if (value.Value is bool && func.Parameters.Length == 3) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  			var bv = (bool)value.Value;  			var bv1 = (bool)v1.Value;  			var bv2 = (bool)v2.Value;  			if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  				return c1;  			}  			if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  				var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  				if (ee != null) {  					var op = InvertOperator (ee.Operator' false);  					return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  				}  				var sc = new SqlQuery.SearchCondition ();  				sc.Conditions.Add (new SqlQuery.Condition (true' c1));  				return sc;  			}  		}  	} else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  		var sc = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (sc != null && v1 != null && v2 != null) {  			if (Equals (value.Value' v1.Value))  				return sc;  			if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  				return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE") {  	if (value.Value is int && func.Parameters.Length == 5) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  		var v2 = func.Parameters [3] as SqlValue;  		var v3 = func.Parameters [4] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  			var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  				int e = 0' g = 0' l = 0;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  					e = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  					g = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  					l = 1;  				if (e + g + l == 2) {  					var n = (int)value.Value;  					var i1 = (int)v1.Value;  					var i2 = (int)v2.Value;  					var i3 = (int)v3.Value;  					var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  					var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  					var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  					if (n1 + n2 + n3 == 1) {  						if (n1 == 1)  							return ee1;  						if (n2 == 1)  							return ee2;  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  					}  					//	CASE  					//		WHEN [p].[FirstName] > 'John'  					//			THEN 1  					//		WHEN [p].[FirstName] = 'John'  					//			THEN 0  					//		ELSE -1  					//	END <= 0  					if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  					}  				}  			}  		}  	} else if (value.Value is bool && func.Parameters.Length == 3) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  			var bv = (bool)value.Value;  			var bv1 = (bool)v1.Value;  			var bv2 = (bool)v2.Value;  			if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  				return c1;  			}  			if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  				var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  				if (ee != null) {  					var op = InvertOperator (ee.Operator' false);  					return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  				}  				var sc = new SqlQuery.SearchCondition ();  				sc.Conditions.Add (new SqlQuery.Condition (true' c1));  				return sc;  			}  		}  	} else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  		var sc = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (sc != null && v1 != null && v2 != null) {  			if (Equals (value.Value' v1.Value))  				return sc;  			if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  				return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE") {  	if (value.Value is int && func.Parameters.Length == 5) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  		var v2 = func.Parameters [3] as SqlValue;  		var v3 = func.Parameters [4] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  			var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  				int e = 0' g = 0' l = 0;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  					e = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  					g = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  					l = 1;  				if (e + g + l == 2) {  					var n = (int)value.Value;  					var i1 = (int)v1.Value;  					var i2 = (int)v2.Value;  					var i3 = (int)v3.Value;  					var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  					var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  					var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  					if (n1 + n2 + n3 == 1) {  						if (n1 == 1)  							return ee1;  						if (n2 == 1)  							return ee2;  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  					}  					//	CASE  					//		WHEN [p].[FirstName] > 'John'  					//			THEN 1  					//		WHEN [p].[FirstName] = 'John'  					//			THEN 0  					//		ELSE -1  					//	END <= 0  					if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  					}  				}  			}  		}  	} else if (value.Value is bool && func.Parameters.Length == 3) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  			var bv = (bool)value.Value;  			var bv1 = (bool)v1.Value;  			var bv2 = (bool)v2.Value;  			if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  				return c1;  			}  			if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  				var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  				if (ee != null) {  					var op = InvertOperator (ee.Operator' false);  					return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  				}  				var sc = new SqlQuery.SearchCondition ();  				sc.Conditions.Add (new SqlQuery.Condition (true' c1));  				return sc;  			}  		}  	} else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  		var sc = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (sc != null && v1 != null && v2 != null) {  			if (Equals (value.Value' v1.Value))  				return sc;  			if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  				return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value != null && func != null && func.Name == "CASE") {  	if (value.Value is int && func.Parameters.Length == 5) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  		var v2 = func.Parameters [3] as SqlValue;  		var v3 = func.Parameters [4] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  			var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  				int e = 0' g = 0' l = 0;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  					e = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  					g = 1;  				if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  					l = 1;  				if (e + g + l == 2) {  					var n = (int)value.Value;  					var i1 = (int)v1.Value;  					var i2 = (int)v2.Value;  					var i3 = (int)v3.Value;  					var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  					var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  					var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  					if (n1 + n2 + n3 == 1) {  						if (n1 == 1)  							return ee1;  						if (n2 == 1)  							return ee2;  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  					}  					//	CASE  					//		WHEN [p].[FirstName] > 'John'  					//			THEN 1  					//		WHEN [p].[FirstName] = 'John'  					//			THEN 0  					//		ELSE -1  					//	END <= 0  					if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  						return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  					}  				}  			}  		}  	} else if (value.Value is bool && func.Parameters.Length == 3) {  		var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  			var bv = (bool)value.Value;  			var bv1 = (bool)v1.Value;  			var bv2 = (bool)v2.Value;  			if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  				return c1;  			}  			if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  				var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  				if (ee != null) {  					var op = InvertOperator (ee.Operator' false);  					return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  				}  				var sc = new SqlQuery.SearchCondition ();  				sc.Conditions.Add (new SqlQuery.Condition (true' c1));  				return sc;  			}  		}  	} else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  		var sc = func.Parameters [0] as SqlQuery.SearchCondition;  		var v1 = func.Parameters [1] as SqlValue;  		var v2 = func.Parameters [2] as SqlValue;  		if (sc != null && v1 != null && v2 != null) {  			if (Equals (value.Value' v1.Value))  				return sc;  			if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  				return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is int && func.Parameters.Length == 5) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  	var v2 = func.Parameters [3] as SqlValue;  	var v3 = func.Parameters [4] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  		var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  			int e = 0' g = 0' l = 0;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  				e = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  				g = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  				l = 1;  			if (e + g + l == 2) {  				var n = (int)value.Value;  				var i1 = (int)v1.Value;  				var i2 = (int)v2.Value;  				var i3 = (int)v3.Value;  				var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  				var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  				var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  				if (n1 + n2 + n3 == 1) {  					if (n1 == 1)  						return ee1;  					if (n2 == 1)  						return ee2;  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  				}  				//	CASE  				//		WHEN [p].[FirstName] > 'John'  				//			THEN 1  				//		WHEN [p].[FirstName] = 'John'  				//			THEN 0  				//		ELSE -1  				//	END <= 0  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  				}  			}  		}  	}  } else if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is int && func.Parameters.Length == 5) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  	var v2 = func.Parameters [3] as SqlValue;  	var v3 = func.Parameters [4] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  		var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  			int e = 0' g = 0' l = 0;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  				e = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  				g = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  				l = 1;  			if (e + g + l == 2) {  				var n = (int)value.Value;  				var i1 = (int)v1.Value;  				var i2 = (int)v2.Value;  				var i3 = (int)v3.Value;  				var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  				var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  				var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  				if (n1 + n2 + n3 == 1) {  					if (n1 == 1)  						return ee1;  					if (n2 == 1)  						return ee2;  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  				}  				//	CASE  				//		WHEN [p].[FirstName] > 'John'  				//			THEN 1  				//		WHEN [p].[FirstName] = 'John'  				//			THEN 0  				//		ELSE -1  				//	END <= 0  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  				}  			}  		}  	}  } else if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is int && func.Parameters.Length == 5) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  	var v2 = func.Parameters [3] as SqlValue;  	var v3 = func.Parameters [4] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  		var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  			int e = 0' g = 0' l = 0;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  				e = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  				g = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  				l = 1;  			if (e + g + l == 2) {  				var n = (int)value.Value;  				var i1 = (int)v1.Value;  				var i2 = (int)v2.Value;  				var i3 = (int)v3.Value;  				var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  				var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  				var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  				if (n1 + n2 + n3 == 1) {  					if (n1 == 1)  						return ee1;  					if (n2 == 1)  						return ee2;  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  				}  				//	CASE  				//		WHEN [p].[FirstName] > 'John'  				//			THEN 1  				//		WHEN [p].[FirstName] = 'John'  				//			THEN 0  				//		ELSE -1  				//	END <= 0  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  				}  			}  		}  	}  } else if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is int && func.Parameters.Length == 5) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  	var v2 = func.Parameters [3] as SqlValue;  	var v3 = func.Parameters [4] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  		var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  			int e = 0' g = 0' l = 0;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  				e = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  				g = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  				l = 1;  			if (e + g + l == 2) {  				var n = (int)value.Value;  				var i1 = (int)v1.Value;  				var i2 = (int)v2.Value;  				var i3 = (int)v3.Value;  				var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  				var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  				var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  				if (n1 + n2 + n3 == 1) {  					if (n1 == 1)  						return ee1;  					if (n2 == 1)  						return ee2;  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  				}  				//	CASE  				//		WHEN [p].[FirstName] > 'John'  				//			THEN 1  				//		WHEN [p].[FirstName] = 'John'  				//			THEN 0  				//		ELSE -1  				//	END <= 0  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  				}  			}  		}  	}  } else if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is int && func.Parameters.Length == 5) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  	var v2 = func.Parameters [3] as SqlValue;  	var v3 = func.Parameters [4] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  		var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  			int e = 0' g = 0' l = 0;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  				e = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  				g = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  				l = 1;  			if (e + g + l == 2) {  				var n = (int)value.Value;  				var i1 = (int)v1.Value;  				var i2 = (int)v2.Value;  				var i3 = (int)v3.Value;  				var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  				var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  				var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  				if (n1 + n2 + n3 == 1) {  					if (n1 == 1)  						return ee1;  					if (n2 == 1)  						return ee2;  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  				}  				//	CASE  				//		WHEN [p].[FirstName] > 'John'  				//			THEN 1  				//		WHEN [p].[FirstName] = 'John'  				//			THEN 0  				//		ELSE -1  				//	END <= 0  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  				}  			}  		}  	}  } else if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is int && func.Parameters.Length == 5) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  	var v2 = func.Parameters [3] as SqlValue;  	var v3 = func.Parameters [4] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  		var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  			int e = 0' g = 0' l = 0;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  				e = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  				g = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  				l = 1;  			if (e + g + l == 2) {  				var n = (int)value.Value;  				var i1 = (int)v1.Value;  				var i2 = (int)v2.Value;  				var i3 = (int)v3.Value;  				var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  				var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  				var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  				if (n1 + n2 + n3 == 1) {  					if (n1 == 1)  						return ee1;  					if (n2 == 1)  						return ee2;  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  				}  				//	CASE  				//		WHEN [p].[FirstName] > 'John'  				//			THEN 1  				//		WHEN [p].[FirstName] = 'John'  				//			THEN 0  				//		ELSE -1  				//	END <= 0  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  				}  			}  		}  	}  } else if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is int && func.Parameters.Length == 5) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  	var v2 = func.Parameters [3] as SqlValue;  	var v3 = func.Parameters [4] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  		var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  			int e = 0' g = 0' l = 0;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  				e = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  				g = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  				l = 1;  			if (e + g + l == 2) {  				var n = (int)value.Value;  				var i1 = (int)v1.Value;  				var i2 = (int)v2.Value;  				var i3 = (int)v3.Value;  				var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  				var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  				var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  				if (n1 + n2 + n3 == 1) {  					if (n1 == 1)  						return ee1;  					if (n2 == 1)  						return ee2;  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  				}  				//	CASE  				//		WHEN [p].[FirstName] > 'John'  				//			THEN 1  				//		WHEN [p].[FirstName] = 'John'  				//			THEN 0  				//		ELSE -1  				//	END <= 0  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  				}  			}  		}  	}  } else if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is int && func.Parameters.Length == 5) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  	var v2 = func.Parameters [3] as SqlValue;  	var v3 = func.Parameters [4] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  		var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  			int e = 0' g = 0' l = 0;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  				e = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  				g = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  				l = 1;  			if (e + g + l == 2) {  				var n = (int)value.Value;  				var i1 = (int)v1.Value;  				var i2 = (int)v2.Value;  				var i3 = (int)v3.Value;  				var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  				var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  				var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  				if (n1 + n2 + n3 == 1) {  					if (n1 == 1)  						return ee1;  					if (n2 == 1)  						return ee2;  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  				}  				//	CASE  				//		WHEN [p].[FirstName] > 'John'  				//			THEN 1  				//		WHEN [p].[FirstName] = 'John'  				//			THEN 0  				//		ELSE -1  				//	END <= 0  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  				}  			}  		}  	}  } else if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is int && func.Parameters.Length == 5) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var c2 = func.Parameters [2] as SqlQuery.SearchCondition;  	var v2 = func.Parameters [3] as SqlValue;  	var v3 = func.Parameters [4] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  		var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  		if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  			int e = 0' g = 0' l = 0;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  				e = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  				g = 1;  			if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  				l = 1;  			if (e + g + l == 2) {  				var n = (int)value.Value;  				var i1 = (int)v1.Value;  				var i2 = (int)v2.Value;  				var i3 = (int)v3.Value;  				var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  				var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  				var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  				if (n1 + n2 + n3 == 1) {  					if (n1 == 1)  						return ee1;  					if (n2 == 1)  						return ee2;  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  				}  				//	CASE  				//		WHEN [p].[FirstName] > 'John'  				//			THEN 1  				//		WHEN [p].[FirstName] = 'John'  				//			THEN 0  				//		ELSE -1  				//	END <= 0  				if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  					return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  				}  			}  		}  	}  } else if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is int && c2 != null && c2.Conditions.Count == 1 && v2 != null && v2.Value is int && v3 != null && v3.Value is int) {  	var ee1 = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  	var ee2 = c2.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  	if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  		int e = 0' g = 0' l = 0;  		if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  			e = 1;  		if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  			g = 1;  		if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  			l = 1;  		if (e + g + l == 2) {  			var n = (int)value.Value;  			var i1 = (int)v1.Value;  			var i2 = (int)v2.Value;  			var i3 = (int)v3.Value;  			var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  			var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  			var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  			if (n1 + n2 + n3 == 1) {  				if (n1 == 1)  					return ee1;  				if (n2 == 1)  					return ee2;  				return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  			}  			//	CASE  			//		WHEN [p].[FirstName] > 'John'  			//			THEN 1  			//		WHEN [p].[FirstName] = 'John'  			//			THEN 0  			//		ELSE -1  			//	END <= 0  			if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  				return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  			}  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (ee1 != null && ee2 != null && ee1.Expr1.Equals (ee2.Expr1) && ee1.Expr2.Equals (ee2.Expr2)) {  	int e = 0' g = 0' l = 0;  	if (ee1.Operator == SqlQuery.Predicate.Operator.Equal || ee2.Operator == SqlQuery.Predicate.Operator.Equal)  		e = 1;  	if (ee1.Operator == SqlQuery.Predicate.Operator.Greater || ee2.Operator == SqlQuery.Predicate.Operator.Greater)  		g = 1;  	if (ee1.Operator == SqlQuery.Predicate.Operator.Less || ee2.Operator == SqlQuery.Predicate.Operator.Less)  		l = 1;  	if (e + g + l == 2) {  		var n = (int)value.Value;  		var i1 = (int)v1.Value;  		var i2 = (int)v2.Value;  		var i3 = (int)v3.Value;  		var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  		var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  		var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  		if (n1 + n2 + n3 == 1) {  			if (n1 == 1)  				return ee1;  			if (n2 == 1)  				return ee2;  			return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  		}  		//	CASE  		//		WHEN [p].[FirstName] > 'John'  		//			THEN 1  		//		WHEN [p].[FirstName] = 'John'  		//			THEN 0  		//		ELSE -1  		//	END <= 0  		if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  			return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (e + g + l == 2) {  	var n = (int)value.Value;  	var i1 = (int)v1.Value;  	var i2 = (int)v2.Value;  	var i3 = (int)v3.Value;  	var n1 = Compare (valueFirst ? n : i1' valueFirst ? i1 : n' expr.Operator) ? 1 : 0;  	var n2 = Compare (valueFirst ? n : i2' valueFirst ? i2 : n' expr.Operator) ? 1 : 0;  	var n3 = Compare (valueFirst ? n : i3' valueFirst ? i3 : n' expr.Operator) ? 1 : 0;  	if (n1 + n2 + n3 == 1) {  		if (n1 == 1)  			return ee1;  		if (n2 == 1)  			return ee2;  		return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' e == 0 ? SqlQuery.Predicate.Operator.Equal : g == 0 ? SqlQuery.Predicate.Operator.Greater : SqlQuery.Predicate.Operator.Less' ee1.Expr2));  	}  	//	CASE  	//		WHEN [p].[FirstName] > 'John'  	//			THEN 1  	//		WHEN [p].[FirstName] = 'John'  	//			THEN 0  	//		ELSE -1  	//	END <= 0  	if (ee1.Operator == SqlQuery.Predicate.Operator.Greater && i1 == 1 && ee2.Operator == SqlQuery.Predicate.Operator.Equal && i2 == 0 && i3 == -1 && n == 0) {  		return ConvertPredicate (new SqlQuery.Predicate.ExprExpr (ee1.Expr1' valueFirst ? InvertOperator (expr.Operator' true) : expr.Operator' ee1.Expr2));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (value.Value is bool && func.Parameters.Length == 3) {  	var c1 = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (c1 != null && c1.Conditions.Count == 1 && v1 != null && v1.Value is bool && v2 != null && v2.Value is bool) {  		var bv = (bool)value.Value;  		var bv1 = (bool)v1.Value;  		var bv2 = (bool)v2.Value;  		if (bv == bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual) {  			return c1;  		}  		if (bv == bv2 && expr.Operator == SqlQuery.Predicate.Operator.NotEqual || bv != bv1 && expr.Operator == SqlQuery.Predicate.Operator.Equal) {  			var ee = c1.Conditions [0].Predicate as SqlQuery.Predicate.ExprExpr;  			if (ee != null) {  				var op = InvertOperator (ee.Operator' false);  				return new SqlQuery.Predicate.ExprExpr (ee.Expr1' op' ee.Expr2);  			}  			var sc = new SqlQuery.SearchCondition ();  			sc.Conditions.Add (new SqlQuery.Condition (true' c1));  			return sc;  		}  	}  } else if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,OptimizeCase,The following statement contains a magic number: if (expr.Operator == SqlQuery.Predicate.Operator.Equal && func.Parameters.Length == 3) {  	var sc = func.Parameters [0] as SqlQuery.SearchCondition;  	var v1 = func.Parameters [1] as SqlValue;  	var v2 = func.Parameters [2] as SqlValue;  	if (sc != null && v1 != null && v2 != null) {  		if (Equals (value.Value' v1.Value))  			return sc;  		if (Equals (value.Value' v2.Value) && !sc.CanBeNull ())  			return ConvertPredicate (new SqlQuery.Predicate.NotExpr (sc' true' Precedence.LogicalNegation));  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,CommandCount,The following statement contains a magic number: return sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity ? 2 : 1;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,BuildSql,The following statement contains a magic number: if (SqlQuery.From.Tables.Count == 0 && SqlQuery.Select.Columns.Count == 1) {  	if (SqlQuery.Select.Columns [0].Expression is SqlFunction) {  		var func = (SqlFunction)SqlQuery.Select.Columns [0].Expression;  		if (func.Name == "Iif" && func.Parameters.Length == 3 && func.Parameters [0] is SqlQuery.SearchCondition) {  			var sc = (SqlQuery.SearchCondition)func.Parameters [0];  			if (sc.Conditions.Count == 1 && sc.Conditions [0].Predicate is SqlQuery.Predicate.FuncLike) {  				var p = (SqlQuery.Predicate.FuncLike)sc.Conditions [0].Predicate;  				if (p.Function.Name == "EXISTS") {  					BuildAnyAsCount (sb);  					return;  				}  			}  		}  	} else if (SqlQuery.Select.Columns [0].Expression is SqlQuery.SearchCondition) {  		var sc = (SqlQuery.SearchCondition)SqlQuery.Select.Columns [0].Expression;  		if (sc.Conditions.Count == 1 && sc.Conditions [0].Predicate is SqlQuery.Predicate.FuncLike) {  			var p = (SqlQuery.Predicate.FuncLike)sc.Conditions [0].Predicate;  			if (p.Function.Name == "EXISTS") {  				BuildAnyAsCount (sb);  				return;  			}  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,BuildSql,The following statement contains a magic number: if (SqlQuery.Select.Columns [0].Expression is SqlFunction) {  	var func = (SqlFunction)SqlQuery.Select.Columns [0].Expression;  	if (func.Name == "Iif" && func.Parameters.Length == 3 && func.Parameters [0] is SqlQuery.SearchCondition) {  		var sc = (SqlQuery.SearchCondition)func.Parameters [0];  		if (sc.Conditions.Count == 1 && sc.Conditions [0].Predicate is SqlQuery.Predicate.FuncLike) {  			var p = (SqlQuery.Predicate.FuncLike)sc.Conditions [0].Predicate;  			if (p.Function.Name == "EXISTS") {  				BuildAnyAsCount (sb);  				return;  			}  		}  	}  } else if (SqlQuery.Select.Columns [0].Expression is SqlQuery.SearchCondition) {  	var sc = (SqlQuery.SearchCondition)SqlQuery.Select.Columns [0].Expression;  	if (sc.Conditions.Count == 1 && sc.Conditions [0].Predicate is SqlQuery.Predicate.FuncLike) {  		var p = (SqlQuery.Predicate.FuncLike)sc.Conditions [0].Predicate;  		if (p.Function.Name == "EXISTS") {  			BuildAnyAsCount (sb);  			return;  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,BuildSql,The following statement contains a magic number: if (func.Name == "Iif" && func.Parameters.Length == 3 && func.Parameters [0] is SqlQuery.SearchCondition) {  	var sc = (SqlQuery.SearchCondition)func.Parameters [0];  	if (sc.Conditions.Count == 1 && sc.Conditions [0].Predicate is SqlQuery.Predicate.FuncLike) {  		var p = (SqlQuery.Predicate.FuncLike)sc.Conditions [0].Predicate;  		if (p.Function.Name == "EXISTS") {  			BuildAnyAsCount (sb);  			return;  		}  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation [0]) {  	case '%':  		return new SqlBinaryExpression (be.SystemType' be.Expr1' "MOD"' be.Expr2' Precedence.Additive - 1);  	case '&':  	case '|':  	case '^':  		throw new SqlException ("Operator '{0}' is not supported by the {1}."' be.Operation' GetType ().Name);  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		if (func.Parameters.Length > 2) {  			var parms = new ISqlExpression[func.Parameters.Length - 1];  			Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  			return new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms));  		}  		var sc = new SqlQuery.SearchCondition ();  		sc.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.IsNull (func.Parameters [0]' false)));  		return new SqlFunction (func.SystemType' "Iif"' sc' func.Parameters [1]' func.Parameters [0]);  	case "CASE":  		return ConvertCase (func.SystemType' func.Parameters' 0);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' new SqlValue (1)' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [2]' func.Parameters [1]' func.Parameters [0]' new SqlValue (1));  	case "Convert": {  		switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  		case TypeCode.String:  			return new SqlFunction (func.SystemType' "CStr"' func.Parameters [1]);  		case TypeCode.DateTime:  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "DateValue"' func.Parameters [1]);  			if (IsTimeDataType (func.Parameters [0]))  				return new SqlFunction (func.SystemType' "TimeValue"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "CDate"' func.Parameters [1]);  		default:  			if (func.SystemType == typeof(DateTime))  				goto case TypeCode.DateTime;  			break;  		}  		return func.Parameters [1];  	}  	/* 					case "Convert"   : 						{ 							string name = null;  							switch (((SqlDataType)func.Parameters[0]).DbType) 							{ 								case SqlDbType.BigInt           : name = "CLng"; break; 								case SqlDbType.TinyInt          : name = "CByte"; break; 								case SqlDbType.Int              : 								case SqlDbType.SmallInt         : name = "CInt"; break; 								case SqlDbType.Bit              : name = "CBool"; break; 								case SqlDbType.Char             : 								case SqlDbType.Text             : 								case SqlDbType.VarChar          : 								case SqlDbType.NChar            : 								case SqlDbType.NText            : 								case SqlDbType.NVarChar         : name = "CStr"; break; 								case SqlDbType.DateTime         : 								case SqlDbType.Date             : 								case SqlDbType.Time             : 								case SqlDbType.DateTime2        : 								case SqlDbType.SmallDateTime    : 								case SqlDbType.DateTimeOffset   : name = "CDate"; break; 								case SqlDbType.Decimal          : name = "CDec"; break; 								case SqlDbType.Float            : name = "CDbl"; break; 								case SqlDbType.Money            : 								case SqlDbType.SmallMoney       : name = "CCur"; break; 								case SqlDbType.Real             : name = "CSng"; break; 								case SqlDbType.Image            : 								case SqlDbType.Binary           : 								case SqlDbType.UniqueIdentifier : 								case SqlDbType.Timestamp        : 								case SqlDbType.VarBinary        : 								case SqlDbType.Variant          : 								case SqlDbType.Xml              : 								case SqlDbType.Udt              : 								case SqlDbType.Structured       : name = "CVar"; break; 							}  							return new SqlFunction(name' func.Parameters[1]); 						} 						*/}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation [0]) {  	case '%':  		return new SqlBinaryExpression (be.SystemType' be.Expr1' "MOD"' be.Expr2' Precedence.Additive - 1);  	case '&':  	case '|':  	case '^':  		throw new SqlException ("Operator '{0}' is not supported by the {1}."' be.Operation' GetType ().Name);  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		if (func.Parameters.Length > 2) {  			var parms = new ISqlExpression[func.Parameters.Length - 1];  			Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  			return new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms));  		}  		var sc = new SqlQuery.SearchCondition ();  		sc.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.IsNull (func.Parameters [0]' false)));  		return new SqlFunction (func.SystemType' "Iif"' sc' func.Parameters [1]' func.Parameters [0]);  	case "CASE":  		return ConvertCase (func.SystemType' func.Parameters' 0);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' new SqlValue (1)' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [2]' func.Parameters [1]' func.Parameters [0]' new SqlValue (1));  	case "Convert": {  		switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  		case TypeCode.String:  			return new SqlFunction (func.SystemType' "CStr"' func.Parameters [1]);  		case TypeCode.DateTime:  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "DateValue"' func.Parameters [1]);  			if (IsTimeDataType (func.Parameters [0]))  				return new SqlFunction (func.SystemType' "TimeValue"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "CDate"' func.Parameters [1]);  		default:  			if (func.SystemType == typeof(DateTime))  				goto case TypeCode.DateTime;  			break;  		}  		return func.Parameters [1];  	}  	/* 					case "Convert"   : 						{ 							string name = null;  							switch (((SqlDataType)func.Parameters[0]).DbType) 							{ 								case SqlDbType.BigInt           : name = "CLng"; break; 								case SqlDbType.TinyInt          : name = "CByte"; break; 								case SqlDbType.Int              : 								case SqlDbType.SmallInt         : name = "CInt"; break; 								case SqlDbType.Bit              : name = "CBool"; break; 								case SqlDbType.Char             : 								case SqlDbType.Text             : 								case SqlDbType.VarChar          : 								case SqlDbType.NChar            : 								case SqlDbType.NText            : 								case SqlDbType.NVarChar         : name = "CStr"; break; 								case SqlDbType.DateTime         : 								case SqlDbType.Date             : 								case SqlDbType.Time             : 								case SqlDbType.DateTime2        : 								case SqlDbType.SmallDateTime    : 								case SqlDbType.DateTimeOffset   : name = "CDate"; break; 								case SqlDbType.Decimal          : name = "CDec"; break; 								case SqlDbType.Float            : name = "CDbl"; break; 								case SqlDbType.Money            : 								case SqlDbType.SmallMoney       : name = "CCur"; break; 								case SqlDbType.Real             : name = "CSng"; break; 								case SqlDbType.Image            : 								case SqlDbType.Binary           : 								case SqlDbType.UniqueIdentifier : 								case SqlDbType.Timestamp        : 								case SqlDbType.VarBinary        : 								case SqlDbType.Variant          : 								case SqlDbType.Xml              : 								case SqlDbType.Udt              : 								case SqlDbType.Structured       : name = "CVar"; break; 							}  							return new SqlFunction(name' func.Parameters[1]); 						} 						*/}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation [0]) {  	case '%':  		return new SqlBinaryExpression (be.SystemType' be.Expr1' "MOD"' be.Expr2' Precedence.Additive - 1);  	case '&':  	case '|':  	case '^':  		throw new SqlException ("Operator '{0}' is not supported by the {1}."' be.Operation' GetType ().Name);  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		if (func.Parameters.Length > 2) {  			var parms = new ISqlExpression[func.Parameters.Length - 1];  			Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  			return new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms));  		}  		var sc = new SqlQuery.SearchCondition ();  		sc.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.IsNull (func.Parameters [0]' false)));  		return new SqlFunction (func.SystemType' "Iif"' sc' func.Parameters [1]' func.Parameters [0]);  	case "CASE":  		return ConvertCase (func.SystemType' func.Parameters' 0);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' new SqlValue (1)' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [2]' func.Parameters [1]' func.Parameters [0]' new SqlValue (1));  	case "Convert": {  		switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  		case TypeCode.String:  			return new SqlFunction (func.SystemType' "CStr"' func.Parameters [1]);  		case TypeCode.DateTime:  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "DateValue"' func.Parameters [1]);  			if (IsTimeDataType (func.Parameters [0]))  				return new SqlFunction (func.SystemType' "TimeValue"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "CDate"' func.Parameters [1]);  		default:  			if (func.SystemType == typeof(DateTime))  				goto case TypeCode.DateTime;  			break;  		}  		return func.Parameters [1];  	}  	/* 					case "Convert"   : 						{ 							string name = null;  							switch (((SqlDataType)func.Parameters[0]).DbType) 							{ 								case SqlDbType.BigInt           : name = "CLng"; break; 								case SqlDbType.TinyInt          : name = "CByte"; break; 								case SqlDbType.Int              : 								case SqlDbType.SmallInt         : name = "CInt"; break; 								case SqlDbType.Bit              : name = "CBool"; break; 								case SqlDbType.Char             : 								case SqlDbType.Text             : 								case SqlDbType.VarChar          : 								case SqlDbType.NChar            : 								case SqlDbType.NText            : 								case SqlDbType.NVarChar         : name = "CStr"; break; 								case SqlDbType.DateTime         : 								case SqlDbType.Date             : 								case SqlDbType.Time             : 								case SqlDbType.DateTime2        : 								case SqlDbType.SmallDateTime    : 								case SqlDbType.DateTimeOffset   : name = "CDate"; break; 								case SqlDbType.Decimal          : name = "CDec"; break; 								case SqlDbType.Float            : name = "CDbl"; break; 								case SqlDbType.Money            : 								case SqlDbType.SmallMoney       : name = "CCur"; break; 								case SqlDbType.Real             : name = "CSng"; break; 								case SqlDbType.Image            : 								case SqlDbType.Binary           : 								case SqlDbType.UniqueIdentifier : 								case SqlDbType.Timestamp        : 								case SqlDbType.VarBinary        : 								case SqlDbType.Variant          : 								case SqlDbType.Xml              : 								case SqlDbType.Udt              : 								case SqlDbType.Structured       : name = "CVar"; break; 							}  							return new SqlFunction(name' func.Parameters[1]); 						} 						*/}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		if (func.Parameters.Length > 2) {  			var parms = new ISqlExpression[func.Parameters.Length - 1];  			Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  			return new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms));  		}  		var sc = new SqlQuery.SearchCondition ();  		sc.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.IsNull (func.Parameters [0]' false)));  		return new SqlFunction (func.SystemType' "Iif"' sc' func.Parameters [1]' func.Parameters [0]);  	case "CASE":  		return ConvertCase (func.SystemType' func.Parameters' 0);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' new SqlValue (1)' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [2]' func.Parameters [1]' func.Parameters [0]' new SqlValue (1));  	case "Convert": {  		switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  		case TypeCode.String:  			return new SqlFunction (func.SystemType' "CStr"' func.Parameters [1]);  		case TypeCode.DateTime:  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "DateValue"' func.Parameters [1]);  			if (IsTimeDataType (func.Parameters [0]))  				return new SqlFunction (func.SystemType' "TimeValue"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "CDate"' func.Parameters [1]);  		default:  			if (func.SystemType == typeof(DateTime))  				goto case TypeCode.DateTime;  			break;  		}  		return func.Parameters [1];  	}  	/* 					case "Convert"   : 						{ 							string name = null;  							switch (((SqlDataType)func.Parameters[0]).DbType) 							{ 								case SqlDbType.BigInt           : name = "CLng"; break; 								case SqlDbType.TinyInt          : name = "CByte"; break; 								case SqlDbType.Int              : 								case SqlDbType.SmallInt         : name = "CInt"; break; 								case SqlDbType.Bit              : name = "CBool"; break; 								case SqlDbType.Char             : 								case SqlDbType.Text             : 								case SqlDbType.VarChar          : 								case SqlDbType.NChar            : 								case SqlDbType.NText            : 								case SqlDbType.NVarChar         : name = "CStr"; break; 								case SqlDbType.DateTime         : 								case SqlDbType.Date             : 								case SqlDbType.Time             : 								case SqlDbType.DateTime2        : 								case SqlDbType.SmallDateTime    : 								case SqlDbType.DateTimeOffset   : name = "CDate"; break; 								case SqlDbType.Decimal          : name = "CDec"; break; 								case SqlDbType.Float            : name = "CDbl"; break; 								case SqlDbType.Money            : 								case SqlDbType.SmallMoney       : name = "CCur"; break; 								case SqlDbType.Real             : name = "CSng"; break; 								case SqlDbType.Image            : 								case SqlDbType.Binary           : 								case SqlDbType.UniqueIdentifier : 								case SqlDbType.Timestamp        : 								case SqlDbType.VarBinary        : 								case SqlDbType.Variant          : 								case SqlDbType.Xml              : 								case SqlDbType.Udt              : 								case SqlDbType.Structured       : name = "CVar"; break; 							}  							return new SqlFunction(name' func.Parameters[1]); 						} 						*/}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		if (func.Parameters.Length > 2) {  			var parms = new ISqlExpression[func.Parameters.Length - 1];  			Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  			return new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms));  		}  		var sc = new SqlQuery.SearchCondition ();  		sc.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.IsNull (func.Parameters [0]' false)));  		return new SqlFunction (func.SystemType' "Iif"' sc' func.Parameters [1]' func.Parameters [0]);  	case "CASE":  		return ConvertCase (func.SystemType' func.Parameters' 0);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' new SqlValue (1)' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [2]' func.Parameters [1]' func.Parameters [0]' new SqlValue (1));  	case "Convert": {  		switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  		case TypeCode.String:  			return new SqlFunction (func.SystemType' "CStr"' func.Parameters [1]);  		case TypeCode.DateTime:  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "DateValue"' func.Parameters [1]);  			if (IsTimeDataType (func.Parameters [0]))  				return new SqlFunction (func.SystemType' "TimeValue"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "CDate"' func.Parameters [1]);  		default:  			if (func.SystemType == typeof(DateTime))  				goto case TypeCode.DateTime;  			break;  		}  		return func.Parameters [1];  	}  	/* 					case "Convert"   : 						{ 							string name = null;  							switch (((SqlDataType)func.Parameters[0]).DbType) 							{ 								case SqlDbType.BigInt           : name = "CLng"; break; 								case SqlDbType.TinyInt          : name = "CByte"; break; 								case SqlDbType.Int              : 								case SqlDbType.SmallInt         : name = "CInt"; break; 								case SqlDbType.Bit              : name = "CBool"; break; 								case SqlDbType.Char             : 								case SqlDbType.Text             : 								case SqlDbType.VarChar          : 								case SqlDbType.NChar            : 								case SqlDbType.NText            : 								case SqlDbType.NVarChar         : name = "CStr"; break; 								case SqlDbType.DateTime         : 								case SqlDbType.Date             : 								case SqlDbType.Time             : 								case SqlDbType.DateTime2        : 								case SqlDbType.SmallDateTime    : 								case SqlDbType.DateTimeOffset   : name = "CDate"; break; 								case SqlDbType.Decimal          : name = "CDec"; break; 								case SqlDbType.Float            : name = "CDbl"; break; 								case SqlDbType.Money            : 								case SqlDbType.SmallMoney       : name = "CCur"; break; 								case SqlDbType.Real             : name = "CSng"; break; 								case SqlDbType.Image            : 								case SqlDbType.Binary           : 								case SqlDbType.UniqueIdentifier : 								case SqlDbType.Timestamp        : 								case SqlDbType.VarBinary        : 								case SqlDbType.Variant          : 								case SqlDbType.Xml              : 								case SqlDbType.Udt              : 								case SqlDbType.Structured       : name = "CVar"; break; 							}  							return new SqlFunction(name' func.Parameters[1]); 						} 						*/}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		if (func.Parameters.Length > 2) {  			var parms = new ISqlExpression[func.Parameters.Length - 1];  			Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  			return new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms));  		}  		var sc = new SqlQuery.SearchCondition ();  		sc.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.IsNull (func.Parameters [0]' false)));  		return new SqlFunction (func.SystemType' "Iif"' sc' func.Parameters [1]' func.Parameters [0]);  	case "CASE":  		return ConvertCase (func.SystemType' func.Parameters' 0);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' new SqlValue (1)' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [2]' func.Parameters [1]' func.Parameters [0]' new SqlValue (1));  	case "Convert": {  		switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  		case TypeCode.String:  			return new SqlFunction (func.SystemType' "CStr"' func.Parameters [1]);  		case TypeCode.DateTime:  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "DateValue"' func.Parameters [1]);  			if (IsTimeDataType (func.Parameters [0]))  				return new SqlFunction (func.SystemType' "TimeValue"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "CDate"' func.Parameters [1]);  		default:  			if (func.SystemType == typeof(DateTime))  				goto case TypeCode.DateTime;  			break;  		}  		return func.Parameters [1];  	}  	/* 					case "Convert"   : 						{ 							string name = null;  							switch (((SqlDataType)func.Parameters[0]).DbType) 							{ 								case SqlDbType.BigInt           : name = "CLng"; break; 								case SqlDbType.TinyInt          : name = "CByte"; break; 								case SqlDbType.Int              : 								case SqlDbType.SmallInt         : name = "CInt"; break; 								case SqlDbType.Bit              : name = "CBool"; break; 								case SqlDbType.Char             : 								case SqlDbType.Text             : 								case SqlDbType.VarChar          : 								case SqlDbType.NChar            : 								case SqlDbType.NText            : 								case SqlDbType.NVarChar         : name = "CStr"; break; 								case SqlDbType.DateTime         : 								case SqlDbType.Date             : 								case SqlDbType.Time             : 								case SqlDbType.DateTime2        : 								case SqlDbType.SmallDateTime    : 								case SqlDbType.DateTimeOffset   : name = "CDate"; break; 								case SqlDbType.Decimal          : name = "CDec"; break; 								case SqlDbType.Float            : name = "CDbl"; break; 								case SqlDbType.Money            : 								case SqlDbType.SmallMoney       : name = "CCur"; break; 								case SqlDbType.Real             : name = "CSng"; break; 								case SqlDbType.Image            : 								case SqlDbType.Binary           : 								case SqlDbType.UniqueIdentifier : 								case SqlDbType.Timestamp        : 								case SqlDbType.VarBinary        : 								case SqlDbType.Variant          : 								case SqlDbType.Xml              : 								case SqlDbType.Udt              : 								case SqlDbType.Structured       : name = "CVar"; break; 							}  							return new SqlFunction(name' func.Parameters[1]); 						} 						*/}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	if (func.Parameters.Length > 2) {  		var parms = new ISqlExpression[func.Parameters.Length - 1];  		Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  		return new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms));  	}  	var sc = new SqlQuery.SearchCondition ();  	sc.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.IsNull (func.Parameters [0]' false)));  	return new SqlFunction (func.SystemType' "Iif"' sc' func.Parameters [1]' func.Parameters [0]);  case "CASE":  	return ConvertCase (func.SystemType' func.Parameters' 0);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' new SqlValue (1)' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [2]' func.Parameters [1]' func.Parameters [0]' new SqlValue (1));  case "Convert": {  	switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  	case TypeCode.String:  		return new SqlFunction (func.SystemType' "CStr"' func.Parameters [1]);  	case TypeCode.DateTime:  		if (IsDateDataType (func.Parameters [0]' "Date"))  			return new SqlFunction (func.SystemType' "DateValue"' func.Parameters [1]);  		if (IsTimeDataType (func.Parameters [0]))  			return new SqlFunction (func.SystemType' "TimeValue"' func.Parameters [1]);  		return new SqlFunction (func.SystemType' "CDate"' func.Parameters [1]);  	default:  		if (func.SystemType == typeof(DateTime))  			goto case TypeCode.DateTime;  		break;  	}  	return func.Parameters [1];  }  /* 					case "Convert"   : 						{ 							string name = null;  							switch (((SqlDataType)func.Parameters[0]).DbType) 							{ 								case SqlDbType.BigInt           : name = "CLng"; break; 								case SqlDbType.TinyInt          : name = "CByte"; break; 								case SqlDbType.Int              : 								case SqlDbType.SmallInt         : name = "CInt"; break; 								case SqlDbType.Bit              : name = "CBool"; break; 								case SqlDbType.Char             : 								case SqlDbType.Text             : 								case SqlDbType.VarChar          : 								case SqlDbType.NChar            : 								case SqlDbType.NText            : 								case SqlDbType.NVarChar         : name = "CStr"; break; 								case SqlDbType.DateTime         : 								case SqlDbType.Date             : 								case SqlDbType.Time             : 								case SqlDbType.DateTime2        : 								case SqlDbType.SmallDateTime    : 								case SqlDbType.DateTimeOffset   : name = "CDate"; break; 								case SqlDbType.Decimal          : name = "CDec"; break; 								case SqlDbType.Float            : name = "CDbl"; break; 								case SqlDbType.Money            : 								case SqlDbType.SmallMoney       : name = "CCur"; break; 								case SqlDbType.Real             : name = "CSng"; break; 								case SqlDbType.Image            : 								case SqlDbType.Binary           : 								case SqlDbType.UniqueIdentifier : 								case SqlDbType.Timestamp        : 								case SqlDbType.VarBinary        : 								case SqlDbType.Variant          : 								case SqlDbType.Xml              : 								case SqlDbType.Udt              : 								case SqlDbType.Structured       : name = "CVar"; break; 							}  							return new SqlFunction(name' func.Parameters[1]); 						} 						*/}  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	if (func.Parameters.Length > 2) {  		var parms = new ISqlExpression[func.Parameters.Length - 1];  		Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  		return new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms));  	}  	var sc = new SqlQuery.SearchCondition ();  	sc.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.IsNull (func.Parameters [0]' false)));  	return new SqlFunction (func.SystemType' "Iif"' sc' func.Parameters [1]' func.Parameters [0]);  case "CASE":  	return ConvertCase (func.SystemType' func.Parameters' 0);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' new SqlValue (1)' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [2]' func.Parameters [1]' func.Parameters [0]' new SqlValue (1));  case "Convert": {  	switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  	case TypeCode.String:  		return new SqlFunction (func.SystemType' "CStr"' func.Parameters [1]);  	case TypeCode.DateTime:  		if (IsDateDataType (func.Parameters [0]' "Date"))  			return new SqlFunction (func.SystemType' "DateValue"' func.Parameters [1]);  		if (IsTimeDataType (func.Parameters [0]))  			return new SqlFunction (func.SystemType' "TimeValue"' func.Parameters [1]);  		return new SqlFunction (func.SystemType' "CDate"' func.Parameters [1]);  	default:  		if (func.SystemType == typeof(DateTime))  			goto case TypeCode.DateTime;  		break;  	}  	return func.Parameters [1];  }  /* 					case "Convert"   : 						{ 							string name = null;  							switch (((SqlDataType)func.Parameters[0]).DbType) 							{ 								case SqlDbType.BigInt           : name = "CLng"; break; 								case SqlDbType.TinyInt          : name = "CByte"; break; 								case SqlDbType.Int              : 								case SqlDbType.SmallInt         : name = "CInt"; break; 								case SqlDbType.Bit              : name = "CBool"; break; 								case SqlDbType.Char             : 								case SqlDbType.Text             : 								case SqlDbType.VarChar          : 								case SqlDbType.NChar            : 								case SqlDbType.NText            : 								case SqlDbType.NVarChar         : name = "CStr"; break; 								case SqlDbType.DateTime         : 								case SqlDbType.Date             : 								case SqlDbType.Time             : 								case SqlDbType.DateTime2        : 								case SqlDbType.SmallDateTime    : 								case SqlDbType.DateTimeOffset   : name = "CDate"; break; 								case SqlDbType.Decimal          : name = "CDec"; break; 								case SqlDbType.Float            : name = "CDbl"; break; 								case SqlDbType.Money            : 								case SqlDbType.SmallMoney       : name = "CCur"; break; 								case SqlDbType.Real             : name = "CSng"; break; 								case SqlDbType.Image            : 								case SqlDbType.Binary           : 								case SqlDbType.UniqueIdentifier : 								case SqlDbType.Timestamp        : 								case SqlDbType.VarBinary        : 								case SqlDbType.Variant          : 								case SqlDbType.Xml              : 								case SqlDbType.Udt              : 								case SqlDbType.Structured       : name = "CVar"; break; 							}  							return new SqlFunction(name' func.Parameters[1]); 						} 						*/}  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	if (func.Parameters.Length > 2) {  		var parms = new ISqlExpression[func.Parameters.Length - 1];  		Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  		return new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms));  	}  	var sc = new SqlQuery.SearchCondition ();  	sc.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.IsNull (func.Parameters [0]' false)));  	return new SqlFunction (func.SystemType' "Iif"' sc' func.Parameters [1]' func.Parameters [0]);  case "CASE":  	return ConvertCase (func.SystemType' func.Parameters' 0);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' new SqlValue (1)' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [2]' func.Parameters [1]' func.Parameters [0]' new SqlValue (1));  case "Convert": {  	switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  	case TypeCode.String:  		return new SqlFunction (func.SystemType' "CStr"' func.Parameters [1]);  	case TypeCode.DateTime:  		if (IsDateDataType (func.Parameters [0]' "Date"))  			return new SqlFunction (func.SystemType' "DateValue"' func.Parameters [1]);  		if (IsTimeDataType (func.Parameters [0]))  			return new SqlFunction (func.SystemType' "TimeValue"' func.Parameters [1]);  		return new SqlFunction (func.SystemType' "CDate"' func.Parameters [1]);  	default:  		if (func.SystemType == typeof(DateTime))  			goto case TypeCode.DateTime;  		break;  	}  	return func.Parameters [1];  }  /* 					case "Convert"   : 						{ 							string name = null;  							switch (((SqlDataType)func.Parameters[0]).DbType) 							{ 								case SqlDbType.BigInt           : name = "CLng"; break; 								case SqlDbType.TinyInt          : name = "CByte"; break; 								case SqlDbType.Int              : 								case SqlDbType.SmallInt         : name = "CInt"; break; 								case SqlDbType.Bit              : name = "CBool"; break; 								case SqlDbType.Char             : 								case SqlDbType.Text             : 								case SqlDbType.VarChar          : 								case SqlDbType.NChar            : 								case SqlDbType.NText            : 								case SqlDbType.NVarChar         : name = "CStr"; break; 								case SqlDbType.DateTime         : 								case SqlDbType.Date             : 								case SqlDbType.Time             : 								case SqlDbType.DateTime2        : 								case SqlDbType.SmallDateTime    : 								case SqlDbType.DateTimeOffset   : name = "CDate"; break; 								case SqlDbType.Decimal          : name = "CDec"; break; 								case SqlDbType.Float            : name = "CDbl"; break; 								case SqlDbType.Money            : 								case SqlDbType.SmallMoney       : name = "CCur"; break; 								case SqlDbType.Real             : name = "CSng"; break; 								case SqlDbType.Image            : 								case SqlDbType.Binary           : 								case SqlDbType.UniqueIdentifier : 								case SqlDbType.Timestamp        : 								case SqlDbType.VarBinary        : 								case SqlDbType.Variant          : 								case SqlDbType.Xml              : 								case SqlDbType.Udt              : 								case SqlDbType.Structured       : name = "CVar"; break; 							}  							return new SqlFunction(name' func.Parameters[1]); 						} 						*/}  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Parameters.Length > 2) {  	var parms = new ISqlExpression[func.Parameters.Length - 1];  	Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  	return new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' new SqlValue (1)' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [2]' func.Parameters [1]' func.Parameters [0]' new SqlValue (1));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' new SqlValue (1)' func.Parameters [1]' func.Parameters [0]' new SqlValue (1)) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [2]' func.Parameters [1]' func.Parameters [0]' new SqlValue (1));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertCase,The following statement contains a magic number: if (len < 3)  	throw new SqlException ("CASE statement is not supported by the {0}."' GetType ().Name);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertCase,The following statement contains a magic number: if (len == 3)  	return new SqlFunction (systemType' "Iif"' parameters [start]' parameters [start + 1]' parameters [start + 2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertCase,The following statement contains a magic number: if (len == 3)  	return new SqlFunction (systemType' "Iif"' parameters [start]' parameters [start + 1]' parameters [start + 2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertCase,The following statement contains a magic number: return new SqlFunction (systemType' "Iif"' parameters [start]' parameters [start + 1]' parameters [start + 2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertCase,The following statement contains a magic number: return new SqlFunction (systemType' "Iif"' parameters [start]' parameters [start + 1]' ConvertCase (systemType' parameters' start + 2));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,BuildUpdateClause,The following statement contains a magic number: sb.Remove (0' 4).Insert (0' "UPDATE");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  	case TypeCode.DateTime:  		if (func.Name == "Convert") {  			var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  			if (IsTimeDataType (func.Parameters [0])) {  				if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  					return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  			}  			if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  				if (IsDateDataType (func.Parameters [0]' "Datetime"))  					return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  			}  			if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  				return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  	case TypeCode.DateTime:  		if (func.Name == "Convert") {  			var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  			if (IsTimeDataType (func.Parameters [0])) {  				if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  					return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  			}  			if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  				if (IsDateDataType (func.Parameters [0]' "Datetime"))  					return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  			}  			if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  				return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  case TypeCode.DateTime:  	if (func.Name == "Convert") {  		var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  		if (IsTimeDataType (func.Parameters [0])) {  			if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  				return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  		}  		if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Datetime"))  				return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  		}  		if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  case TypeCode.DateTime:  	if (func.Name == "Convert") {  		var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  		if (IsTimeDataType (func.Parameters [0])) {  			if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  				return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  		}  		if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Datetime"))  				return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  		}  		if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Name == "Convert") {  	var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  	if (IsTimeDataType (func.Parameters [0])) {  		if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  			return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  		if (func.Parameters [1].SystemType == typeof(string))  			return func.Parameters [1];  		return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  	}  	if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  		if (IsDateDataType (func.Parameters [0]' "Datetime"))  			return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  	}  	if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  		return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Name == "Convert") {  	var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  	if (IsTimeDataType (func.Parameters [0])) {  		if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  			return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  		if (func.Parameters [1].SystemType == typeof(string))  			return func.Parameters [1];  		return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  	}  	if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  		if (IsDateDataType (func.Parameters [0]' "Datetime"))  			return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  	}  	if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  		return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  	return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  	return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "CharIndex":  		if (func.Parameters.Length == 3)  			return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  		break;  	case "Stuff":  		if (func.Parameters [3] is SqlValue) {  			var value = (SqlValue)func.Parameters [3];  			if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  				return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "CharIndex":  		if (func.Parameters.Length == 3)  			return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  		break;  	case "Stuff":  		if (func.Parameters [3] is SqlValue) {  			var value = (SqlValue)func.Parameters [3];  			if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  				return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "CharIndex":  		if (func.Parameters.Length == 3)  			return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  		break;  	case "Stuff":  		if (func.Parameters [3] is SqlValue) {  			var value = (SqlValue)func.Parameters [3];  			if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  				return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "CharIndex":  		if (func.Parameters.Length == 3)  			return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  		break;  	case "Stuff":  		if (func.Parameters [3] is SqlValue) {  			var value = (SqlValue)func.Parameters [3];  			if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  				return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "CharIndex":  		if (func.Parameters.Length == 3)  			return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  		break;  	case "Stuff":  		if (func.Parameters [3] is SqlValue) {  			var value = (SqlValue)func.Parameters [3];  			if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  				return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "CharIndex":  	if (func.Parameters.Length == 3)  		return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  	break;  case "Stuff":  	if (func.Parameters [3] is SqlValue) {  		var value = (SqlValue)func.Parameters [3];  		if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "CharIndex":  	if (func.Parameters.Length == 3)  		return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  	break;  case "Stuff":  	if (func.Parameters [3] is SqlValue) {  		var value = (SqlValue)func.Parameters [3];  		if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "CharIndex":  	if (func.Parameters.Length == 3)  		return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  	break;  case "Stuff":  	if (func.Parameters [3] is SqlValue) {  		var value = (SqlValue)func.Parameters [3];  		if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "CharIndex":  	if (func.Parameters.Length == 3)  		return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  	break;  case "Stuff":  	if (func.Parameters [3] is SqlValue) {  		var value = (SqlValue)func.Parameters [3];  		if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "CharIndex":  	if (func.Parameters.Length == 3)  		return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  	break;  case "Stuff":  	if (func.Parameters [3] is SqlValue) {  		var value = (SqlValue)func.Parameters [3];  		if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Parameters.Length == 3)  	return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Parameters.Length == 3)  	return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Parameters.Length == 3)  	return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Parameters [3] is SqlValue) {  	var value = (SqlValue)func.Parameters [3];  	if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  		return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (func.Parameters [3] is SqlValue) {  	var value = (SqlValue)func.Parameters [3];  	if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  		return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,BuildString,The following statement contains a magic number: foreach (var ch in value) {  	if (ch > 127) {  		sb.Append ("N");  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,BuildString,The following statement contains a magic number: if (ch > 127) {  	sb.Append ("N");  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,BuildChar,The following statement contains a magic number: if (value > 127)  	sb.Append ("N");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: switch (convertType) {  case ConvertType.NameToQueryParameter:  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter: {  	var name = "@" + value.ToString ().Replace (" "' string.Empty);  	if (name.Length > 27)  		name = name.Substring (0' 27);  	return name;  }  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTableAlias:  	{  		var name = value.ToString ();  		if (name.Length > 28 || name.Length > 0 && name [0] == '[')  			return value;  	}  	return "[" + value + "]";  case ConvertType.NameToDatabase:  case ConvertType.NameToOwner:  case ConvertType.NameToQueryTable:  	{  		var name = value.ToString ();  		if (name.Length > 28 || name.Length > 0 && (name [0] == '[' || name [0] == '#'))  			return value;  		if (name.IndexOf ('.') > 0)  			value = string.Join ("].["' name.Split ('.'));  	}  	return "[" + value + "]";  case ConvertType.SprocParameterToName:  	if (value != null) {  		var str = value.ToString ();  		return str.Length > 0 && str [0] == '@' ? str.Substring (1) : str;  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: switch (convertType) {  case ConvertType.NameToQueryParameter:  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter: {  	var name = "@" + value.ToString ().Replace (" "' string.Empty);  	if (name.Length > 27)  		name = name.Substring (0' 27);  	return name;  }  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTableAlias:  	{  		var name = value.ToString ();  		if (name.Length > 28 || name.Length > 0 && name [0] == '[')  			return value;  	}  	return "[" + value + "]";  case ConvertType.NameToDatabase:  case ConvertType.NameToOwner:  case ConvertType.NameToQueryTable:  	{  		var name = value.ToString ();  		if (name.Length > 28 || name.Length > 0 && (name [0] == '[' || name [0] == '#'))  			return value;  		if (name.IndexOf ('.') > 0)  			value = string.Join ("].["' name.Split ('.'));  	}  	return "[" + value + "]";  case ConvertType.SprocParameterToName:  	if (value != null) {  		var str = value.ToString ();  		return str.Length > 0 && str [0] == '@' ? str.Substring (1) : str;  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: switch (convertType) {  case ConvertType.NameToQueryParameter:  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter: {  	var name = "@" + value.ToString ().Replace (" "' string.Empty);  	if (name.Length > 27)  		name = name.Substring (0' 27);  	return name;  }  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTableAlias:  	{  		var name = value.ToString ();  		if (name.Length > 28 || name.Length > 0 && name [0] == '[')  			return value;  	}  	return "[" + value + "]";  case ConvertType.NameToDatabase:  case ConvertType.NameToOwner:  case ConvertType.NameToQueryTable:  	{  		var name = value.ToString ();  		if (name.Length > 28 || name.Length > 0 && (name [0] == '[' || name [0] == '#'))  			return value;  		if (name.IndexOf ('.') > 0)  			value = string.Join ("].["' name.Split ('.'));  	}  	return "[" + value + "]";  case ConvertType.SprocParameterToName:  	if (value != null) {  		var str = value.ToString ();  		return str.Length > 0 && str [0] == '@' ? str.Substring (1) : str;  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: switch (convertType) {  case ConvertType.NameToQueryParameter:  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter: {  	var name = "@" + value.ToString ().Replace (" "' string.Empty);  	if (name.Length > 27)  		name = name.Substring (0' 27);  	return name;  }  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTableAlias:  	{  		var name = value.ToString ();  		if (name.Length > 28 || name.Length > 0 && name [0] == '[')  			return value;  	}  	return "[" + value + "]";  case ConvertType.NameToDatabase:  case ConvertType.NameToOwner:  case ConvertType.NameToQueryTable:  	{  		var name = value.ToString ();  		if (name.Length > 28 || name.Length > 0 && (name [0] == '[' || name [0] == '#'))  			return value;  		if (name.IndexOf ('.') > 0)  			value = string.Join ("].["' name.Split ('.'));  	}  	return "[" + value + "]";  case ConvertType.SprocParameterToName:  	if (value != null) {  		var str = value.ToString ();  		return str.Length > 0 && str [0] == '@' ? str.Substring (1) : str;  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: if (name.Length > 27)  	name = name.Substring (0' 27);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: if (name.Length > 27)  	name = name.Substring (0' 27);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: name = name.Substring (0' 27);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: if (name.Length > 28 || name.Length > 0 && name [0] == '[')  	return value;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following statement contains a magic number: if (name.Length > 28 || name.Length > 0 && (name [0] == '[' || name [0] == '#'))  	return value;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,BuildString,The following statement contains a magic number: foreach (var ch in value) {  	if (ch > 127) {  		sb.Append ("N");  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,BuildString,The following statement contains a magic number: if (ch > 127) {  	sb.Append ("N");  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,BuildChar,The following statement contains a magic number: if (value > 127)  	sb.Append ("N");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,CommandCount,The following statement contains a magic number: return sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity ? 2 : 1;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,BuildUpdateClause,The following statement contains a magic number: sb.Remove (0' 4).Insert (0' "UPDATE");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: for (var i = 0; i < barray.Length; ++i) {  	var b = ((byte)(barray [i] >> 4));  	c [i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  	b = ((byte)(barray [i] & 0xF));  	c [i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: for (var i = 0; i < barray.Length; ++i) {  	var b = ((byte)(barray [i] >> 4));  	c [i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  	b = ((byte)(barray [i] & 0xF));  	c [i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: for (var i = 0; i < barray.Length; ++i) {  	var b = ((byte)(barray [i] >> 4));  	c [i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  	b = ((byte)(barray [i] & 0xF));  	c [i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: for (var i = 0; i < barray.Length; ++i) {  	var b = ((byte)(barray [i] >> 4));  	c [i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  	b = ((byte)(barray [i] & 0xF));  	c [i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: for (var i = 0; i < barray.Length; ++i) {  	var b = ((byte)(barray [i] >> 4));  	c [i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  	b = ((byte)(barray [i] & 0xF));  	c [i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: c [i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: c [i * 2] = (char)(b > 9 ? b + 0x37 : b + 0x30);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: c [i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ByteArrayToHex,The following statement contains a magic number: c [i * 2 + 1] = (char)(b > 9 ? b + 0x37 : b + 0x30);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,CommandCount,The following statement contains a magic number: return sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity ? 2 : 1;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,CommandCount,The following statement contains a magic number: return sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity ? 2 : 1;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	case "^":  		// (a + b) - (a & b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlBinaryExpression (be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType);  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Space":  		return new SqlFunction (func.SystemType' "PadR"' new SqlValue (" ")' func.Parameters [0]);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "Date"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "DateTime"' func.Parameters [1]);  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters [1]' func.Parameters [0]);  	}  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Cast(StrFTime(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Cast(StrFTime('%w'"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));  	if (e.Expr.StartsWith ("Cast(StrFTime('%f'"))  		return new SqlExpression (e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);  	if (e.Expr.StartsWith ("DateTime")) {  		if (e.Expr.EndsWith ("Quarter')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  		if (e.Expr.EndsWith ("Week')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	case "^":  		// (a + b) - (a & b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlBinaryExpression (be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType);  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Space":  		return new SqlFunction (func.SystemType' "PadR"' new SqlValue (" ")' func.Parameters [0]);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "Date"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "DateTime"' func.Parameters [1]);  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters [1]' func.Parameters [0]);  	}  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Cast(StrFTime(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Cast(StrFTime('%w'"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));  	if (e.Expr.StartsWith ("Cast(StrFTime('%f'"))  		return new SqlExpression (e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);  	if (e.Expr.StartsWith ("DateTime")) {  		if (e.Expr.EndsWith ("Quarter')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  		if (e.Expr.EndsWith ("Week')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	case "^":  		// (a + b) - (a & b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlBinaryExpression (be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType);  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Space":  		return new SqlFunction (func.SystemType' "PadR"' new SqlValue (" ")' func.Parameters [0]);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "Date"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "DateTime"' func.Parameters [1]);  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters [1]' func.Parameters [0]);  	}  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Cast(StrFTime(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Cast(StrFTime('%w'"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));  	if (e.Expr.StartsWith ("Cast(StrFTime('%f'"))  		return new SqlExpression (e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);  	if (e.Expr.StartsWith ("DateTime")) {  		if (e.Expr.EndsWith ("Quarter')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  		if (e.Expr.EndsWith ("Week')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	case "^":  		// (a + b) - (a & b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlBinaryExpression (be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType);  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Space":  		return new SqlFunction (func.SystemType' "PadR"' new SqlValue (" ")' func.Parameters [0]);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "Date"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "DateTime"' func.Parameters [1]);  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters [1]' func.Parameters [0]);  	}  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Cast(StrFTime(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Cast(StrFTime('%w'"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));  	if (e.Expr.StartsWith ("Cast(StrFTime('%f'"))  		return new SqlExpression (e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);  	if (e.Expr.StartsWith ("DateTime")) {  		if (e.Expr.EndsWith ("Quarter')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  		if (e.Expr.EndsWith ("Week')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (be.Operation) {  case "+":  	return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  case "^":  	// (a + b) - (a & b) * 2  	return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlBinaryExpression (be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlBinaryExpression (be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Space":  		return new SqlFunction (func.SystemType' "PadR"' new SqlValue (" ")' func.Parameters [0]);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "Date"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "DateTime"' func.Parameters [1]);  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters [1]' func.Parameters [0]);  	}  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Cast(StrFTime(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Cast(StrFTime('%w'"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));  	if (e.Expr.StartsWith ("Cast(StrFTime('%f'"))  		return new SqlExpression (e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);  	if (e.Expr.StartsWith ("DateTime")) {  		if (e.Expr.EndsWith ("Quarter')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  		if (e.Expr.EndsWith ("Week')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Space":  		return new SqlFunction (func.SystemType' "PadR"' new SqlValue (" ")' func.Parameters [0]);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "Date"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "DateTime"' func.Parameters [1]);  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters [1]' func.Parameters [0]);  	}  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Cast(StrFTime(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Cast(StrFTime('%w'"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));  	if (e.Expr.StartsWith ("Cast(StrFTime('%f'"))  		return new SqlExpression (e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);  	if (e.Expr.StartsWith ("DateTime")) {  		if (e.Expr.EndsWith ("Quarter')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  		if (e.Expr.EndsWith ("Week')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Space":  		return new SqlFunction (func.SystemType' "PadR"' new SqlValue (" ")' func.Parameters [0]);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Date"))  				return new SqlFunction (func.SystemType' "Date"' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "DateTime"' func.Parameters [1]);  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters [1]' func.Parameters [0]);  	}  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Cast(StrFTime(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Cast(StrFTime('%w'"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));  	if (e.Expr.StartsWith ("Cast(StrFTime('%f'"))  		return new SqlExpression (e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);  	if (e.Expr.StartsWith ("DateTime")) {  		if (e.Expr.EndsWith ("Quarter')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  		if (e.Expr.EndsWith ("Week')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Cast(StrFTime(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Cast(StrFTime('%w'"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));  	if (e.Expr.StartsWith ("Cast(StrFTime('%f'"))  		return new SqlExpression (e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);  	if (e.Expr.StartsWith ("DateTime")) {  		if (e.Expr.EndsWith ("Quarter')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  		if (e.Expr.EndsWith ("Week')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Cast(StrFTime(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Cast(StrFTime('%w'"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));  	if (e.Expr.StartsWith ("Cast(StrFTime('%f'"))  		return new SqlExpression (e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);  	if (e.Expr.StartsWith ("DateTime")) {  		if (e.Expr.EndsWith ("Quarter')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  		if (e.Expr.EndsWith ("Week')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Cast(StrFTime(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Cast(StrFTime('%w'"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime('%w'"' "Cast(strFTime('%w'")' e.Parameters));  	if (e.Expr.StartsWith ("Cast(StrFTime('%f'"))  		return new SqlExpression (e.SystemType' "Cast(strFTime('%f'' {0}) * 1000 as int) % 1000"' Precedence.Multiplicative' e.Parameters);  	if (e.Expr.StartsWith ("DateTime")) {  		if (e.Expr.EndsWith ("Quarter')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  		if (e.Expr.EndsWith ("Week')"))  			return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (e.Expr.StartsWith ("Cast(StrFTime(Quarter"))  	return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Inc (Div (Dec (new SqlExpression (e.SystemType' e.Expr.Replace ("Cast(StrFTime(Quarter"' "Cast(StrFTime('%m'")' e.Parameters))' 3));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (e.Expr.StartsWith ("DateTime")) {  	if (e.Expr.EndsWith ("Quarter')"))  		return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  	if (e.Expr.EndsWith ("Week')"))  		return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (e.Expr.StartsWith ("DateTime")) {  	if (e.Expr.EndsWith ("Quarter')"))  		return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  	if (e.Expr.EndsWith ("Week')"))  		return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (e.Expr.EndsWith ("Quarter')"))  	return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Month')"' Precedence.Primary' Mul (e.Parameters [0]' 3)' e.Parameters [1]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (e.Expr.EndsWith ("Week')"))  	return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlExpression (e.SystemType' "DateTime({1}' '{0} Day')"' Precedence.Primary' Mul (e.Parameters [0]' 7)' e.Parameters [1]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as blob)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	SqlBinaryExpression be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "Mod"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "Bin_Or"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	SqlFunction func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "DateAdd":  		switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Sql.DateParts.Quarter:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  		case Sql.DateParts.DayOfYear:  		case Sql.DateParts.WeekDay:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  		case Sql.DateParts.Week:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  		}  		break;  	}  } else if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	SqlBinaryExpression be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "Mod"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "Bin_Or"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	SqlFunction func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "DateAdd":  		switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Sql.DateParts.Quarter:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  		case Sql.DateParts.DayOfYear:  		case Sql.DateParts.WeekDay:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  		case Sql.DateParts.Week:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  		}  		break;  	}  } else if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	SqlBinaryExpression be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "Mod"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "Bin_Or"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	SqlFunction func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "DateAdd":  		switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Sql.DateParts.Quarter:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  		case Sql.DateParts.DayOfYear:  		case Sql.DateParts.WeekDay:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  		case Sql.DateParts.Week:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  		}  		break;  	}  } else if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	SqlBinaryExpression be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "Mod"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "Bin_Or"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	SqlFunction func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "DateAdd":  		switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Sql.DateParts.Quarter:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  		case Sql.DateParts.DayOfYear:  		case Sql.DateParts.WeekDay:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  		case Sql.DateParts.Week:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  		}  		break;  	}  } else if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	SqlBinaryExpression be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "Mod"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "Bin_Or"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	SqlFunction func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "DateAdd":  		switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Sql.DateParts.Quarter:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  		case Sql.DateParts.DayOfYear:  		case Sql.DateParts.WeekDay:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  		case Sql.DateParts.Week:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  		}  		break;  	}  } else if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	SqlBinaryExpression be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "Mod"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "Bin_Or"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	SqlFunction func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "DateAdd":  		switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Sql.DateParts.Quarter:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  		case Sql.DateParts.DayOfYear:  		case Sql.DateParts.WeekDay:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  		case Sql.DateParts.Week:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  		}  		break;  	}  } else if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	SqlFunction func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "DateAdd":  		switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Sql.DateParts.Quarter:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  		case Sql.DateParts.DayOfYear:  		case Sql.DateParts.WeekDay:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  		case Sql.DateParts.Week:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  		}  		break;  	}  } else if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	SqlFunction func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "DateAdd":  		switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Sql.DateParts.Quarter:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  		case Sql.DateParts.DayOfYear:  		case Sql.DateParts.WeekDay:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  		case Sql.DateParts.Week:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  		}  		break;  	}  } else if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	SqlFunction func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "DateAdd":  		switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Sql.DateParts.Quarter:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  		case Sql.DateParts.DayOfYear:  		case Sql.DateParts.WeekDay:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  		case Sql.DateParts.Week:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  		}  		break;  	}  } else if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	SqlFunction func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "DateAdd":  		switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Sql.DateParts.Quarter:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  		case Sql.DateParts.DayOfYear:  		case Sql.DateParts.WeekDay:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  		case Sql.DateParts.Week:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  		}  		break;  	}  } else if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	SqlFunction func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "DateAdd":  		switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Sql.DateParts.Quarter:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  		case Sql.DateParts.DayOfYear:  		case Sql.DateParts.WeekDay:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  		case Sql.DateParts.Week:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  		}  		break;  	}  } else if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	SqlFunction func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "DateAdd":  		switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Sql.DateParts.Quarter:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  		case Sql.DateParts.DayOfYear:  		case Sql.DateParts.WeekDay:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  		case Sql.DateParts.Week:  			return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  		}  		break;  	}  } else if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  case "DateAdd":  	switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  	case Sql.DateParts.Quarter:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  	case Sql.DateParts.DayOfYear:  	case Sql.DateParts.WeekDay:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  	case Sql.DateParts.Week:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  case "DateAdd":  	switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  	case Sql.DateParts.Quarter:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  	case Sql.DateParts.DayOfYear:  	case Sql.DateParts.WeekDay:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  	case Sql.DateParts.Week:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  case "DateAdd":  	switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  	case Sql.DateParts.Quarter:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  	case Sql.DateParts.DayOfYear:  	case Sql.DateParts.WeekDay:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  	case Sql.DateParts.Week:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  case "DateAdd":  	switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  	case Sql.DateParts.Quarter:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  	case Sql.DateParts.DayOfYear:  	case Sql.DateParts.WeekDay:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  	case Sql.DateParts.Week:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  case "DateAdd":  	switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  	case Sql.DateParts.Quarter:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  	case Sql.DateParts.DayOfYear:  	case Sql.DateParts.WeekDay:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  	case Sql.DateParts.Week:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  case Sql.DateParts.Quarter:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  case Sql.DateParts.DayOfYear:  case Sql.DateParts.WeekDay:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  case Sql.DateParts.Week:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  case Sql.DateParts.Quarter:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  case Sql.DateParts.DayOfYear:  case Sql.DateParts.WeekDay:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  case Sql.DateParts.Week:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  case Sql.DateParts.Quarter:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  case Sql.DateParts.DayOfYear:  case Sql.DateParts.WeekDay:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  case Sql.DateParts.Week:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  case Sql.DateParts.Quarter:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  case Sql.DateParts.DayOfYear:  case Sql.DateParts.WeekDay:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  case Sql.DateParts.Week:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  case Sql.DateParts.Quarter:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  case Sql.DateParts.DayOfYear:  case Sql.DateParts.WeekDay:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  case Sql.DateParts.Week:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlExpression) {  	SqlExpression e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(Quarter"))  		return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  	if (e.Expr.StartsWith ("Extract(YearDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(YearDay"' "Extract(yearDay")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(WeekDay"))  		return Inc (new SqlExpression (e.SystemType' e.Expr.Replace ("Extract(WeekDay"' "Extract(weekDay")' e.Parameters));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (e.Expr.StartsWith ("Extract(Quarter"))  	return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Inc (Div (Dec (new SqlExpression (e.SystemType' "Extract(Month from {0})"' e.Parameters))' 3));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,BuildDataType,The following statement contains a magic number: switch (type.SqlDbType) {  case SqlDbType.Decimal:  	base.BuildDataType (sb' type.Precision > 18 ? new SqlDataType (type.SqlDbType' type.Type' 18' type.Scale) : type);  	break;  case SqlDbType.TinyInt:  	sb.Append ("SmallInt");  	break;  case SqlDbType.Money:  	sb.Append ("Decimal(18'4)");  	break;  case SqlDbType.SmallMoney:  	sb.Append ("Decimal(10'4)");  	break;  #if !MONO  case SqlDbType.DateTime2:  #endif  case SqlDbType.SmallDateTime:  case SqlDbType.DateTime:  	sb.Append ("TimeStamp");  	break;  case SqlDbType.NVarChar:  	sb.Append ("VarChar");  	if (type.Length > 0)  		sb.Append ('(').Append (type.Length).Append (')');  	break;  default:  	base.BuildDataType (sb' type);  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,BuildDataType,The following statement contains a magic number: switch (type.SqlDbType) {  case SqlDbType.Decimal:  	base.BuildDataType (sb' type.Precision > 18 ? new SqlDataType (type.SqlDbType' type.Type' 18' type.Scale) : type);  	break;  case SqlDbType.TinyInt:  	sb.Append ("SmallInt");  	break;  case SqlDbType.Money:  	sb.Append ("Decimal(18'4)");  	break;  case SqlDbType.SmallMoney:  	sb.Append ("Decimal(10'4)");  	break;  #if !MONO  case SqlDbType.DateTime2:  #endif  case SqlDbType.SmallDateTime:  case SqlDbType.DateTime:  	sb.Append ("TimeStamp");  	break;  case SqlDbType.NVarChar:  	sb.Append ("VarChar");  	if (type.Length > 0)  		sb.Append ('(').Append (type.Length).Append (')');  	break;  default:  	base.BuildDataType (sb' type);  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,BuildDataType,The following statement contains a magic number: base.BuildDataType (sb' type.Precision > 18 ? new SqlDataType (type.SqlDbType' type.Type' 18' type.Scale) : type);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,BuildDataType,The following statement contains a magic number: base.BuildDataType (sb' type.Precision > 18 ? new SqlDataType (type.SqlDbType' type.Type' 18' type.Scale) : type);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,CommandCount,The following statement contains a magic number: return sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity ? 2 : 1;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "^":  		return new SqlBinaryExpression (be.SystemType' be.Expr1' "#"' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(DOW"))  		return Inc (new SqlExpression (expr.SystemType' e.Expr.Replace ("Extract(DOW"' "Extract(Dow")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(Millisecond"))  		return new SqlExpression (expr.SystemType' "Cast(To_Char({0}' 'MS') as int)"' e.Parameters);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "^":  		return new SqlBinaryExpression (be.SystemType' be.Expr1' "#"' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(DOW"))  		return Inc (new SqlExpression (expr.SystemType' e.Expr.Replace ("Extract(DOW"' "Extract(Dow")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(Millisecond"))  		return new SqlExpression (expr.SystemType' "Cast(To_Char({0}' 'MS') as int)"' e.Parameters);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "^":  		return new SqlBinaryExpression (be.SystemType' be.Expr1' "#"' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(DOW"))  		return Inc (new SqlExpression (expr.SystemType' e.Expr.Replace ("Extract(DOW"' "Extract(Dow")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(Millisecond"))  		return new SqlExpression (expr.SystemType' "Cast(To_Char({0}' 'MS') as int)"' e.Parameters);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "^":  		return new SqlBinaryExpression (be.SystemType' be.Expr1' "#"' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(DOW"))  		return Inc (new SqlExpression (expr.SystemType' e.Expr.Replace ("Extract(DOW"' "Extract(Dow")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(Millisecond"))  		return new SqlExpression (expr.SystemType' "Cast(To_Char({0}' 'MS') as int)"' e.Parameters);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(DOW"))  		return Inc (new SqlExpression (expr.SystemType' e.Expr.Replace ("Extract(DOW"' "Extract(Dow")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(Millisecond"))  		return new SqlExpression (expr.SystemType' "Cast(To_Char({0}' 'MS') as int)"' e.Parameters);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(DOW"))  		return Inc (new SqlExpression (expr.SystemType' e.Expr.Replace ("Extract(DOW"' "Extract(Dow")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(Millisecond"))  		return new SqlExpression (expr.SystemType' "Cast(To_Char({0}' 'MS') as int)"' e.Parameters);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(DOW"))  		return Inc (new SqlExpression (expr.SystemType' e.Expr.Replace ("Extract(DOW"' "Extract(Dow")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(Millisecond"))  		return new SqlExpression (expr.SystemType' "Cast(To_Char({0}' 'MS') as int)"' e.Parameters);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("Extract(DOW"))  		return Inc (new SqlExpression (expr.SystemType' e.Expr.Replace ("Extract(DOW"' "Extract(Dow")' e.Parameters));  	if (e.Expr.StartsWith ("Extract(Millisecond"))  		return new SqlExpression (expr.SystemType' "Cast(To_Char({0}' 'MS') as int)"' e.Parameters);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildSql,The following statement contains a magic number: if (buildRowNum) {  	aliases = GetTempAliases (2' "t");  	if (_rowNumberAlias == null)  		_rowNumberAlias = GetTempAliases (1' "rn") [0];  	AppendIndent (sb).AppendFormat ("SELECT {0}.*"' aliases [1]).AppendLine ();  	AppendIndent (sb).Append ("FROM").AppendLine ();  	AppendIndent (sb).Append ("(").AppendLine ();  	Indent++;  	AppendIndent (sb).AppendFormat ("SELECT {0}.*' ROWNUM as {1}"' aliases [0]' _rowNumberAlias).AppendLine ();  	AppendIndent (sb).Append ("FROM").AppendLine ();  	AppendIndent (sb).Append ("(").AppendLine ();  	Indent++;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildSql,The following statement contains a magic number: aliases = GetTempAliases (2' "t");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  	case "|":  		// (a + b) - BITAND(a' b)  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  	case "^":  		// (a + b) - BITAND(a' b) * 2  		return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (be.Operation) {  case "%":  	return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  case "&":  	return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  case "|":  	// (a + b) - BITAND(a' b)  	return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  case "^":  	// (a + b) - BITAND(a' b) * 2  	return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  case "+":  	return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  		if (ftype == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  			if (IsTimeDataType (func.Parameters [0])) {  				if (func.Parameters [1].SystemType == typeof(string))  					return func.Parameters [1];  				return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  			}  			if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  				return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  			}  			return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  	}  	case "ContainsExactly":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "CharIndex":  		return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  	case "AddYear":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  	case "AddQuarter":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  	case "AddMonth":  		return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  	case "AddDayOfYear":  	case "AddWeekDay":  	case "AddDay":  		return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  	case "AddWeek":  		return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  	case "AddHour":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  	case "AddMinute":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  	case "AddSecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  	case "AddMillisecond":  		return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  	case "Avg":  		return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  	}  } else if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlExpression) {  	var e = (SqlExpression)expr;  	if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  		return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (e.Expr.StartsWith ("To_Number(To_Char(") && e.Expr.EndsWith ("' 'FF'))"))  	return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Div (new SqlExpression (e.SystemType' e.Expr.Replace ("To_Number(To_Char("' "to_Number(To_Char(")' e.Parameters)' 1000);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,Finalize,The following statement contains a magic number: CheckAliases (sqlQuery' 30);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  } else if (value is DateTime) {  	sb.AppendFormat ("TO_TIMESTAMP('{0:yyyy-MM-dd HH:mm:ss.fffffff}'' 'YYYY-MM-DD HH24:MI:SS.FF7')"' value);  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast('").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as raw(16))");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,Convert,The following statement contains a magic number: switch (convertType) {  case ConvertType.NameToQueryParameter:  	string name = value.ToString ().Replace (" "' string.Empty);  	if (name.Length <= 28)  		return ":" + name;  	int hashCode = name.GetHashCode ();  	return string.Format (":P{0}{1}_"' hashCode < 0 ? "m" : ""' Math.Abs (hashCode));  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,Convert,The following statement contains a magic number: if (name.Length <= 28)  	return ":" + name;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildEmptyInsert,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,BuildEmptyInsert,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,CommandCount,The following statement contains a magic number: if (sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity) {  	_identityField = sqlQuery.Insert.Into.GetIdentityField ();  	if (_identityField == null)  		return 2;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,CommandCount,The following statement contains a magic number: if (_identityField == null)  	return 2;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,CommandCount,The following statement contains a magic number: return 2;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildSql,The following statement contains a magic number: if (_identityField != null) {  	indent += 2;  	AppendIndent (sb).AppendLine ("SELECT");  	AppendIndent (sb).Append ("\t");  	BuildExpression (sb' _identityField' false' true);  	sb.AppendLine ();  	AppendIndent (sb).AppendLine ("FROM");  	AppendIndent (sb).AppendLine ("\tNEW TABLE");  	AppendIndent (sb).AppendLine ("\t(");  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildSql,The following statement contains a magic number: indent += 2;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%": {  		var expr1 = !TypeHelper.IsIntegerType (be.Expr1.SystemType) ? new SqlFunction (typeof(int)' "Int"' be.Expr1) : be.Expr1;  		return new SqlFunction (be.SystemType' "Mod"' expr1' be.Expr2);  	}  	case "&":  		return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%": {  		var expr1 = !TypeHelper.IsIntegerType (be.Expr1.SystemType) ? new SqlFunction (typeof(int)' "Int"' be.Expr1) : be.Expr1;  		return new SqlFunction (be.SystemType' "Mod"' expr1' be.Expr2);  	}  	case "&":  		return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%": {  		var expr1 = !TypeHelper.IsIntegerType (be.Expr1.SystemType) ? new SqlFunction (typeof(int)' "Int"' be.Expr1) : be.Expr1;  		return new SqlFunction (be.SystemType' "Mod"' expr1' be.Expr2);  	}  	case "&":  		return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%": {  		var expr1 = !TypeHelper.IsIntegerType (be.Expr1.SystemType) ? new SqlFunction (typeof(int)' "Int"' be.Expr1) : be.Expr1;  		return new SqlFunction (be.SystemType' "Mod"' expr1' be.Expr2);  	}  	case "&":  		return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%": {  		var expr1 = !TypeHelper.IsIntegerType (be.Expr1.SystemType) ? new SqlFunction (typeof(int)' "Int"' be.Expr1) : be.Expr1;  		return new SqlFunction (be.SystemType' "Mod"' expr1' be.Expr2);  	}  	case "&":  		return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%": {  		var expr1 = !TypeHelper.IsIntegerType (be.Expr1.SystemType) ? new SqlFunction (typeof(int)' "Int"' be.Expr1) : be.Expr1;  		return new SqlFunction (be.SystemType' "Mod"' expr1' be.Expr2);  	}  	case "&":  		return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%": {  		var expr1 = !TypeHelper.IsIntegerType (be.Expr1.SystemType) ? new SqlFunction (typeof(int)' "Int"' be.Expr1) : be.Expr1;  		return new SqlFunction (be.SystemType' "Mod"' expr1' be.Expr2);  	}  	case "&":  		return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%": {  		var expr1 = !TypeHelper.IsIntegerType (be.Expr1.SystemType) ? new SqlFunction (typeof(int)' "Int"' be.Expr1) : be.Expr1;  		return new SqlFunction (be.SystemType' "Mod"' expr1' be.Expr2);  	}  	case "&":  		return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%": {  		var expr1 = !TypeHelper.IsIntegerType (be.Expr1.SystemType) ? new SqlFunction (typeof(int)' "Int"' be.Expr1) : be.Expr1;  		return new SqlFunction (be.SystemType' "Mod"' expr1' be.Expr2);  	}  	case "&":  		return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%": {  		var expr1 = !TypeHelper.IsIntegerType (be.Expr1.SystemType) ? new SqlFunction (typeof(int)' "Int"' be.Expr1) : be.Expr1;  		return new SqlFunction (be.SystemType' "Mod"' expr1' be.Expr2);  	}  	case "&":  		return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert":  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  		}  		if (func.Parameters [0] is SqlDataType) {  			var type = (SqlDataType)func.Parameters [0];  			if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  				return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  			if (type.Length > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  			if (type.Precision > 0)  				return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  		}  		if (func.Parameters [0] is SqlFunction) {  			var f = (SqlFunction)func.Parameters [0];  			return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  		}  		{  			var e = (SqlExpression)func.Parameters [0];  			return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  		}  	case "Millisecond":  		return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  	case "SmallDateTime":  	case "DateTime":  	case "DateTime2":  		return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  	case "TinyInt":  		return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  	case "Money":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  	case "SmallMoney":  		return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  	case "VarChar":  		if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  			return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  		break;  	case "NChar":  	case "NVarChar":  		return new SqlFunction (func.SystemType' "Char"' func.Parameters);  	case "DateDiff":  		{  			switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  			case Linq.Sql.DateParts.Day:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Hour:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Minute:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Second:  				return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			case Linq.Sql.DateParts.Millisecond:  				return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  			}  		}  		break;  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (func.Parameters [0] is SqlDataType) {  		var type = (SqlDataType)func.Parameters [0];  		if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  			return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  		if (type.Length > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  		if (type.Precision > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  		return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  	}  	if (func.Parameters [0] is SqlFunction) {  		var f = (SqlFunction)func.Parameters [0];  		return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  	}  	{  		var e = (SqlExpression)func.Parameters [0];  		return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  	}  case "Millisecond":  	return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  case "SmallDateTime":  case "DateTime":  case "DateTime2":  	return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  case "TinyInt":  	return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  case "Money":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  case "SmallMoney":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  case "VarChar":  	if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  		return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  	break;  case "NChar":  case "NVarChar":  	return new SqlFunction (func.SystemType' "Char"' func.Parameters);  case "DateDiff":  	{  		switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Linq.Sql.DateParts.Day:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Hour:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Minute:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Second:  			return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Millisecond:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (func.Parameters [0] is SqlDataType) {  		var type = (SqlDataType)func.Parameters [0];  		if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  			return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  		if (type.Length > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  		if (type.Precision > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  		return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  	}  	if (func.Parameters [0] is SqlFunction) {  		var f = (SqlFunction)func.Parameters [0];  		return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  	}  	{  		var e = (SqlExpression)func.Parameters [0];  		return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  	}  case "Millisecond":  	return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  case "SmallDateTime":  case "DateTime":  case "DateTime2":  	return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  case "TinyInt":  	return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  case "Money":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  case "SmallMoney":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  case "VarChar":  	if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  		return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  	break;  case "NChar":  case "NVarChar":  	return new SqlFunction (func.SystemType' "Char"' func.Parameters);  case "DateDiff":  	{  		switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Linq.Sql.DateParts.Day:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Hour:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Minute:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Second:  			return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Millisecond:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (func.Parameters [0] is SqlDataType) {  		var type = (SqlDataType)func.Parameters [0];  		if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  			return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  		if (type.Length > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  		if (type.Precision > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  		return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  	}  	if (func.Parameters [0] is SqlFunction) {  		var f = (SqlFunction)func.Parameters [0];  		return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  	}  	{  		var e = (SqlExpression)func.Parameters [0];  		return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  	}  case "Millisecond":  	return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  case "SmallDateTime":  case "DateTime":  case "DateTime2":  	return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  case "TinyInt":  	return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  case "Money":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  case "SmallMoney":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  case "VarChar":  	if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  		return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  	break;  case "NChar":  case "NVarChar":  	return new SqlFunction (func.SystemType' "Char"' func.Parameters);  case "DateDiff":  	{  		switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Linq.Sql.DateParts.Day:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Hour:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Minute:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Second:  			return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Millisecond:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (func.Parameters [0] is SqlDataType) {  		var type = (SqlDataType)func.Parameters [0];  		if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  			return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  		if (type.Length > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  		if (type.Precision > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  		return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  	}  	if (func.Parameters [0] is SqlFunction) {  		var f = (SqlFunction)func.Parameters [0];  		return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  	}  	{  		var e = (SqlExpression)func.Parameters [0];  		return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  	}  case "Millisecond":  	return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  case "SmallDateTime":  case "DateTime":  case "DateTime2":  	return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  case "TinyInt":  	return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  case "Money":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  case "SmallMoney":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  case "VarChar":  	if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  		return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  	break;  case "NChar":  case "NVarChar":  	return new SqlFunction (func.SystemType' "Char"' func.Parameters);  case "DateDiff":  	{  		switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Linq.Sql.DateParts.Day:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Hour:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Minute:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Second:  			return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Millisecond:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (func.Parameters [0] is SqlDataType) {  		var type = (SqlDataType)func.Parameters [0];  		if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  			return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  		if (type.Length > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  		if (type.Precision > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  		return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  	}  	if (func.Parameters [0] is SqlFunction) {  		var f = (SqlFunction)func.Parameters [0];  		return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  	}  	{  		var e = (SqlExpression)func.Parameters [0];  		return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  	}  case "Millisecond":  	return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  case "SmallDateTime":  case "DateTime":  case "DateTime2":  	return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  case "TinyInt":  	return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  case "Money":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  case "SmallMoney":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  case "VarChar":  	if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  		return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  	break;  case "NChar":  case "NVarChar":  	return new SqlFunction (func.SystemType' "Char"' func.Parameters);  case "DateDiff":  	{  		switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Linq.Sql.DateParts.Day:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Hour:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Minute:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Second:  			return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Millisecond:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (func.Parameters [0] is SqlDataType) {  		var type = (SqlDataType)func.Parameters [0];  		if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  			return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  		if (type.Length > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  		if (type.Precision > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  		return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  	}  	if (func.Parameters [0] is SqlFunction) {  		var f = (SqlFunction)func.Parameters [0];  		return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  	}  	{  		var e = (SqlExpression)func.Parameters [0];  		return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  	}  case "Millisecond":  	return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  case "SmallDateTime":  case "DateTime":  case "DateTime2":  	return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  case "TinyInt":  	return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  case "Money":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  case "SmallMoney":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  case "VarChar":  	if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  		return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  	break;  case "NChar":  case "NVarChar":  	return new SqlFunction (func.SystemType' "Char"' func.Parameters);  case "DateDiff":  	{  		switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Linq.Sql.DateParts.Day:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Hour:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Minute:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Second:  			return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Millisecond:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (func.Parameters [0] is SqlDataType) {  		var type = (SqlDataType)func.Parameters [0];  		if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  			return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  		if (type.Length > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  		if (type.Precision > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  		return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  	}  	if (func.Parameters [0] is SqlFunction) {  		var f = (SqlFunction)func.Parameters [0];  		return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  	}  	{  		var e = (SqlExpression)func.Parameters [0];  		return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  	}  case "Millisecond":  	return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  case "SmallDateTime":  case "DateTime":  case "DateTime2":  	return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  case "TinyInt":  	return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  case "Money":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  case "SmallMoney":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  case "VarChar":  	if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  		return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  	break;  case "NChar":  case "NVarChar":  	return new SqlFunction (func.SystemType' "Char"' func.Parameters);  case "DateDiff":  	{  		switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Linq.Sql.DateParts.Day:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Hour:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Minute:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Second:  			return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Millisecond:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (func.Parameters [0] is SqlDataType) {  		var type = (SqlDataType)func.Parameters [0];  		if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  			return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  		if (type.Length > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  		if (type.Precision > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  		return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  	}  	if (func.Parameters [0] is SqlFunction) {  		var f = (SqlFunction)func.Parameters [0];  		return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  	}  	{  		var e = (SqlExpression)func.Parameters [0];  		return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  	}  case "Millisecond":  	return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  case "SmallDateTime":  case "DateTime":  case "DateTime2":  	return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  case "TinyInt":  	return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  case "Money":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  case "SmallMoney":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  case "VarChar":  	if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  		return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  	break;  case "NChar":  case "NVarChar":  	return new SqlFunction (func.SystemType' "Char"' func.Parameters);  case "DateDiff":  	{  		switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Linq.Sql.DateParts.Day:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Hour:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Minute:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Second:  			return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Millisecond:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (func.Parameters [0] is SqlDataType) {  		var type = (SqlDataType)func.Parameters [0];  		if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  			return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  		if (type.Length > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  		if (type.Precision > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  		return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  	}  	if (func.Parameters [0] is SqlFunction) {  		var f = (SqlFunction)func.Parameters [0];  		return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  	}  	{  		var e = (SqlExpression)func.Parameters [0];  		return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  	}  case "Millisecond":  	return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  case "SmallDateTime":  case "DateTime":  case "DateTime2":  	return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  case "TinyInt":  	return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  case "Money":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  case "SmallMoney":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  case "VarChar":  	if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  		return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  	break;  case "NChar":  case "NVarChar":  	return new SqlFunction (func.SystemType' "Char"' func.Parameters);  case "DateDiff":  	{  		switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Linq.Sql.DateParts.Day:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Hour:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Minute:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Second:  			return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Millisecond:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (func.Parameters [0] is SqlDataType) {  		var type = (SqlDataType)func.Parameters [0];  		if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  			return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  		if (type.Length > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  		if (type.Precision > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  		return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  	}  	if (func.Parameters [0] is SqlFunction) {  		var f = (SqlFunction)func.Parameters [0];  		return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  	}  	{  		var e = (SqlExpression)func.Parameters [0];  		return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  	}  case "Millisecond":  	return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  case "SmallDateTime":  case "DateTime":  case "DateTime2":  	return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  case "TinyInt":  	return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  case "Money":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  case "SmallMoney":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  case "VarChar":  	if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  		return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  	break;  case "NChar":  case "NVarChar":  	return new SqlFunction (func.SystemType' "Char"' func.Parameters);  case "DateDiff":  	{  		switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Linq.Sql.DateParts.Day:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Hour:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Minute:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Second:  			return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Millisecond:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		}  	}  	break;  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  case Linq.Sql.DateParts.Day:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Hour:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Minute:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Second:  	return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Millisecond:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  case Linq.Sql.DateParts.Day:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Hour:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Minute:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Second:  	return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Millisecond:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  case Linq.Sql.DateParts.Day:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Hour:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Minute:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Second:  	return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Millisecond:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  case Linq.Sql.DateParts.Day:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Hour:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Minute:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Second:  	return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Millisecond:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  case Linq.Sql.DateParts.Day:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Hour:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Minute:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Second:  	return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Millisecond:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following statement contains a magic number: return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: if (value is Guid) {  	var s = ((Guid)value).ToString ("N");  	sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  } else  	base.BuildValue (sb' value);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildValue,The following statement contains a magic number: sb.Append ("Cast(x'").Append (s.Substring (6' 2)).Append (s.Substring (4' 2)).Append (s.Substring (2' 2)).Append (s.Substring (0' 2)).Append (s.Substring (10' 2)).Append (s.Substring (8' 2)).Append (s.Substring (14' 2)).Append (s.Substring (12' 2)).Append (s.Substring (16' 16)).Append ("' as char(16) for bit data)");  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildEmptyInsert,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,BuildEmptyInsert,The following statement contains a magic number: sb.Remove (sb.Length - 2' 2);  
Magic Number,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,CommandCount,The following statement contains a magic number: return sqlQuery.IsInsert && sqlQuery.Insert.WithIdentity ? 2 : 1;  
Magic Number,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlBinaryExpression) {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%":  		return new SqlFunction (be.SystemType' "Mod"' be.Expr1' be.Expr2);  	case "&":  		return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  	case "|":  		return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  	case "^":  		return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  	case "+":  		return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  	}  } else if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var par0 = func.Parameters [0];  		var par1 = func.Parameters [1];  		switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  		case TypeCode.String:  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]);  		case TypeCode.Boolean: {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  			break;  		}  		case TypeCode.UInt64:  			if (TypeHelper.IsFloatType (func.Parameters [1].SystemType))  				par1 = new SqlFunction (func.SystemType' "Floor"' func.Parameters [1]);  			break;  		case TypeCode.DateTime:  			if (IsDateDataType (func.Parameters [0]' "Date")) {  				if (func.Parameters [1].SystemType == typeof(string)) {  					return new SqlFunction (func.SystemType' "Date"' new SqlFunction (func.SystemType' "To_Date"' func.Parameters [1]' new SqlValue ("%Y-%m-%d")));  				}  				return new SqlFunction (func.SystemType' "Date"' func.Parameters [1]);  			}  			if (IsTimeDataType (func.Parameters [0]))  				return new SqlExpression (func.SystemType' "Cast(Extend({0}' hour to second) as Char(8))"' Precedence.Primary' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "To_Date"' func.Parameters [1]);  		default:  			if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(DateTimeOffset))  				goto case TypeCode.DateTime;  			break;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' par1' par0);  	}  	case "Quarter":  		return Inc (Div (Dec (new SqlFunction (func.SystemType' "Month"' func.Parameters))' 3));  	case "WeekDay":  		return Inc (new SqlFunction (func.SystemType' "weekDay"' func.Parameters));  	case "DayOfYear":  		return Inc (Sub<int> (new SqlFunction (null' "Mdy"' new SqlFunction (null' "Month"' func.Parameters)' new SqlFunction (null' "Day"' func.Parameters)' new SqlFunction (null' "Year"' func.Parameters))' new SqlFunction (null' "Mdy"' new SqlValue (1)' new SqlValue (1)' new SqlFunction (null' "Year"' func.Parameters))));  	case "Week":  		return new SqlExpression (func.SystemType' "((Extend({0}' year to day) - (Mdy(12' 31 - WeekDay(Mdy(1' 1' year({0})))' Year({0}) - 1) + Interval(1) day to day)) / 7 + Interval(1) day to day)::char(10)::int"' func.Parameters);  	case "Hour":  	case "Minute":  	case "Second":  		return new SqlExpression (func.SystemType' string.Format ("(({{0}})::datetime {0} to {0})::char(3)::int"' func.Name)' func.Parameters);  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The following statement contains a magic number: if (expr is SqlFunction) {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Coalesce":  		return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  	case "Convert": {  		var par0 = func.Parameters [0];  		var par1 = func.Parameters [1];  		switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  		case TypeCode.String:  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]);  		case TypeCode.Boolean: {  			var ex = AlternativeConvertToBoolean (func' 1);  			if (ex != null)  				return ex;  			break;  		}  		case TypeCode.UInt64:  			if (TypeHelper.IsFloatType (func.Parameters [1].SystemType))  				par1 = new SqlFunction (func.SystemType' "Floor"' func.Parameters [1]);  			break;  		case TypeCode.DateTime:  			if (IsDateDataType (func.Parameters [0]' "Date")) {  				if (func.Parameters [1].SystemType == typeof(string)) {  					return new SqlFunction (func.SystemType' "Date"' new SqlFunction (func.SystemType' "To_Date"' func.Parameters [1]' new SqlValue ("%Y-%m-%d")));  				}  				return new SqlFunction (func.SystemType' "Date"' func.Parameters [1]);  			}  			if (IsTimeDataType (func.Parameters [0]))  				return new SqlExpression (func.SystemType' "Cast(Extend({0}' hour to second) as Char(8))"' Precedence.Primary' func.Parameters [1]);  			return new SqlFunction (func.SystemType' "To_Date"' func.Parameters [1]);  		default:  			if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(DateTimeOffset))  				goto case TypeCode.DateTime;  			break;  		}  		return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' par1' par0);  	}  	case "Quarter":  		return Inc (Div (Dec (new SqlFunction (func.SystemType' "Month"' func.Parameters))' 3));  	case "WeekDay":  		return Inc (new SqlFunction (func.SystemType' "weekDay"' func.Parameters));  	case "DayOfYear":  		return Inc (Sub<int> (new SqlFunction (null' "Mdy"' new SqlFunction (null' "Month"' func.Parameters)' new SqlFunction (null' "Day"' func.Parameters)' new SqlFunction (null' "Year"' func.Parameters))' new SqlFunction (null' "Mdy"' new SqlValue (1)' new SqlValue (1)' new SqlFunction (null' "Year"' func.Parameters))));  	case "Week":  		return new SqlExpression (func.SystemType' "((Extend({0}' year to day) - (Mdy(12' 31 - WeekDay(Mdy(1' 1' year({0})))' Year({0}) - 1) + Interval(1) day to day)) / 7 + Interval(1) day to day)::char(10)::int"' func.Parameters);  	case "Hour":  	case "Minute":  	case "Second":  		return new SqlExpression (func.SystemType' string.Format ("(({{0}})::datetime {0} to {0})::char(3)::int"' func.Name)' func.Parameters);  	}  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The following statement contains a magic number: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var par0 = func.Parameters [0];  	var par1 = func.Parameters [1];  	switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  	case TypeCode.String:  		return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]);  	case TypeCode.Boolean: {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  		break;  	}  	case TypeCode.UInt64:  		if (TypeHelper.IsFloatType (func.Parameters [1].SystemType))  			par1 = new SqlFunction (func.SystemType' "Floor"' func.Parameters [1]);  		break;  	case TypeCode.DateTime:  		if (IsDateDataType (func.Parameters [0]' "Date")) {  			if (func.Parameters [1].SystemType == typeof(string)) {  				return new SqlFunction (func.SystemType' "Date"' new SqlFunction (func.SystemType' "To_Date"' func.Parameters [1]' new SqlValue ("%Y-%m-%d")));  			}  			return new SqlFunction (func.SystemType' "Date"' func.Parameters [1]);  		}  		if (IsTimeDataType (func.Parameters [0]))  			return new SqlExpression (func.SystemType' "Cast(Extend({0}' hour to second) as Char(8))"' Precedence.Primary' func.Parameters [1]);  		return new SqlFunction (func.SystemType' "To_Date"' func.Parameters [1]);  	default:  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(DateTimeOffset))  			goto case TypeCode.DateTime;  		break;  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' par1' par0);  }  case "Quarter":  	return Inc (Div (Dec (new SqlFunction (func.SystemType' "Month"' func.Parameters))' 3));  case "WeekDay":  	return Inc (new SqlFunction (func.SystemType' "weekDay"' func.Parameters));  case "DayOfYear":  	return Inc (Sub<int> (new SqlFunction (null' "Mdy"' new SqlFunction (null' "Month"' func.Parameters)' new SqlFunction (null' "Day"' func.Parameters)' new SqlFunction (null' "Year"' func.Parameters))' new SqlFunction (null' "Mdy"' new SqlValue (1)' new SqlValue (1)' new SqlFunction (null' "Year"' func.Parameters))));  case "Week":  	return new SqlExpression (func.SystemType' "((Extend({0}' year to day) - (Mdy(12' 31 - WeekDay(Mdy(1' 1' year({0})))' Year({0}) - 1) + Interval(1) day to day)) / 7 + Interval(1) day to day)::char(10)::int"' func.Parameters);  case "Hour":  case "Minute":  case "Second":  	return new SqlExpression (func.SystemType' string.Format ("(({{0}})::datetime {0} to {0})::char(3)::int"' func.Name)' func.Parameters);  }  
Magic Number,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The following statement contains a magic number: return Inc (Div (Dec (new SqlFunction (func.SystemType' "Month"' func.Parameters))' 3));  
Magic Number,BLToolkit.Data.Sql,SqlFunction,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlFunction.cs,ToString,The following statement contains a magic number: if (Parameters.Length > 0)  	sb.Length -= 2;  
Magic Number,BLToolkit.Data.Sql,SqlFunction,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlFunction.cs,ToString,The following statement contains a magic number: sb.Length -= 2;  
Magic Number,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,CheckColumn,The following statement contains a magic number: if (optimizeColumns && visitor.Find (expr' e => e is SqlQuery || IsAggregationFunction (e)) == null) {  	var n = 0;  	var q = query.ParentSql ?? query;  	visitor.VisitAll (q' e => {  		if (e == column)  			n++;  	});  	return n > 2;  }  
Magic Number,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,CheckColumn,The following statement contains a magic number: return n > 2;  
Magic Number,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,GetAlias,The following statement contains a magic number: if (string.IsNullOrEmpty (desiredAlias) || desiredAlias.Length > 30) {  	desiredAlias = defaultAlias;  	alias = defaultAlias + "1";  }  
Magic Number,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetMapper,The following statement contains a magic number: if (_parameters.ContextParameterUsed) {  	var l = Expression.Lambda<Func<TSource' MappingContext' TDest>> (expr' parm' _parameters.MappingContext);  	var f = l.Compile ();  	if (!_parameters.UseContext)  		return s => f (s' null);  	return s => {  		var ctx = new MappingContext {  			Objects = new Dictionary<object' object> (10) {  				{  					s'  					null  				}  			}'  			GetParent = p => p'  		};  		var dest = f (s' ctx);  		if (ctx.CrossActions != null)  			foreach (var circle in ctx.CrossActions)  				circle (dest);  		if (ctx.Crosses != null) {  			List<Action<object' object>> list;  			if (ctx.Crosses.TryGetValue (s' out list))  				foreach (var action in list)  					action (dest' dest);  		}  		return dest;  	};  }  
Magic Number,BLToolkit.Mapping,ExpressionMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\ExpressionMapper.cs,GetMapper,The following statement contains a magic number: return s => {  	var ctx = new MappingContext {  		Objects = new Dictionary<object' object> (10) {  			{  				s'  				null  			}  		}'  		GetParent = p => p'  	};  	var dest = f (s' ctx);  	if (ctx.CrossActions != null)  		foreach (var circle in ctx.CrossActions)  			circle (dest);  	if (ctx.Crosses != null) {  		List<Action<object' object>> list;  		if (ctx.Crosses.TryGetValue (s' out list))  			foreach (var action in list)  				action (dest' dest);  	}  	return dest;  };  
Magic Number,BLToolkit.Mapping,TextDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadHeader,The following statement contains a magic number: while (ReadNextLine ()) {  	if (_line.StartsWith ("*:")) {  		_names = _line.Substring (2).Split (':');  		_values = new string[_names.Length];  		for (int i = 0; i < _names.Length; i++)  			_names [i] = _names [i].Trim ();  	} else if (_line.StartsWith ("**") || _line.StartsWith ("*-"))  		break;  }  
Magic Number,BLToolkit.Mapping,TextDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadHeader,The following statement contains a magic number: if (_line.StartsWith ("*:")) {  	_names = _line.Substring (2).Split (':');  	_values = new string[_names.Length];  	for (int i = 0; i < _names.Length; i++)  		_names [i] = _names [i].Trim ();  } else if (_line.StartsWith ("**") || _line.StartsWith ("*-"))  	break;  
Magic Number,BLToolkit.Mapping,TextDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadHeader,The following statement contains a magic number: _names = _line.Substring (2).Split (':');  
Magic Number,BLToolkit.Mapping,TextDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadRecord,The following statement contains a magic number: if (!IsEof) {  	if (_line.StartsWith ("*-"))  		return false;  	if (_line.StartsWith ("**") && _line.Length > 3) {  		var values = _line.Substring (3).Split (_line [2]);  		for (var i = 0; i < _values.Length && i < values.Length; i++) {  			var value = values [i];  			_values [i] = value.Length == 0 ? null : value [0] == '*' ? value.Substring (1) : value [0] == '+' ? Encode (value.Substring (1)) : value;  		}  		ReadNextLine ();  		return true;  	}  	throw new MappingException (string.Format ("Invalid data format in the line {0}."' _lineNumber));  }  
Magic Number,BLToolkit.Mapping,TextDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadRecord,The following statement contains a magic number: if (!IsEof) {  	if (_line.StartsWith ("*-"))  		return false;  	if (_line.StartsWith ("**") && _line.Length > 3) {  		var values = _line.Substring (3).Split (_line [2]);  		for (var i = 0; i < _values.Length && i < values.Length; i++) {  			var value = values [i];  			_values [i] = value.Length == 0 ? null : value [0] == '*' ? value.Substring (1) : value [0] == '+' ? Encode (value.Substring (1)) : value;  		}  		ReadNextLine ();  		return true;  	}  	throw new MappingException (string.Format ("Invalid data format in the line {0}."' _lineNumber));  }  
Magic Number,BLToolkit.Mapping,TextDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadRecord,The following statement contains a magic number: if (!IsEof) {  	if (_line.StartsWith ("*-"))  		return false;  	if (_line.StartsWith ("**") && _line.Length > 3) {  		var values = _line.Substring (3).Split (_line [2]);  		for (var i = 0; i < _values.Length && i < values.Length; i++) {  			var value = values [i];  			_values [i] = value.Length == 0 ? null : value [0] == '*' ? value.Substring (1) : value [0] == '+' ? Encode (value.Substring (1)) : value;  		}  		ReadNextLine ();  		return true;  	}  	throw new MappingException (string.Format ("Invalid data format in the line {0}."' _lineNumber));  }  
Magic Number,BLToolkit.Mapping,TextDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadRecord,The following statement contains a magic number: if (_line.StartsWith ("**") && _line.Length > 3) {  	var values = _line.Substring (3).Split (_line [2]);  	for (var i = 0; i < _values.Length && i < values.Length; i++) {  		var value = values [i];  		_values [i] = value.Length == 0 ? null : value [0] == '*' ? value.Substring (1) : value [0] == '+' ? Encode (value.Substring (1)) : value;  	}  	ReadNextLine ();  	return true;  }  
Magic Number,BLToolkit.Mapping,TextDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadRecord,The following statement contains a magic number: if (_line.StartsWith ("**") && _line.Length > 3) {  	var values = _line.Substring (3).Split (_line [2]);  	for (var i = 0; i < _values.Length && i < values.Length; i++) {  		var value = values [i];  		_values [i] = value.Length == 0 ? null : value [0] == '*' ? value.Substring (1) : value [0] == '+' ? Encode (value.Substring (1)) : value;  	}  	ReadNextLine ();  	return true;  }  
Magic Number,BLToolkit.Mapping,TextDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\TextDataReader.cs,ReadRecord,The following statement contains a magic number: if (_line.StartsWith ("**") && _line.Length > 3) {  	var values = _line.Substring (3).Split (_line [2]);  	for (var i = 0; i < _values.Length && i < values.Length; i++) {  		var value = values [i];  		_values [i] = value.Length == 0 ? null : value [0] == '*' ? value.Substring (1) : value [0] == '+' ? Encode (value.Substring (1)) : value;  	}  	ReadNextLine ();  	return true;  }  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,LoadTypes,The following statement contains a magic number: try {  	_treeView.Nodes.Clear ();  	var assemblyNodes = new Dictionary<Assembly' TreeNode> ();  	var namespaceNodes = new Dictionary<string' TreeNode> ();  	var typeNodes = new Dictionary<Type' TypePicker.TypeNode> ();  	var service = (ITypeDiscoveryService)_serviceProvider.GetService (typeof(ITypeDiscoveryService));  	var cTypes = service.GetTypes (_baseType' _systemCheckBox.Checked);  	var types = new List<Type> (cTypes.Count);  	foreach (Type type in cTypes)  		types.Add (type);  	types.Sort ((a' b) => a.Assembly == b.Assembly ? string.Compare (a.FullName' b.FullName) : string.Compare (a.Assembly.FullName' b.Assembly.FullName));  	foreach (var type in types) {  		if (_filter != null && _filter (type) == false)  			continue;  		var assembly = type.Assembly;  		TreeNode assemblyNode;  		if (!assemblyNodes.TryGetValue (assembly' out assemblyNode)) {  			assemblyNodes [assembly] = assemblyNode = _treeView.Nodes.Add (assembly.FullName' assembly.GetName ().Name' 1' 1);  		}  		var @namespace = type.Namespace ?? string.Empty;  		var namespaceKey = assembly.FullName + "' " + @namespace;  		TreeNode namespaceNode;  		if (!namespaceNodes.TryGetValue (namespaceKey' out namespaceNode)) {  			namespaceNodes [namespaceKey] = namespaceNode = assemblyNode.Nodes.Add (namespaceKey' @namespace' 2' 2);  		}  		GetTypeNode getTypeNode = null;  		getTypeNode = t => {  			TypePicker.TypeNode node;  			if (typeNodes.TryGetValue (t' out node))  				return node;  			if (t.DeclaringType == null) {  				namespaceNode.Nodes.Add (node = new TypePicker.TypeNode (t.Name' t' false));  			} else {  				TreeNode parent = getTypeNode (t.DeclaringType);  				parent.Nodes.Add (node = new TypePicker.TypeNode (t.Name' t' false));  			}  			typeNodes.Add (t' node);  			return node;  		};  		getTypeNode (type).IsSelectable = true;  	}  } catch (Exception ex) {  	Debug.WriteLine (ex.Message);  } finally {  	Cursor = Cursors.Default;  }  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,LoadTypes,The following statement contains a magic number: try {  	_treeView.Nodes.Clear ();  	var assemblyNodes = new Dictionary<Assembly' TreeNode> ();  	var namespaceNodes = new Dictionary<string' TreeNode> ();  	var typeNodes = new Dictionary<Type' TypePicker.TypeNode> ();  	var service = (ITypeDiscoveryService)_serviceProvider.GetService (typeof(ITypeDiscoveryService));  	var cTypes = service.GetTypes (_baseType' _systemCheckBox.Checked);  	var types = new List<Type> (cTypes.Count);  	foreach (Type type in cTypes)  		types.Add (type);  	types.Sort ((a' b) => a.Assembly == b.Assembly ? string.Compare (a.FullName' b.FullName) : string.Compare (a.Assembly.FullName' b.Assembly.FullName));  	foreach (var type in types) {  		if (_filter != null && _filter (type) == false)  			continue;  		var assembly = type.Assembly;  		TreeNode assemblyNode;  		if (!assemblyNodes.TryGetValue (assembly' out assemblyNode)) {  			assemblyNodes [assembly] = assemblyNode = _treeView.Nodes.Add (assembly.FullName' assembly.GetName ().Name' 1' 1);  		}  		var @namespace = type.Namespace ?? string.Empty;  		var namespaceKey = assembly.FullName + "' " + @namespace;  		TreeNode namespaceNode;  		if (!namespaceNodes.TryGetValue (namespaceKey' out namespaceNode)) {  			namespaceNodes [namespaceKey] = namespaceNode = assemblyNode.Nodes.Add (namespaceKey' @namespace' 2' 2);  		}  		GetTypeNode getTypeNode = null;  		getTypeNode = t => {  			TypePicker.TypeNode node;  			if (typeNodes.TryGetValue (t' out node))  				return node;  			if (t.DeclaringType == null) {  				namespaceNode.Nodes.Add (node = new TypePicker.TypeNode (t.Name' t' false));  			} else {  				TreeNode parent = getTypeNode (t.DeclaringType);  				parent.Nodes.Add (node = new TypePicker.TypeNode (t.Name' t' false));  			}  			typeNodes.Add (t' node);  			return node;  		};  		getTypeNode (type).IsSelectable = true;  	}  } catch (Exception ex) {  	Debug.WriteLine (ex.Message);  } finally {  	Cursor = Cursors.Default;  }  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,LoadTypes,The following statement contains a magic number: foreach (var type in types) {  	if (_filter != null && _filter (type) == false)  		continue;  	var assembly = type.Assembly;  	TreeNode assemblyNode;  	if (!assemblyNodes.TryGetValue (assembly' out assemblyNode)) {  		assemblyNodes [assembly] = assemblyNode = _treeView.Nodes.Add (assembly.FullName' assembly.GetName ().Name' 1' 1);  	}  	var @namespace = type.Namespace ?? string.Empty;  	var namespaceKey = assembly.FullName + "' " + @namespace;  	TreeNode namespaceNode;  	if (!namespaceNodes.TryGetValue (namespaceKey' out namespaceNode)) {  		namespaceNodes [namespaceKey] = namespaceNode = assemblyNode.Nodes.Add (namespaceKey' @namespace' 2' 2);  	}  	GetTypeNode getTypeNode = null;  	getTypeNode = t => {  		TypePicker.TypeNode node;  		if (typeNodes.TryGetValue (t' out node))  			return node;  		if (t.DeclaringType == null) {  			namespaceNode.Nodes.Add (node = new TypePicker.TypeNode (t.Name' t' false));  		} else {  			TreeNode parent = getTypeNode (t.DeclaringType);  			parent.Nodes.Add (node = new TypePicker.TypeNode (t.Name' t' false));  		}  		typeNodes.Add (t' node);  		return node;  	};  	getTypeNode (type).IsSelectable = true;  }  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,LoadTypes,The following statement contains a magic number: foreach (var type in types) {  	if (_filter != null && _filter (type) == false)  		continue;  	var assembly = type.Assembly;  	TreeNode assemblyNode;  	if (!assemblyNodes.TryGetValue (assembly' out assemblyNode)) {  		assemblyNodes [assembly] = assemblyNode = _treeView.Nodes.Add (assembly.FullName' assembly.GetName ().Name' 1' 1);  	}  	var @namespace = type.Namespace ?? string.Empty;  	var namespaceKey = assembly.FullName + "' " + @namespace;  	TreeNode namespaceNode;  	if (!namespaceNodes.TryGetValue (namespaceKey' out namespaceNode)) {  		namespaceNodes [namespaceKey] = namespaceNode = assemblyNode.Nodes.Add (namespaceKey' @namespace' 2' 2);  	}  	GetTypeNode getTypeNode = null;  	getTypeNode = t => {  		TypePicker.TypeNode node;  		if (typeNodes.TryGetValue (t' out node))  			return node;  		if (t.DeclaringType == null) {  			namespaceNode.Nodes.Add (node = new TypePicker.TypeNode (t.Name' t' false));  		} else {  			TreeNode parent = getTypeNode (t.DeclaringType);  			parent.Nodes.Add (node = new TypePicker.TypeNode (t.Name' t' false));  		}  		typeNodes.Add (t' node);  		return node;  	};  	getTypeNode (type).IsSelectable = true;  }  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,LoadTypes,The following statement contains a magic number: if (!namespaceNodes.TryGetValue (namespaceKey' out namespaceNode)) {  	namespaceNodes [namespaceKey] = namespaceNode = assemblyNode.Nodes.Add (namespaceKey' @namespace' 2' 2);  }  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,LoadTypes,The following statement contains a magic number: if (!namespaceNodes.TryGetValue (namespaceKey' out namespaceNode)) {  	namespaceNodes [namespaceKey] = namespaceNode = assemblyNode.Nodes.Add (namespaceKey' @namespace' 2' 2);  }  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,LoadTypes,The following statement contains a magic number: namespaceNodes [namespaceKey] = namespaceNode = assemblyNode.Nodes.Add (namespaceKey' @namespace' 2' 2);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,LoadTypes,The following statement contains a magic number: namespaceNodes [namespaceKey] = namespaceNode = assemblyNode.Nodes.Add (namespaceKey' @namespace' 2' 2);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._treeView.Location = new System.Drawing.Point (14' 48);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._treeView.Location = new System.Drawing.Point (14' 48);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._treeView.Size = new System.Drawing.Size (523' 345);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._treeView.Size = new System.Drawing.Size (523' 345);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this.imageList.Images.SetKeyName (2' "Namespace.bmp");  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this.imageList.Images.SetKeyName (3' "Object.bmp");  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._systemCheckBox.Location = new System.Drawing.Point (14' 409);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._systemCheckBox.Location = new System.Drawing.Point (14' 409);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._systemCheckBox.Size = new System.Drawing.Size (330' 20);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._systemCheckBox.Size = new System.Drawing.Size (330' 20);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: labelRebuild.Font = new System.Drawing.Font ("Microsoft Sans Serif"' 9.75F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(204)));  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: labelRebuild.Location = new System.Drawing.Point (11' 9);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: labelRebuild.Location = new System.Drawing.Point (11' 9);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: labelRebuild.Size = new System.Drawing.Size (525' 32);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: labelRebuild.Size = new System.Drawing.Size (525' 32);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: labelRebuild.TabIndex = 5;  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Location = new System.Drawing.Point (350' 404);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Location = new System.Drawing.Point (350' 404);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Size = new System.Drawing.Size (87' 29);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._okButton.Size = new System.Drawing.Size (87' 29);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._okButton.TabIndex = 3;  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._cancelButton.Location = new System.Drawing.Point (450' 404);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._cancelButton.Location = new System.Drawing.Point (450' 404);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._cancelButton.Size = new System.Drawing.Size (87' 29);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._cancelButton.Size = new System.Drawing.Size (87' 29);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this._cancelButton.TabIndex = 4;  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (547' 442);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (547' 442);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this.Font = new System.Drawing.Font ("Tahoma"' 9.75F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(204)));  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size (555' 275);  
Magic Number,BLToolkit.ComponentModel.Design,GetTypeDialog,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\GetTypeDialog.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size (555' 275);  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,AddGroup,The following statement contains a magic number: foreach (DataSourceDescriptor d in group.DataSources) {  	if (d == null)  		continue;  	TypeNode node = GetTypeNode (d);  	if (node == null)  		continue;  	if (group.IsDefault) {  		treeView.Nodes.Add (node);  	} else {  		if (groupNode == null)  			treeView.Nodes.Add (groupNode = new TreeNode (group.Name' 2' 2));  		groupNode.Nodes.Add (node);  	}  	if (_resultType == node.Type)  		treeView.SelectedNode = node;  }  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,AddGroup,The following statement contains a magic number: foreach (DataSourceDescriptor d in group.DataSources) {  	if (d == null)  		continue;  	TypeNode node = GetTypeNode (d);  	if (node == null)  		continue;  	if (group.IsDefault) {  		treeView.Nodes.Add (node);  	} else {  		if (groupNode == null)  			treeView.Nodes.Add (groupNode = new TreeNode (group.Name' 2' 2));  		groupNode.Nodes.Add (node);  	}  	if (_resultType == node.Type)  		treeView.SelectedNode = node;  }  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,AddGroup,The following statement contains a magic number: if (group.IsDefault) {  	treeView.Nodes.Add (node);  } else {  	if (groupNode == null)  		treeView.Nodes.Add (groupNode = new TreeNode (group.Name' 2' 2));  	groupNode.Nodes.Add (node);  }  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,AddGroup,The following statement contains a magic number: if (group.IsDefault) {  	treeView.Nodes.Add (node);  } else {  	if (groupNode == null)  		treeView.Nodes.Add (groupNode = new TreeNode (group.Name' 2' 2));  	groupNode.Nodes.Add (node);  }  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,AddGroup,The following statement contains a magic number: if (groupNode == null)  	treeView.Nodes.Add (groupNode = new TreeNode (group.Name' 2' 2));  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,AddGroup,The following statement contains a magic number: if (groupNode == null)  	treeView.Nodes.Add (groupNode = new TreeNode (group.Name' 2' 2));  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,AddGroup,The following statement contains a magic number: treeView.Nodes.Add (groupNode = new TreeNode (group.Name' 2' 2));  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,AddGroup,The following statement contains a magic number: treeView.Nodes.Add (groupNode = new TreeNode (group.Name' 2' 2));  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.treeView.Size = new System.Drawing.Size (251' 243);  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.treeView.Size = new System.Drawing.Size (251' 243);  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: imageList.Images.SetKeyName (2' "Namespace.bmp");  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: imageList.Images.SetKeyName (3' "Object.bmp");  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.addNewLinkLabel.Location = new System.Drawing.Point (0' 3);  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.addNewLinkLabel.Padding = new System.Windows.Forms.Padding (5' 0' 0' 0);  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.addNewLinkLabel.Size = new System.Drawing.Size (100' 13);  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.addNewLinkLabel.Size = new System.Drawing.Size (100' 13);  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.addNewPanel.Location = new System.Drawing.Point (0' 243);  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.addNewPanel.Size = new System.Drawing.Size (251' 20);  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.addNewPanel.Size = new System.Drawing.Size (251' 20);  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.addNewPanel.TabIndex = 2;  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.addNewSplitPanel.Size = new System.Drawing.Size (251' 1);  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.addNewSplitPanel.TabIndex = 2;  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (251' 263);  
Magic Number,BLToolkit.ComponentModel.Design,TypePicker,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ComponentModel\Design\TypePicker.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (251' 263);  
Magic Number,BLToolkit.Reflection,TypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessorT.cs,GetMember,The following statement contains a magic number: switch (memberType) {  case 1:  	mi = Type.GetField (memberName' allInstaceMembers);  	break;  case 2:  	mi = Type.GetProperty (memberName' allInstaceMembers) ?? OriginalType.GetProperty (memberName' allInstaceMembers);  	break;  default:  	throw new InvalidOperationException ();  }  
Magic Number,BLToolkit.Reflection,TypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessorT.cs,GetHashCode,The following statement contains a magic number: foreach (MemberAccessor ma in GetAccessor (obj.GetType ())) {  	value = ma.GetValue (obj);  	hash = ((hash << 5) + hash) ^ (value == null ? 0 : value.GetHashCode ());  }  
Magic Number,BLToolkit.Reflection,TypeAccessor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeAccessorT.cs,GetHashCode,The following statement contains a magic number: hash = ((hash << 5) + hash) ^ (value == null ? 0 : value.GetHashCode ());  
Magic Number,BLToolkit.ServiceModel,ServiceModelDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\ServiceModelDataReader.cs,GetValue,The following statement contains a magic number: if (_result.VaryingTypes.Length > 0 && !string.IsNullOrEmpty (value) && value [0] == '\0') {  	type = _result.VaryingTypes [value [1]];  	value = value.Substring (2);  }  
Magic Number,BLToolkit.ServiceModel,ServiceModelDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\ServiceModelDataReader.cs,GetValue,The following statement contains a magic number: value = value.Substring (2);  
Magic Number,BLToolkit.TypeBuilder,TypeFactory,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,AssemblyResolver,The following statement contains a magic number: if (nameParts.Length > 0 && nameParts [0].ToLower ().EndsWith (".dll")) {  	nameParts [0] = nameParts [0].Substring (0' nameParts [0].Length - 4);  	name = string.Join ("'"' nameParts);  }  
Magic Number,BLToolkit.TypeBuilder,TypeFactory,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\TypeFactory.cs,AssemblyResolver,The following statement contains a magic number: nameParts [0] = nameParts [0].Substring (0' nameParts [0].Length - 4);  
Magic Number,BLToolkit.TypeBuilder.Builders,BuildContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\BuildContext.cs,BuildContext,The following statement contains a magic number: Items = new Dictionary<object' object> (10);  
Magic Number,BLToolkit.TypeBuilder.Builders,TypeAccessorBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\TypeAccessorBuilder.cs,BuildInitMember,The following statement contains a magic number: _typeBuilder.DefaultConstructor.Emitter.ldarg_0.ldarg_0.ldarg_0.ldc_i4 (mi is FieldInfo ? 1 : 2).ldstr (mi.Name).call (_accessorType.GetMethod ("GetMember"' typeof(int)' typeof(string))).newobj (ctorBuilder).call (_accessorType.GetMethod ("AddMember"' typeof(MemberAccessor)));  
Magic Number,BLToolkit.Reflection.Emit,AssemblyBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\AssemblyBuilderHelper.cs,AssemblyBuilderHelper,The following statement contains a magic number: if (idx > 0) {  	path = path.Substring (0' idx);  	if (path.Length >= 200) {  		idx = path.IndexOf ('`');  		if (idx > 0) {  			var idx2 = path.LastIndexOf ('.');  			if (idx2 > 0 && idx2 > idx)  				path = path.Substring (0' idx + 1) + path.Substring (idx2 + 1);  		}  	}  }  
Magic Number,BLToolkit.Reflection.Emit,AssemblyBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\AssemblyBuilderHelper.cs,AssemblyBuilderHelper,The following statement contains a magic number: if (path.Length >= 200) {  	idx = path.IndexOf ('`');  	if (idx > 0) {  		var idx2 = path.LastIndexOf ('.');  		if (idx2 > 0 && idx2 > idx)  			path = path.Substring (0' idx + 1) + path.Substring (idx2 + 1);  	}  }  
Magic Number,BLToolkit.Reflection.Emit,AssemblyBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\AssemblyBuilderHelper.cs,AssemblyBuilderHelper,The following statement contains a magic number: if (path.Length >= 260) {  	path = path.Substring (0' 248);  	for (var i = 0; i < int.MaxValue; i++) {  		var newPath = string.Format ("{0}_{1:0000}.dll"' path' i);  		if (!System.IO.File.Exists (newPath)) {  			path = newPath;  			break;  		}  	}  }  
Magic Number,BLToolkit.Reflection.Emit,AssemblyBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\AssemblyBuilderHelper.cs,AssemblyBuilderHelper,The following statement contains a magic number: if (path.Length >= 260) {  	path = path.Substring (0' 248);  	for (var i = 0; i < int.MaxValue; i++) {  		var newPath = string.Format ("{0}_{1:0000}.dll"' path' i);  		if (!System.IO.File.Exists (newPath)) {  			path = newPath;  			break;  		}  	}  }  
Magic Number,BLToolkit.Reflection.Emit,AssemblyBuilderHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\AssemblyBuilderHelper.cs,AssemblyBuilderHelper,The following statement contains a magic number: path = path.Substring (0' 248);  
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldarg,The following statement contains a magic number: switch (index) {  case 0:  	ldarg_0.end ();  	break;  case 1:  	ldarg_1.end ();  	break;  case 2:  	ldarg_2.end ();  	break;  case 3:  	ldarg_3.end ();  	break;  default:  	if (index <= byte.MaxValue)  		ldarg_s ((byte)index);  	else if (index <= short.MaxValue)  		ldarg ((short)index);  	else  		throw new ArgumentOutOfRangeException ("index");  	break;  }  
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldarg,The following statement contains a magic number: switch (index) {  case 0:  	ldarg_0.end ();  	break;  case 1:  	ldarg_1.end ();  	break;  case 2:  	ldarg_2.end ();  	break;  case 3:  	ldarg_3.end ();  	break;  default:  	if (index <= byte.MaxValue)  		ldarg_s ((byte)index);  	else if (index <= short.MaxValue)  		ldarg ((short)index);  	else  		throw new ArgumentOutOfRangeException ("index");  	break;  }  
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num) {  case -1:  	ldc_i4_m1.end ();  	break;  case 0:  	ldc_i4_0.end ();  	break;  case 1:  	ldc_i4_1.end ();  	break;  case 2:  	ldc_i4_2.end ();  	break;  case 3:  	ldc_i4_3.end ();  	break;  case 4:  	ldc_i4_4.end ();  	break;  case 5:  	ldc_i4_5.end ();  	break;  case 6:  	ldc_i4_6.end ();  	break;  case 7:  	ldc_i4_7.end ();  	break;  case 8:  	ldc_i4_8.end ();  	break;  default:  	if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  		ldc_i4_s ((sbyte)num);  	else  		ldc_i4 (num);  	break;  }  
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num) {  case -1:  	ldc_i4_m1.end ();  	break;  case 0:  	ldc_i4_0.end ();  	break;  case 1:  	ldc_i4_1.end ();  	break;  case 2:  	ldc_i4_2.end ();  	break;  case 3:  	ldc_i4_3.end ();  	break;  case 4:  	ldc_i4_4.end ();  	break;  case 5:  	ldc_i4_5.end ();  	break;  case 6:  	ldc_i4_6.end ();  	break;  case 7:  	ldc_i4_7.end ();  	break;  case 8:  	ldc_i4_8.end ();  	break;  default:  	if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  		ldc_i4_s ((sbyte)num);  	else  		ldc_i4 (num);  	break;  }  
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num) {  case -1:  	ldc_i4_m1.end ();  	break;  case 0:  	ldc_i4_0.end ();  	break;  case 1:  	ldc_i4_1.end ();  	break;  case 2:  	ldc_i4_2.end ();  	break;  case 3:  	ldc_i4_3.end ();  	break;  case 4:  	ldc_i4_4.end ();  	break;  case 5:  	ldc_i4_5.end ();  	break;  case 6:  	ldc_i4_6.end ();  	break;  case 7:  	ldc_i4_7.end ();  	break;  case 8:  	ldc_i4_8.end ();  	break;  default:  	if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  		ldc_i4_s ((sbyte)num);  	else  		ldc_i4 (num);  	break;  }  
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num) {  case -1:  	ldc_i4_m1.end ();  	break;  case 0:  	ldc_i4_0.end ();  	break;  case 1:  	ldc_i4_1.end ();  	break;  case 2:  	ldc_i4_2.end ();  	break;  case 3:  	ldc_i4_3.end ();  	break;  case 4:  	ldc_i4_4.end ();  	break;  case 5:  	ldc_i4_5.end ();  	break;  case 6:  	ldc_i4_6.end ();  	break;  case 7:  	ldc_i4_7.end ();  	break;  case 8:  	ldc_i4_8.end ();  	break;  default:  	if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  		ldc_i4_s ((sbyte)num);  	else  		ldc_i4 (num);  	break;  }  
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num) {  case -1:  	ldc_i4_m1.end ();  	break;  case 0:  	ldc_i4_0.end ();  	break;  case 1:  	ldc_i4_1.end ();  	break;  case 2:  	ldc_i4_2.end ();  	break;  case 3:  	ldc_i4_3.end ();  	break;  case 4:  	ldc_i4_4.end ();  	break;  case 5:  	ldc_i4_5.end ();  	break;  case 6:  	ldc_i4_6.end ();  	break;  case 7:  	ldc_i4_7.end ();  	break;  case 8:  	ldc_i4_8.end ();  	break;  default:  	if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  		ldc_i4_s ((sbyte)num);  	else  		ldc_i4 (num);  	break;  }  
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num) {  case -1:  	ldc_i4_m1.end ();  	break;  case 0:  	ldc_i4_0.end ();  	break;  case 1:  	ldc_i4_1.end ();  	break;  case 2:  	ldc_i4_2.end ();  	break;  case 3:  	ldc_i4_3.end ();  	break;  case 4:  	ldc_i4_4.end ();  	break;  case 5:  	ldc_i4_5.end ();  	break;  case 6:  	ldc_i4_6.end ();  	break;  case 7:  	ldc_i4_7.end ();  	break;  case 8:  	ldc_i4_8.end ();  	break;  default:  	if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  		ldc_i4_s ((sbyte)num);  	else  		ldc_i4 (num);  	break;  }  
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,ldc_i4_,The following statement contains a magic number: switch (num) {  case -1:  	ldc_i4_m1.end ();  	break;  case 0:  	ldc_i4_0.end ();  	break;  case 1:  	ldc_i4_1.end ();  	break;  case 2:  	ldc_i4_2.end ();  	break;  case 3:  	ldc_i4_3.end ();  	break;  case 4:  	ldc_i4_4.end ();  	break;  case 5:  	ldc_i4_5.end ();  	break;  case 6:  	ldc_i4_6.end ();  	break;  case 7:  	ldc_i4_7.end ();  	break;  case 8:  	ldc_i4_8.end ();  	break;  default:  	if (num >= sbyte.MinValue && num <= sbyte.MaxValue)  		ldc_i4_s ((sbyte)num);  	else  		ldc_i4 (num);  	break;  }  
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,stloc_s,The following statement contains a magic number: switch (index) {  case 0:  	stloc_0.end ();  	break;  case 1:  	stloc_1.end ();  	break;  case 2:  	stloc_2.end ();  	break;  case 3:  	stloc_3.end ();  	break;  default:  	_ilGenerator.Emit (OpCodes.Stloc_S' index);  	break;  }  
Magic Number,BLToolkit.Reflection.Emit,EmitHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\Emit\EmitHelper.cs,stloc_s,The following statement contains a magic number: switch (index) {  case 0:  	stloc_0.end ();  	break;  case 1:  	stloc_1.end ();  	break;  case 2:  	stloc_2.end ();  	break;  case 3:  	stloc_3.end ();  	break;  default:  	_ilGenerator.Emit (OpCodes.Stloc_S' index);  	break;  }  
Magic Number,BLToolkit.Net,HttpReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Net\HttpReader.cs,Post,The following statement contains a magic number: for (int i = 0; i < 10; i++) {  	bool post = false;  	switch (StatusCode) {  	case HttpStatusCode.MultipleChoices:  	// 300  	case HttpStatusCode.MovedPermanently:  	// 301  	case HttpStatusCode.Found:  	// 302  	case HttpStatusCode.SeeOther:  		// 303  		break;  	case HttpStatusCode.TemporaryRedirect:  		// 307  		post = true;  		break;  	default:  		return StatusCode;  	}  	if (Location == null)  		break;  	Uri uri = new Uri (new Uri (PreviousUri)' Location);  	BaseUri = uri.Scheme + "://" + uri.Host;  	requestUri = uri.AbsolutePath + uri.Query;  	Request (requestUri' post ? "POST" : "GET"' post ? requestStreamProcessor : null' responseStreamProcessor);  }  
Missing Default,BLToolkit.Aspects.Builders,InterceptorAspectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Builders\InterceptorAspectBuilder.cs,IsApplied,The following switch statement is missing a default case: switch (context.Step) {  case BuildStep.Begin:  	return true;  case BuildStep.Before:  	return (_interceptType & InterceptType.BeforeCall) != 0;  case BuildStep.After:  	return (_interceptType & InterceptType.AfterCall) != 0;  case BuildStep.Catch:  	return (_interceptType & InterceptType.OnCatch) != 0;  case BuildStep.Finally:  	return (_interceptType & InterceptType.OnFinally) != 0;  case BuildStep.End:  	return true;  }  
Missing Default,BLToolkit.Aspects,CacheAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\CacheAspect.cs,Init,The following switch statement is missing a default case: switch (vs [0].ToLower ().Trim ()) {  case "maxcachetime":  	_instanceMaxCacheTime = int.Parse (vs [1].Trim ());  	break;  case "isweak":  	_instanceIsWeak = bool.Parse (vs [1].Trim ());  	break;  }  
Missing Default,BLToolkit.Aspects,Interceptor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\Interceptor.cs,Intercept,The following switch statement is missing a default case: switch (info.InterceptType) {  case InterceptType.BeforeCall:  	BeforeCall (info);  	break;  case InterceptType.AfterCall:  	AfterCall (info);  	break;  case InterceptType.OnCatch:  	OnCatch (info);  	break;  case InterceptType.OnFinally:  	OnFinally (info);  	break;  }  
Missing Default,BLToolkit.Aspects,LoggingAspect,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Aspects\LoggingAspect.cs,Init,The following switch statement is missing a default case: switch (vs [0].ToLower ().Trim ()) {  case "filename":  	_instanceFileName = vs [1].Trim ();  	break;  case "mincalltime":  	_instanceMinCallTime = int.Parse (vs [1].Trim ());  	break;  case "logexceptions":  	_instanceLogExceptions = bool.Parse (vs [1].Trim ());  	break;  case "logparameters":  	_instanceLogParameters = bool.Parse (vs [1].Trim ());  	break;  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToBoolean,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.Boolean;  case TypeCode.Boolean:  	return (Boolean)p;  case TypeCode.Char:  	return ToBoolean ((Char)p);  case TypeCode.String:  	return ToBoolean ((String)p);  case TypeCode.SByte:  	return ToBoolean ((SByte)p);  case TypeCode.Int16:  	return ToBoolean ((Int16)p);  case TypeCode.Int32:  	return ToBoolean ((Int32)p);  case TypeCode.Int64:  	return ToBoolean ((Int64)p);  case TypeCode.Byte:  	return ToBoolean ((Byte)p);  case TypeCode.UInt16:  	return ToBoolean ((UInt16)p);  case TypeCode.UInt32:  	return ToBoolean ((UInt32)p);  case TypeCode.UInt64:  	return ToBoolean ((UInt64)p);  case TypeCode.Single:  	return ToBoolean ((Single)p);  case TypeCode.Double:  	return ToBoolean ((Double)p);  case TypeCode.Decimal:  	return ToBoolean ((Decimal)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToByte,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.Byte;  case TypeCode.Byte:  	return (Byte)p;  case TypeCode.SByte:  	return ToByte ((SByte)p);  case TypeCode.Int16:  	return ToByte ((Int16)p);  case TypeCode.Int32:  	return ToByte ((Int32)p);  case TypeCode.Int64:  	return ToByte ((Int64)p);  case TypeCode.UInt16:  	return ToByte ((UInt16)p);  case TypeCode.UInt32:  	return ToByte ((UInt32)p);  case TypeCode.UInt64:  	return ToByte ((UInt64)p);  case TypeCode.Single:  	return ToByte ((Single)p);  case TypeCode.Double:  	return ToByte ((Double)p);  case TypeCode.Decimal:  	return ToByte ((Decimal)p);  case TypeCode.Char:  	return ToByte ((Char)p);  case TypeCode.String:  	return ToByte ((String)p);  case TypeCode.Boolean:  	return ToByte ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToChar,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.Char;  case TypeCode.Char:  	return (Char)p;  case TypeCode.SByte:  	return ToChar ((SByte)p);  case TypeCode.Int16:  	return ToChar ((Int16)p);  case TypeCode.Int32:  	return ToChar ((Int32)p);  case TypeCode.Int64:  	return ToChar ((Int64)p);  case TypeCode.Byte:  	return ToChar ((Byte)p);  case TypeCode.UInt16:  	return ToChar ((UInt16)p);  case TypeCode.UInt32:  	return ToChar ((UInt32)p);  case TypeCode.UInt64:  	return ToChar ((UInt64)p);  case TypeCode.Single:  	return ToChar ((Single)p);  case TypeCode.Double:  	return ToChar ((Double)p);  case TypeCode.Decimal:  	return ToChar ((Decimal)p);  case TypeCode.String:  	return ToChar ((String)p);  case TypeCode.Boolean:  	return ToChar ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTime,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.DateTime;  case TypeCode.DateTime:  	return (DateTime)p;  case TypeCode.String:  	return ToDateTime ((String)p);  case TypeCode.Int64:  	return ToDateTime ((Int64)p);  case TypeCode.Double:  	return ToDateTime ((Double)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDateTimeOffset,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return DateTimeOffset.MinValue;  case TypeCode.Int64:  	return ToDateTimeOffset ((Int64)p);  case TypeCode.Double:  	return ToDateTimeOffset ((Double)p);  case TypeCode.DateTime:  	return ToDateTimeOffset ((DateTime)p);  case TypeCode.String:  	return ToDateTimeOffset ((String)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDecimal,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.Decimal;  case TypeCode.Decimal:  	return (Decimal)p;  case TypeCode.SByte:  	return ToDecimal ((SByte)p);  case TypeCode.Int16:  	return ToDecimal ((Int16)p);  case TypeCode.Int32:  	return ToDecimal ((Int32)p);  case TypeCode.Int64:  	return ToDecimal ((Int64)p);  case TypeCode.Byte:  	return ToDecimal ((Byte)p);  case TypeCode.UInt16:  	return ToDecimal ((UInt16)p);  case TypeCode.UInt32:  	return ToDecimal ((UInt32)p);  case TypeCode.Char:  	return ToDecimal ((Char)p);  case TypeCode.UInt64:  	return ToDecimal ((UInt64)p);  case TypeCode.Single:  	return ToDecimal ((Single)p);  case TypeCode.Double:  	return ToDecimal ((Double)p);  case TypeCode.String:  	return ToDecimal ((String)p);  case TypeCode.Boolean:  	return ToDecimal ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToDouble,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.Double;  case TypeCode.Double:  	return (Double)p;  case TypeCode.DateTime:  	return ToDouble ((DateTime)p);  case TypeCode.SByte:  	return ToDouble ((SByte)p);  case TypeCode.Int16:  	return ToDouble ((Int16)p);  case TypeCode.Int32:  	return ToDouble ((Int32)p);  case TypeCode.Int64:  	return ToDouble ((Int64)p);  case TypeCode.Byte:  	return ToDouble ((Byte)p);  case TypeCode.UInt16:  	return ToDouble ((UInt16)p);  case TypeCode.UInt32:  	return ToDouble ((UInt32)p);  case TypeCode.Char:  	return ToDouble ((Char)p);  case TypeCode.UInt64:  	return ToDouble ((UInt64)p);  case TypeCode.Single:  	return ToDouble ((Single)p);  case TypeCode.Decimal:  	return ToDouble ((Decimal)p);  case TypeCode.String:  	return ToDouble ((String)p);  case TypeCode.Boolean:  	return ToDouble ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToGuid,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.Guid;  case TypeCode.String:  	return ToGuid ((String)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt16,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.Int16;  case TypeCode.Int16:  	return (Int16)p;  case TypeCode.SByte:  	return ToInt16 ((SByte)p);  case TypeCode.Byte:  	return ToInt16 ((Byte)p);  case TypeCode.Int32:  	return ToInt16 ((Int32)p);  case TypeCode.Int64:  	return ToInt16 ((Int64)p);  case TypeCode.UInt16:  	return ToInt16 ((UInt16)p);  case TypeCode.UInt32:  	return ToInt16 ((UInt32)p);  case TypeCode.UInt64:  	return ToInt16 ((UInt64)p);  case TypeCode.Single:  	return ToInt16 ((Single)p);  case TypeCode.Double:  	return ToInt16 ((Double)p);  case TypeCode.Decimal:  	return ToInt16 ((Decimal)p);  case TypeCode.Char:  	return ToInt16 ((Char)p);  case TypeCode.String:  	return ToInt16 ((String)p);  case TypeCode.Boolean:  	return ToInt16 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt32,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.Int32;  case TypeCode.Int32:  	return (Int32)p;  case TypeCode.SByte:  	return ToInt32 ((SByte)p);  case TypeCode.Int16:  	return ToInt32 ((Int16)p);  case TypeCode.Byte:  	return ToInt32 ((Byte)p);  case TypeCode.UInt16:  	return ToInt32 ((UInt16)p);  case TypeCode.Char:  	return ToInt32 ((Char)p);  case TypeCode.Int64:  	return ToInt32 ((Int64)p);  case TypeCode.UInt32:  	return ToInt32 ((UInt32)p);  case TypeCode.UInt64:  	return ToInt32 ((UInt64)p);  case TypeCode.Single:  	return ToInt32 ((Single)p);  case TypeCode.Double:  	return ToInt32 ((Double)p);  case TypeCode.Decimal:  	return ToInt32 ((Decimal)p);  case TypeCode.String:  	return ToInt32 ((String)p);  case TypeCode.Boolean:  	return ToInt32 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.Int64;  case TypeCode.Int64:  	return (Int64)p;  case TypeCode.DateTime:  	return ToInt64 ((DateTime)p);  case TypeCode.SByte:  	return ToInt64 ((SByte)p);  case TypeCode.Int16:  	return ToInt64 ((Int16)p);  case TypeCode.Int32:  	return ToInt64 ((Int32)p);  case TypeCode.Byte:  	return ToInt64 ((Byte)p);  case TypeCode.UInt16:  	return ToInt64 ((UInt16)p);  case TypeCode.UInt32:  	return ToInt64 ((UInt32)p);  case TypeCode.Char:  	return ToInt64 ((Char)p);  case TypeCode.UInt64:  	return ToInt64 ((UInt64)p);  case TypeCode.Single:  	return ToInt64 ((Single)p);  case TypeCode.Double:  	return ToInt64 ((Double)p);  case TypeCode.Decimal:  	return ToInt64 ((Decimal)p);  case TypeCode.String:  	return ToInt64 ((String)p);  case TypeCode.Boolean:  	return ToInt64 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSByte,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.SByte;  case TypeCode.SByte:  	return (SByte)p;  case TypeCode.Int16:  	return ToSByte ((Int16)p);  case TypeCode.Int32:  	return ToSByte ((Int32)p);  case TypeCode.Int64:  	return ToSByte ((Int64)p);  case TypeCode.Byte:  	return ToSByte ((Byte)p);  case TypeCode.UInt16:  	return ToSByte ((UInt16)p);  case TypeCode.UInt32:  	return ToSByte ((UInt32)p);  case TypeCode.UInt64:  	return ToSByte ((UInt64)p);  case TypeCode.Single:  	return ToSByte ((Single)p);  case TypeCode.Double:  	return ToSByte ((Double)p);  case TypeCode.Decimal:  	return ToSByte ((Decimal)p);  case TypeCode.Char:  	return ToSByte ((Char)p);  case TypeCode.String:  	return ToSByte ((String)p);  case TypeCode.Boolean:  	return ToSByte ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSingle,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.Single;  case TypeCode.Single:  	return (Single)p;  case TypeCode.SByte:  	return ToSingle ((SByte)p);  case TypeCode.Int16:  	return ToSingle ((Int16)p);  case TypeCode.Int32:  	return ToSingle ((Int32)p);  case TypeCode.Int64:  	return ToSingle ((Int64)p);  case TypeCode.Byte:  	return ToSingle ((Byte)p);  case TypeCode.UInt16:  	return ToSingle ((UInt16)p);  case TypeCode.UInt32:  	return ToSingle ((UInt32)p);  case TypeCode.Char:  	return ToSingle ((Char)p);  case TypeCode.UInt64:  	return ToSingle ((UInt64)p);  case TypeCode.Double:  	return ToSingle ((Double)p);  case TypeCode.Decimal:  	return ToSingle ((Decimal)p);  case TypeCode.String:  	return ToSingle ((String)p);  case TypeCode.Boolean:  	return ToSingle ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToString,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.String;  case TypeCode.String:  	return (String)p;  case TypeCode.SByte:  	return ToString ((SByte)p);  case TypeCode.Int16:  	return ToString ((Int16)p);  case TypeCode.Int32:  	return ToString ((Int32)p);  case TypeCode.Int64:  	return ToString ((Int64)p);  case TypeCode.Byte:  	return ToString ((Byte)p);  case TypeCode.UInt16:  	return ToString ((UInt16)p);  case TypeCode.UInt32:  	return ToString ((UInt32)p);  case TypeCode.UInt64:  	return ToString ((UInt64)p);  case TypeCode.Single:  	return ToString ((Single)p);  case TypeCode.Double:  	return ToString ((Double)p);  case TypeCode.Boolean:  	return ToString ((Boolean)p);  case TypeCode.Decimal:  	return ToString ((Decimal)p);  case TypeCode.Char:  	return ToString ((Char)p);  case TypeCode.DateTime:  	return ToString ((DateTime)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToTimeSpan,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.TimeSpan;  case TypeCode.DateTime:  	return ToTimeSpan ((DateTime)p);  case TypeCode.Int64:  	return ToTimeSpan ((Int64)p);  case TypeCode.Double:  	return ToTimeSpan ((Double)p);  case TypeCode.String:  	return ToTimeSpan ((String)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt16,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.UInt16;  case TypeCode.UInt16:  	return (UInt16)p;  case TypeCode.Byte:  	return ToUInt16 ((Byte)p);  case TypeCode.SByte:  	return ToUInt16 ((SByte)p);  case TypeCode.Int16:  	return ToUInt16 ((Int16)p);  case TypeCode.Int32:  	return ToUInt16 ((Int32)p);  case TypeCode.Int64:  	return ToUInt16 ((Int64)p);  case TypeCode.UInt32:  	return ToUInt16 ((UInt32)p);  case TypeCode.UInt64:  	return ToUInt16 ((UInt64)p);  case TypeCode.Single:  	return ToUInt16 ((Single)p);  case TypeCode.Double:  	return ToUInt16 ((Double)p);  case TypeCode.Decimal:  	return ToUInt16 ((Decimal)p);  case TypeCode.Char:  	return ToUInt16 ((Char)p);  case TypeCode.String:  	return ToUInt16 ((String)p);  case TypeCode.Boolean:  	return ToUInt16 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt32,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.UInt32;  case TypeCode.UInt32:  	return (UInt32)p;  case TypeCode.Byte:  	return ToUInt32 ((Byte)p);  case TypeCode.UInt16:  	return ToUInt32 ((UInt16)p);  case TypeCode.SByte:  	return ToUInt32 ((SByte)p);  case TypeCode.Int16:  	return ToUInt32 ((Int16)p);  case TypeCode.Int32:  	return ToUInt32 ((Int32)p);  case TypeCode.Int64:  	return ToUInt32 ((Int64)p);  case TypeCode.UInt64:  	return ToUInt32 ((UInt64)p);  case TypeCode.Single:  	return ToUInt32 ((Single)p);  case TypeCode.Double:  	return ToUInt32 ((Double)p);  case TypeCode.Decimal:  	return ToUInt32 ((Decimal)p);  case TypeCode.Char:  	return ToUInt32 ((Char)p);  case TypeCode.String:  	return ToUInt32 ((String)p);  case TypeCode.Boolean:  	return ToUInt32 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToUInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return Configuration.NullableValues.UInt64;  case TypeCode.UInt64:  	return (UInt64)p;  case TypeCode.Byte:  	return ToUInt64 ((Byte)p);  case TypeCode.UInt16:  	return ToUInt64 ((UInt16)p);  case TypeCode.UInt32:  	return ToUInt64 ((UInt32)p);  case TypeCode.SByte:  	return ToUInt64 ((SByte)p);  case TypeCode.Int16:  	return ToUInt64 ((Int16)p);  case TypeCode.Int32:  	return ToUInt64 ((Int32)p);  case TypeCode.Int64:  	return ToUInt64 ((Int64)p);  case TypeCode.Single:  	return ToUInt64 ((Single)p);  case TypeCode.Double:  	return ToUInt64 ((Double)p);  case TypeCode.Decimal:  	return ToUInt64 ((Decimal)p);  case TypeCode.Char:  	return ToUInt64 ((Char)p);  case TypeCode.String:  	return ToUInt64 ((String)p);  case TypeCode.Boolean:  	return ToUInt64 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableBoolean,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.String:  	return ToNullableBoolean ((String)p);  case TypeCode.Boolean:  	return ToNullableBoolean ((Boolean)p);  case TypeCode.Char:  	return ToNullableBoolean ((Char)p);  case TypeCode.SByte:  	return ToNullableBoolean ((SByte)p);  case TypeCode.Int16:  	return ToNullableBoolean ((Int16)p);  case TypeCode.Int32:  	return ToNullableBoolean ((Int32)p);  case TypeCode.Int64:  	return ToNullableBoolean ((Int64)p);  case TypeCode.Byte:  	return ToNullableBoolean ((Byte)p);  case TypeCode.UInt16:  	return ToNullableBoolean ((UInt16)p);  case TypeCode.UInt32:  	return ToNullableBoolean ((UInt32)p);  case TypeCode.UInt64:  	return ToNullableBoolean ((UInt64)p);  case TypeCode.Single:  	return ToNullableBoolean ((Single)p);  case TypeCode.Double:  	return ToNullableBoolean ((Double)p);  case TypeCode.Decimal:  	return ToNullableBoolean ((Decimal)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableByte,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.Byte:  	return ToNullableByte ((Byte)p);  case TypeCode.SByte:  	return ToNullableByte ((SByte)p);  case TypeCode.Int16:  	return ToNullableByte ((Int16)p);  case TypeCode.Int32:  	return ToNullableByte ((Int32)p);  case TypeCode.Int64:  	return ToNullableByte ((Int64)p);  case TypeCode.UInt16:  	return ToNullableByte ((UInt16)p);  case TypeCode.UInt32:  	return ToNullableByte ((UInt32)p);  case TypeCode.UInt64:  	return ToNullableByte ((UInt64)p);  case TypeCode.Single:  	return ToNullableByte ((Single)p);  case TypeCode.Double:  	return ToNullableByte ((Double)p);  case TypeCode.Decimal:  	return ToNullableByte ((Decimal)p);  case TypeCode.Char:  	return ToNullableByte ((Char)p);  case TypeCode.String:  	return ToNullableByte ((String)p);  case TypeCode.Boolean:  	return ToNullableByte ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableChar,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.Char:  	return ToNullableChar ((Char)p);  case TypeCode.SByte:  	return ToNullableChar ((SByte)p);  case TypeCode.Int16:  	return ToNullableChar ((Int16)p);  case TypeCode.Int32:  	return ToNullableChar ((Int32)p);  case TypeCode.Int64:  	return ToNullableChar ((Int64)p);  case TypeCode.Byte:  	return ToNullableChar ((Byte)p);  case TypeCode.UInt16:  	return ToNullableChar ((UInt16)p);  case TypeCode.UInt32:  	return ToNullableChar ((UInt32)p);  case TypeCode.UInt64:  	return ToNullableChar ((UInt64)p);  case TypeCode.Single:  	return ToNullableChar ((Single)p);  case TypeCode.Double:  	return ToNullableChar ((Double)p);  case TypeCode.Decimal:  	return ToNullableChar ((Decimal)p);  case TypeCode.String:  	return ToNullableChar ((String)p);  case TypeCode.Boolean:  	return ToNullableChar ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDateTime,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.DateTime:  	return ToNullableDateTime ((DateTime)p);  case TypeCode.String:  	return ToNullableDateTime ((String)p);  case TypeCode.Int64:  	return ToNullableDateTime ((Int64)p);  case TypeCode.Double:  	return ToNullableDateTime ((Double)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDateTimeOffset,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.Int64:  	return ToNullableDateTimeOffset ((Int64)p);  case TypeCode.Double:  	return ToNullableDateTimeOffset ((Double)p);  case TypeCode.DateTime:  	return ToNullableDateTimeOffset ((DateTime)p);  case TypeCode.String:  	return ToNullableDateTimeOffset ((String)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDecimal,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.SByte:  	return ToNullableDecimal ((SByte)p);  case TypeCode.Int16:  	return ToNullableDecimal ((Int16)p);  case TypeCode.Int32:  	return ToNullableDecimal ((Int32)p);  case TypeCode.Int64:  	return ToNullableDecimal ((Int64)p);  case TypeCode.Byte:  	return ToNullableDecimal ((Byte)p);  case TypeCode.UInt16:  	return ToNullableDecimal ((UInt16)p);  case TypeCode.UInt32:  	return ToNullableDecimal ((UInt32)p);  case TypeCode.Char:  	return ToNullableDecimal ((Char)p);  case TypeCode.UInt64:  	return ToNullableDecimal ((UInt64)p);  case TypeCode.Decimal:  	return ToNullableDecimal ((Decimal)p);  case TypeCode.Single:  	return ToNullableDecimal ((Single)p);  case TypeCode.Double:  	return ToNullableDecimal ((Double)p);  case TypeCode.String:  	return ToNullableDecimal ((String)p);  case TypeCode.Boolean:  	return ToNullableDecimal ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableDouble,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.DateTime:  	return ToNullableDouble ((DateTime)p);  case TypeCode.SByte:  	return ToNullableDouble ((SByte)p);  case TypeCode.Int16:  	return ToNullableDouble ((Int16)p);  case TypeCode.Int32:  	return ToNullableDouble ((Int32)p);  case TypeCode.Int64:  	return ToNullableDouble ((Int64)p);  case TypeCode.Byte:  	return ToNullableDouble ((Byte)p);  case TypeCode.UInt16:  	return ToNullableDouble ((UInt16)p);  case TypeCode.UInt32:  	return ToNullableDouble ((UInt32)p);  case TypeCode.Char:  	return ToNullableDouble ((Char)p);  case TypeCode.UInt64:  	return ToNullableDouble ((UInt64)p);  case TypeCode.Single:  	return ToNullableDouble ((Single)p);  case TypeCode.Double:  	return ToNullableDouble ((Double)p);  case TypeCode.Decimal:  	return ToNullableDouble ((Decimal)p);  case TypeCode.String:  	return ToNullableDouble ((String)p);  case TypeCode.Boolean:  	return ToNullableDouble ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableGuid,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.String:  	return ToNullableGuid ((String)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt16,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.SByte:  	return ToNullableInt16 ((SByte)p);  case TypeCode.Int16:  	return ToNullableInt16 ((Int16)p);  case TypeCode.Byte:  	return ToNullableInt16 ((Byte)p);  case TypeCode.Int32:  	return ToNullableInt16 ((Int32)p);  case TypeCode.Int64:  	return ToNullableInt16 ((Int64)p);  case TypeCode.UInt16:  	return ToNullableInt16 ((UInt16)p);  case TypeCode.UInt32:  	return ToNullableInt16 ((UInt32)p);  case TypeCode.UInt64:  	return ToNullableInt16 ((UInt64)p);  case TypeCode.Single:  	return ToNullableInt16 ((Single)p);  case TypeCode.Double:  	return ToNullableInt16 ((Double)p);  case TypeCode.Decimal:  	return ToNullableInt16 ((Decimal)p);  case TypeCode.Char:  	return ToNullableInt16 ((Char)p);  case TypeCode.String:  	return ToNullableInt16 ((String)p);  case TypeCode.Boolean:  	return ToNullableInt16 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt32,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.SByte:  	return ToNullableInt32 ((SByte)p);  case TypeCode.Int16:  	return ToNullableInt32 ((Int16)p);  case TypeCode.Int32:  	return ToNullableInt32 ((Int32)p);  case TypeCode.Byte:  	return ToNullableInt32 ((Byte)p);  case TypeCode.UInt16:  	return ToNullableInt32 ((UInt16)p);  case TypeCode.Char:  	return ToNullableInt32 ((Char)p);  case TypeCode.Int64:  	return ToNullableInt32 ((Int64)p);  case TypeCode.UInt32:  	return ToNullableInt32 ((UInt32)p);  case TypeCode.UInt64:  	return ToNullableInt32 ((UInt64)p);  case TypeCode.Single:  	return ToNullableInt32 ((Single)p);  case TypeCode.Double:  	return ToNullableInt32 ((Double)p);  case TypeCode.Decimal:  	return ToNullableInt32 ((Decimal)p);  case TypeCode.String:  	return ToNullableInt32 ((String)p);  case TypeCode.Boolean:  	return ToNullableInt32 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.DateTime:  	return ToNullableInt64 ((DateTime)p);  case TypeCode.SByte:  	return ToNullableInt64 ((SByte)p);  case TypeCode.Int16:  	return ToNullableInt64 ((Int16)p);  case TypeCode.Int32:  	return ToNullableInt64 ((Int32)p);  case TypeCode.Int64:  	return ToNullableInt64 ((Int64)p);  case TypeCode.Byte:  	return ToNullableInt64 ((Byte)p);  case TypeCode.UInt16:  	return ToNullableInt64 ((UInt16)p);  case TypeCode.UInt32:  	return ToNullableInt64 ((UInt32)p);  case TypeCode.Char:  	return ToNullableInt64 ((Char)p);  case TypeCode.UInt64:  	return ToNullableInt64 ((UInt64)p);  case TypeCode.Single:  	return ToNullableInt64 ((Single)p);  case TypeCode.Double:  	return ToNullableInt64 ((Double)p);  case TypeCode.Decimal:  	return ToNullableInt64 ((Decimal)p);  case TypeCode.String:  	return ToNullableInt64 ((String)p);  case TypeCode.Boolean:  	return ToNullableInt64 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableSByte,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.SByte:  	return ToNullableSByte ((SByte)p);  case TypeCode.Int16:  	return ToNullableSByte ((Int16)p);  case TypeCode.Int32:  	return ToNullableSByte ((Int32)p);  case TypeCode.Int64:  	return ToNullableSByte ((Int64)p);  case TypeCode.Byte:  	return ToNullableSByte ((Byte)p);  case TypeCode.UInt16:  	return ToNullableSByte ((UInt16)p);  case TypeCode.UInt32:  	return ToNullableSByte ((UInt32)p);  case TypeCode.UInt64:  	return ToNullableSByte ((UInt64)p);  case TypeCode.Single:  	return ToNullableSByte ((Single)p);  case TypeCode.Double:  	return ToNullableSByte ((Double)p);  case TypeCode.Decimal:  	return ToNullableSByte ((Decimal)p);  case TypeCode.Char:  	return ToNullableSByte ((Char)p);  case TypeCode.String:  	return ToNullableSByte ((String)p);  case TypeCode.Boolean:  	return ToNullableSByte ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableSingle,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.SByte:  	return ToNullableSingle ((SByte)p);  case TypeCode.Int16:  	return ToNullableSingle ((Int16)p);  case TypeCode.Int32:  	return ToNullableSingle ((Int32)p);  case TypeCode.Int64:  	return ToNullableSingle ((Int64)p);  case TypeCode.Byte:  	return ToNullableSingle ((Byte)p);  case TypeCode.UInt16:  	return ToNullableSingle ((UInt16)p);  case TypeCode.UInt32:  	return ToNullableSingle ((UInt32)p);  case TypeCode.Char:  	return ToNullableSingle ((Char)p);  case TypeCode.UInt64:  	return ToNullableSingle ((UInt64)p);  case TypeCode.Single:  	return ToNullableSingle ((Single)p);  case TypeCode.Double:  	return ToNullableSingle ((Double)p);  case TypeCode.Decimal:  	return ToNullableSingle ((Decimal)p);  case TypeCode.String:  	return ToNullableSingle ((String)p);  case TypeCode.Boolean:  	return ToNullableSingle ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableTimeSpan,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.DateTime:  	return ToNullableTimeSpan ((DateTime)p);  case TypeCode.Int64:  	return ToNullableTimeSpan ((Int64)p);  case TypeCode.Double:  	return ToNullableTimeSpan ((Double)p);  case TypeCode.String:  	return ToNullableTimeSpan ((String)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt16,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.UInt16:  	return ToNullableUInt16 ((UInt16)p);  case TypeCode.Byte:  	return ToNullableUInt16 ((Byte)p);  case TypeCode.SByte:  	return ToNullableUInt16 ((SByte)p);  case TypeCode.Int16:  	return ToNullableUInt16 ((Int16)p);  case TypeCode.Int32:  	return ToNullableUInt16 ((Int32)p);  case TypeCode.Int64:  	return ToNullableUInt16 ((Int64)p);  case TypeCode.UInt32:  	return ToNullableUInt16 ((UInt32)p);  case TypeCode.UInt64:  	return ToNullableUInt16 ((UInt64)p);  case TypeCode.Single:  	return ToNullableUInt16 ((Single)p);  case TypeCode.Double:  	return ToNullableUInt16 ((Double)p);  case TypeCode.Decimal:  	return ToNullableUInt16 ((Decimal)p);  case TypeCode.Char:  	return ToNullableUInt16 ((Char)p);  case TypeCode.String:  	return ToNullableUInt16 ((String)p);  case TypeCode.Boolean:  	return ToNullableUInt16 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt32,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.Byte:  	return ToNullableUInt32 ((Byte)p);  case TypeCode.UInt16:  	return ToNullableUInt32 ((UInt16)p);  case TypeCode.UInt32:  	return ToNullableUInt32 ((UInt32)p);  case TypeCode.SByte:  	return ToNullableUInt32 ((SByte)p);  case TypeCode.Int16:  	return ToNullableUInt32 ((Int16)p);  case TypeCode.Int32:  	return ToNullableUInt32 ((Int32)p);  case TypeCode.Int64:  	return ToNullableUInt32 ((Int64)p);  case TypeCode.UInt64:  	return ToNullableUInt32 ((UInt64)p);  case TypeCode.Single:  	return ToNullableUInt32 ((Single)p);  case TypeCode.Double:  	return ToNullableUInt32 ((Double)p);  case TypeCode.Decimal:  	return ToNullableUInt32 ((Decimal)p);  case TypeCode.Char:  	return ToNullableUInt32 ((Char)p);  case TypeCode.String:  	return ToNullableUInt32 ((String)p);  case TypeCode.Boolean:  	return ToNullableUInt32 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToNullableUInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.Byte:  	return ToNullableUInt64 ((Byte)p);  case TypeCode.UInt16:  	return ToNullableUInt64 ((UInt16)p);  case TypeCode.UInt32:  	return ToNullableUInt64 ((UInt32)p);  case TypeCode.UInt64:  	return ToNullableUInt64 ((UInt64)p);  case TypeCode.SByte:  	return ToNullableUInt64 ((SByte)p);  case TypeCode.Int16:  	return ToNullableUInt64 ((Int16)p);  case TypeCode.Int32:  	return ToNullableUInt64 ((Int32)p);  case TypeCode.Int64:  	return ToNullableUInt64 ((Int64)p);  case TypeCode.Single:  	return ToNullableUInt64 ((Single)p);  case TypeCode.Double:  	return ToNullableUInt64 ((Double)p);  case TypeCode.Decimal:  	return ToNullableUInt64 ((Decimal)p);  case TypeCode.Char:  	return ToNullableUInt64 ((Char)p);  case TypeCode.String:  	return ToNullableUInt64 ((String)p);  case TypeCode.Boolean:  	return ToNullableUInt64 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlBoolean,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlBoolean.Null;  case TypeCode.String:  	return ToSqlBoolean ((String)p);  case TypeCode.Boolean:  	return ToSqlBoolean ((Boolean)p);  case TypeCode.Char:  	return ToSqlBoolean ((Char)p);  case TypeCode.SByte:  	return ToSqlBoolean ((SByte)p);  case TypeCode.Int16:  	return ToSqlBoolean ((Int16)p);  case TypeCode.Int32:  	return ToSqlBoolean ((Int32)p);  case TypeCode.Int64:  	return ToSqlBoolean ((Int64)p);  case TypeCode.Byte:  	return ToSqlBoolean ((Byte)p);  case TypeCode.UInt16:  	return ToSqlBoolean ((UInt16)p);  case TypeCode.UInt32:  	return ToSqlBoolean ((UInt32)p);  case TypeCode.UInt64:  	return ToSqlBoolean ((UInt64)p);  case TypeCode.Single:  	return ToSqlBoolean ((Single)p);  case TypeCode.Double:  	return ToSqlBoolean ((Double)p);  case TypeCode.Decimal:  	return ToSqlBoolean ((Decimal)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlByte,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlByte.Null;  case TypeCode.Byte:  	return ToSqlByte ((Byte)p);  case TypeCode.SByte:  	return ToSqlByte ((SByte)p);  case TypeCode.Int16:  	return ToSqlByte ((Int16)p);  case TypeCode.Int32:  	return ToSqlByte ((Int32)p);  case TypeCode.Int64:  	return ToSqlByte ((Int64)p);  case TypeCode.UInt16:  	return ToSqlByte ((UInt16)p);  case TypeCode.UInt32:  	return ToSqlByte ((UInt32)p);  case TypeCode.UInt64:  	return ToSqlByte ((UInt64)p);  case TypeCode.Single:  	return ToSqlByte ((Single)p);  case TypeCode.Double:  	return ToSqlByte ((Double)p);  case TypeCode.Decimal:  	return ToSqlByte ((Decimal)p);  case TypeCode.Char:  	return ToSqlByte ((Char)p);  case TypeCode.String:  	return ToSqlByte ((String)p);  case TypeCode.Boolean:  	return ToSqlByte ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlBytes,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlBytes.Null;  case TypeCode.String:  	return ToSqlBytes ((String)p);  case TypeCode.Byte:  	return ToSqlBytes ((Byte)p);  case TypeCode.SByte:  	return ToSqlBytes ((SByte)p);  case TypeCode.DateTime:  	return ToSqlBytes ((DateTime)p);  case TypeCode.Int16:  	return ToSqlBytes ((Int16)p);  case TypeCode.Int32:  	return ToSqlBytes ((Int32)p);  case TypeCode.Int64:  	return ToSqlBytes ((Int64)p);  case TypeCode.UInt16:  	return ToSqlBytes ((UInt16)p);  case TypeCode.UInt32:  	return ToSqlBytes ((UInt32)p);  case TypeCode.UInt64:  	return ToSqlBytes ((UInt64)p);  case TypeCode.Single:  	return ToSqlBytes ((Single)p);  case TypeCode.Double:  	return ToSqlBytes ((Double)p);  case TypeCode.Boolean:  	return ToSqlBytes ((Boolean)p);  case TypeCode.Char:  	return ToSqlBytes ((Char)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDateTime,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlDateTime.Null;  case TypeCode.DateTime:  	return ToSqlDateTime ((DateTime)p);  case TypeCode.String:  	return ToSqlDateTime ((String)p);  case TypeCode.Int64:  	return ToSqlDateTime ((Int64)p);  case TypeCode.Double:  	return ToSqlDateTime ((Double)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDecimal,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlDecimal.Null;  case TypeCode.SByte:  	return ToSqlDecimal ((SByte)p);  case TypeCode.Int16:  	return ToSqlDecimal ((Int16)p);  case TypeCode.Int32:  	return ToSqlDecimal ((Int32)p);  case TypeCode.Int64:  	return ToSqlDecimal ((Int64)p);  case TypeCode.Byte:  	return ToSqlDecimal ((Byte)p);  case TypeCode.UInt16:  	return ToSqlDecimal ((UInt16)p);  case TypeCode.UInt32:  	return ToSqlDecimal ((UInt32)p);  case TypeCode.Char:  	return ToSqlDecimal ((Char)p);  case TypeCode.UInt64:  	return ToSqlDecimal ((UInt64)p);  case TypeCode.Decimal:  	return ToSqlDecimal ((Decimal)p);  case TypeCode.Single:  	return ToSqlDecimal ((Single)p);  case TypeCode.Double:  	return ToSqlDecimal ((Double)p);  case TypeCode.String:  	return ToSqlDecimal ((String)p);  case TypeCode.Boolean:  	return ToSqlDecimal ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlDouble,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlDouble.Null;  case TypeCode.DateTime:  	return ToSqlDouble ((DateTime)p);  case TypeCode.SByte:  	return ToSqlDouble ((SByte)p);  case TypeCode.Int16:  	return ToSqlDouble ((Int16)p);  case TypeCode.Int32:  	return ToSqlDouble ((Int32)p);  case TypeCode.Int64:  	return ToSqlDouble ((Int64)p);  case TypeCode.Byte:  	return ToSqlDouble ((Byte)p);  case TypeCode.UInt16:  	return ToSqlDouble ((UInt16)p);  case TypeCode.UInt32:  	return ToSqlDouble ((UInt32)p);  case TypeCode.Char:  	return ToSqlDouble ((Char)p);  case TypeCode.UInt64:  	return ToSqlDouble ((UInt64)p);  case TypeCode.Single:  	return ToSqlDouble ((Single)p);  case TypeCode.Double:  	return ToSqlDouble ((Double)p);  case TypeCode.Decimal:  	return ToSqlDouble ((Decimal)p);  case TypeCode.String:  	return ToSqlDouble ((String)p);  case TypeCode.Boolean:  	return ToSqlDouble ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlGuid,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlGuid.Null;  case TypeCode.String:  	return ToSqlGuid ((String)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt16,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlInt16.Null;  case TypeCode.SByte:  	return ToSqlInt16 ((SByte)p);  case TypeCode.Int16:  	return ToSqlInt16 ((Int16)p);  case TypeCode.Byte:  	return ToSqlInt16 ((Byte)p);  case TypeCode.Int32:  	return ToSqlInt16 ((Int32)p);  case TypeCode.Int64:  	return ToSqlInt16 ((Int64)p);  case TypeCode.UInt16:  	return ToSqlInt16 ((UInt16)p);  case TypeCode.UInt32:  	return ToSqlInt16 ((UInt32)p);  case TypeCode.UInt64:  	return ToSqlInt16 ((UInt64)p);  case TypeCode.Single:  	return ToSqlInt16 ((Single)p);  case TypeCode.Double:  	return ToSqlInt16 ((Double)p);  case TypeCode.Decimal:  	return ToSqlInt16 ((Decimal)p);  case TypeCode.Char:  	return ToSqlInt16 ((Char)p);  case TypeCode.String:  	return ToSqlInt16 ((String)p);  case TypeCode.Boolean:  	return ToSqlInt16 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt32,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlInt32.Null;  case TypeCode.SByte:  	return ToSqlInt32 ((SByte)p);  case TypeCode.Int16:  	return ToSqlInt32 ((Int16)p);  case TypeCode.Int32:  	return ToSqlInt32 ((Int32)p);  case TypeCode.Byte:  	return ToSqlInt32 ((Byte)p);  case TypeCode.UInt16:  	return ToSqlInt32 ((UInt16)p);  case TypeCode.Char:  	return ToSqlInt32 ((Char)p);  case TypeCode.Int64:  	return ToSqlInt32 ((Int64)p);  case TypeCode.UInt32:  	return ToSqlInt32 ((UInt32)p);  case TypeCode.UInt64:  	return ToSqlInt32 ((UInt64)p);  case TypeCode.Single:  	return ToSqlInt32 ((Single)p);  case TypeCode.Double:  	return ToSqlInt32 ((Double)p);  case TypeCode.Decimal:  	return ToSqlInt32 ((Decimal)p);  case TypeCode.String:  	return ToSqlInt32 ((String)p);  case TypeCode.Boolean:  	return ToSqlInt32 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlInt64.Null;  case TypeCode.DateTime:  	return ToSqlInt64 ((DateTime)p);  case TypeCode.SByte:  	return ToSqlInt64 ((SByte)p);  case TypeCode.Int16:  	return ToSqlInt64 ((Int16)p);  case TypeCode.Int32:  	return ToSqlInt64 ((Int32)p);  case TypeCode.Int64:  	return ToSqlInt64 ((Int64)p);  case TypeCode.Byte:  	return ToSqlInt64 ((Byte)p);  case TypeCode.UInt16:  	return ToSqlInt64 ((UInt16)p);  case TypeCode.UInt32:  	return ToSqlInt64 ((UInt32)p);  case TypeCode.Char:  	return ToSqlInt64 ((Char)p);  case TypeCode.UInt64:  	return ToSqlInt64 ((UInt64)p);  case TypeCode.Single:  	return ToSqlInt64 ((Single)p);  case TypeCode.Double:  	return ToSqlInt64 ((Double)p);  case TypeCode.Decimal:  	return ToSqlInt64 ((Decimal)p);  case TypeCode.String:  	return ToSqlInt64 ((String)p);  case TypeCode.Boolean:  	return ToSqlInt64 ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlMoney,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlMoney.Null;  case TypeCode.SByte:  	return ToSqlMoney ((SByte)p);  case TypeCode.Int16:  	return ToSqlMoney ((Int16)p);  case TypeCode.Int32:  	return ToSqlMoney ((Int32)p);  case TypeCode.Int64:  	return ToSqlMoney ((Int64)p);  case TypeCode.Byte:  	return ToSqlMoney ((Byte)p);  case TypeCode.UInt16:  	return ToSqlMoney ((UInt16)p);  case TypeCode.UInt32:  	return ToSqlMoney ((UInt32)p);  case TypeCode.Char:  	return ToSqlMoney ((Char)p);  case TypeCode.UInt64:  	return ToSqlMoney ((UInt64)p);  case TypeCode.Decimal:  	return ToSqlMoney ((Decimal)p);  case TypeCode.Single:  	return ToSqlMoney ((Single)p);  case TypeCode.Double:  	return ToSqlMoney ((Double)p);  case TypeCode.String:  	return ToSqlMoney ((String)p);  case TypeCode.Boolean:  	return ToSqlMoney ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlSingle,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlSingle.Null;  case TypeCode.SByte:  	return ToSqlSingle ((SByte)p);  case TypeCode.Int16:  	return ToSqlSingle ((Int16)p);  case TypeCode.Int32:  	return ToSqlSingle ((Int32)p);  case TypeCode.Int64:  	return ToSqlSingle ((Int64)p);  case TypeCode.Byte:  	return ToSqlSingle ((Byte)p);  case TypeCode.UInt16:  	return ToSqlSingle ((UInt16)p);  case TypeCode.UInt32:  	return ToSqlSingle ((UInt32)p);  case TypeCode.Char:  	return ToSqlSingle ((Char)p);  case TypeCode.UInt64:  	return ToSqlSingle ((UInt64)p);  case TypeCode.Single:  	return ToSqlSingle ((Single)p);  case TypeCode.Double:  	return ToSqlSingle ((Double)p);  case TypeCode.Decimal:  	return ToSqlSingle ((Decimal)p);  case TypeCode.String:  	return ToSqlSingle ((String)p);  case TypeCode.Boolean:  	return ToSqlSingle ((Boolean)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlString,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlString.Null;  case TypeCode.SByte:  	return ToSqlString ((SByte)p);  case TypeCode.Int16:  	return ToSqlString ((Int16)p);  case TypeCode.Int32:  	return ToSqlString ((Int32)p);  case TypeCode.Int64:  	return ToSqlString ((Int64)p);  case TypeCode.Byte:  	return ToSqlString ((Byte)p);  case TypeCode.UInt16:  	return ToSqlString ((UInt16)p);  case TypeCode.UInt32:  	return ToSqlString ((UInt32)p);  case TypeCode.UInt64:  	return ToSqlString ((UInt64)p);  case TypeCode.Single:  	return ToSqlString ((Single)p);  case TypeCode.Double:  	return ToSqlString ((Double)p);  case TypeCode.Boolean:  	return ToSqlString ((Boolean)p);  case TypeCode.Decimal:  	return ToSqlString ((Decimal)p);  case TypeCode.Char:  	return ToSqlString ((Char)p);  case TypeCode.DateTime:  	return ToSqlString ((DateTime)p);  case TypeCode.String:  	return ToSqlString ((String)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToSqlXml,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return SqlXml.Null;  case TypeCode.String:  	return ToSqlXml ((String)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToByteArray,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.Decimal:  	return ToByteArray ((Decimal)p);  case TypeCode.String:  	return ToByteArray ((String)p);  case TypeCode.Byte:  	return ToByteArray ((Byte)p);  case TypeCode.SByte:  	return ToByteArray ((SByte)p);  #if !SILVERLIGHT  case TypeCode.DateTime:  	return ToByteArray ((DateTime)p);  #endif  case TypeCode.Int16:  	return ToByteArray ((Int16)p);  case TypeCode.Int32:  	return ToByteArray ((Int32)p);  case TypeCode.Int64:  	return ToByteArray ((Int64)p);  case TypeCode.UInt16:  	return ToByteArray ((UInt16)p);  case TypeCode.UInt32:  	return ToByteArray ((UInt32)p);  case TypeCode.UInt64:  	return ToByteArray ((UInt64)p);  case TypeCode.Single:  	return ToByteArray ((Single)p);  case TypeCode.Double:  	return ToByteArray ((Double)p);  case TypeCode.Boolean:  	return ToByteArray ((Boolean)p);  case TypeCode.Char:  	return ToByteArray ((Char)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToType,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.DBNull:  	return null;  case TypeCode.String:  	return ToType ((String)p);  }  
Missing Default,BLToolkit.Common,Convert,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Common\Convert.generated.cs,ToBoolean,The following switch statement is missing a default case: switch (p) {  case '\x0':  // Allow int <=> Char <=> Boolean  case '0':  case 'n':  case 'N':  case 'f':  case 'F':  	return false;  case '\x1':  // Allow int <=> Char <=> Boolean  case '1':  case 'y':  case 'Y':  case 't':  case 'T':  	return true;  }  
Missing Default,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,MapOutputParameters,The following switch statement is missing a default case: switch (parameter.Direction) {  case ParameterDirection.InputOutput:  case ParameterDirection.Output:  	ordinal = dest.GetOrdinal (_dataProvider.Convert (parameter.ParameterName' ConvertType.SprocParameterToName).ToString ());  	break;  case ParameterDirection.ReturnValue:  	if (returnValueMember != null) {  		if (!returnValueMember.StartsWith ("@") && dest is ObjectMapper) {  			var om = (ObjectMapper)dest;  			var ma = om.TypeAccessor [returnValueMember];  			if (ma != null) {  				ma.SetValue (obj' _mappingSchema.ConvertChangeType (parameter.Value' ma.Type));  				continue;  			}  		} else  			returnValueMember = returnValueMember.Substring (1);  		ordinal = dest.GetOrdinal (returnValueMember);  	}  	break;  }  
Missing Default,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,SetCommand,The following switch statement is missing a default case: switch (commandAction) {  case CommandAction.Select:  	_selectCommand = command;  	break;  case CommandAction.Insert:  	_insertCommand = command;  	break;  case CommandAction.Update:  	_updateCommand = command;  	break;  case CommandAction.Delete:  	_deleteCommand = command;  	break;  }  
Missing Default,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,SetCommandParameters,The following switch statement is missing a default case: switch (commandAction) {  case CommandAction.Select:  	_selectCommandParameters = commandParameters;  	break;  case CommandAction.Insert:  	_insertCommandParameters = commandParameters;  	break;  case CommandAction.Update:  	_updateCommandParameters = commandParameters;  	break;  case CommandAction.Delete:  	_deleteCommandParameters = commandParameters;  	break;  }  
Missing Default,BLToolkit.Data,DbManager,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DbManager.cs,InitParameters,The following switch statement is missing a default case: switch (p.DbType) {  case DbType.AnsiString:  case DbType.Binary:  case DbType.Object:  case DbType.String:  case DbType.VarNumeric:  case DbType.AnsiStringFixedLength:  case DbType.StringFixedLength:  case DbType.DateTime:  case DbType.DateTime2:  case DbType.DateTimeOffset:  case DbType.Date:  	if (p.Size == 0) {  		p.Size = 1;  		prepare = true;  	}  	break;  case DbType.Decimal:  	if (p.Precision == 0 && p.Scale == 0)  		p.Precision = 1;  	break;  }  
Missing Default,BLToolkit.Data.DataProvider,FirebirdMappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\FirebirdMappingSchema.cs,ConvertToBoolean,The following switch statement is missing a default case: switch (value [0]) {  case '1':  case 'T':  case 'Y':  case 't':  case 'y':  	return true;  case '0':  case 'F':  case 'N':  case 'f':  case 'n':  	return false;  }  
Missing Default,BLToolkit.Data.DataProvider,AccessDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\AccessDataProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.ExceptionToErrorNumber:  	if (value is OleDbException) {  		var ex = (OleDbException)value;  		if (ex.Errors.Count > 0)  			return ex.Errors [0].NativeError;  	}  	break;  }  
Missing Default,BLToolkit.Data.DataProvider,OdbcDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OdbcDataProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.ExceptionToErrorNumber:  	if (value is OdbcException) {  		var ex = (OdbcException)value;  		if (ex.Errors.Count > 0)  			return ex.Errors [0].NativeError;  	}  	break;  }  
Missing Default,BLToolkit.Data.DataProvider,OleDbDataProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\OleDbDataProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.NameToQueryParameter:  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter:  	return "@" + value.ToString ().Replace (" "' string.Empty);  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTableAlias:  	{  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '[')  			return value;  	}  	return "[" + value + "]";  case ConvertType.NameToDatabase:  case ConvertType.NameToOwner:  case ConvertType.NameToQueryTable:  	{  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '[')  			return value;  		if (name.IndexOf ('.') > 0)  			value = string.Join ("].["' name.Split ('.'));  	}  	return "[" + value + "]";  case ConvertType.SprocParameterToName:  	if (value != null) {  		var str = value.ToString ();  		return str.Length > 0 && str [0] == '@' ? str.Substring (1) : str;  	}  	break;  case ConvertType.ExceptionToErrorNumber:  	if (value is OleDbException) {  		var ex = (OleDbException)value;  		if (ex.Errors.Count > 0)  			return ex.Errors [0].NativeError;  	}  	break;  }  
Missing Default,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.ExceptionToErrorNumber:  	if (value is SqlException)  		return ((SqlException)value).Number;  	break;  }  
Missing Default,BLToolkit.Data.DataProvider,SqlDataProviderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\DataProvider\SqlDataProviderBase.cs,ConvertErrorNumberToDataExceptionType,The following switch statement is missing a default case: switch (number) {  case 1205:  	return DataExceptionType.Deadlock;  case -2:  	return DataExceptionType.Timeout;  case 547:  	return DataExceptionType.ForeignKeyViolation;  case 2601:  	return DataExceptionType.UniqueIndexViolation;  case 2627:  	return DataExceptionType.ConstraintViolation;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,BuildExpression,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.Add:  case ExpressionType.AddChecked:  	_exprBuilder.Append (" + ");  	break;  case ExpressionType.And:  	_exprBuilder.Append (" & ");  	break;  case ExpressionType.AndAlso:  	_exprBuilder.Append (" && ");  	break;  #if FW4 || SILVERLIGHT  case ExpressionType.Assign:  	_exprBuilder.Append (" = ");  	break;  #endif  case ExpressionType.Coalesce:  	_exprBuilder.Append (" ?? ");  	break;  case ExpressionType.Divide:  	_exprBuilder.Append (" / ");  	break;  case ExpressionType.Equal:  	_exprBuilder.Append (" == ");  	break;  case ExpressionType.ExclusiveOr:  	_exprBuilder.Append (" ^ ");  	break;  case ExpressionType.GreaterThan:  	_exprBuilder.Append (" > ");  	break;  case ExpressionType.GreaterThanOrEqual:  	_exprBuilder.Append (" >= ");  	break;  case ExpressionType.LeftShift:  	_exprBuilder.Append (" << ");  	break;  case ExpressionType.LessThan:  	_exprBuilder.Append (" < ");  	break;  case ExpressionType.LessThanOrEqual:  	_exprBuilder.Append (" <= ");  	break;  case ExpressionType.Modulo:  	_exprBuilder.Append (" % ");  	break;  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  	_exprBuilder.Append (" * ");  	break;  case ExpressionType.NotEqual:  	_exprBuilder.Append (" != ");  	break;  case ExpressionType.Or:  	_exprBuilder.Append (" | ");  	break;  case ExpressionType.OrElse:  	_exprBuilder.Append (" || ");  	break;  case ExpressionType.Power:  	_exprBuilder.Append (" ** ");  	break;  case ExpressionType.RightShift:  	_exprBuilder.Append (" >> ");  	break;  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked:  	_exprBuilder.Append (" - ");  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,VisitMembers,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.Call: {  	var ex = (MethodCallExpression)expr;  	_usedMembers.Add (ex.Method);  	if (ex.Method.IsGenericMethod) {  		var gmd = ex.Method.GetGenericMethodDefinition ();  		if (gmd != ex.Method)  			_usedMembers.Add (gmd);  		var ga = ex.Method.GetGenericArguments ();  		foreach (var type in ga)  			_usedMembers.Add (type);  	}  	break;  }  case ExpressionType.MemberAccess: {  	var ex = (MemberExpression)expr;  	_usedMembers.Add (ex.Member);  	break;  }  case ExpressionType.MemberInit: {  	var ex = (MemberInitExpression)expr;  	Action<IEnumerable<MemberBinding>> visit = null;  	visit = bs => {  		foreach (var b in bs) {  			_usedMembers.Add (b.Member);  			switch (b.BindingType) {  			case MemberBindingType.MemberBinding:  				visit (((MemberMemberBinding)b).Bindings);  				break;  			}  		}  	};  	visit (ex.Bindings);  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,VisitMembers,The following switch statement is missing a default case: switch (b.BindingType) {  case MemberBindingType.MemberBinding:  	visit (((MemberMemberBinding)b).Bindings);  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionTestGenerator,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionTestGenerator.cs,VisitTypes,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.Call: {  	var ex = (MethodCallExpression)expr;  	var mi = ex.Method;  	AddType (mi.DeclaringType);  	AddType (mi.ReturnType);  	foreach (var arg in mi.GetGenericArguments ())  		AddType (arg);  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,UpdateBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\UpdateBuilder.cs,BuildMethodCall,The following switch statement is missing a default case: switch (methodCall.Arguments.Count) {  case 1:  	// int Update<T>(this IUpdateable<T> source)  	CheckAssociation (sequence);  	break;  case 2:// int Update<T>(this IQueryable<T> source' Expression<Func<T'T>> setter)   {  	CheckAssociation (sequence);  	BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  	break;  }  case 3: {  	var expr = methodCall.Arguments [1].Unwrap ();  	if (expr is LambdaExpression) {  		// int Update<T>(this IQueryable<T> source' Expression<Func<T'bool>> predicate' Expression<Func<T'T>> setter)  		//  		sequence = builder.BuildWhere (buildInfo.Parent' sequence' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' false);  		CheckAssociation (sequence);  		BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' sequence' sequence.SqlQuery.Update.Items' sequence);  	} else {  		// static int Update<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)  		//  		var into = builder.BuildSequence (new BuildInfo (buildInfo' expr' new SqlQuery ()));  		sequence.ConvertToIndex (null' 0' ConvertFlags.All);  		sequence.SqlQuery.ResolveWeakJoins (new List<ISqlTableSource> ());  		sequence.SqlQuery.Select.Columns.Clear ();  		BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Update.Items' sequence);  		var sql = sequence.SqlQuery;  		sql.Select.Columns.Clear ();  		foreach (var item in sql.Update.Items)  			sql.Select.Columns.Add (new SqlQuery.Column (sql' item.Expression));  		sql.Update.Table = ((TableBuilder.TableContext)into).SqlTable;  	}  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,InsertBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\InsertBuilder.cs,BuildMethodCall,The following switch statement is missing a default case: switch (methodCall.Arguments.Count) {  case 1:// static int Insert<T>              (this IValueInsertable<T> source)  // static int Insert<TSource'TTarget>(this ISelectInsertable<TSource'TTarget> source)   {  	foreach (var item in sequence.SqlQuery.Insert.Items)  		sequence.SqlQuery.Select.Expr (item.Expression);  	break;  }  case 2:// static int Insert<T>(this Table<T> target' Expression<Func<T>> setter)   {  	UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [1].Unwrap ()' sequence' sequence.SqlQuery.Insert.Items' sequence);  	sequence.SqlQuery.Insert.Into = ((TableBuilder.TableContext)sequence).SqlTable;  	sequence.SqlQuery.From.Tables.Clear ();  	break;  }  case 3:// static int Insert<TSource'TTarget>(this IQueryable<TSource> source' Table<TTarget> target' Expression<Func<TSource'TTarget>> setter)   {  	var into = builder.BuildSequence (new BuildInfo (buildInfo' methodCall.Arguments [1]' new SqlQuery ()));  	UpdateBuilder.BuildSetter (builder' buildInfo' (LambdaExpression)methodCall.Arguments [2].Unwrap ()' into' sequence.SqlQuery.Insert.Items' sequence);  	sequence.SqlQuery.Select.Columns.Clear ();  	foreach (var item in sequence.SqlQuery.Insert.Items)  		sequence.SqlQuery.Select.Columns.Add (new SqlQuery.Column (sequence.SqlQuery' item.Expression));  	sequence.SqlQuery.Insert.Into = ((TableBuilder.TableContext)into).SqlTable;  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,TableAttributeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableAttributeBuilder.cs,BuildMethodCall,The following switch statement is missing a default case: switch (methodCall.Method.Name) {  case "TableName":  	table.SqlTable.PhysicalName = value;  	break;  case "DatabaseName":  	table.SqlTable.Database = value;  	break;  case "OwnerName":  	table.SqlTable.Owner = value;  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertParameters,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.Parameter:  	if (CompiledParameters != null) {  		var idx = Array.IndexOf (CompiledParameters' (ParameterExpression)expr);  		if (idx > 0)  			return Expression.Convert (Expression.ArrayIndex (ParametersParam' Expression.Constant (Array.IndexOf (CompiledParameters' (ParameterExpression)expr)))' expr.Type);  	}  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ExposeExpression,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.MemberAccess: {  	var me = (MemberExpression)expr;  	var l = ConvertMethodExpression (me.Member);  	if (l != null) {  		var body = l.Body.Unwrap ();  		var ex = body.Convert2 (wpi => new ExpressionHelper.ConvertInfo (wpi.NodeType == ExpressionType.Parameter ? me.Expression : wpi));  		if (ex.Type != expr.Type)  			ex = new ChangeTypeExpression (ex' expr.Type);  		return ExposeExpression (ex);  	}  	break;  }  case ExpressionType.Constant: {  	var c = (ConstantExpression)expr;  	// Fix Mono behaviour.  	//  	//if (c.Value is IExpressionQuery)  	//	return ((IQueryable)c.Value).Expression;  	if (c.Value is IQueryable && !(c.Value is ITable)) {  		var e = ((IQueryable)c.Value).Expression;  		if (!_visitedExpressions.Contains (e)) {  			_visitedExpressions.Add (e);  			return ExposeExpression (e);  		}  	}  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,OptimizeExpressionImpl,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.MemberAccess: {  	var me = (MemberExpression)expr;  	// Replace Count with Count()  	//  	if (me.Member.Name == "Count") {  		var isList = typeof(ICollection).IsAssignableFrom (me.Member.DeclaringType);  		if (!isList)  			isList = me.Member.DeclaringType.GetInterfaces ().Any (t => t.IsGenericType && t.GetGenericTypeDefinition () == typeof(IList<>));  		if (isList) {  			var mi = EnumerableMethods.First (m => m.Name == "Count" && m.GetParameters ().Length == 1).MakeGenericMethod (TypeHelper.GetElementType (me.Expression.Type));  			return Expression.Call (null' mi' me.Expression);  		}  	}  	if (CompiledParameters == null && TypeHelper.IsSameOrParent (typeof(IQueryable)' expr.Type)) {  		var ex = ConvertIQueriable (expr);  		if (ex != expr)  			return ConvertExpressionTree (ex);  	}  	return ConvertSubquery (expr);  }  case ExpressionType.Call: {  	var call = (MethodCallExpression)expr;  	if (call.IsQueryable ()) {  		switch (call.Method.Name) {  		case "Where":  			return ConvertWhere (call);  		case "GroupBy":  			return ConvertGroupBy (call);  		case "SelectMany":  			return ConvertSelectMany (call);  		case "Select":  			return ConvertSelect (call);  		case "LongCount":  		case "Count":  		case "Single":  		case "SingleOrDefault":  		case "First":  		case "FirstOrDefault":  			return ConvertPredicate (call);  		case "Min":  		case "Max":  			return ConvertSelector (call' true);  		case "Sum":  		case "Average":  			return ConvertSelector (call' false);  		case "ElementAt":  		case "ElementAtOrDefault":  			return ConvertElementAt (call);  		}  	} else {  		var l = ConvertMethodExpression (call.Method);  		if (l != null)  			return OptimizeExpression (ConvertMethod (call' l));  		if (CompiledParameters == null && TypeHelper.IsSameOrParent (typeof(IQueryable)' expr.Type)) {  			var attr = GetTableFunctionAttribute (call.Method);  			if (attr == null) {  				var ex = ConvertIQueriable (expr);  				if (ex != expr)  					return ConvertExpressionTree (ex);  			}  		}  	}  	return ConvertSubquery (expr);  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,OptimizeExpressionImpl,The following switch statement is missing a default case: switch (call.Method.Name) {  case "Where":  	return ConvertWhere (call);  case "GroupBy":  	return ConvertGroupBy (call);  case "SelectMany":  	return ConvertSelectMany (call);  case "Select":  	return ConvertSelect (call);  case "LongCount":  case "Count":  case "Single":  case "SingleOrDefault":  case "First":  case "FirstOrDefault":  	return ConvertPredicate (call);  case "Min":  case "Max":  	return ConvertSelector (call' true);  case "Sum":  case "Average":  	return ConvertSelector (call' false);  case "ElementAt":  case "ElementAtOrDefault":  	return ConvertElementAt (call);  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertSubquery,The following switch statement is missing a default case: switch (call.Method.Name) {  case "Single":  case "SingleOrDefault":  case "First":  case "FirstOrDefault":  	return ConvertSingleOrFirst (expr' call);  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,GetPredicate,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.MemberAccess:  	var li = Expression.Lambda<Func<object>> (((MemberExpression)expr)).Compile ().DynamicInvoke ();  	return GetPredicate ((System.Linq.Expressions.Expression)li);  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsExpression,The following switch statement is missing a default case: switch (ex.NodeType) {  case ExpressionType.Convert:  case ExpressionType.ConvertChecked:  case ExpressionType.MemberInit:  case ExpressionType.New:  case ExpressionType.NewArrayBounds:  case ExpressionType.NewArrayInit:  case ExpressionType.Parameter:  	return false;  case ExpressionType.MemberAccess: {  	var ma = (MemberExpression)ex;  	var attr = GetFunctionAttribute (ma.Member);  	if (attr != null)  		return true;  	return false;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,CheckSubQueryForWhere,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.MemberAccess: {  	var ma = (MemberExpression)expr;  	if (TypeHelper.IsNullableValueMember (ma.Member) || TypeHelper.IsNullableHasValueMember (ma.Member))  		break;  	if (SqlProvider.ConvertMember (ma.Member) == null) {  		var ctx = GetContext (context' expr);  		if (ctx != null) {  			if (ctx.IsExpression (expr' 0' RequestFor.Expression).Result)  				makeSubQuery = true;  			stopWalking = true;  		}  	}  	isWhere = true;  	break;  }  case ExpressionType.Call: {  	var e = (MethodCallExpression)expr;  	if (e.Method.DeclaringType == typeof(Enumerable) && e.Method.Name != "Contains")  		return isHaving = true;  	isWhere = true;  	break;  }  case ExpressionType.Parameter: {  	var ctx = GetContext (context' expr);  	if (ctx != null) {  		if (ctx.IsExpression (expr' 0' RequestFor.Expression).Result)  			makeSubQuery = true;  		stopWalking = true;  	}  	isWhere = true;  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertExpressions,The following switch statement is missing a default case: switch (expression.NodeType) {  case ExpressionType.New: {  	var expr = (NewExpression)expression;  	// ReSharper disable ConditionIsAlwaysTrueOrFalse  	// ReSharper disable HeuristicUnreachableCode  	if (expr.Members == null)  		return Array<SqlInfo>.Empty;  	// ReSharper restore HeuristicUnreachableCode  	// ReSharper restore ConditionIsAlwaysTrueOrFalse  	return expr.Arguments.Select ((arg' i) => {  		var mi = expr.Members [i];  		if (mi is MethodInfo)  			mi = TypeHelper.GetPropertyByMethod ((MethodInfo)mi);  		return ConvertExpressions (context' arg' queryConvertFlag).Select (si => si.Clone (mi));  	}).SelectMany (si => si).ToArray ();  }  case ExpressionType.MemberInit: {  	var expr = (MemberInitExpression)expression;  	var dic = TypeAccessor.GetAccessor (expr.Type).Select ((m' i) => new {  		m'  		i  	}).ToDictionary (_ => _.m.MemberInfo' _ => _.i);  	return expr.Bindings.Where (b => b is MemberAssignment).Cast<MemberAssignment> ().OrderBy (b => dic [b.Member]).Select (a => {  		var mi = a.Member;  		if (mi is MethodInfo)  			mi = TypeHelper.GetPropertyByMethod ((MethodInfo)mi);  		return ConvertExpressions (context' a.Expression' queryConvertFlag).Select (si => si.Clone (mi));  	}).SelectMany (si => si).ToArray ();  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following switch statement is missing a default case: switch (expression.NodeType) {  case ExpressionType.Add:  case ExpressionType.AddChecked:  	return Convert (context' new SqlBinaryExpression (t' l' "+"' r' Precedence.Additive));  case ExpressionType.And:  	return Convert (context' new SqlBinaryExpression (t' l' "&"' r' Precedence.Bitwise));  case ExpressionType.Divide:  	return Convert (context' new SqlBinaryExpression (t' l' "/"' r' Precedence.Multiplicative));  case ExpressionType.ExclusiveOr:  	return Convert (context' new SqlBinaryExpression (t' l' "^"' r' Precedence.Bitwise));  case ExpressionType.Modulo:  	return Convert (context' new SqlBinaryExpression (t' l' "%"' r' Precedence.Multiplicative));  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  	return Convert (context' new SqlBinaryExpression (t' l' "*"' r' Precedence.Multiplicative));  case ExpressionType.Or:  	return Convert (context' new SqlBinaryExpression (t' l' "|"' r' Precedence.Bitwise));  case ExpressionType.Power:  	return Convert (context' new SqlFunction (t' "Power"' l' r));  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked:  	return Convert (context' new SqlBinaryExpression (t' l' "-"' r' Precedence.Subtraction));  case ExpressionType.Coalesce: {  	if (r is SqlFunction) {  		var c = (SqlFunction)r;  		if (c.Name == "Coalesce") {  			var parms = new ISqlExpression[c.Parameters.Length + 1];  			parms [0] = l;  			c.Parameters.CopyTo (parms' 1);  			return Convert (context' new SqlFunction (t' "Coalesce"' parms));  		}  	}  	return Convert (context' new SqlFunction (t' "Coalesce"' l' r));  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertToSql,The following switch statement is missing a default case: switch (expression.NodeType) {  case ExpressionType.UnaryPlus:  	return o;  case ExpressionType.Negate:  case ExpressionType.NegateChecked:  	return Convert (context' new SqlBinaryExpression (t' new SqlValue (-1)' "*"' o' Precedence.Multiplicative));  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsServerSideOnly,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.MemberAccess: {  	var ex = (MemberExpression)expr;  	var l = SqlProvider.ConvertMember (ex.Member);  	if (l != null)  		return IsServerSideOnly (l.Body.Unwrap ());  	var attr = GetFunctionAttribute (ex.Member);  	return attr != null && attr.ServerSideOnly;  }  case ExpressionType.Call: {  	var e = (MethodCallExpression)expr;  	if (e.Method.DeclaringType == typeof(Enumerable)) {  		if (CountBuilder.MethodNames.Concat (AggregationBuilder.MethodNames).Contains (e.Method.Name))  			return IsQueryMember (e.Arguments [0]);  	} else if (e.Method.DeclaringType == typeof(Queryable)) {  		switch (e.Method.Name) {  		case "Any":  		case "All":  		case "Contains":  			return true;  		}  	} else {  		var l = SqlProvider.ConvertMember (e.Method);  		if (l != null)  			return l.Body.Unwrap ().Find (IsServerSideOnly) != null;  		var attr = GetFunctionAttribute (e.Method);  		return attr != null && attr.ServerSideOnly;  	}  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsServerSideOnly,The following switch statement is missing a default case: switch (e.Method.Name) {  case "Any":  case "All":  case "Contains":  	return true;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsQueryMember,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.Parameter:  	return true;  case ExpressionType.MemberAccess:  	return IsQueryMember (((MemberExpression)expr).Expression);  case ExpressionType.Call: {  	var call = (MethodCallExpression)expr;  	if (call.Method.DeclaringType == typeof(Queryable))  		return true;  	if (call.Method.DeclaringType == typeof(Enumerable) && call.Arguments.Count > 0)  		return IsQueryMember (call.Arguments [0]);  	return IsQueryMember (call.Object);  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,CanBeConstant,The following switch statement is missing a default case: switch (ex.NodeType) {  case ExpressionType.Constant: {  	var c = (ConstantExpression)ex;  	if (c.Value == null || ExpressionHelper.IsConstant (ex.Type))  		return false;  	break;  }  case ExpressionType.MemberAccess: {  	var ma = (MemberExpression)ex;  	if (ExpressionHelper.IsConstant (ma.Member.DeclaringType) || TypeHelper.IsNullableValueMember (ma.Member))  		return false;  	break;  }  case ExpressionType.Call: {  	var mc = (MethodCallExpression)ex;  	if (ExpressionHelper.IsConstant (mc.Method.DeclaringType) || mc.Method.DeclaringType == typeof(object))  		return false;  	var attr = GetFunctionAttribute (mc.Method);  	if (attr != null && !attr.ServerSideOnly)  		return false;  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,CanBeCompiled,The following switch statement is missing a default case: switch (ex.NodeType) {  case ExpressionType.Parameter:  	return ex != ParametersParam;  case ExpressionType.MemberAccess: {  	var attr = GetFunctionAttribute (((MemberExpression)ex).Member);  	return attr != null && attr.ServerSideOnly;  }  case ExpressionType.Call: {  	var attr = GetFunctionAttribute (((MethodCallExpression)ex).Method);  	return attr != null && attr.ServerSideOnly;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following switch statement is missing a default case: switch (expression.NodeType) {  case ExpressionType.Equal:  case ExpressionType.NotEqual:  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual: {  	var e = (BinaryExpression)expression;  	return ConvertCompare (context' expression.NodeType' e.Left' e.Right);  }  case ExpressionType.Call: {  	var e = (MethodCallExpression)expression;  	ISqlPredicate predicate = null;  	if (e.Method.Name == "Equals" && e.Object != null && e.Arguments.Count == 1)  		return ConvertCompare (context' ExpressionType.Equal' e.Object' e.Arguments [0]);  	if (e.Method.DeclaringType == typeof(string)) {  		switch (e.Method.Name) {  		case "Contains":  			predicate = ConvertLikePredicate (context' e' "%"' "%");  			break;  		case "StartsWith":  			predicate = ConvertLikePredicate (context' e' ""' "%");  			break;  		case "EndsWith":  			predicate = ConvertLikePredicate (context' e' "%"' "");  			break;  		}  	} else if (e.Method.Name == "Contains") {  		if (e.Method.DeclaringType == typeof(Enumerable) || TypeHelper.IsSameOrParent (typeof(IList)' e.Method.DeclaringType) || TypeHelper.IsSameOrParent (typeof(ICollection<>)' e.Method.DeclaringType)) {  			predicate = ConvertInPredicate (context' e);  		}  	} else if (e.Method.Name == "ContainsValue" && TypeHelper.IsSameOrParent (typeof(Dictionary<' >)' e.Method.DeclaringType)) {  		var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(Dictionary<' >));  		var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [1]);  		var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Values")' e.Arguments [0]);  		predicate = ConvertInPredicate (context' expr);  	} else if (e.Method.Name == "ContainsKey" && TypeHelper.IsSameOrParent (typeof(IDictionary<' >)' e.Method.DeclaringType)) {  		var args = TypeHelper.GetGenericArguments (e.Method.DeclaringType' typeof(IDictionary<' >));  		var minf = EnumerableMethods.First (m => m.Name == "Contains" && m.GetParameters ().Length == 2).MakeGenericMethod (args [0]);  		var expr = Expression.Call (minf' Expression.PropertyOrField (e.Object' "Keys")' e.Arguments [0]);  		predicate = ConvertInPredicate (context' expr);  	}   	#if !SILVERLIGHT  	else if (e.Method == ReflectionHelper.Functions.String.Like11)  		predicate = ConvertLikePredicate (context' e);  	else if (e.Method == ReflectionHelper.Functions.String.Like12)  		predicate = ConvertLikePredicate (context' e);  	#endif  	else if (e.Method == ReflectionHelper.Functions.String.Like21)  		predicate = ConvertLikePredicate (context' e);  	else if (e.Method == ReflectionHelper.Functions.String.Like22)  		predicate = ConvertLikePredicate (context' e);  	if (predicate != null)  		return Convert (context' predicate);  	break;  }  case ExpressionType.Conditional:  	return Convert (context' new SqlQuery.Predicate.ExprExpr (ConvertToSql (context' expression' false)' SqlQuery.Predicate.Operator.Equal' new SqlValue (true)));  case ExpressionType.MemberAccess: {  	var e = (MemberExpression)expression;  	if (e.Member.Name == "HasValue" && e.Member.DeclaringType.IsGenericType && e.Member.DeclaringType.GetGenericTypeDefinition () == typeof(Nullable<>)) {  		var expr = ConvertToSql (context' e.Expression' false);  		return Convert (context' new SqlQuery.Predicate.IsNull (expr' true));  	}  	break;  }  case ExpressionType.TypeIs: {  	var e = (TypeBinaryExpression)expression;  	var ctx = GetContext (context' e.Expression);  	if (ctx != null && ctx.IsExpression (e.Expression' 0' RequestFor.Table).Result)  		return MakeIsPredicate (ctx' e);  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertPredicate,The following switch statement is missing a default case: switch (e.Method.Name) {  case "Contains":  	predicate = ConvertLikePredicate (context' e' "%"' "%");  	break;  case "StartsWith":  	predicate = ConvertLikePredicate (context' e' ""' "%");  	break;  case "EndsWith":  	predicate = ConvertLikePredicate (context' e' "%"' "");  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The following switch statement is missing a default case: switch (nodeType) {  case ExpressionType.Equal:  case ExpressionType.NotEqual:  	var p = ConvertObjectComparison (nodeType' context' left' context' right);  	if (p != null)  		return p;  	p = ConvertObjectNullComparison (context' left' right' nodeType == ExpressionType.Equal);  	if (p != null)  		return p;  	p = ConvertObjectNullComparison (context' right' left' nodeType == ExpressionType.Equal);  	if (p != null)  		return p;  	if (left.NodeType == ExpressionType.New || right.NodeType == ExpressionType.New) {  		p = ConvertNewObjectComparison (context' nodeType' left' right);  		if (p != null)  			return p;  	}  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertCompare,The following switch statement is missing a default case: switch (nodeType) {  case ExpressionType.Equal:  case ExpressionType.NotEqual:  	if (!context.SqlQuery.IsParameterDependent && (l is SqlParameter && l.CanBeNull () || r is SqlParameter && r.CanBeNull ()))  		context.SqlQuery.IsParameterDependent = true;  	// | (SqlQuery(Select([]) as q)' SqlValue(null))  	// | (SqlValue(null)' SqlQuery(Select([]) as q))  =>  	var q = l.ElementType == QueryElementType.SqlQuery && r.ElementType == QueryElementType.SqlValue && ((SqlValue)r).Value == null && ((SqlQuery)l).Select.Columns.Count == 0 ? (SqlQuery)l : r.ElementType == QueryElementType.SqlQuery && l.ElementType == QueryElementType.SqlValue && ((SqlValue)l).Value == null && ((SqlQuery)r).Select.Columns.Count == 0 ? (SqlQuery)r : null;  	if (q != null) {  		q.Select.Columns.Add (new SqlQuery.Column (q' new SqlValue (1)));  	}  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,ConvertEnumConversion,The following switch statement is missing a default case: switch (value.NodeType) {  case ExpressionType.Constant: {  	var enumValue = ((ConstantExpression)value).Value;  	if (enumValue == null)  		return null;  	var name = Enum.GetName (type' enumValue);  	// ReSharper disable ConditionIsAlwaysTrueOrFalse  	// ReSharper disable HeuristicUnreachableCode  	if (name == null)  		return null;  	// ReSharper restore HeuristicUnreachableCode  	// ReSharper restore ConditionIsAlwaysTrueOrFalse  	var origValue = Enum.Parse (type' name' false);  	var mapValue = origValue;  	if (!(operand is MemberExpression)) {  		if (!dic.TryGetValue (origValue' out mapValue))  			return null;  	}  	ISqlExpression l' r;  	SqlValue sqlValue;  	if (left.NodeType == ExpressionType.Convert) {  		l = ConvertToSql (context' operand' false);  		r = sqlValue = new SqlValue (mapValue);  	} else {  		r = ConvertToSql (context' operand' false);  		l = sqlValue = new SqlValue (mapValue);  	}  	if (operand is MemberExpression) {  		var me = (MemberExpression)operand;  		var memberAccessor = TypeAccessor.GetAccessor (me.Member.DeclaringType) [me.Member.Name];  		sqlValue.SetEnumConverter (memberAccessor' MappingSchema);  	}  	return Convert (context' new SqlQuery.Predicate.ExprExpr (l' op' r));  }  case ExpressionType.Convert: {  	value = ((UnaryExpression)value).Operand;  	var l = ConvertToSql (context' operand' false' false);  	var r = ConvertToSql (context' value' false' false);  	MemberAccessor memberAccessor = null;  	if (operand is MemberExpression) {  		// is it even possible that operand is not MemberExpression?  		// if no' then we can remove this two last uses of SetEnumConverter(type' map)  		// and other depending code  		// At least currently there is no test coverage for this method and I didn't  		// manage to create such test  		var me = (MemberExpression)operand;  		memberAccessor = TypeAccessor.GetAccessor (me.Member.DeclaringType) [me.Member.Name];  	}  	if (l is SqlValueBase) {  		if (memberAccessor != null) {  			((SqlValueBase)l).SetEnumConverter (memberAccessor' MappingSchema);  		} else {  			((SqlValueBase)l).SetEnumConverter (type' MappingSchema);  		}  	}  	if (r is SqlValueBase) {  		if (memberAccessor != null) {  			((SqlValueBase)r).SetEnumConverter (memberAccessor' MappingSchema);  		} else {  			((SqlValueBase)r).SetEnumConverter (type' MappingSchema);  		}  	}  	return Convert (context' new SqlQuery.Predicate.ExprExpr (l' op' r));  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,FindExpression,The following switch statement is missing a default case: switch (pi.NodeType) {  case ExpressionType.Convert: {  	var e = (UnaryExpression)expr;  	return e.Operand.NodeType == ExpressionType.ArrayIndex && ((BinaryExpression)e.Operand).Left == ParametersParam;  }  case ExpressionType.MemberAccess:  case ExpressionType.New:  	return true;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,EscapeLikeText,The following switch statement is missing a default case: switch (ch) {  case '%':  case '_':  case '~':  	builder.Append ('~');  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,CanBeTranslatedToSql,The following switch statement is missing a default case: switch (pi.NodeType) {  case ExpressionType.MemberAccess: {  	var ma = (MemberExpression)pi;  	var attr = GetFunctionAttribute (ma.Member);  	if (attr == null && !TypeHelper.IsNullableValueMember (ma.Member)) {  		if (canBeCompiled) {  			var ctx = GetContext (context' pi);  			if (ctx == null)  				return !CanBeCompiled (pi);  			if (ctx.IsExpression (pi' 0' RequestFor.Object).Result)  				return !CanBeCompiled (pi);  			ignoredMembers = ma.Expression.GetMembers ();  		}  	}  	break;  }  case ExpressionType.Parameter: {  	var ctx = GetContext (context' pi);  	if (ctx == null)  		if (canBeCompiled)  			return !CanBeCompiled (pi);  	break;  }  case ExpressionType.Call: {  	var e = (MethodCallExpression)pi;  	if (e.Method.DeclaringType != typeof(Enumerable)) {  		var attr = GetFunctionAttribute (e.Method);  		if (attr == null && canBeCompiled)  			return !CanBeCompiled (pi);  	}  	break;  }  case ExpressionType.TypeIs:  	return canBeCompiled;  case ExpressionType.TypeAs:  case ExpressionType.New:  	return true;  case ExpressionType.NotEqual:  case ExpressionType.Equal: {  	var e = (BinaryExpression)pi;  	Expression obj = null;  	if (IsNullConstant (e.Left))  		obj = e.Right;  	else if (IsNullConstant (e.Right))  		obj = e.Left;  	if (obj != null) {  		var ctx = GetContext (context' obj);  		if (ctx != null) {  			if (ctx.IsExpression (obj' 0' RequestFor.Table).Result || ctx.IsExpression (obj' 0' RequestFor.Association).Result) {  				ignoredMembers = obj.GetMembers ();  			}  		}  	}  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildExpression,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.MemberAccess: {  	if (IsServerSideOnly (expr) || PreferServerSide (expr))  		return new ExpressionHelper.ConvertInfo (BuildSql (context' expr));  	var ma = (MemberExpression)expr;  	if (SqlProvider.ConvertMember (ma.Member) != null)  		return new ExpressionHelper.ConvertInfo (BuildSql (context' expr));  	//break;  	//var l = SqlProvider.ConvertMember(ma.Member);  	var ctx = GetContext (context' expr);  	if (ctx != null)  		return new ExpressionHelper.ConvertInfo (ctx.BuildExpression (expr' 0));  	var ex = ma.Expression;  	if (ex != null && ex.NodeType == ExpressionType.Constant) {  		// field = localVariable  		//  		var c = _expressionAccessors [ex];  		return new ExpressionHelper.ConvertInfo (Expression.MakeMemberAccess (Expression.Convert (c' ex.Type)' ma.Member));  	}  	break;  }  case ExpressionType.Parameter: {  	if (expr == ParametersParam)  		break;  	var ctx = GetContext (context' expr);  	if (ctx != null)  		return new ExpressionHelper.ConvertInfo (ctx.BuildExpression (expr' 0));  	break;  }  case ExpressionType.Constant: {  	if (ExpressionHelper.IsConstant (expr.Type))  		break;  	if (_expressionAccessors.ContainsKey (expr))  		return new ExpressionHelper.ConvertInfo (Expression.Convert (_expressionAccessors [expr]' expr.Type));  	break;  }  case ExpressionType.Coalesce:  	if (expr.Type == typeof(string) && MappingSchema.GetDefaultNullValue<string> () != null)  		return new ExpressionHelper.ConvertInfo (BuildSql (context' expr));  	if (CanBeTranslatedToSql (context' ConvertExpression (expr)' true))  		return new ExpressionHelper.ConvertInfo (BuildSql (context' expr));  	break;  case ExpressionType.Conditional:  	if (CanBeTranslatedToSql (context' ConvertExpression (expr)' true))  		return new ExpressionHelper.ConvertInfo (BuildSql (context' expr));  	break;  case ExpressionType.Call:  	{  		var ce = (MethodCallExpression)expr;  		if (IsGroupJoinSource (context' ce)) {  			foreach (var arg in ce.Arguments.Skip (1))  				if (!_skippedExpressions.Contains (arg))  					_skippedExpressions.Add (arg);  			break;  		}  		if (IsSubQuery (context' ce)) {  			if (TypeHelper.IsSameOrParent (typeof(IEnumerable)' expr.Type) && expr.Type != typeof(string) && !expr.Type.IsArray)  				return new ExpressionHelper.ConvertInfo (BuildMultipleQuery (context' expr));  			return new ExpressionHelper.ConvertInfo (GetSubQuery (context' ce).BuildExpression (null' 0));  		}  		if (IsServerSideOnly (expr) || PreferServerSide (expr))  			return new ExpressionHelper.ConvertInfo (BuildSql (context' expr));  	}  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,IsNoneSqlMember,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.MemberAccess: {  	var me = (MemberExpression)expr;  	var om = (from c in Contexts.OfType<TableBuilder.TableContext> ()  	where c.ObjectType == me.Member.DeclaringType  	select c.ObjectMapper).FirstOrDefault ();  	return om != null && om.Associations.All (a => !TypeHelper.Equals (a.MemberAccessor.MemberInfo' me.Member)) && om [me.Member.Name' true] == null;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,PreferServerSide,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.MemberAccess: {  	var pi = (MemberExpression)expr;  	var l = SqlProvider.ConvertMember (pi.Member);  	if (l != null) {  		var info = l.Body.Unwrap ();  		if (l.Parameters.Count == 1 && pi.Expression != null)  			info = info.Convert (wpi => wpi == l.Parameters [0] ? pi.Expression : wpi);  		return info.Find (PreferServerSide) != null;  	}  	var attr = GetFunctionAttribute (pi.Member);  	return attr != null && attr.PreferServerSide && !CanBeCompiled (expr);  }  case ExpressionType.Call: {  	var pi = (MethodCallExpression)expr;  	var e = pi;  	var l = SqlProvider.ConvertMember (e.Method);  	if (l != null)  		return l.Body.Unwrap ().Find (PreferServerSide) != null;  	var attr = GetFunctionAttribute (e.Method);  	return attr != null && attr.PreferServerSide && !CanBeCompiled (expr);  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionBuilder.cs,BuildMultipleQuery,The following switch statement is missing a default case: switch (e.NodeType) {  case ExpressionType.MemberAccess: {  	var root = e.GetRootObject ();  	if (root != null && root.NodeType == ExpressionType.Parameter && !parameters.Contains ((ParameterExpression)root)) {  		var res = context.IsExpression (e' 0' RequestFor.Association);  		if (res.Result) {  			var table = (TableBuilder.AssociatedTableContext)res.Context;  			if (table.IsList) {  				var ttype = typeof(Table<>).MakeGenericType (table.ObjectType);  				var tbl = Activator.CreateInstance (ttype);  				var method = typeof(LinqExtensions).GetMethod ("Where"' BindingFlags.NonPublic | BindingFlags.Static).MakeGenericMethod (e.Type' table.ObjectType' ttype);  				var me = (MemberExpression)e;  				var op = Expression.Parameter (table.ObjectType' "t");  				parameters.Add (op);  				Expression ex = null;  				for (var i = 0; i < table.Association.ThisKey.Length; i++) {  					var field1 = table.ParentAssociation.SqlTable.Fields [table.Association.ThisKey [i]];  					var field2 = table.SqlTable.Fields [table.Association.OtherKey [i]];  					var ee = Expression.Equal (Expression.MakeMemberAccess (op' field2.MemberMapper.MemberAccessor.MemberInfo)' Expression.MakeMemberAccess (me.Expression' field1.MemberMapper.MemberAccessor.MemberInfo));  					ex = ex == null ? ee : Expression.AndAlso (ex' ee);  				}  				return Expression.Call (null' method' Expression.Constant (tbl)' Expression.Lambda (ex' op));  			}  		}  	}  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,FirstSingleBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\FirstSingleBuilder.cs,BuildMethodCall,The following switch statement is missing a default case: switch (methodCall.Method.Name) {  case "First":  case "FirstOrDefault":  	take = 1;  	break;  case "Single":  case "SingleOrDefault":  	if (!buildInfo.IsSubQuery)  		take = 2;  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,MethodCallBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\MethodCallBuilder.cs,ConvertMethod,The following switch statement is missing a default case: switch (expression.NodeType) {  case ExpressionType.Parameter:  	if (info.ExpressionsToReplace != null)  		foreach (var item in info.ExpressionsToReplace)  			if (expression == item.Path || expression == param && item.Path.NodeType == ExpressionType.Parameter)  				return item.Expr;  	break;  case ExpressionType.MemberAccess:  	if (info.ExpressionsToReplace != null) {  		foreach (var item in info.ExpressionsToReplace) {  			var ex1 = expression;  			var ex2 = item.Path;  			while (ex1.NodeType == ex2.NodeType) {  				if (ex1.NodeType == ExpressionType.Parameter)  					return ex1 == ex2 || info.Parameter == ex2 ? item.Expr : expression;  				if (ex2.NodeType != ExpressionType.MemberAccess)  					break;  				var ma1 = (MemberExpression)ex1;  				var ma2 = (MemberExpression)ex2;  				if (ma1.Member != ma2.Member)  					break;  				ex1 = ma1.Expression;  				ex2 = ma2.Expression;  			}  		}  	}  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionContext.cs,ConvertToSql,The following switch statement is missing a default case: switch (flags) {  case ConvertFlags.Field:  case ConvertFlags.Key:  case ConvertFlags.All: {  	var root = expression.GetRootObject ();  	if (root.NodeType == ExpressionType.Parameter) {  		var ctx = Builder.GetContext (this' root);  		if (ctx != null) {  			if (ctx != this)  				return ctx.ConvertToSql (expression' 0' flags);  			return root == expression ? Sequence.ConvertToSql (null' 0' flags) : Sequence.ConvertToSql (expression' level + 1' flags);  		}  	}  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionContext.cs,IsExpression,The following switch statement is missing a default case: switch (requestFlag) {  case RequestFor.Root:  	return new IsExpressionResult (Lambda.Parameters.Count > 0 && expression == Lambda.Parameters [0]);  case RequestFor.Table:  case RequestFor.Association:  case RequestFor.Object:  case RequestFor.GroupJoin:  case RequestFor.Field:  case RequestFor.Expression: {  	var levelExpression = expression.GetLevelExpression (level);  	return levelExpression == expression ? Sequence.IsExpression (null' 0' requestFlag) : Sequence.IsExpression (expression' level + 1' requestFlag);  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,ExpressionContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\ExpressionContext.cs,GetContext,The following switch statement is missing a default case: switch (expression.NodeType) {  case ExpressionType.Constant:  case ExpressionType.New:  case ExpressionType.MemberInit:  	return null;  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The following switch statement is missing a default case: switch (levelExpression.NodeType) {  case ExpressionType.MemberAccess: {  	var memberExpression = GetMemberExpression (((MemberExpression)levelExpression).Member' levelExpression == expression' levelExpression.Type);  	if (levelExpression == expression) {  		if (IsSubQuery ()) {  			switch (memberExpression.NodeType) {  			case ExpressionType.New:  			case ExpressionType.MemberInit: {  				return memberExpression.Convert (e => {  					if (e != memberExpression) {  						switch (e.NodeType) {  						case ExpressionType.MemberAccess:  							var sequence = GetSequence (memberExpression' 0);  							if (sequence != null && !sequence.IsExpression (e' 0' RequestFor.Object).Result && !sequence.IsExpression (e' 0' RequestFor.Field).Result) {  								var info = ConvertToIndex (e' 0' ConvertFlags.Field).Single ();  								var idx = Parent == null ? info.Index : Parent.ConvertToParentIndex (info.Index' this);  								return Builder.BuildSql (e.Type' idx);  							}  							return Builder.BuildExpression (this' e);  						}  					}  					return e;  				});  			}  			}  			var me = memberExpression.NodeType == ExpressionType.Parameter ? null : memberExpression;  			if (!IsExpression (me' 0' RequestFor.Object).Result && !IsExpression (me' 0' RequestFor.Field).Result) {  				var info = ConvertToIndex (expression' level' ConvertFlags.Field).Single ();  				var idx = Parent == null ? info.Index : Parent.ConvertToParentIndex (info.Index' this);  				return Builder.BuildSql (expression.Type' idx);  			}  		}  		return Builder.BuildExpression (this' memberExpression);  	}  	{  		var sequence = GetSequence (expression' level);  		switch (memberExpression.NodeType) {  		case ExpressionType.Parameter: {  			var parameter = Lambda.Parameters [Sequence.Length == 0 ? 0 : Array.IndexOf (Sequence' sequence)];  			if (memberExpression == parameter)  				return sequence.BuildExpression (expression' level + 1);  			break;  		}  		case ExpressionType.New:  		case ExpressionType.MemberInit: {  			var mmExpresion = GetMemberExpression (memberExpression' expression' level + 1);  			return Builder.BuildExpression (this' mmExpresion);  		}  		}  		var expr = expression.Convert (ex => ex == levelExpression ? memberExpression : ex);  		return sequence.BuildExpression (expr' 1);  	}  }  case ExpressionType.Parameter:  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The following switch statement is missing a default case: switch (memberExpression.NodeType) {  case ExpressionType.New:  case ExpressionType.MemberInit: {  	return memberExpression.Convert (e => {  		if (e != memberExpression) {  			switch (e.NodeType) {  			case ExpressionType.MemberAccess:  				var sequence = GetSequence (memberExpression' 0);  				if (sequence != null && !sequence.IsExpression (e' 0' RequestFor.Object).Result && !sequence.IsExpression (e' 0' RequestFor.Field).Result) {  					var info = ConvertToIndex (e' 0' ConvertFlags.Field).Single ();  					var idx = Parent == null ? info.Index : Parent.ConvertToParentIndex (info.Index' this);  					return Builder.BuildSql (e.Type' idx);  				}  				return Builder.BuildExpression (this' e);  			}  		}  		return e;  	});  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The following switch statement is missing a default case: switch (e.NodeType) {  case ExpressionType.MemberAccess:  	var sequence = GetSequence (memberExpression' 0);  	if (sequence != null && !sequence.IsExpression (e' 0' RequestFor.Object).Result && !sequence.IsExpression (e' 0' RequestFor.Field).Result) {  		var info = ConvertToIndex (e' 0' ConvertFlags.Field).Single ();  		var idx = Parent == null ? info.Index : Parent.ConvertToParentIndex (info.Index' this);  		return Builder.BuildSql (e.Type' idx);  	}  	return Builder.BuildExpression (this' e);  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,BuildExpression,The following switch statement is missing a default case: switch (memberExpression.NodeType) {  case ExpressionType.Parameter: {  	var parameter = Lambda.Parameters [Sequence.Length == 0 ? 0 : Array.IndexOf (Sequence' sequence)];  	if (memberExpression == parameter)  		return sequence.BuildExpression (expression' level + 1);  	break;  }  case ExpressionType.New:  case ExpressionType.MemberInit: {  	var mmExpresion = GetMemberExpression (memberExpression' expression' level + 1);  	return Builder.BuildExpression (this' mmExpresion);  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToSql,The following switch statement is missing a default case: switch (flags) {  case ConvertFlags.Field:  case ConvertFlags.Key:  case ConvertFlags.All: {  	if (Body.NodeType != ExpressionType.Parameter && level == 0) {  		var levelExpression = expression.GetLevelExpression (level);  		if (levelExpression != expression)  			if (flags != ConvertFlags.Field && IsExpression (expression' level' RequestFor.Field).Result)  				flags = ConvertFlags.Field;  	}  	return ProcessScalar (expression' level' (ctx' ex' l) => ctx.ConvertToSql (ex' l' flags)' () => new[] {  		new SqlInfo {  			Sql = Builder.ConvertToSql (this' expression' false)  		}  	});  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,The following switch statement is missing a default case: switch (flags) {  case ConvertFlags.Field:  case ConvertFlags.All:  	return ProcessScalar (expression' level' (ctx' ex' l) => ctx.ConvertToIndex (ex' l' flags)' () => GetSequence (expression' level).ConvertToIndex (expression' level + 1' flags));  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,The following switch statement is missing a default case: switch (flags) {  case ConvertFlags.Field:  	throw new InvalidOperationException ();  case ConvertFlags.Key:  case ConvertFlags.All: {  	var p = Expression.Parameter (Body.Type' "p");  	var q = from m in Members.Keys  	where !(m is MethodInfo)  	select new {  		Sql = ConvertToIndex (Expression.MakeMemberAccess (p' m)' 1' flags)'  		Member = m  	} into mm  	from m in mm.Sql.Select (s => s.Clone (mm.Member))  	select m;  	return q.ToArray ();  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,The following switch statement is missing a default case: switch (flags) {  case ConvertFlags.All:  case ConvertFlags.Key:  case ConvertFlags.Field: {  	if (level == 0) {  		var idx = Builder.ConvertExpressions (this' expression' flags);  		foreach (var info in idx)  			SetInfo (info);  		return idx;  	}  	var levelExpression = expression.GetLevelExpression (level);  	switch (levelExpression.NodeType) {  	case ExpressionType.MemberAccess: {  		if (levelExpression == expression) {  			var member = Tuple.Create (((MemberExpression)levelExpression).Member' flags);  			SqlInfo[] idx;  			if (!_memberIndex.TryGetValue (member' out idx)) {  				idx = ConvertToSql (expression' level' flags);  				if (flags == ConvertFlags.Field && idx.Length != 1)  					throw new InvalidOperationException ();  				foreach (var info in idx)  					SetInfo (info);  				_memberIndex.Add (member' idx);  			}  			return idx;  		}  		return ProcessMemberAccess (expression' (MemberExpression)levelExpression' level' (n' ctx' ex' l' _) => n == 0 ? GetSequence (expression' level).ConvertToIndex (expression' level + 1' flags) : ctx.ConvertToIndex (ex' l' flags));  	}  	case ExpressionType.Parameter:  		if (levelExpression != expression)  			return GetSequence (expression' level).ConvertToIndex (expression' level + 1' flags);  		break;  	}  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ConvertToIndexInternal,The following switch statement is missing a default case: switch (levelExpression.NodeType) {  case ExpressionType.MemberAccess: {  	if (levelExpression == expression) {  		var member = Tuple.Create (((MemberExpression)levelExpression).Member' flags);  		SqlInfo[] idx;  		if (!_memberIndex.TryGetValue (member' out idx)) {  			idx = ConvertToSql (expression' level' flags);  			if (flags == ConvertFlags.Field && idx.Length != 1)  				throw new InvalidOperationException ();  			foreach (var info in idx)  				SetInfo (info);  			_memberIndex.Add (member' idx);  		}  		return idx;  	}  	return ProcessMemberAccess (expression' (MemberExpression)levelExpression' level' (n' ctx' ex' l' _) => n == 0 ? GetSequence (expression' level).ConvertToIndex (expression' level + 1' flags) : ctx.ConvertToIndex (ex' l' flags));  }  case ExpressionType.Parameter:  	if (levelExpression != expression)  		return GetSequence (expression' level).ConvertToIndex (expression' level + 1' flags);  	break;  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,IsExpression,The following switch statement is missing a default case: switch (requestFlag) {  case RequestFor.SubQuery:  	return IsExpressionResult.False;  case RequestFor.Root:  	return new IsExpressionResult (Sequence.Length == 1 ? expression == Lambda.Parameters [0] : Lambda.Parameters.Any (p => p == expression));  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,IsExpression,The following switch statement is missing a default case: switch (memberExpression.NodeType) {  case ExpressionType.New:  case ExpressionType.MemberInit:  	return new IsExpressionResult (requestFlag == RequestFor.Object);  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetContext,The following switch statement is missing a default case: switch (levelExpression.NodeType) {  case ExpressionType.MemberAccess: {  	if (levelExpression == expression && Sequence.Length == 1 && !(Sequence [0] is GroupByBuilder.GroupByContext)) {  		var memberExpression = GetMemberExpression (((MemberExpression)levelExpression).Member' levelExpression == expression' levelExpression.Type);  		//var sequence = GetSequence(memberExpression' 0);  		//return sequence.GetContext(memberExpression' 1' new BuildInfo(buildInfo' memberExpression));  		var ctx = GetContext (memberExpression' 0' new BuildInfo (this' memberExpression' buildInfo.SqlQuery));  		if (ctx != null) {  			return ctx;  		}  	}  	var context = ProcessMemberAccess (expression' (MemberExpression)levelExpression' level' (n' ctx' ex' l' _) => n == 0 ? null : ctx.GetContext (ex' l' buildInfo));  	if (context == null)  		throw new InvalidOperationException ();  	return context;  }  case ExpressionType.Parameter: {  	var sequence = GetSequence (expression' level);  	var parameter = Lambda.Parameters [Sequence.Length == 0 ? 0 : Array.IndexOf (Sequence' sequence)];  	if (levelExpression == expression) {  		if (levelExpression == parameter)  			return sequence.GetContext (null' 0' buildInfo);  	} else if (level == 0)  		return sequence.GetContext (expression' 1' buildInfo);  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,ProcessMemberAccess,The following switch statement is missing a default case: switch (memberExpression.NodeType) {  case ExpressionType.MemberAccess:  case ExpressionType.Parameter:  	if (sequence != null)  		return action (2' sequence' newExpression' nextLevel' memberExpression);  	break;  //throw new InvalidOperationException();  case ExpressionType.New:  case ExpressionType.MemberInit: {  	var mmExpresion = GetMemberExpression (memberExpression' expression' level + 1);  	return action (3' this' mmExpresion' 0' memberExpression);  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetSequence,The following switch statement is missing a default case: switch (levelExpression.NodeType) {  case ExpressionType.MemberAccess: {  	var memberExpression = Members [((MemberExpression)levelExpression).Member];  	root = memberExpression.GetRootObject ();  	if (root.NodeType != ExpressionType.Parameter)  		return null;  	break;  }  case ExpressionType.Parameter: {  	root = expression.GetRootObject ();  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectContext.cs,GetMemberExpression,The following switch statement is missing a default case: switch (newExpression.NodeType) {  case ExpressionType.New: {  	var expr = (NewExpression)newExpression;  	// ReSharper disable ConditionIsAlwaysTrueOrFalse  	// ReSharper disable HeuristicUnreachableCode  	if (expr.Members == null)  		throw new LinqException ("Invalid expression {0}"' expression);  	// ReSharper restore HeuristicUnreachableCode  	// ReSharper restore ConditionIsAlwaysTrueOrFalse  	for (var i = 0; i < expr.Members.Count; i++)  		if (me.Member == expr.Members [i])  			return levelExpresion == expression ? expr.Arguments [i].Unwrap () : GetMemberExpression (expr.Arguments [i].Unwrap ()' expression' level + 1);  	throw new LinqException ("Invalid expression {0}"' expression);  }  case ExpressionType.MemberInit: {  	var expr = (MemberInitExpression)newExpression;  	foreach (var binding in expr.Bindings.Cast<MemberAssignment> ()) {  		if (me.Member == binding.Member)  			return levelExpresion == expression ? binding.Expression.Unwrap () : GetMemberExpression (binding.Expression.Unwrap ()' expression' level + 1);  	}  	throw new LinqException ("Invalid expression {0}"' expression);  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,SelectBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SelectBuilder.cs,GetExpressions,The following switch statement is missing a default case: switch (expression.NodeType) {  // new { ... }  //  case ExpressionType.New: {  	var expr = (NewExpression)expression;  	if (expr.Members != null)  		for (var i = 0; i < expr.Members.Count; i++) {  			var q = GetExpressions (param' Expression.MakeMemberAccess (path' expr.Members [i])' level + 1' expr.Arguments [i]);  			foreach (var e in q)  				yield return e;  		}  	break;  }  // new MyObject { ... }  //  case ExpressionType.MemberInit: {  	var expr = (MemberInitExpression)expression;  	var dic = TypeAccessor.GetAccessor (expr.Type).Select ((m' i) => new {  		m'  		i  	}).ToDictionary (_ => _.m.MemberInfo.Name' _ => _.i);  	foreach (var binding in expr.Bindings.Cast<MemberAssignment> ().OrderBy (b => dic [b.Member.Name])) {  		var q = GetExpressions (param' Expression.MakeMemberAccess (path' binding.Member)' level + 1' binding.Expression);  		foreach (var e in q)  			yield return e;  	}  	break;  }  // parameter  //  case ExpressionType.Parameter:  	if (expression == param)  		yield return new SequenceConvertPath {  			Path = path'  			Expr = expression'  			Level = level  		};  	break;  case ExpressionType.TypeAs:  	yield return new SequenceConvertPath {  		Path = path'  		Expr = expression'  		Level = level  	};  	break;  // Queriable method.  //  case ExpressionType.Call: {  	var call = (MethodCallExpression)expression;  	if (call.IsQueryable ())  		if (TypeHelper.IsSameOrParent (typeof(IEnumerable)' call.Type) || TypeHelper.IsSameOrParent (typeof(IQueryable)' call.Type) || FirstSingleBuilder.MethodNames.Contains (call.Method.Name))  			yield return new SequenceConvertPath {  				Path = path'  				Expr = expression'  				Level = level  			};  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,SubQueryContext,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\SubQueryContext.cs,IsExpression,The following switch statement is missing a default case: switch (testFlag) {  case RequestFor.SubQuery:  	return IsExpressionResult.True;  }  
Missing Default,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,Find,The following switch statement is missing a default case: switch (expression.NodeType) {  case ExpressionType.Constant: {  	var c = (ConstantExpression)expression;  	if (c.Value is IQueryable)  		return action (1' null);  	break;  }  case ExpressionType.Call: {  	var mc = (MethodCallExpression)expression;  	if (mc.Method.Name == "GetTable")  		if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  			return action (2' null);  	var attr = builder.GetTableFunctionAttribute (mc.Method);  	if (attr != null)  		return action (5' null);  	break;  }  case ExpressionType.MemberAccess:  	if (expression.Type.IsGenericType && expression.Type.GetGenericTypeDefinition () == typeof(Table<>))  		return action (3' null);  	// Looking for association.  	//  	if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  		var ctx = builder.GetContext (buildInfo.Parent' expression);  		if (ctx != null)  			return action (4' ctx);  	}  	break;  case ExpressionType.Parameter: {  	if (buildInfo.IsSubQuery && buildInfo.SqlQuery.From.Tables.Count == 0) {  		var ctx = builder.GetContext (buildInfo.Parent' expression);  		if (ctx != null)  			return action (4' ctx);  	}  	break;  }  }  
Missing Default,BLToolkit.Data.Linq.Builder,TableBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Builder\TableBuilder.cs,BuildSequence,The following switch statement is missing a default case: switch (n) {  case 0:  	return null;  case 1:  	return new TableContext (builder' buildInfo' ((IQueryable)((ConstantExpression)buildInfo.Expression).Value).ElementType);  case 2:  case 3:  	return new TableContext (builder' buildInfo' buildInfo.Expression.Type.GetGenericArguments () [0]);  case 4:  	return ctx.GetContext (buildInfo.Expression' 0' buildInfo);  case 5:  	return new TableContext (builder' buildInfo);  }  
Missing Default,BLToolkit.Data.Linq,CompiledQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\CompiledQuery.cs,CompileQuery,The following switch statement is missing a default case: switch (pi.NodeType) {  case ExpressionType.Parameter: {  	var idx = query.Parameters.IndexOf ((ParameterExpression)pi);  	if (idx >= 0)  		return Expression.Convert (Expression.ArrayIndex (ps' Expression.Constant (idx))' pi.Type);  	break;  }  case ExpressionType.Call:  	{  		var expr = (MethodCallExpression)pi;  		if (expr.IsQueryable ()) {  			var qtype = TypeHelper.GetGenericType (TypeHelper.IsSameOrParent (typeof(IQueryable)' expr.Type) ? typeof(IQueryable<>) : typeof(IEnumerable<>)' expr.Type);  			var helper = (ITableHelper)Activator.CreateInstance (typeof(TableHelper<>).MakeGenericType (qtype == null ? expr.Type : qtype.GetGenericArguments () [0]));  			return helper.CallTable (query' expr' ps' qtype != null);  		}  		if (expr.Method.Name == "GetTable" && expr.Method.DeclaringType == typeof(Extensions))  			goto case ExpressionType.MemberAccess;  	}  	break;  case ExpressionType.MemberAccess:  	if (pi.Type.IsGenericType && pi.Type.GetGenericTypeDefinition () == typeof(Table<>)) {  		var helper = (ITableHelper)Activator.CreateInstance (typeof(TableHelper<>).MakeGenericType (pi.Type.GetGenericArguments () [0]));  		return helper.CallTable (query' pi' ps' true);  	}  	break;  }  
Missing Default,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DateAdd,The following switch statement is missing a default case: switch (part) {  case DateParts.Year:  	return date.Value.AddYears ((int)number);  case DateParts.Quarter:  	return date.Value.AddMonths ((int)number * 3);  case DateParts.Month:  	return date.Value.AddMonths ((int)number);  case DateParts.DayOfYear:  	return date.Value.AddDays (number.Value);  case DateParts.Day:  	return date.Value.AddDays (number.Value);  case DateParts.Week:  	return date.Value.AddDays (number.Value * 7);  case DateParts.WeekDay:  	return date.Value.AddDays (number.Value);  case DateParts.Hour:  	return date.Value.AddHours (number.Value);  case DateParts.Minute:  	return date.Value.AddMinutes (number.Value);  case DateParts.Second:  	return date.Value.AddSeconds (number.Value);  case DateParts.Millisecond:  	return date.Value.AddMilliseconds (number.Value);  }  
Missing Default,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DatePart,The following switch statement is missing a default case: switch (part) {  case DateParts.Year:  	return date.Value.Year;  case DateParts.Quarter:  	return (date.Value.Month - 1) / 3 + 1;  case DateParts.Month:  	return date.Value.Month;  case DateParts.DayOfYear:  	return date.Value.DayOfYear;  case DateParts.Day:  	return date.Value.Day;  case DateParts.Week:  	return CultureInfo.CurrentCulture.Calendar.GetWeekOfYear (date.Value' CalendarWeekRule.FirstDay' DayOfWeek.Sunday);  case DateParts.WeekDay:  	return ((int)date.Value.DayOfWeek + 1 + DateFirst + 6) % 7 + 1;  case DateParts.Hour:  	return date.Value.Hour;  case DateParts.Minute:  	return date.Value.Minute;  case DateParts.Second:  	return date.Value.Second;  case DateParts.Millisecond:  	return date.Value.Millisecond;  }  
Missing Default,BLToolkit.Data.Linq,Sql,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Linq\Sql.GroupBy.cs,DateDiff,The following switch statement is missing a default case: switch (part) {  case DateParts.Day:  	return (int)(endDate - startDate).Value.TotalDays;  case DateParts.Hour:  	return (int)(endDate - startDate).Value.TotalHours;  case DateParts.Minute:  	return (int)(endDate - startDate).Value.TotalMinutes;  case DateParts.Second:  	return (int)(endDate - startDate).Value.TotalSeconds;  case DateParts.Millisecond:  	return (int)(endDate - startDate).Value.TotalMilliseconds;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSql2000SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2000SqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  case TypeCode.DateTime:  	if (func.Name == "Convert") {  		var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  		if (IsTimeDataType (func.Parameters [0])) {  			if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  				return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  		}  		if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Datetime"))  				return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  		}  		if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSql2012SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2012SqlProvider.cs,BuildFunction,The following switch statement is missing a default case: switch (func.Name) {  case "CASE":  	func = ConvertCase (func.SystemType' func.Parameters' 0);  	break;  case "Coalesce":  	if (func.Parameters.Length > 2) {  		var parms = new ISqlExpression[func.Parameters.Length - 1];  		Array.Copy (func.Parameters' 1' parms' 0' parms.Length);  		BuildFunction (sb' new SqlFunction (func.SystemType' func.Name' func.Parameters [0]' new SqlFunction (func.SystemType' func.Name' parms)));  		return;  	}  	var sc = new SqlQuery.SearchCondition ();  	sc.Conditions.Add (new SqlQuery.Condition (false' new SqlQuery.Predicate.IsNull (func.Parameters [0]' false)));  	func = new SqlFunction (func.SystemType' "IIF"' sc' func.Parameters [1]' func.Parameters [0]);  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildPredicate,The following switch statement is missing a default case: switch (expr.Operator) {  case SqlQuery.Predicate.Operator.Equal:  case SqlQuery.Predicate.Operator.NotEqual: {  	ISqlExpression e = null;  	if (expr.Expr1 is SqlValueBase && ((SqlValueBase)expr.Expr1).Value == null)  		e = expr.Expr2;  	else if (expr.Expr2 is SqlValueBase && ((SqlValueBase)expr.Expr2).Value == null)  		e = expr.Expr1;  	if (e != null) {  		BuildExpression (sb' GetPrecedence (expr)' e);  		sb.Append (expr.Operator == SqlQuery.Predicate.Operator.Equal ? " IS NULL" : " IS NOT NULL");  		return;  	}  	break;  }  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,BuildPredicate,The following switch statement is missing a default case: switch (expr.Operator) {  case SqlQuery.Predicate.Operator.Equal:  	sb.Append (" = ");  	break;  case SqlQuery.Predicate.Operator.NotEqual:  	sb.Append (" <> ");  	break;  case SqlQuery.Predicate.Operator.Greater:  	sb.Append (" > ");  	break;  case SqlQuery.Predicate.Operator.GreaterOrEqual:  	sb.Append (" >= ");  	break;  case SqlQuery.Predicate.Operator.NotGreater:  	sb.Append (" !> ");  	break;  case SqlQuery.Predicate.Operator.Less:  	sb.Append (" < ");  	break;  case SqlQuery.Predicate.Operator.LessOrEqual:  	sb.Append (" <= ");  	break;  case SqlQuery.Predicate.Operator.NotLess:  	sb.Append (" !< ");  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,GetUnderlayingField,The following switch statement is missing a default case: switch (expr.ElementType) {  case QueryElementType.SqlField:  	return (SqlField)expr;  case QueryElementType.Column:  	return GetUnderlayingField (((SqlQuery.Column)expr).Expression);  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,IsDateDataType,The following switch statement is missing a default case: switch (expr.ElementType) {  case QueryElementType.SqlDataType:  	return ((SqlDataType)expr).SqlDbType == SqlDbType.Date;  case QueryElementType.SqlExpression:  	return ((SqlExpression)expr).Expr == dateName;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,IsTimeDataType,The following switch statement is missing a default case: switch (expr.ElementType) {  case QueryElementType.SqlDataType:  	return ((SqlDataType)expr).SqlDbType == SqlDbType.Time;  case QueryElementType.SqlExpression:  	return ((SqlExpression)expr).Expr == "Time";  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,IsBooleanParameter,The following switch statement is missing a default case: switch (expr.ElementType) {  case QueryElementType.SearchCondition:  	return true;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,CheckAliases,The following switch statement is missing a default case: switch (e.ElementType) {  case QueryElementType.SqlField:  	((SqlField)e).Alias = SetAlias (((SqlField)e).Alias' maxLen);  	break;  case QueryElementType.SqlParameter:  	((SqlParameter)e).Name = SetAlias (((SqlParameter)e).Name' maxLen);  	break;  case QueryElementType.SqlTable:  	((SqlTable)e).Alias = SetAlias (((SqlTable)e).Alias' maxLen);  	break;  case QueryElementType.Join:  	((Join)e).Alias = SetAlias (((Join)e).Alias' maxLen);  	break;  case QueryElementType.Column:  	((SqlQuery.Column)e).Alias = SetAlias (((SqlQuery.Column)e).Alias' maxLen);  	break;  case QueryElementType.TableSource:  	((SqlQuery.TableSource)e).Alias = SetAlias (((SqlQuery.TableSource)e).Alias' maxLen);  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be1.Operation) {  case "+": {  	var value = (int)be1v2.Value + (int)v2.Value;  	var oper = be1.Operation;  	if (value < 0) {  		value = -value;  		oper = "-";  	}  	return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  }  case "-": {  	var value = (int)be1v2.Value - (int)v2.Value;  	var oper = be1.Operation;  	if (value < 0) {  		value = -value;  		oper = "+";  	}  	return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  }  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be1.Operation) {  case "+": {  	var value = (int)be1v2.Value - (int)v2.Value;  	var oper = be1.Operation;  	if (value < 0) {  		value = -value;  		oper = "-";  	}  	return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  }  case "-": {  	var value = (int)be1v2.Value + (int)v2.Value;  	var oper = be1.Operation;  	if (value < 0) {  		value = -value;  		oper = "+";  	}  	return new SqlBinaryExpression (be.SystemType' be1.Expr1' oper' new SqlValue (value)' be.Precedence);  }  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name) {  case "ConvertToCaseCompareTo":  	return ConvertExpression (new SqlFunction (func.SystemType' "CASE"' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Greater.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (1)' new SqlQuery.SearchCondition ().Expr (func.Parameters [0]).Equal.Expr (func.Parameters [1]).ToExpr ()' new SqlValue (0)' new SqlValue (-1)));  case "$Convert$":  	return ConvertConvertion (func);  case "Average":  	return new SqlFunction (func.SystemType' "Avg"' func.Parameters);  case "Max":  case "Min": {  	if (func.SystemType == typeof(bool) || func.SystemType == typeof(bool?)) {  		return new SqlFunction (typeof(int)' func.Name' new SqlFunction (func.SystemType' "CASE"' func.Parameters [0]' new SqlValue (1)' new SqlValue (0)));  	}  	break;  }  case "CASE":  	{  		var parms = func.Parameters;  		var len = parms.Length;  		for (var i = 0; i < parms.Length - 1; i += 2) {  			var value = parms [i] as SqlValue;  			if (value != null) {  				if ((bool)value.Value == false) {  					var newParms = new ISqlExpression[parms.Length - 2];  					if (i != 0)  						Array.Copy (parms' 0' newParms' 0' i);  					Array.Copy (parms' i + 2' newParms' i' parms.Length - i - 2);  					parms = newParms;  					i -= 2;  				} else {  					var newParms = new ISqlExpression[i + 1];  					if (i != 0)  						Array.Copy (parms' 0' newParms' 0' i);  					newParms [i] = parms [i + 1];  					parms = newParms;  					break;  				}  			}  		}  		if (parms.Length == 1)  			return parms [0];  		if (parms.Length != len)  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  	}  	break;  case "Convert":  	{  		var from = func.Parameters [1] as SqlFunction;  		var typef = TypeHelper.GetUnderlyingType (func.SystemType);  		if (from != null && from.Name == "Convert" && TypeHelper.GetUnderlyingType (from.Parameters [1].SystemType) == typef)  			return from.Parameters [1];  		var fe = func.Parameters [1] as SqlExpression;  		if (fe != null && fe.Expr == "Cast({0} as {1})" && TypeHelper.GetUnderlyingType (fe.Parameters [0].SystemType) == typef)  			return fe.Parameters [0];  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertPredicate,The following switch statement is missing a default case: switch (predicate.ElementType) {  case QueryElementType.ExprExprPredicate:  	{  		var expr = (SqlQuery.Predicate.ExprExpr)predicate;  		if (expr.Operator == SqlQuery.Predicate.Operator.Equal && expr.Expr1 is SqlValue && expr.Expr2 is SqlValue) {  			var value = Equals (((SqlValue)expr.Expr1).Value' ((SqlValue)expr.Expr2).Value);  			return new SqlQuery.Predicate.Expr (new SqlValue (value)' Precedence.Comparison);  		}  		switch (expr.Operator) {  		case SqlQuery.Predicate.Operator.Equal:  		case SqlQuery.Predicate.Operator.NotEqual:  		case SqlQuery.Predicate.Operator.Greater:  		case SqlQuery.Predicate.Operator.GreaterOrEqual:  		case SqlQuery.Predicate.Operator.Less:  		case SqlQuery.Predicate.Operator.LessOrEqual:  			predicate = OptimizeCase (expr);  			break;  		}  		if (predicate is SqlQuery.Predicate.ExprExpr) {  			expr = (SqlQuery.Predicate.ExprExpr)predicate;  			switch (expr.Operator) {  			case SqlQuery.Predicate.Operator.Equal:  			case SqlQuery.Predicate.Operator.NotEqual:  				var expr1 = expr.Expr1;  				var expr2 = expr.Expr2;  				if (expr1.CanBeNull () && expr2.CanBeNull ()) {  					if (expr1 is SqlParameter || expr2 is SqlParameter)  						SqlQuery.IsParameterDependent = true;  					else if (expr1 is SqlQuery.Column || expr1 is SqlField)  						if (expr2 is SqlQuery.Column || expr2 is SqlField)  							predicate = ConvertEqualPredicate (expr);  				}  				break;  			}  		}  	}  	break;  case QueryElementType.NotExprPredicate:  	{  		var expr = (SqlQuery.Predicate.NotExpr)predicate;  		if (expr.IsNot && expr.Expr1 is SqlQuery.SearchCondition) {  			var sc = (SqlQuery.SearchCondition)expr.Expr1;  			if (sc.Conditions.Count == 1) {  				var cond = sc.Conditions [0];  				if (cond.IsNot)  					return cond.Predicate;  				if (cond.Predicate is SqlQuery.Predicate.ExprExpr) {  					var ee = (SqlQuery.Predicate.ExprExpr)cond.Predicate;  					if (ee.Operator == SqlQuery.Predicate.Operator.Equal)  						return new SqlQuery.Predicate.ExprExpr (ee.Expr1' SqlQuery.Predicate.Operator.NotEqual' ee.Expr2);  					if (ee.Operator == SqlQuery.Predicate.Operator.NotEqual)  						return new SqlQuery.Predicate.ExprExpr (ee.Expr1' SqlQuery.Predicate.Operator.Equal' ee.Expr2);  				}  			}  		}  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertPredicate,The following switch statement is missing a default case: switch (expr.Operator) {  case SqlQuery.Predicate.Operator.Equal:  case SqlQuery.Predicate.Operator.NotEqual:  case SqlQuery.Predicate.Operator.Greater:  case SqlQuery.Predicate.Operator.GreaterOrEqual:  case SqlQuery.Predicate.Operator.Less:  case SqlQuery.Predicate.Operator.LessOrEqual:  	predicate = OptimizeCase (expr);  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,ConvertPredicate,The following switch statement is missing a default case: switch (expr.Operator) {  case SqlQuery.Predicate.Operator.Equal:  case SqlQuery.Predicate.Operator.NotEqual:  	var expr1 = expr.Expr1;  	var expr2 = expr.Expr2;  	if (expr1.CanBeNull () && expr2.CanBeNull ()) {  		if (expr1 is SqlParameter || expr2 is SqlParameter)  			SqlQuery.IsParameterDependent = true;  		else if (expr1 is SqlQuery.Column || expr1 is SqlField)  			if (expr2 is SqlQuery.Column || expr2 is SqlField)  				predicate = ConvertEqualPredicate (expr);  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,Compare,The following switch statement is missing a default case: switch (op) {  case SqlQuery.Predicate.Operator.Equal:  	return v1 == v2;  case SqlQuery.Predicate.Operator.NotEqual:  	return v1 != v2;  case SqlQuery.Predicate.Operator.Greater:  	return v1 > v2;  case SqlQuery.Predicate.Operator.NotLess:  case SqlQuery.Predicate.Operator.GreaterOrEqual:  	return v1 >= v2;  case SqlQuery.Predicate.Operator.Less:  	return v1 < v2;  case SqlQuery.Predicate.Operator.NotGreater:  case SqlQuery.Predicate.Operator.LessOrEqual:  	return v1 <= v2;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveCountSubQuery,The following switch statement is missing a default case: switch (e.ElementType) {  case QueryElementType.SqlField:  	return !allTables.Contains (((SqlField)e).Table);  case QueryElementType.Column:  	return !allTables.Contains (((SqlQuery.Column)e).Parent);  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveCountSubQuery,The following switch statement is missing a default case: switch (e.ElementType) {  case QueryElementType.SqlField:  	if (replaced.TryGetValue (e' out ne))  		return ne;  	if (levelTables.Contains (((SqlField)e).Table)) {  		subQuery.GroupBy.Expr ((SqlField)e);  		ne = subQuery.Select.Columns [subQuery.Select.Add ((SqlField)e)];  		break;  	}  	break;  case QueryElementType.Column:  	if (replaced.TryGetValue (e' out ne))  		return ne;  	if (levelTables.Contains (((SqlQuery.Column)e).Parent)) {  		subQuery.GroupBy.Expr ((SqlQuery.Column)e);  		ne = subQuery.Select.Columns [subQuery.Select.Add ((SqlQuery.Column)e)];  		break;  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveSubQueryColumn,The following switch statement is missing a default case: switch (e.ElementType) {  case QueryElementType.SqlField:  	return !allTables.Contains (((SqlField)e).Table);  case QueryElementType.Column:  	return !allTables.Contains (((SqlQuery.Column)e).Parent);  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveSubQueryColumn,The following switch statement is missing a default case: switch (((SqlFunction)subCol.Expression).Name) {  case "Min":  case "Max":  case "Sum":  case "Average":  	isAggregated = true;  	break;  case "Count":  	isAggregated = true;  	isCount = true;  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,BasicSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\BasicSqlProvider.cs,MoveSubQueryColumn,The following switch statement is missing a default case: switch (e.ElementType) {  case QueryElementType.SqlField:  	if (replaced.TryGetValue (e' out ne))  		return ne;  	if (levelTables.Contains (((SqlField)e).Table)) {  		if (isAggregated)  			subQuery.GroupBy.Expr ((SqlField)e);  		ne = subQuery.Select.Columns [subQuery.Select.Add ((SqlField)e)];  		break;  	}  	break;  case QueryElementType.Column:  	if (replaced.TryGetValue (e' out ne))  		return ne;  	if (levelTables.Contains (((SqlQuery.Column)e).Parent)) {  		if (isAggregated)  			subQuery.GroupBy.Expr ((SqlQuery.Column)e);  		ne = subQuery.Select.Columns [subQuery.Select.Add ((SqlQuery.Column)e)];  		break;  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation [0]) {  case '%':  	return new SqlBinaryExpression (be.SystemType' be.Expr1' "MOD"' be.Expr2' Precedence.Additive - 1);  case '&':  case '|':  case '^':  	throw new SqlException ("Operator '{0}' is not supported by the {1}."' be.Operation' GetType ().Name);  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,AccessSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\AccessSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.NameToQueryParameter:  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter:  	return "@" + value.ToString ().Replace (" "' string.Empty);  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTableAlias:  	{  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '[')  			return value;  	}  	return "[" + value + "]";  case ConvertType.NameToDatabase:  case ConvertType.NameToOwner:  case ConvertType.NameToQueryTable:  	{  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '[')  			return value;  		if (name.IndexOf ('.') > 0)  			value = string.Join ("].["' name.Split ('.'));  	}  	return "[" + value + "]";  case ConvertType.SprocParameterToName:  	if (value != null) {  		var str = value.ToString ();  		return str.Length > 0 && str [0] == '@' ? str.Substring (1) : str;  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSql2005SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSql2005SqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  case TypeCode.DateTime:  	if (func.Name == "Convert") {  		var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  		if (IsTimeDataType (func.Parameters [0])) {  			if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  				return new SqlExpression (func.SystemType' "Cast(Convert(Char' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlExpression (func.SystemType' "Convert(Char' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  		}  		if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Datetime"))  				return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  		}  		if (func.Parameters.Length == 2 && func.Parameters [0] is SqlDataType && func.Parameters [0] == SqlDataType.DateTime)  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' new SqlValue (120));  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name) {  case "CharIndex":  	if (func.Parameters.Length == 3)  		return Add<int> (ConvertExpression (new SqlFunction (func.SystemType' "CharIndex"' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' new SqlFunction (typeof(int)' "Len"' func.Parameters [1])))))' Sub (func.Parameters [2]' 1));  	break;  case "Stuff":  	if (func.Parameters [3] is SqlValue) {  		var value = (SqlValue)func.Parameters [3];  		if (value.Value is string && string.IsNullOrEmpty ((string)value.Value))  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' func.Parameters [1]' func.Parameters [1]' new SqlValue (null));  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,SybaseSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SybaseSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.NameToQueryParameter:  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter: {  	var name = "@" + value.ToString ().Replace (" "' string.Empty);  	if (name.Length > 27)  		name = name.Substring (0' 27);  	return name;  }  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTableAlias:  	{  		var name = value.ToString ();  		if (name.Length > 28 || name.Length > 0 && name [0] == '[')  			return value;  	}  	return "[" + value + "]";  case ConvertType.NameToDatabase:  case ConvertType.NameToOwner:  case ConvertType.NameToQueryTable:  	{  		var name = value.ToString ();  		if (name.Length > 28 || name.Length > 0 && (name [0] == '[' || name [0] == '#'))  			return value;  		if (name.IndexOf ('.') > 0)  			value = string.Join ("].["' name.Split ('.'));  	}  	return "[" + value + "]";  case ConvertType.SprocParameterToName:  	if (value != null) {  		var str = value.ToString ();  		return str.Length > 0 && str [0] == '@' ? str.Substring (1) : str;  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (expr.ElementType) {  case QueryElementType.SqlBinaryExpression: {  	var be = (SqlBinaryExpression)expr;  	switch (be.Operation) {  	case "%": {  		var type1 = TypeHelper.GetUnderlyingType (be.Expr1.SystemType);  		if (type1 == typeof(double) || type1 == typeof(float)) {  			return new SqlBinaryExpression (be.Expr2.SystemType' new SqlFunction (typeof(int)' "Convert"' SqlDataType.Int32' be.Expr1)' be.Operation' be.Expr2);  		}  		break;  	}  	}  	break;  }  case QueryElementType.SqlFunction: {  	var func = (SqlFunction)expr;  	switch (func.Name) {  	case "Convert": {  		if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(ulong) && TypeHelper.IsFloatType (func.Parameters [1].SystemType))  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' new SqlFunction (func.SystemType' "Floor"' func.Parameters [1]));  		break;  	}  	}  	break;  }  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation) {  case "%": {  	var type1 = TypeHelper.GetUnderlyingType (be.Expr1.SystemType);  	if (type1 == typeof(double) || type1 == typeof(float)) {  		return new SqlBinaryExpression (be.Expr2.SystemType' new SqlFunction (typeof(int)' "Convert"' SqlDataType.Int32' be.Expr1)' be.Operation' be.Expr2);  	}  	break;  }  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name) {  case "Convert": {  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(ulong) && TypeHelper.IsFloatType (func.Parameters [1].SystemType))  		return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' new SqlFunction (func.SystemType' "Floor"' func.Parameters [1]));  	break;  }  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,MsSqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MsSqlSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.NameToQueryParameter:  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter:  	return "@" + value.ToString ().Replace (" "' string.Empty);  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTableAlias:  	{  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '[')  			return value;  	}  	return "[" + value + "]";  case ConvertType.NameToDatabase:  case ConvertType.NameToOwner:  case ConvertType.NameToQueryTable:  	{  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '[')  			return value;  		if (name.IndexOf ('.') > 0)  			value = string.Join ("].["' name.Split ('.'));  	}  	return "[" + value + "]";  case ConvertType.SprocParameterToName:  	if (value != null) {  		var str = value.ToString ();  		return str.Length > 0 && str [0] == '@' ? str.Substring (1) : str;  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation) {  case "+":  	if (be.SystemType == typeof(string)) {  		if (be.Expr1 is SqlFunction) {  			var func = (SqlFunction)be.Expr1;  			if (func.Name == "Concat") {  				var list = new List<ISqlExpression> (func.Parameters) {  					be.Expr2  				};  				return new SqlFunction (be.SystemType' "Concat"' list.ToArray ());  			}  		}  		return new SqlFunction (be.SystemType' "Concat"' be.Expr1' be.Expr2);  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name) {  case "Convert":  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if ((ftype == typeof(double) || ftype == typeof(float)) && TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(decimal))  		return func.Parameters [1];  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,MySqlSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\MySqlSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.NameToQueryParameter:  	return ParameterSymbol + value.ToString ().Replace (" "' string.Empty);  case ConvertType.NameToCommandParameter:  	return ParameterSymbol + CommandParameterPrefix + value.ToString ().Replace (" "' string.Empty);  case ConvertType.NameToSprocParameter: {  	var valueStr = value.ToString ().Replace (" "' string.Empty);  	if (string.IsNullOrEmpty (valueStr))  		throw new ArgumentException ("Argument 'value' must represent parameter name.");  	if (valueStr [0] == ParameterSymbol)  		valueStr = valueStr.Substring (1);  	if (valueStr.StartsWith (SprocParameterPrefix' StringComparison.Ordinal))  		valueStr = valueStr.Substring (SprocParameterPrefix.Length);  	return ParameterSymbol + SprocParameterPrefix + valueStr;  }  case ConvertType.SprocParameterToName: {  	var str = value.ToString ();  	str = (str.Length > 0 && (str [0] == ParameterSymbol || (TryConvertParameterSymbol && ConvertParameterSymbols.Contains (str [0])))) ? str.Substring (1) : str;  	if (!string.IsNullOrEmpty (SprocParameterPrefix) && str.StartsWith (SprocParameterPrefix))  		str = str.Substring (SprocParameterPrefix.Length);  	return str;  }  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTableAlias:  	{  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '`')  			return value;  	}  	return "`" + value + "`";  case ConvertType.NameToDatabase:  case ConvertType.NameToOwner:  case ConvertType.NameToQueryTable:  	{  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '`')  			return value;  		if (name.IndexOf ('.') > 0)  			value = string.Join ("`.`"' name.Split ('.'));  	}  	return "`" + value + "`";  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation) {  case "%":  	return TypeHelper.IsIntegerType (be.Expr1.SystemType) ? be : new SqlBinaryExpression (typeof(int)' new SqlFunction (typeof(int)' "Convert"' SqlDataType.Int32' be.Expr1)' be.Operation' be.Expr2' be.Precedence);  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name) {  case "Convert":  	switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  	case TypeCode.UInt64:  		if (TypeHelper.IsFloatType (func.Parameters [1].SystemType))  			return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' new SqlFunction (func.SystemType' "Floor"' func.Parameters [1]));  		break;  	case TypeCode.DateTime:  		var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  		if (IsTimeDataType (func.Parameters [0])) {  			if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  				return new SqlExpression (func.SystemType' "Cast(Convert(NChar' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlExpression (func.SystemType' "Convert(NChar' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  		}  		if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  			if (IsDateDataType (func.Parameters [0]' "Datetime"))  				return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  		}  		break;  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (Type.GetTypeCode (TypeHelper.GetUnderlyingType (func.SystemType))) {  case TypeCode.UInt64:  	if (TypeHelper.IsFloatType (func.Parameters [1].SystemType))  		return new SqlFunction (func.SystemType' func.Name' func.Precedence' func.Parameters [0]' new SqlFunction (func.SystemType' "Floor"' func.Parameters [1]));  	break;  case TypeCode.DateTime:  	var type1 = TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType);  	if (IsTimeDataType (func.Parameters [0])) {  		if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset))  			return new SqlExpression (func.SystemType' "Cast(Convert(NChar' {0}' 114) as DateTime)"' Precedence.Primary' func.Parameters [1]);  		if (func.Parameters [1].SystemType == typeof(string))  			return func.Parameters [1];  		return new SqlExpression (func.SystemType' "Convert(NChar' {0}' 114)"' Precedence.Primary' func.Parameters [1]);  	}  	if (type1 == typeof(DateTime) || type1 == typeof(DateTimeOffset)) {  		if (IsDateDataType (func.Parameters [0]' "Datetime"))  			return new SqlExpression (func.SystemType' "Cast(Floor(Cast({0} as Float)) as DateTime)"' Precedence.Primary' func.Parameters [1]);  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,Finalize,The following switch statement is missing a default case: switch (sqlQuery.QueryType) {  case QueryType.Delete:  	sqlQuery = GetAlternativeDelete (sqlQuery);  	sqlQuery.From.Tables [0].Alias = "$";  	break;  case QueryType.Update:  	sqlQuery = GetAlternativeUpdate (sqlQuery);  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,SqlCeSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SqlCeSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.NameToQueryParameter:  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter:  	return "@" + value.ToString ().Replace (" "' string.Empty);  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTableAlias:  	{  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '[')  			return value;  	}  	return "[" + value + "]";  case ConvertType.NameToDatabase:  case ConvertType.NameToOwner:  case ConvertType.NameToQueryTable:  	{  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '[')  			return value;  		if (name.IndexOf ('.') > 0)  			value = string.Join ("].["' name.Split ('.'));  	}  	return "[" + value + "]";  case ConvertType.SprocParameterToName:  	if (value != null) {  		var str = value.ToString ();  		return str.Length > 0 && str [0] == '@' ? str.Substring (1) : str;  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation) {  case "+":  	return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  case "^":  	// (a + b) - (a & b) * 2  	return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlBinaryExpression (be.SystemType' be.Expr1' "&"' be.Expr2)' 2)' be.SystemType);  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name) {  case "Space":  	return new SqlFunction (func.SystemType' "PadR"' new SqlValue (" ")' func.Parameters [0]);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsDateDataType (func.Parameters [0]' "Date"))  			return new SqlFunction (func.SystemType' "Date"' func.Parameters [1]);  		return new SqlFunction (func.SystemType' "DateTime"' func.Parameters [1]);  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' func.Parameters [1]' func.Parameters [0]);  }  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,Finalize,The following switch statement is missing a default case: switch (sqlQuery.QueryType) {  case QueryType.Delete:  	sqlQuery = GetAlternativeDelete (base.Finalize (sqlQuery));  	sqlQuery.From.Tables [0].Alias = "$";  	break;  case QueryType.Update:  	sqlQuery = GetAlternativeUpdate (sqlQuery);  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,SQLiteSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\SQLiteSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.NameToQueryParameter:  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter:  	return "@" + value.ToString ().Replace (" "' string.Empty);  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTableAlias:  	{  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '[')  			return value;  	}  	return "[" + value + "]";  case ConvertType.NameToDatabase:  case ConvertType.NameToOwner:  case ConvertType.NameToQueryTable:  	{  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '[')  			return value;  		if (name.IndexOf ('.') > 0)  			value = string.Join ("].["' name.Split ('.'));  	}  	return "[" + value + "]";  case ConvertType.SprocParameterToName: {  	var name = (string)value;  	return name.Length > 0 && name [0] == '@' ? name.Substring (1) : name;  }  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation) {  case "%":  	return new SqlFunction (be.SystemType' "Mod"' be.Expr1' be.Expr2);  case "&":  	return new SqlFunction (be.SystemType' "Bin_And"' be.Expr1' be.Expr2);  case "|":  	return new SqlFunction (be.SystemType' "Bin_Or"' be.Expr1' be.Expr2);  case "^":  	return new SqlFunction (be.SystemType' "Bin_Xor"' be.Expr1' be.Expr2);  case "+":  	return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		ISqlExpression ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  case "DateAdd":  	switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  	case Sql.DateParts.Quarter:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  	case Sql.DateParts.DayOfYear:  	case Sql.DateParts.WeekDay:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  	case Sql.DateParts.Week:  		return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch ((Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  case Sql.DateParts.Quarter:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Month)' Mul (func.Parameters [1]' 3)' func.Parameters [2]);  case Sql.DateParts.DayOfYear:  case Sql.DateParts.WeekDay:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' func.Parameters [1]' func.Parameters [2]);  case Sql.DateParts.Week:  	return new SqlFunction (func.SystemType' func.Name' new SqlValue (Sql.DateParts.Day)' Mul (func.Parameters [1]' 7)' func.Parameters [2]);  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,FirebirdSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\FirebirdSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryTable:  	if (QuoteIdentifiers) {  		string name = value.ToString ();  		if (name.Length > 0 && name [0] == '"')  			return value;  		return '"' + name + '"';  	}  	break;  case ConvertType.NameToQueryParameter:  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter:  	return "@" + value.ToString ().Replace (" "' string.Empty);  case ConvertType.SprocParameterToName:  	if (value != null) {  		string str = value.ToString ();  		return str.Length > 0 && str [0] == '@' ? str.Substring (1) : str;  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation) {  case "^":  	return new SqlBinaryExpression (be.SystemType' be.Expr1' "#"' be.Expr2);  case "+":  	return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' func.Parameters [1]) : Add<int> (new SqlExpression (func.SystemType' "Position({0} in {1})"' Precedence.Primary' func.Parameters [0]' ConvertExpression (new SqlFunction (typeof(string)' "Substring"' func.Parameters [1]' func.Parameters [2]' Sub<int> (ConvertExpression (new SqlFunction (typeof(int)' "Length"' func.Parameters [1]))' func.Parameters [2]))))' Sub (func.Parameters [2]' 1));  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,PostgreSQLSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\PostgreSQLSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTable:  case ConvertType.NameToQueryTableAlias:  case ConvertType.NameToOwner:  	if (QuoteIdentifiers) {  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '"')  			return value;  		return '"' + name + '"';  	}  	break;  case ConvertType.NameToQueryParameter:  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter:  	return ":" + value.ToString ().Replace (" "' string.Empty);  case ConvertType.SprocParameterToName:  	if (value != null) {  		var str = value.ToString ();  		return (str.Length > 0 && str [0] == ':') ? str.Substring (1) : str;  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation) {  case "%":  	return new SqlFunction (be.SystemType' "MOD"' be.Expr1' be.Expr2);  case "&":  	return new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2);  case "|":  	// (a + b) - BITAND(a' b)  	return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' be.SystemType);  case "^":  	// (a + b) - BITAND(a' b) * 2  	return Sub (Add (be.Expr1' be.Expr2' be.SystemType)' Mul (new SqlFunction (be.SystemType' "BITAND"' be.Expr1' be.Expr2)' 2)' be.SystemType);  case "+":  	return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name) {  case "Coalesce":  	return new SqlFunction (func.SystemType' "Nvl"' func.Parameters);  case "Convert": {  	var ftype = TypeHelper.GetUnderlyingType (func.SystemType);  	if (ftype == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (ftype == typeof(DateTime) || ftype == typeof(DateTimeOffset)) {  		if (IsTimeDataType (func.Parameters [0])) {  			if (func.Parameters [1].SystemType == typeof(string))  				return func.Parameters [1];  			return new SqlFunction (func.SystemType' "To_Char"' func.Parameters [1]' new SqlValue ("HH24:MI:SS"));  		}  		if (TypeHelper.GetUnderlyingType (func.Parameters [1].SystemType) == typeof(DateTime) && IsDateDataType (func.Parameters [0]' "Date")) {  			return new SqlFunction (func.SystemType' "Trunc"' func.Parameters [1]' new SqlValue ("DD"));  		}  		return new SqlFunction (func.SystemType' "To_Timestamp"' func.Parameters [1]' new SqlValue ("YYYY-MM-DD HH24:MI:SS"));  	}  	return new SqlExpression (func.SystemType' "Cast({0} as {1})"' Precedence.Primary' FloorBeforeConvert (func)' func.Parameters [0]);  }  case "ContainsExactly":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "Contains"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "CharIndex":  	return func.Parameters.Length == 2 ? new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]) : new SqlFunction (func.SystemType' "InStr"' func.Parameters [1]' func.Parameters [0]' func.Parameters [2]);  case "AddYear":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 12));  case "AddQuarter":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' Mul (func.Parameters [1]' 3));  case "AddMonth":  	return new SqlFunction (func.SystemType' "Add_Months"' func.Parameters [0]' func.Parameters [1]);  case "AddDayOfYear":  case "AddWeekDay":  case "AddDay":  	return Add<DateTime> (func.Parameters [0]' func.Parameters [1]);  case "AddWeek":  	return Add<DateTime> (func.Parameters [0]' Mul (func.Parameters [1]' 7));  case "AddHour":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 24));  case "AddMinute":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 24));  case "AddSecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 60 * 60 * 24));  case "AddMillisecond":  	return Add<DateTime> (func.Parameters [0]' Div (func.Parameters [1]' 1000 * 60 * 60 * 24));  case "Avg":  	return new SqlFunction (func.SystemType' "Round"' new SqlFunction (func.SystemType' "AVG"' func.Parameters [0])' new SqlValue (27));  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,OracleSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\OracleSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.NameToQueryParameter:  	string name = value.ToString ().Replace (" "' string.Empty);  	if (name.Length <= 28)  		return ":" + name;  	int hashCode = name.GetHashCode ();  	return string.Format (":P{0}{1}_"' hashCode < 0 ? "m" : ""' Math.Abs (hashCode));  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation) {  case "%": {  	var expr1 = !TypeHelper.IsIntegerType (be.Expr1.SystemType) ? new SqlFunction (typeof(int)' "Int"' be.Expr1) : be.Expr1;  	return new SqlFunction (be.SystemType' "Mod"' expr1' be.Expr2);  }  case "&":  	return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  case "|":  	return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  case "^":  	return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  case "+":  	return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (func.Name) {  case "Convert":  	if (TypeHelper.GetUnderlyingType (func.SystemType) == typeof(bool)) {  		var ex = AlternativeConvertToBoolean (func' 1);  		if (ex != null)  			return ex;  	}  	if (func.Parameters [0] is SqlDataType) {  		var type = (SqlDataType)func.Parameters [0];  		if (type.Type == typeof(string) && func.Parameters [1].SystemType != typeof(string))  			return new SqlFunction (func.SystemType' "RTrim"' new SqlFunction (typeof(string)' "Char"' func.Parameters [1]));  		if (type.Length > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Length));  		if (type.Precision > 0)  			return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]' new SqlValue (type.Precision)' new SqlValue (type.Scale));  		return new SqlFunction (func.SystemType' type.SqlDbType.ToString ()' func.Parameters [1]);  	}  	if (func.Parameters [0] is SqlFunction) {  		var f = (SqlFunction)func.Parameters [0];  		return f.Name == "Char" ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]) : f.Parameters.Length == 1 ? new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]) : new SqlFunction (func.SystemType' f.Name' func.Parameters [1]' f.Parameters [0]' f.Parameters [1]);  	}  	{  		var e = (SqlExpression)func.Parameters [0];  		return new SqlFunction (func.SystemType' e.Expr' func.Parameters [1]);  	}  case "Millisecond":  	return Div (new SqlFunction (func.SystemType' "Microsecond"' func.Parameters)' 1000);  case "SmallDateTime":  case "DateTime":  case "DateTime2":  	return new SqlFunction (func.SystemType' "TimeStamp"' func.Parameters);  case "TinyInt":  	return new SqlFunction (func.SystemType' "SmallInt"' func.Parameters);  case "Money":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (19)' new SqlValue (4));  case "SmallMoney":  	return new SqlFunction (func.SystemType' "Decimal"' func.Parameters [0]' new SqlValue (10)' new SqlValue (4));  case "VarChar":  	if (TypeHelper.GetUnderlyingType (func.Parameters [0].SystemType) == typeof(decimal))  		return new SqlFunction (func.SystemType' "Char"' func.Parameters [0]);  	break;  case "NChar":  case "NVarChar":  	return new SqlFunction (func.SystemType' "Char"' func.Parameters);  case "DateDiff":  	{  		switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  		case Linq.Sql.DateParts.Day:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Hour:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Minute:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Second:  			return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		case Linq.Sql.DateParts.Millisecond:  			return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  		}  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch ((Linq.Sql.DateParts)((SqlValue)func.Parameters [0]).Value) {  case Linq.Sql.DateParts.Day:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 86400"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Hour:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 3600"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Minute:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) / 60"' Precedence.Multiplicative' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Second:  	return new SqlExpression (typeof(int)' "(Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  case Linq.Sql.DateParts.Millisecond:  	return new SqlExpression (typeof(int)' "((Days({0}) - Days({1})) * 86400 + (MIDNIGHT_SECONDS({0}) - MIDNIGHT_SECONDS({1}))) * 1000 + (MICROSECOND({0}) - MICROSECOND({1})) / 1000"' Precedence.Additive' func.Parameters [2]' func.Parameters [1]);  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,DB2SqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\DB2SqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.NameToQueryParameter:  	return "@" + value.ToString ().Replace (" "' string.Empty);  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter:  	return ":" + value.ToString ().Replace (" "' string.Empty);  case ConvertType.SprocParameterToName:  	if (value != null) {  		var str = value.ToString ();  		return str.Length > 0 && str [0] == ':' ? str.Substring (1) : str;  	}  	break;  case ConvertType.NameToQueryField:  case ConvertType.NameToQueryFieldAlias:  case ConvertType.NameToQueryTable:  case ConvertType.NameToQueryTableAlias:  	if (QuoteIdentifiers) {  		var name = value.ToString ();  		if (name.Length > 0 && name [0] == '"')  			return value;  		return '"' + name + '"';  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,ConvertExpression,The following switch statement is missing a default case: switch (be.Operation) {  case "%":  	return new SqlFunction (be.SystemType' "Mod"' be.Expr1' be.Expr2);  case "&":  	return new SqlFunction (be.SystemType' "BitAnd"' be.Expr1' be.Expr2);  case "|":  	return new SqlFunction (be.SystemType' "BitOr"' be.Expr1' be.Expr2);  case "^":  	return new SqlFunction (be.SystemType' "BitXor"' be.Expr1' be.Expr2);  case "+":  	return be.SystemType == typeof(string) ? new SqlBinaryExpression (be.SystemType' be.Expr1' "||"' be.Expr2' be.Precedence) : expr;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,Finalize,The following switch statement is missing a default case: switch (sqlQuery.QueryType) {  case QueryType.Delete:  	sqlQuery = GetAlternativeDelete (sqlQuery);  	sqlQuery.From.Tables [0].Alias = "$";  	break;  case QueryType.Update:  	sqlQuery = GetAlternativeUpdate (sqlQuery);  	break;  }  
Missing Default,BLToolkit.Data.Sql.SqlProvider,InformixSqlProvider,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlProvider\InformixSqlProvider.cs,Convert,The following switch statement is missing a default case: switch (convertType) {  case ConvertType.NameToQueryParameter:  	return "?";  case ConvertType.NameToCommandParameter:  case ConvertType.NameToSprocParameter:  	return ":" + value.ToString ().Replace (" "' string.Empty);  case ConvertType.SprocParameterToName:  	if (value != null) {  		var str = value.ToString ();  		return (str.Length > 0 && str [0] == ':') ? str.Substring (1) : str;  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,Find,The following switch statement is missing a default case: switch (element.ElementType) {  case QueryElementType.SqlFunction:  	return Find (((SqlFunction)element).Parameters' find);  case QueryElementType.SqlExpression:  	return Find (((SqlExpression)element).Parameters' find);  case QueryElementType.Join:  	return Find (((Join)element).JoinOns' find);  case QueryElementType.Column:  	return Find (((SqlQuery.Column)element).Expression' find);  case QueryElementType.SearchCondition:  	return Find (((SqlQuery.SearchCondition)element).Conditions' find);  case QueryElementType.Condition:  	return Find (((SqlQuery.Condition)element).Predicate' find);  case QueryElementType.ExprPredicate:  	return Find (((SqlQuery.Predicate.Expr)element).Expr1' find);  case QueryElementType.NotExprPredicate:  	return Find (((SqlQuery.Predicate.NotExpr)element).Expr1' find);  case QueryElementType.IsNullPredicate:  	return Find (((SqlQuery.Predicate.IsNull)element).Expr1' find);  case QueryElementType.FromClause:  	return Find (((SqlQuery.FromClause)element).Tables' find);  case QueryElementType.WhereClause:  	return Find (((SqlQuery.WhereClause)element).SearchCondition' find);  case QueryElementType.GroupByClause:  	return Find (((SqlQuery.GroupByClause)element).Items' find);  case QueryElementType.OrderByClause:  	return Find (((SqlQuery.OrderByClause)element).Items' find);  case QueryElementType.OrderByItem:  	return Find (((SqlQuery.OrderByItem)element).Expression' find);  case QueryElementType.Union:  	return Find (((SqlQuery.Union)element).SqlQuery' find);  case QueryElementType.FuncLikePredicate:  	return Find (((SqlQuery.Predicate.FuncLike)element).Function' find);  case QueryElementType.SqlBinaryExpression: {  	var bexpr = (SqlBinaryExpression)element;  	return Find (bexpr.Expr1' find) ?? Find (bexpr.Expr2' find);  }  case QueryElementType.SqlTable: {  	var table = (SqlTable)element;  	return Find (table.All' find) ?? Find (table.Fields.Values' find) ?? Find (table.Joins' find) ?? Find (table.TableArguments' find);  }  case QueryElementType.TableSource: {  	var table = (SqlQuery.TableSource)element;  	return Find (table.Source' find) ?? Find (table.Joins' find);  }  case QueryElementType.JoinedTable: {  	var join = (SqlQuery.JoinedTable)element;  	return Find (join.Table' find) ?? Find (join.Condition' find);  }  case QueryElementType.ExprExprPredicate: {  	var p = (SqlQuery.Predicate.ExprExpr)element;  	return Find (p.Expr1' find) ?? Find (p.Expr2' find);  }  case QueryElementType.LikePredicate: {  	var p = (SqlQuery.Predicate.Like)element;  	return Find (p.Expr1' find) ?? Find (p.Expr2' find) ?? Find (p.Escape' find);  }  case QueryElementType.BetweenPredicate: {  	var p = (SqlQuery.Predicate.Between)element;  	return Find (p.Expr1' find) ?? Find (p.Expr2' find) ?? Find (p.Expr3' find);  }  case QueryElementType.InSubQueryPredicate: {  	var p = (SqlQuery.Predicate.InSubQuery)element;  	return Find (p.Expr1' find) ?? Find (p.SubQuery' find);  }  case QueryElementType.InListPredicate: {  	var p = (SqlQuery.Predicate.InList)element;  	return Find (p.Expr1' find) ?? Find (p.Values' find);  }  case QueryElementType.SetExpression: {  	var s = (SqlQuery.SetExpression)element;  	return Find (s.Column' find) ?? Find (s.Expression' find);  }  case QueryElementType.InsertClause: {  	var sc = (SqlQuery.InsertClause)element;  	return Find (sc.Into' find) ?? Find (sc.Items' find);  }  case QueryElementType.UpdateClause: {  	var sc = (SqlQuery.UpdateClause)element;  	return Find (sc.Table' find) ?? Find (sc.Items' find) ?? Find (sc.Keys' find);  }  case QueryElementType.DeleteClause: {  	var sc = (SqlQuery.DeleteClause)element;  	return Find (sc.Table' find);  }  case QueryElementType.SelectClause: {  	var sc = (SqlQuery.SelectClause)element;  	return Find (sc.TakeValue' find) ?? Find (sc.SkipValue' find) ?? Find (sc.Columns' find);  }  case QueryElementType.SqlQuery: {  	var q = (SqlQuery)element;  	return Find (q.Select' find) ?? (q.IsInsert ? Find (q.Insert' find) : null) ?? (q.IsUpdate ? Find (q.Update' find) : null) ?? Find (q.From' find) ?? Find (q.Where' find) ?? Find (q.GroupBy' find) ?? Find (q.Having' find) ?? Find (q.OrderBy' find) ?? (q.HasUnion ? Find (q.Unions' find) : null);  }  }  
Missing Default,BLToolkit.Data.Sql,QueryVisitor,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\QueryVisitor.cs,ConvertInternal,The following switch statement is missing a default case: switch (element.ElementType) {  case QueryElementType.SqlFunction: {  	var func = (SqlFunction)element;  	var parms = Convert (func.Parameters' action);  	if (parms != null && !ReferenceEquals (parms' func.Parameters))  		newElement = new SqlFunction (func.SystemType' func.Name' func.Precedence' parms);  	break;  }  case QueryElementType.SqlExpression: {  	var expr = (SqlExpression)element;  	var parameter = Convert (expr.Parameters' action);  	if (parameter != null && !ReferenceEquals (parameter' expr.Parameters))  		newElement = new SqlExpression (expr.SystemType' expr.Expr' expr.Precedence' parameter);  	break;  }  case QueryElementType.SqlBinaryExpression: {  	var bexpr = (SqlBinaryExpression)element;  	var expr1 = (ISqlExpression)ConvertInternal (bexpr.Expr1' action);  	var expr2 = (ISqlExpression)ConvertInternal (bexpr.Expr2' action);  	if (expr1 != null && !ReferenceEquals (expr1' bexpr.Expr1) || expr2 != null && !ReferenceEquals (expr2' bexpr.Expr2))  		newElement = new SqlBinaryExpression (bexpr.SystemType' expr1 ?? bexpr.Expr1' bexpr.Operation' expr2 ?? bexpr.Expr2' bexpr.Precedence);  	break;  }  case QueryElementType.SqlTable: {  	var table = (SqlTable)element;  	var fields1 = ToArray (table.Fields);  	var fields2 = Convert (fields1' action' f => new SqlField (f));  	var joins = Convert (table.Joins' action' j => j.Clone ());  	var targs = table.TableArguments == null ? null : Convert (table.TableArguments' action);  	var fe = fields2 == null || ReferenceEquals (fields1' fields2);  	var je = joins == null || ReferenceEquals (table.Joins' joins);  	var ta = ReferenceEquals (table.TableArguments' targs);  	if (!fe || !je || !ta) {  		if (fe) {  			fields2 = fields1;  			for (var i = 0; i < fields2.Length; i++) {  				var field = fields2 [i];  				fields2 [i] = new SqlField (field);  				_visitedElements [field] = fields2 [i];  			}  		}  		newElement = new SqlTable (table' fields2' joins ?? table.Joins' targs ?? table.TableArguments);  		_visitedElements [((SqlTable)newElement).All] = table.All;  	}  	break;  }  case QueryElementType.Join: {  	var join = (Join)element;  	var ons = Convert (join.JoinOns' action);  	if (ons != null && !ReferenceEquals (join.JoinOns' ons))  		newElement = new Join (join.TableName' join.Alias' ons);  	break;  }  case QueryElementType.Column: {  	var col = (SqlQuery.Column)element;  	var expr = (ISqlExpression)ConvertInternal (col.Expression' action);  	IQueryElement parent;  	_visitedElements.TryGetValue (col.Parent' out parent);  	if (parent != null || expr != null && !ReferenceEquals (expr' col.Expression))  		newElement = new SqlQuery.Column (parent == null ? col.Parent : (SqlQuery)parent' expr ?? col.Expression' col._alias);  	break;  }  case QueryElementType.TableSource: {  	var table = (SqlQuery.TableSource)element;  	var source = (ISqlTableSource)ConvertInternal (table.Source' action);  	var joins = Convert (table.Joins' action);  	if (source != null && !ReferenceEquals (source' table.Source) || joins != null && !ReferenceEquals (table.Joins' joins))  		newElement = new SqlQuery.TableSource (source ?? table.Source' table._alias' joins ?? table.Joins);  	break;  }  case QueryElementType.JoinedTable: {  	var join = (SqlQuery.JoinedTable)element;  	var table = (SqlQuery.TableSource)ConvertInternal (join.Table' action);  	var cond = (SqlQuery.SearchCondition)ConvertInternal (join.Condition' action);  	if (table != null && !ReferenceEquals (table' join.Table) || cond != null && !ReferenceEquals (cond' join.Condition))  		newElement = new SqlQuery.JoinedTable (join.JoinType' table ?? join.Table' join.IsWeak' cond ?? join.Condition);  	break;  }  case QueryElementType.SearchCondition: {  	var sc = (SqlQuery.SearchCondition)element;  	var conds = Convert (sc.Conditions' action);  	if (conds != null && !ReferenceEquals (sc.Conditions' conds))  		newElement = new SqlQuery.SearchCondition (conds);  	break;  }  case QueryElementType.Condition: {  	var c = (SqlQuery.Condition)element;  	var p = (ISqlPredicate)ConvertInternal (c.Predicate' action);  	if (p != null && !ReferenceEquals (c.Predicate' p))  		newElement = new SqlQuery.Condition (c.IsNot' p' c.IsOr);  	break;  }  case QueryElementType.ExprPredicate: {  	var p = (SqlQuery.Predicate.Expr)element;  	var e = (ISqlExpression)ConvertInternal (p.Expr1' action);  	if (e != null && !ReferenceEquals (p.Expr1' e))  		newElement = new SqlQuery.Predicate.Expr (e' p.Precedence);  	break;  }  case QueryElementType.NotExprPredicate: {  	var p = (SqlQuery.Predicate.NotExpr)element;  	var e = (ISqlExpression)ConvertInternal (p.Expr1' action);  	if (e != null && !ReferenceEquals (p.Expr1' e))  		newElement = new SqlQuery.Predicate.NotExpr (e' p.IsNot' p.Precedence);  	break;  }  case QueryElementType.ExprExprPredicate: {  	var p = (SqlQuery.Predicate.ExprExpr)element;  	var e1 = (ISqlExpression)ConvertInternal (p.Expr1' action);  	var e2 = (ISqlExpression)ConvertInternal (p.Expr2' action);  	if (e1 != null && !ReferenceEquals (p.Expr1' e1) || e2 != null && !ReferenceEquals (p.Expr2' e2))  		newElement = new SqlQuery.Predicate.ExprExpr (e1 ?? p.Expr1' p.Operator' e2 ?? p.Expr2);  	break;  }  case QueryElementType.LikePredicate: {  	var p = (SqlQuery.Predicate.Like)element;  	var e1 = (ISqlExpression)ConvertInternal (p.Expr1' action);  	var e2 = (ISqlExpression)ConvertInternal (p.Expr2' action);  	var es = (ISqlExpression)ConvertInternal (p.Escape' action);  	if (e1 != null && !ReferenceEquals (p.Expr1' e1) || e2 != null && !ReferenceEquals (p.Expr2' e2) || es != null && !ReferenceEquals (p.Escape' es))  		newElement = new SqlQuery.Predicate.Like (e1 ?? p.Expr1' p.IsNot' e2 ?? p.Expr2' es ?? p.Escape);  	break;  }  case QueryElementType.BetweenPredicate: {  	var p = (SqlQuery.Predicate.Between)element;  	var e1 = (ISqlExpression)ConvertInternal (p.Expr1' action);  	var e2 = (ISqlExpression)ConvertInternal (p.Expr2' action);  	var e3 = (ISqlExpression)ConvertInternal (p.Expr3' action);  	if (e1 != null && !ReferenceEquals (p.Expr1' e1) || e2 != null && !ReferenceEquals (p.Expr2' e2) || e3 != null && !ReferenceEquals (p.Expr3' e3))  		newElement = new SqlQuery.Predicate.Between (e1 ?? p.Expr1' p.IsNot' e2 ?? p.Expr2' e3 ?? p.Expr3);  	break;  }  case QueryElementType.IsNullPredicate: {  	var p = (SqlQuery.Predicate.IsNull)element;  	var e = (ISqlExpression)ConvertInternal (p.Expr1' action);  	if (e != null && !ReferenceEquals (p.Expr1' e))  		newElement = new SqlQuery.Predicate.IsNull (e' p.IsNot);  	break;  }  case QueryElementType.InSubQueryPredicate: {  	var p = (SqlQuery.Predicate.InSubQuery)element;  	var e = (ISqlExpression)ConvertInternal (p.Expr1' action);  	var q = (SqlQuery)ConvertInternal (p.SubQuery' action);  	if (e != null && !ReferenceEquals (p.Expr1' e) || q != null && !ReferenceEquals (p.SubQuery' q))  		newElement = new SqlQuery.Predicate.InSubQuery (e ?? p.Expr1' p.IsNot' q ?? p.SubQuery);  	break;  }  case QueryElementType.InListPredicate: {  	var p = (SqlQuery.Predicate.InList)element;  	var e = (ISqlExpression)ConvertInternal (p.Expr1' action);  	var v = Convert (p.Values' action);  	if (e != null && !ReferenceEquals (p.Expr1' e) || v != null && !ReferenceEquals (p.Values' v))  		newElement = new SqlQuery.Predicate.InList (e ?? p.Expr1' p.IsNot' v ?? p.Values);  	break;  }  case QueryElementType.FuncLikePredicate: {  	var p = (SqlQuery.Predicate.FuncLike)element;  	var f = (SqlFunction)ConvertInternal (p.Function' action);  	if (f != null && !ReferenceEquals (p.Function' f))  		newElement = new SqlQuery.Predicate.FuncLike (f);  	break;  }  case QueryElementType.SetExpression: {  	var s = (SqlQuery.SetExpression)element;  	var c = (ISqlExpression)ConvertInternal (s.Column' action);  	var e = (ISqlExpression)ConvertInternal (s.Expression' action);  	if (c != null && !ReferenceEquals (s.Column' c) || e != null && !ReferenceEquals (s.Expression' e))  		newElement = new SqlQuery.SetExpression (c ?? s.Column' e ?? s.Expression);  	break;  }  case QueryElementType.InsertClause: {  	var s = (SqlQuery.InsertClause)element;  	var t = s.Into != null ? (SqlTable)ConvertInternal (s.Into' action) : null;  	var i = Convert (s.Items' action);  	if (t != null && !ReferenceEquals (s.Into' t) || i != null && !ReferenceEquals (s.Items' i)) {  		var sc = new SqlQuery.InsertClause {  			Into = t ?? s.Into  		};  		sc.Items.AddRange (i ?? s.Items);  		sc.WithIdentity = s.WithIdentity;  		newElement = sc;  	}  	break;  }  case QueryElementType.UpdateClause: {  	var s = (SqlQuery.UpdateClause)element;  	var t = s.Table != null ? (SqlTable)ConvertInternal (s.Table' action) : null;  	var i = Convert (s.Items' action);  	var k = Convert (s.Keys' action);  	if (t != null && !ReferenceEquals (s.Table' t) || i != null && !ReferenceEquals (s.Items' i) || k != null && !ReferenceEquals (s.Keys' k)) {  		var sc = new SqlQuery.UpdateClause {  			Table = t ?? s.Table  		};  		sc.Items.AddRange (i ?? s.Items);  		sc.Keys.AddRange (k ?? s.Keys);  		newElement = sc;  	}  	break;  }  case QueryElementType.DeleteClause: {  	var s = (SqlQuery.DeleteClause)element;  	var t = s.Table != null ? (SqlTable)ConvertInternal (s.Table' action) : null;  	if (t != null && !ReferenceEquals (s.Table' t)) {  		newElement = new SqlQuery.DeleteClause {  			Table = t ?? s.Table  		};  	}  	break;  }  case QueryElementType.SelectClause: {  	var sc = (SqlQuery.SelectClause)element;  	var cols = Convert (sc.Columns' action);  	var take = (ISqlExpression)ConvertInternal (sc.TakeValue' action);  	var skip = (ISqlExpression)ConvertInternal (sc.SkipValue' action);  	IQueryElement parent;  	_visitedElements.TryGetValue (sc.SqlQuery' out parent);  	if (parent != null || cols != null && !ReferenceEquals (sc.Columns' cols) || take != null && !ReferenceEquals (sc.TakeValue' take) || skip != null && !ReferenceEquals (sc.SkipValue' skip)) {  		newElement = new SqlQuery.SelectClause (sc.IsDistinct' take ?? sc.TakeValue' skip ?? sc.SkipValue' cols ?? sc.Columns);  		((SqlQuery.SelectClause)newElement).SetSqlQuery ((SqlQuery)parent);  	}  	break;  }  case QueryElementType.FromClause: {  	var fc = (SqlQuery.FromClause)element;  	var ts = Convert (fc.Tables' action);  	IQueryElement parent;  	_visitedElements.TryGetValue (fc.SqlQuery' out parent);  	if (parent != null || ts != null && !ReferenceEquals (fc.Tables' ts)) {  		newElement = new SqlQuery.FromClause (ts ?? fc.Tables);  		((SqlQuery.FromClause)newElement).SetSqlQuery ((SqlQuery)parent);  	}  	break;  }  case QueryElementType.WhereClause: {  	var wc = (SqlQuery.WhereClause)element;  	var cond = (SqlQuery.SearchCondition)ConvertInternal (wc.SearchCondition' action);  	IQueryElement parent;  	_visitedElements.TryGetValue (wc.SqlQuery' out parent);  	if (parent != null || cond != null && !ReferenceEquals (wc.SearchCondition' cond)) {  		newElement = new SqlQuery.WhereClause (cond ?? wc.SearchCondition);  		((SqlQuery.WhereClause)newElement).SetSqlQuery ((SqlQuery)parent);  	}  	break;  }  case QueryElementType.GroupByClause: {  	var gc = (SqlQuery.GroupByClause)element;  	var es = Convert (gc.Items' action);  	IQueryElement parent;  	_visitedElements.TryGetValue (gc.SqlQuery' out parent);  	if (parent != null || es != null && !ReferenceEquals (gc.Items' es)) {  		newElement = new SqlQuery.GroupByClause (es ?? gc.Items);  		((SqlQuery.GroupByClause)newElement).SetSqlQuery ((SqlQuery)parent);  	}  	break;  }  case QueryElementType.OrderByClause: {  	var oc = (SqlQuery.OrderByClause)element;  	var es = Convert (oc.Items' action);  	IQueryElement parent;  	_visitedElements.TryGetValue (oc.SqlQuery' out parent);  	if (parent != null || es != null && !ReferenceEquals (oc.Items' es)) {  		newElement = new SqlQuery.OrderByClause (es ?? oc.Items);  		((SqlQuery.OrderByClause)newElement).SetSqlQuery ((SqlQuery)parent);  	}  	break;  }  case QueryElementType.OrderByItem: {  	var i = (SqlQuery.OrderByItem)element;  	var e = (ISqlExpression)ConvertInternal (i.Expression' action);  	if (e != null && !ReferenceEquals (i.Expression' e))  		newElement = new SqlQuery.OrderByItem (e' i.IsDescending);  	break;  }  case QueryElementType.Union: {  	var u = (SqlQuery.Union)element;  	var q = (SqlQuery)ConvertInternal (u.SqlQuery' action);  	if (q != null && !ReferenceEquals (u.SqlQuery' q))  		newElement = new SqlQuery.Union (q' u.IsAll);  	break;  }  case QueryElementType.SqlQuery: {  	var q = (SqlQuery)element;  	IQueryElement parent = null;  	var doConvert = q.ParentSql != null && !_visitedElements.TryGetValue (q.ParentSql' out parent);  	if (!doConvert) {  		doConvert = null != Find (q' e => {  			if (_visitedElements.ContainsKey (e) && _visitedElements [e] != e)  				return true;  			var ret = action (e);  			if (ret != null && !ReferenceEquals (e' ret)) {  				_visitedElements.Add (e' ret);  				return true;  			}  			return false;  		});  	}  	if (!doConvert)  		break;  	var nq = new SqlQuery {  		QueryType = q.QueryType  	};  	_visitedElements.Add (q' nq);  	var fc = (SqlQuery.FromClause)ConvertInternal (q.From' action) ?? q.From;  	var sc = (SqlQuery.SelectClause)ConvertInternal (q.Select' action) ?? q.Select;  	var ic = q.IsInsert ? ((SqlQuery.InsertClause)ConvertInternal (q.Insert' action) ?? q.Insert) : null;  	var uc = q.IsUpdate ? ((SqlQuery.UpdateClause)ConvertInternal (q.Update' action) ?? q.Update) : null;  	var dc = q.IsDelete ? ((SqlQuery.DeleteClause)ConvertInternal (q.Delete' action) ?? q.Delete) : null;  	var wc = (SqlQuery.WhereClause)ConvertInternal (q.Where' action) ?? q.Where;  	var gc = (SqlQuery.GroupByClause)ConvertInternal (q.GroupBy' action) ?? q.GroupBy;  	var hc = (SqlQuery.WhereClause)ConvertInternal (q.Having' action) ?? q.Having;  	var oc = (SqlQuery.OrderByClause)ConvertInternal (q.OrderBy' action) ?? q.OrderBy;  	var us = q.HasUnion ? Convert (q.Unions' action) : q.Unions;  	var ps = new List<SqlParameter> (q.Parameters.Count);  	foreach (var p in q.Parameters) {  		IQueryElement e;  		if (_visitedElements.TryGetValue (p' out e)) {  			if (e == null)  				ps.Add (p);  			else if (e is SqlParameter)  				ps.Add ((SqlParameter)e);  		}  	}  	nq.Init (ic' uc' dc' sc' fc' wc' gc' hc' oc' us' (SqlQuery)parent' q.IsParameterDependent' ps);  	_visitedElements [q] = action (nq) ?? nq;  	return nq;  }  }  
Missing Default,BLToolkit.Data.Sql,SqlDataType,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlDataType.cs,GetDataType,The following switch statement is missing a default case: switch (type) {  case SqlDbType.BigInt:  	return DbBigInt;  case SqlDbType.Binary:  	return DbBinary;  case SqlDbType.Bit:  	return DbBit;  case SqlDbType.Char:  	return DbChar;  case SqlDbType.DateTime:  	return DbDateTime;  case SqlDbType.Decimal:  	return DbDecimal;  case SqlDbType.Float:  	return DbFloat;  case SqlDbType.Image:  	return DbImage;  case SqlDbType.Int:  	return DbInt;  case SqlDbType.Money:  	return DbMoney;  case SqlDbType.NChar:  	return DbNChar;  case SqlDbType.NText:  	return DbNText;  case SqlDbType.NVarChar:  	return DbNVarChar;  case SqlDbType.Real:  	return DbReal;  case SqlDbType.UniqueIdentifier:  	return DbUniqueIdentifier;  case SqlDbType.SmallDateTime:  	return DbSmallDateTime;  case SqlDbType.SmallInt:  	return DbSmallInt;  case SqlDbType.SmallMoney:  	return DbSmallMoney;  case SqlDbType.Text:  	return DbText;  case SqlDbType.Timestamp:  	return DbTimestamp;  case SqlDbType.TinyInt:  	return DbTinyInt;  case SqlDbType.VarBinary:  	return DbVarBinary;  case SqlDbType.VarChar:  	return DbVarChar;  case SqlDbType.Variant:  	return DbVariant;  #if !SILVERLIGHT  case SqlDbType.Xml:  	return DbXml;  #endif  case SqlDbType.Udt:  	return DbUdt;  #if !MONO  case SqlDbType.Structured:  	return DbStructured;  #endif  case SqlDbType.Date:  	return DbDate;  case SqlDbType.Time:  	return DbTime;  #if !MONO  case SqlDbType.DateTime2:  	return DbDateTime2;  case SqlDbType.DateTimeOffset:  	return DbDateTimeOffset;  #endif  }  
Missing Default,BLToolkit.Data.Sql,SqlExpression,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlExpression.cs,NeedsEqual,The following switch statement is missing a default case: switch (ex.ElementType) {  case QueryElementType.SqlParameter:  case QueryElementType.SqlField:  case QueryElementType.Column:  	return true;  case QueryElementType.SqlFunction:  	var f = (SqlFunction)ex;  	switch (f.Name) {  	case "EXISTS":  		return false;  	}  	return true;  }  
Missing Default,BLToolkit.Data.Sql,SqlExpression,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlExpression.cs,NeedsEqual,The following switch statement is missing a default case: switch (f.Name) {  case "EXISTS":  	return false;  }  
Missing Default,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,GetQueryData,The following switch statement is missing a default case: switch (e.ElementType) {  case QueryElementType.SqlField: {  	var field = (SqlField)e;  	if (field.Name.Length != 1 || field.Name [0] != '*')  		data.Fields.Add (field);  	break;  }  case QueryElementType.SqlQuery: {  	if (e != this) {  		data.Queries.Add (((SqlQuery)e).GetQueryData ());  		return false;  	}  	break;  }  case QueryElementType.Column:  	return ((Column)e).Parent == this;  case QueryElementType.SqlTable:  	return false;  }  
Missing Default,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ResolveFields,The following switch statement is missing a default case: switch (e.ElementType) {  case QueryElementType.SqlQuery:  	return e == data.Query;  case QueryElementType.SqlFunction: {  	var parms = ((SqlFunction)e).Parameters;  	for (var i = 0; i < parms.Length; i++)  		if (dic.TryGetValue (parms [i]' out ex))  			parms [i] = ex;  	break;  }  case QueryElementType.SqlExpression: {  	var parms = ((SqlExpression)e).Parameters;  	for (var i = 0; i < parms.Length; i++)  		if (dic.TryGetValue (parms [i]' out ex))  			parms [i] = ex;  	break;  }  case QueryElementType.SqlBinaryExpression: {  	var expr = (SqlBinaryExpression)e;  	if (dic.TryGetValue (expr.Expr1' out ex))  		expr.Expr1 = ex;  	if (dic.TryGetValue (expr.Expr2' out ex))  		expr.Expr2 = ex;  	break;  }  case QueryElementType.ExprPredicate:  case QueryElementType.NotExprPredicate:  case QueryElementType.IsNullPredicate:  case QueryElementType.InSubQueryPredicate: {  	var expr = (Predicate.Expr)e;  	if (dic.TryGetValue (expr.Expr1' out ex))  		expr.Expr1 = ex;  	break;  }  case QueryElementType.ExprExprPredicate: {  	var expr = (Predicate.ExprExpr)e;  	if (dic.TryGetValue (expr.Expr1' out ex))  		expr.Expr1 = ex;  	if (dic.TryGetValue (expr.Expr2' out ex))  		expr.Expr2 = ex;  	break;  }  case QueryElementType.LikePredicate: {  	var expr = (Predicate.Like)e;  	if (dic.TryGetValue (expr.Expr1' out ex))  		expr.Expr1 = ex;  	if (dic.TryGetValue (expr.Expr2' out ex))  		expr.Expr2 = ex;  	if (dic.TryGetValue (expr.Escape' out ex))  		expr.Escape = ex;  	break;  }  case QueryElementType.BetweenPredicate: {  	var expr = (Predicate.Between)e;  	if (dic.TryGetValue (expr.Expr1' out ex))  		expr.Expr1 = ex;  	if (dic.TryGetValue (expr.Expr2' out ex))  		expr.Expr2 = ex;  	if (dic.TryGetValue (expr.Expr3' out ex))  		expr.Expr3 = ex;  	break;  }  case QueryElementType.InListPredicate: {  	var expr = (Predicate.InList)e;  	if (dic.TryGetValue (expr.Expr1' out ex))  		expr.Expr1 = ex;  	for (var i = 0; i < expr.Values.Count; i++)  		if (dic.TryGetValue (expr.Values [i]' out ex))  			expr.Values [i] = ex;  	break;  }  case QueryElementType.Column: {  	var expr = (Column)e;  	if (expr.Parent != data.Query)  		return false;  	if (dic.TryGetValue (expr.Expression' out ex))  		expr.Expression = ex;  	break;  }  case QueryElementType.SetExpression: {  	var expr = (SetExpression)e;  	if (dic.TryGetValue (expr.Expression' out ex))  		expr.Expression = ex;  	break;  }  case QueryElementType.GroupByClause: {  	var expr = (GroupByClause)e;  	for (var i = 0; i < expr.Items.Count; i++)  		if (dic.TryGetValue (expr.Items [i]' out ex))  			expr.Items [i] = ex;  	break;  }  case QueryElementType.OrderByItem: {  	var expr = (OrderByItem)e;  	if (dic.TryGetValue (expr.Expression' out ex))  		expr.Expression = ex;  	break;  }  }  
Missing Default,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,IsAggregationFunction,The following switch statement is missing a default case: switch (((SqlFunction)expr).Name) {  case "Count":  case "Average":  case "Min":  case "Max":  case "Sum":  	return true;  }  
Missing Default,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,SetAliases,The following switch statement is missing a default case: switch (expr.ElementType) {  case QueryElementType.SqlParameter:  	{  		var p = (SqlParameter)expr;  		//if (p.IsQueryParameter)  		//{  		if (!objs.ContainsKey (expr)) {  			objs.Add (expr' expr);  			p.Name = GetAlias (p.Name' "p");  		}  		Parameters.Add (p);  		//}  		//else  		//	IsParameterDependent = true;  		IsParameterDependent |= !p.IsQueryParameter;  	}  	break;  case QueryElementType.Column:  	{  		if (!objs.ContainsKey (expr)) {  			objs.Add (expr' expr);  			var c = (Column)expr;  			if (c.Alias != "*")  				c.Alias = GetAlias (c.Alias' "c");  		}  	}  	break;  case QueryElementType.TableSource:  	{  		var table = (TableSource)expr;  		if (!objs.ContainsKey (table)) {  			objs.Add (table' table);  			table.Alias = GetAlias (table.Alias' "t");  		}  	}  	break;  case QueryElementType.SqlQuery:  	{  		var sql = (SqlQuery)expr;  		if (sql.HasUnion) {  			for (var i = 0; i < sql.Select.Columns.Count; i++) {  				var col = sql.Select.Columns [i];  				foreach (var t in sql.Unions) {  					var union = t.SqlQuery.Select;  					objs.Remove (union.Columns [i].Alias);  					union.Columns [i].Alias = col.Alias;  				}  			}  		}  	}  	break;  }  
Missing Default,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,ProcessParameters,The following switch statement is missing a default case: switch (e.ElementType) {  case QueryElementType.SqlParameter:  	{  		var p = (SqlParameter)e;  		if (p.Value == null)  			return new SqlValue (null);  	}  	break;  case QueryElementType.ExprExprPredicate:  	{  		var ee = (Predicate.ExprExpr)e;  		if (ee.Operator == Predicate.Operator.Equal || ee.Operator == Predicate.Operator.NotEqual) {  			object value1;  			object value2;  			if (ee.Expr1 is SqlValue)  				value1 = ((SqlValue)ee.Expr1).Value;  			else if (ee.Expr1 is SqlParameter)  				value1 = ((SqlParameter)ee.Expr1).Value;  			else  				break;  			if (ee.Expr2 is SqlValue)  				value2 = ((SqlValue)ee.Expr2).Value;  			else if (ee.Expr2 is SqlParameter)  				value2 = ((SqlParameter)ee.Expr2).Value;  			else  				break;  			var value = Equals (value1' value2);  			if (ee.Operator == Predicate.Operator.NotEqual)  				value = !value;  			return new Predicate.Expr (new SqlValue (value)' Sql.Precedence.Comparison);  		}  	}  	break;  case QueryElementType.InListPredicate:  	return ConvertInListPredicate ((Predicate.InList)e);  }  
Missing Default,BLToolkit.Data.Sql,SqlQuery,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Data\Sql\SqlQuery.cs,GetUnderlayingField,The following switch statement is missing a default case: switch (expr.ElementType) {  case QueryElementType.SqlField:  	return (SqlField)expr;  case QueryElementType.Column:  	return GetUnderlayingField (((Column)expr).Expression);  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,IsConstant,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.Int16:  case TypeCode.Int32:  case TypeCode.Int64:  case TypeCode.UInt16:  case TypeCode.UInt32:  case TypeCode.UInt64:  case TypeCode.SByte:  case TypeCode.Byte:  case TypeCode.Decimal:  case TypeCode.Double:  case TypeCode.Single:  case TypeCode.Boolean:  case TypeCode.String:  case TypeCode.Char:  	return true;  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The following switch statement is missing a default case: switch (expr1.NodeType) {  case ExpressionType.Add:  case ExpressionType.AddChecked:  case ExpressionType.And:  case ExpressionType.AndAlso:  case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  case ExpressionType.Assign:  #endif  case ExpressionType.Coalesce:  case ExpressionType.Divide:  case ExpressionType.Equal:  case ExpressionType.ExclusiveOr:  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.LeftShift:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual:  case ExpressionType.Modulo:  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  case ExpressionType.NotEqual:  case ExpressionType.Or:  case ExpressionType.OrElse:  case ExpressionType.Power:  case ExpressionType.RightShift:  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked: {  	var e1 = (BinaryExpression)expr1;  	var e2 = (BinaryExpression)expr2;  	return e1.Method == e2.Method && Compare (e1.Conversion' e2.Conversion' visited' queryableAccessorDic) && Compare (e1.Left' e2.Left' visited' queryableAccessorDic) && Compare (e1.Right' e2.Right' visited' queryableAccessorDic);  }  case ExpressionType.ArrayLength:  case ExpressionType.Convert:  case ExpressionType.ConvertChecked:  case ExpressionType.Negate:  case ExpressionType.NegateChecked:  case ExpressionType.Not:  case ExpressionType.Quote:  case ExpressionType.TypeAs:  case ExpressionType.UnaryPlus: {  	var e1 = (UnaryExpression)expr1;  	var e2 = (UnaryExpression)expr2;  	return e1.Method == e2.Method && Compare (e1.Operand' e2.Operand' visited' queryableAccessorDic);  }  case ExpressionType.Call: {  	var e1 = (MethodCallExpression)expr1;  	var e2 = (MethodCallExpression)expr2;  	if (e1.Arguments.Count != e2.Arguments.Count || e1.Method != e2.Method)  		return false;  	if (queryableAccessorDic.Count > 0) {  		QueryableAccessor qa;  		if (queryableAccessorDic.TryGetValue (expr1' out qa))  			return Compare (qa.Queryable.Expression' qa.Accessor (expr2).Expression' visited' queryableAccessorDic);  	}  	if (!Compare (e1.Object' e2.Object' visited' queryableAccessorDic))  		return false;  	for (var i = 0; i < e1.Arguments.Count; i++)  		if (!Compare (e1.Arguments [i]' e2.Arguments [i]' visited' queryableAccessorDic))  			return false;  	return true;  }  case ExpressionType.Conditional: {  	var e1 = (ConditionalExpression)expr1;  	var e2 = (ConditionalExpression)expr2;  	return Compare (e1.Test' e2.Test' visited' queryableAccessorDic) && Compare (e1.IfTrue' e2.IfTrue' visited' queryableAccessorDic) && Compare (e1.IfFalse' e2.IfFalse' visited' queryableAccessorDic);  }  case ExpressionType.Constant: {  	var e1 = (ConstantExpression)expr1;  	var e2 = (ConstantExpression)expr2;  	if (e1.Value == null && e2.Value == null)  		return true;  	if (IsConstant (e1.Type))  		return Equals (e1.Value' e2.Value);  	if (e1.Value == null || e2.Value == null)  		return false;  	if (e1.Value is IQueryable) {  		var eq1 = ((IQueryable)e1.Value).Expression;  		var eq2 = ((IQueryable)e2.Value).Expression;  		if (visited.Add (eq1))  			return Compare (eq1' eq2' visited' queryableAccessorDic);  	}  	return true;  }  case ExpressionType.Invoke: {  	var e1 = (InvocationExpression)expr1;  	var e2 = (InvocationExpression)expr2;  	if (e1.Arguments.Count != e2.Arguments.Count || !Compare (e1.Expression' e2.Expression' visited' queryableAccessorDic))  		return false;  	for (var i = 0; i < e1.Arguments.Count; i++)  		if (!Compare (e1.Arguments [i]' e2.Arguments [i]' visited' queryableAccessorDic))  			return false;  	return true;  }  case ExpressionType.Lambda: {  	var e1 = (LambdaExpression)expr1;  	var e2 = (LambdaExpression)expr2;  	if (e1.Parameters.Count != e2.Parameters.Count || !Compare (e1.Body' e2.Body' visited' queryableAccessorDic))  		return false;  	for (var i = 0; i < e1.Parameters.Count; i++)  		if (!Compare (e1.Parameters [i]' e2.Parameters [i]' visited' queryableAccessorDic))  			return false;  	return true;  }  case ExpressionType.ListInit: {  	var e1 = (ListInitExpression)expr1;  	var e2 = (ListInitExpression)expr2;  	if (e1.Initializers.Count != e2.Initializers.Count || !Compare (e1.NewExpression' e2.NewExpression' visited' queryableAccessorDic))  		return false;  	for (var i = 0; i < e1.Initializers.Count; i++) {  		var i1 = e1.Initializers [i];  		var i2 = e2.Initializers [i];  		if (i1.Arguments.Count != i2.Arguments.Count || i1.AddMethod != i2.AddMethod)  			return false;  		for (var j = 0; j < i1.Arguments.Count; j++)  			if (!Compare (i1.Arguments [j]' i2.Arguments [j]' visited' queryableAccessorDic))  				return false;  	}  	return true;  }  case ExpressionType.MemberAccess: {  	var e1 = (MemberExpression)expr1;  	var e2 = (MemberExpression)expr2;  	if (e1.Member == e2.Member) {  		if (e1.Expression == e2.Expression || e1.Expression.Type == e2.Expression.Type) {  			if (queryableAccessorDic.Count > 0) {  				QueryableAccessor qa;  				if (queryableAccessorDic.TryGetValue (expr1' out qa))  					return Compare (e1.Expression' e2.Expression' visited' queryableAccessorDic) && Compare (qa.Queryable.Expression' qa.Accessor (expr2).Expression' visited' queryableAccessorDic);  			}  		}  		return Compare (e1.Expression' e2.Expression' visited' queryableAccessorDic);  	}  	return false;  }  case ExpressionType.MemberInit: {  	var e1 = (MemberInitExpression)expr1;  	var e2 = (MemberInitExpression)expr2;  	if (e1.Bindings.Count != e2.Bindings.Count || !Compare (e1.NewExpression' e2.NewExpression' visited' queryableAccessorDic))  		return false;  	Func<MemberBinding' MemberBinding' bool> compareBindings = null;  	compareBindings = (b1' b2) => {  		if (b1 == b2)  			return true;  		if (b1 == null || b2 == null || b1.BindingType != b2.BindingType || b1.Member != b2.Member)  			return false;  		switch (b1.BindingType) {  		case MemberBindingType.Assignment:  			return Compare (((MemberAssignment)b1).Expression' ((MemberAssignment)b2).Expression' visited' queryableAccessorDic);  		case MemberBindingType.ListBinding:  			var ml1 = (MemberListBinding)b1;  			var ml2 = (MemberListBinding)b2;  			if (ml1.Initializers.Count != ml2.Initializers.Count)  				return false;  			for (var i = 0; i < ml1.Initializers.Count; i++) {  				var ei1 = ml1.Initializers [i];  				var ei2 = ml2.Initializers [i];  				if (ei1.AddMethod != ei2.AddMethod || ei1.Arguments.Count != ei2.Arguments.Count)  					return false;  				for (var j = 0; j < ei1.Arguments.Count; j++)  					if (!Compare (ei1.Arguments [j]' ei2.Arguments [j]' visited' queryableAccessorDic))  						return false;  			}  			break;  		case MemberBindingType.MemberBinding:  			var mm1 = (MemberMemberBinding)b1;  			var mm2 = (MemberMemberBinding)b2;  			if (mm1.Bindings.Count != mm2.Bindings.Count)  				return false;  			for (var i = 0; i < mm1.Bindings.Count; i++)  				if (!compareBindings (mm1.Bindings [i]' mm2.Bindings [i]))  					return false;  			break;  		}  		return true;  	};  	for (var i = 0; i < e1.Bindings.Count; i++) {  		var b1 = e1.Bindings [i];  		var b2 = e2.Bindings [i];  		if (!compareBindings (b1' b2))  			return false;  	}  	return true;  }  case ExpressionType.New: {  	var e1 = (NewExpression)expr1;  	var e2 = (NewExpression)expr2;  	if (e1.Arguments.Count != e2.Arguments.Count)  		return false;  	if (e1.Members == null && e2.Members != null)  		return false;  	if (e1.Members != null && e2.Members == null)  		return false;  	if (e1.Constructor != e2.Constructor)  		return false;  	if (e1.Members != null) {  		if (e1.Members.Count != e2.Members.Count)  			return false;  		for (var i = 0; i < e1.Members.Count; i++)  			if (e1.Members [i] != e2.Members [i])  				return false;  	}  	for (var i = 0; i < e1.Arguments.Count; i++)  		if (!Compare (e1.Arguments [i]' e2.Arguments [i]' visited' queryableAccessorDic))  			return false;  	return true;  }  case ExpressionType.NewArrayBounds:  case ExpressionType.NewArrayInit: {  	var e1 = (NewArrayExpression)expr1;  	var e2 = (NewArrayExpression)expr2;  	if (e1.Expressions.Count != e2.Expressions.Count)  		return false;  	for (var i = 0; i < e1.Expressions.Count; i++)  		if (!Compare (e1.Expressions [i]' e2.Expressions [i]' visited' queryableAccessorDic))  			return false;  	return true;  }  case ExpressionType.Parameter: {  	var e1 = (ParameterExpression)expr1;  	var e2 = (ParameterExpression)expr2;  	return e1.Name == e2.Name;  }  case ExpressionType.TypeIs: {  	var e1 = (TypeBinaryExpression)expr1;  	var e2 = (TypeBinaryExpression)expr2;  	return e1.TypeOperand == e2.TypeOperand && Compare (e1.Expression' e2.Expression' visited' queryableAccessorDic);  }  #if FW4 || SILVERLIGHT  case ExpressionType.Block: {  	var e1 = (BlockExpression)expr1;  	var e2 = (BlockExpression)expr2;  	for (var i = 0; i < e1.Expressions.Count; i++)  		if (!Compare (e1.Expressions [i]' e2.Expressions [i]' visited' queryableAccessorDic))  			return false;  	for (var i = 0; i < e1.Variables.Count; i++)  		if (!Compare (e1.Variables [i]' e2.Variables [i]' visited' queryableAccessorDic))  			return false;  	return true;  }  #endif  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Compare,The following switch statement is missing a default case: switch (b1.BindingType) {  case MemberBindingType.Assignment:  	return Compare (((MemberAssignment)b1).Expression' ((MemberAssignment)b2).Expression' visited' queryableAccessorDic);  case MemberBindingType.ListBinding:  	var ml1 = (MemberListBinding)b1;  	var ml2 = (MemberListBinding)b2;  	if (ml1.Initializers.Count != ml2.Initializers.Count)  		return false;  	for (var i = 0; i < ml1.Initializers.Count; i++) {  		var ei1 = ml1.Initializers [i];  		var ei2 = ml2.Initializers [i];  		if (ei1.AddMethod != ei2.AddMethod || ei1.Arguments.Count != ei2.Arguments.Count)  			return false;  		for (var j = 0; j < ei1.Arguments.Count; j++)  			if (!Compare (ei1.Arguments [j]' ei2.Arguments [j]' visited' queryableAccessorDic))  				return false;  	}  	break;  case MemberBindingType.MemberBinding:  	var mm1 = (MemberMemberBinding)b1;  	var mm2 = (MemberMemberBinding)b2;  	if (mm1.Bindings.Count != mm2.Bindings.Count)  		return false;  	for (var i = 0; i < mm1.Bindings.Count; i++)  		if (!compareBindings (mm1.Bindings [i]' mm2.Bindings [i]))  			return false;  	break;  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.Add:  case ExpressionType.AddChecked:  case ExpressionType.And:  case ExpressionType.AndAlso:  case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  case ExpressionType.Assign:  #endif  case ExpressionType.Coalesce:  case ExpressionType.Divide:  case ExpressionType.Equal:  case ExpressionType.ExclusiveOr:  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.LeftShift:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual:  case ExpressionType.Modulo:  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  case ExpressionType.NotEqual:  case ExpressionType.Or:  case ExpressionType.OrElse:  case ExpressionType.Power:  case ExpressionType.RightShift:  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked: {  	path = ConvertTo (path' typeof(BinaryExpression));  	var e = (BinaryExpression)expr;  	Path (e.Conversion' visited' path' ReflectionHelper.Binary.Conversion' func);  	Path (e.Left' visited' path' ReflectionHelper.Binary.Left' func);  	Path (e.Right' visited' path' ReflectionHelper.Binary.Right' func);  	break;  }  case ExpressionType.ArrayLength:  case ExpressionType.Convert:  case ExpressionType.ConvertChecked:  case ExpressionType.Negate:  case ExpressionType.NegateChecked:  case ExpressionType.Not:  case ExpressionType.Quote:  case ExpressionType.TypeAs:  case ExpressionType.UnaryPlus:  	Path (((UnaryExpression)expr).Operand' visited' path = ConvertTo (path' typeof(UnaryExpression))' ReflectionHelper.Unary.Operand' func);  	break;  case ExpressionType.Call: {  	path = ConvertTo (path' typeof(MethodCallExpression));  	var e = (MethodCallExpression)expr;  	Path (e.Object' visited' path' ReflectionHelper.MethodCall.Object' func);  	Path (e.Arguments' visited' path' ReflectionHelper.MethodCall.Arguments' func);  	break;  }  case ExpressionType.Conditional: {  	path = ConvertTo (path' typeof(ConditionalExpression));  	var e = (ConditionalExpression)expr;  	Path (e.Test' visited' path' ReflectionHelper.Conditional.Test' func);  	Path (e.IfTrue' visited' path' ReflectionHelper.Conditional.IfTrue' func);  	Path (e.IfFalse' visited' path' ReflectionHelper.Conditional.IfFalse' func);  	break;  }  case ExpressionType.Invoke: {  	path = ConvertTo (path' typeof(InvocationExpression));  	var e = (InvocationExpression)expr;  	Path (e.Expression' visited' path' ReflectionHelper.Invocation.Expression' func);  	Path (e.Arguments' visited' path' ReflectionHelper.Invocation.Arguments' func);  	break;  }  case ExpressionType.Lambda: {  	path = ConvertTo (path' typeof(LambdaExpression));  	var e = (LambdaExpression)expr;  	Path (e.Body' visited' path' ReflectionHelper.LambdaExpr.Body' func);  	Path (e.Parameters' visited' path' ReflectionHelper.LambdaExpr.Parameters' func);  	break;  }  case ExpressionType.ListInit: {  	path = ConvertTo (path' typeof(ListInitExpression));  	var e = (ListInitExpression)expr;  	Path (e.NewExpression' visited' path' ReflectionHelper.ListInit.NewExpression' func);  	Path (e.Initializers' visited' path' ReflectionHelper.ListInit.Initializers' (ex' p) => Path (ex.Arguments' visited' p' ReflectionHelper.ElementInit.Arguments' func));  	break;  }  case ExpressionType.MemberAccess:  	Path (((MemberExpression)expr).Expression' visited' path = ConvertTo (path' typeof(MemberExpression))' ReflectionHelper.Member.Expression' func);  	break;  case ExpressionType.MemberInit: {  	Action<MemberBinding' Expression> modify = null;  	modify = (b' pinf) => {  		switch (b.BindingType) {  		case MemberBindingType.Assignment:  			Path (((MemberAssignment)b).Expression' visited' ConvertTo (pinf' typeof(MemberAssignment))' ReflectionHelper.MemberAssignmentBind.Expression' func);  			break;  		case MemberBindingType.ListBinding:  			Path (((MemberListBinding)b).Initializers' visited' ConvertTo (pinf' typeof(MemberListBinding))' ReflectionHelper.MemberListBind.Initializers' (p' psi) => Path (p.Arguments' visited' psi' ReflectionHelper.ElementInit.Arguments' func));  			break;  		case MemberBindingType.MemberBinding:  			Path (((MemberMemberBinding)b).Bindings' visited' ConvertTo (pinf' typeof(MemberMemberBinding))' ReflectionHelper.MemberMemberBind.Bindings' modify);  			break;  		}  	};  	path = ConvertTo (path' typeof(MemberInitExpression));  	var e = (MemberInitExpression)expr;  	Path (e.NewExpression' visited' path' ReflectionHelper.MemberInit.NewExpression' func);  	Path (e.Bindings' visited' path' ReflectionHelper.MemberInit.Bindings' modify);  	break;  }  case ExpressionType.New:  	Path (((NewExpression)expr).Arguments' visited' path = ConvertTo (path' typeof(NewExpression))' ReflectionHelper.New.Arguments' func);  	break;  case ExpressionType.NewArrayBounds:  	Path (((NewArrayExpression)expr).Expressions' visited' path = ConvertTo (path' typeof(NewArrayExpression))' ReflectionHelper.NewArray.Expressions' func);  	break;  case ExpressionType.NewArrayInit:  	Path (((NewArrayExpression)expr).Expressions' visited' path = ConvertTo (path' typeof(NewArrayExpression))' ReflectionHelper.NewArray.Expressions' func);  	break;  case ExpressionType.TypeIs:  	Path (((TypeBinaryExpression)expr).Expression' visited' path = ConvertTo (path' typeof(TypeBinaryExpression))' ReflectionHelper.TypeBinary.Expression' func);  	break;  #if FW4 || SILVERLIGHT  case ExpressionType.Block: {  	path = ConvertTo (path' typeof(BlockExpression));  	var e = (BlockExpression)expr;  	Path (e.Expressions' visited' path' ReflectionHelper.Block.Expressions' func);  	Path (e.Variables' visited' path' ReflectionHelper.Block.Variables' func);  	// ?  	break;  }  #endif  case ExpressionType.Constant: {  	path = ConvertTo (path' typeof(ConstantExpression));  	var e = (ConstantExpression)expr;  	var iq = e.Value as IQueryable;  	if (iq != null && !visited.Contains (iq.Expression)) {  		visited.Add (iq.Expression);  		Expression p = Expression.Property (path' ReflectionHelper.Constant.Value);  		p = ConvertTo (p' typeof(IQueryable));  		Path (iq.Expression' visited' p' ReflectionHelper.QueryableInt.Expression' func);  	}  	break;  }  case ExpressionType.Parameter:  	path = ConvertTo (path' typeof(ParameterExpression));  	break;  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Path,The following switch statement is missing a default case: switch (b.BindingType) {  case MemberBindingType.Assignment:  	Path (((MemberAssignment)b).Expression' visited' ConvertTo (pinf' typeof(MemberAssignment))' ReflectionHelper.MemberAssignmentBind.Expression' func);  	break;  case MemberBindingType.ListBinding:  	Path (((MemberListBinding)b).Initializers' visited' ConvertTo (pinf' typeof(MemberListBinding))' ReflectionHelper.MemberListBind.Initializers' (p' psi) => Path (p.Arguments' visited' psi' ReflectionHelper.ElementInit.Arguments' func));  	break;  case MemberBindingType.MemberBinding:  	Path (((MemberMemberBinding)b).Bindings' visited' ConvertTo (pinf' typeof(MemberMemberBinding))' ReflectionHelper.MemberMemberBind.Bindings' modify);  	break;  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.Add:  case ExpressionType.AddChecked:  case ExpressionType.And:  case ExpressionType.AndAlso:  case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  case ExpressionType.Assign:  #endif  case ExpressionType.Coalesce:  case ExpressionType.Divide:  case ExpressionType.Equal:  case ExpressionType.ExclusiveOr:  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.LeftShift:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual:  case ExpressionType.Modulo:  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  case ExpressionType.NotEqual:  case ExpressionType.Or:  case ExpressionType.OrElse:  case ExpressionType.Power:  case ExpressionType.RightShift:  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked: {  	var e = (BinaryExpression)expr;  	Visit (e.Conversion' func);  	Visit (e.Left' func);  	Visit (e.Right' func);  	break;  }  case ExpressionType.ArrayLength:  case ExpressionType.Convert:  case ExpressionType.ConvertChecked:  case ExpressionType.Negate:  case ExpressionType.NegateChecked:  case ExpressionType.Not:  case ExpressionType.Quote:  case ExpressionType.TypeAs:  case ExpressionType.UnaryPlus:  	Visit (((UnaryExpression)expr).Operand' func);  	break;  case ExpressionType.Call: {  	var e = (MethodCallExpression)expr;  	Visit (e.Object' func);  	Visit (e.Arguments' func);  	break;  }  case ExpressionType.Conditional: {  	var e = (ConditionalExpression)expr;  	Visit (e.Test' func);  	Visit (e.IfTrue' func);  	Visit (e.IfFalse' func);  	break;  }  case ExpressionType.Invoke: {  	var e = (InvocationExpression)expr;  	Visit (e.Expression' func);  	Visit (e.Arguments' func);  	break;  }  case ExpressionType.Lambda: {  	var e = (LambdaExpression)expr;  	Visit (e.Body' func);  	Visit (e.Parameters' func);  	break;  }  case ExpressionType.ListInit: {  	var e = (ListInitExpression)expr;  	Visit (e.NewExpression' func);  	Visit (e.Initializers' ex => Visit (ex.Arguments' func));  	break;  }  case ExpressionType.MemberAccess:  	Visit (((MemberExpression)expr).Expression' func);  	break;  case ExpressionType.MemberInit: {  	Action<MemberBinding> modify = null;  	modify = b => {  		switch (b.BindingType) {  		case MemberBindingType.Assignment:  			Visit (((MemberAssignment)b).Expression' func);  			break;  		case MemberBindingType.ListBinding:  			Visit (((MemberListBinding)b).Initializers' p => Visit (p.Arguments' func));  			break;  		case MemberBindingType.MemberBinding:  			Visit (((MemberMemberBinding)b).Bindings' modify);  			break;  		}  	};  	var e = (MemberInitExpression)expr;  	Visit (e.NewExpression' func);  	Visit (e.Bindings' modify);  	break;  }  case ExpressionType.New:  	Visit (((NewExpression)expr).Arguments' func);  	break;  case ExpressionType.NewArrayBounds:  	Visit (((NewArrayExpression)expr).Expressions' func);  	break;  case ExpressionType.NewArrayInit:  	Visit (((NewArrayExpression)expr).Expressions' func);  	break;  case ExpressionType.TypeIs:  	Visit (((TypeBinaryExpression)expr).Expression' func);  	break;  #if FW4 || SILVERLIGHT  case ExpressionType.Block: {  	var e = (BlockExpression)expr;  	Visit (e.Expressions' func);  	Visit (e.Variables' func);  	break;  }  #endif  case (ExpressionType)ChangeTypeExpression.ChangeTypeType:  	Visit (((ChangeTypeExpression)expr).Expression' func);  	break;  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The following switch statement is missing a default case: switch (b.BindingType) {  case MemberBindingType.Assignment:  	Visit (((MemberAssignment)b).Expression' func);  	break;  case MemberBindingType.ListBinding:  	Visit (((MemberListBinding)b).Initializers' p => Visit (p.Arguments' func));  	break;  case MemberBindingType.MemberBinding:  	Visit (((MemberMemberBinding)b).Bindings' modify);  	break;  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.Add:  case ExpressionType.AddChecked:  case ExpressionType.And:  case ExpressionType.AndAlso:  case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  case ExpressionType.Assign:  #endif  case ExpressionType.Coalesce:  case ExpressionType.Divide:  case ExpressionType.Equal:  case ExpressionType.ExclusiveOr:  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.LeftShift:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual:  case ExpressionType.Modulo:  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  case ExpressionType.NotEqual:  case ExpressionType.Or:  case ExpressionType.OrElse:  case ExpressionType.Power:  case ExpressionType.RightShift:  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked: {  	var e = (BinaryExpression)expr;  	Visit (e.Conversion' func);  	Visit (e.Left' func);  	Visit (e.Right' func);  	break;  }  case ExpressionType.ArrayLength:  case ExpressionType.Convert:  case ExpressionType.ConvertChecked:  case ExpressionType.Negate:  case ExpressionType.NegateChecked:  case ExpressionType.Not:  case ExpressionType.Quote:  case ExpressionType.TypeAs:  case ExpressionType.UnaryPlus:  	Visit (((UnaryExpression)expr).Operand' func);  	break;  case ExpressionType.Call: {  	var e = (MethodCallExpression)expr;  	Visit (e.Object' func);  	Visit (e.Arguments' func);  	break;  }  case ExpressionType.Conditional: {  	var e = (ConditionalExpression)expr;  	Visit (e.Test' func);  	Visit (e.IfTrue' func);  	Visit (e.IfFalse' func);  	break;  }  case ExpressionType.Invoke: {  	var e = (InvocationExpression)expr;  	Visit (e.Expression' func);  	Visit (e.Arguments' func);  	break;  }  case ExpressionType.Lambda: {  	var e = (LambdaExpression)expr;  	Visit (e.Body' func);  	Visit (e.Parameters' func);  	break;  }  case ExpressionType.ListInit: {  	var e = (ListInitExpression)expr;  	Visit (e.NewExpression' func);  	Visit (e.Initializers' ex => Visit (ex.Arguments' func));  	break;  }  case ExpressionType.MemberAccess:  	Visit (((MemberExpression)expr).Expression' func);  	break;  case ExpressionType.MemberInit: {  	Func<MemberBinding' bool> modify = null;  	modify = b => {  		switch (b.BindingType) {  		case MemberBindingType.Assignment:  			Visit (((MemberAssignment)b).Expression' func);  			break;  		case MemberBindingType.ListBinding:  			Visit (((MemberListBinding)b).Initializers' p => Visit (p.Arguments' func));  			break;  		case MemberBindingType.MemberBinding:  			Visit (((MemberMemberBinding)b).Bindings' modify);  			break;  		}  		return true;  	};  	var e = (MemberInitExpression)expr;  	Visit (e.NewExpression' func);  	Visit (e.Bindings' modify);  	break;  }  case ExpressionType.New:  	Visit (((NewExpression)expr).Arguments' func);  	break;  case ExpressionType.NewArrayBounds:  	Visit (((NewArrayExpression)expr).Expressions' func);  	break;  case ExpressionType.NewArrayInit:  	Visit (((NewArrayExpression)expr).Expressions' func);  	break;  case ExpressionType.TypeIs:  	Visit (((TypeBinaryExpression)expr).Expression' func);  	break;  #if FW4 || SILVERLIGHT  case ExpressionType.Block: {  	var e = (BlockExpression)expr;  	Visit (e.Expressions' func);  	Visit (e.Variables' func);  	break;  }  #endif  case (ExpressionType)ChangeTypeExpression.ChangeTypeType:  	Visit (((ChangeTypeExpression)expr).Expression' func);  	break;  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Visit,The following switch statement is missing a default case: switch (b.BindingType) {  case MemberBindingType.Assignment:  	Visit (((MemberAssignment)b).Expression' func);  	break;  case MemberBindingType.ListBinding:  	Visit (((MemberListBinding)b).Initializers' p => Visit (p.Arguments' func));  	break;  case MemberBindingType.MemberBinding:  	Visit (((MemberMemberBinding)b).Bindings' modify);  	break;  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Find,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.Add:  case ExpressionType.AddChecked:  case ExpressionType.And:  case ExpressionType.AndAlso:  case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  case ExpressionType.Assign:  #endif  case ExpressionType.Coalesce:  case ExpressionType.Divide:  case ExpressionType.Equal:  case ExpressionType.ExclusiveOr:  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.LeftShift:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual:  case ExpressionType.Modulo:  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  case ExpressionType.NotEqual:  case ExpressionType.Or:  case ExpressionType.OrElse:  case ExpressionType.Power:  case ExpressionType.RightShift:  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked: {  	var e = (BinaryExpression)expr;  	return Find (e.Conversion' func) ?? Find (e.Left' func) ?? Find (e.Right' func);  }  case ExpressionType.ArrayLength:  case ExpressionType.Convert:  case ExpressionType.ConvertChecked:  case ExpressionType.Negate:  case ExpressionType.NegateChecked:  case ExpressionType.Not:  case ExpressionType.Quote:  case ExpressionType.TypeAs:  case ExpressionType.UnaryPlus:  	return Find (((UnaryExpression)expr).Operand' func);  case ExpressionType.Call: {  	var e = (MethodCallExpression)expr;  	return Find (e.Object' func) ?? Find (e.Arguments' func);  }  case ExpressionType.Conditional: {  	var e = (ConditionalExpression)expr;  	return Find (e.Test' func) ?? Find (e.IfTrue' func) ?? Find (e.IfFalse' func);  }  case ExpressionType.Invoke: {  	var e = (InvocationExpression)expr;  	return Find (e.Expression' func) ?? Find (e.Arguments' func);  }  case ExpressionType.Lambda: {  	var e = (LambdaExpression)expr;  	return Find (e.Body' func) ?? Find (e.Parameters' func);  }  case ExpressionType.ListInit: {  	var e = (ListInitExpression)expr;  	return Find (e.NewExpression' func) ?? Find (e.Initializers' ex => Find (ex.Arguments' func));  }  case ExpressionType.MemberAccess:  	return Find (((MemberExpression)expr).Expression' func);  case ExpressionType.MemberInit: {  	Func<MemberBinding' Expression> modify = null;  	modify = b => {  		switch (b.BindingType) {  		case MemberBindingType.Assignment:  			return Find (((MemberAssignment)b).Expression' func);  		case MemberBindingType.ListBinding:  			return Find (((MemberListBinding)b).Initializers' p => Find (p.Arguments' func));  		case MemberBindingType.MemberBinding:  			return Find (((MemberMemberBinding)b).Bindings' modify);  		}  		return null;  	};  	var e = (MemberInitExpression)expr;  	return Find (e.NewExpression' func) ?? Find (e.Bindings' modify);  }  case ExpressionType.New:  	return Find (((NewExpression)expr).Arguments' func);  case ExpressionType.NewArrayBounds:  	return Find (((NewArrayExpression)expr).Expressions' func);  case ExpressionType.NewArrayInit:  	return Find (((NewArrayExpression)expr).Expressions' func);  case ExpressionType.TypeIs:  	return Find (((TypeBinaryExpression)expr).Expression' func);  #if FW4 || SILVERLIGHT  case ExpressionType.Block: {  	var e = (BlockExpression)expr;  	return Find (e.Expressions' func) ?? Find (e.Variables' func);  }  #endif  case (ExpressionType)ChangeTypeExpression.ChangeTypeType:  	return Find (((ChangeTypeExpression)expr).Expression' func);  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Find,The following switch statement is missing a default case: switch (b.BindingType) {  case MemberBindingType.Assignment:  	return Find (((MemberAssignment)b).Expression' func);  case MemberBindingType.ListBinding:  	return Find (((MemberListBinding)b).Initializers' p => Find (p.Arguments' func));  case MemberBindingType.MemberBinding:  	return Find (((MemberMemberBinding)b).Bindings' modify);  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.Add:  case ExpressionType.AddChecked:  case ExpressionType.And:  case ExpressionType.AndAlso:  case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  case ExpressionType.Assign:  #endif  case ExpressionType.Coalesce:  case ExpressionType.Divide:  case ExpressionType.Equal:  case ExpressionType.ExclusiveOr:  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.LeftShift:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual:  case ExpressionType.Modulo:  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  case ExpressionType.NotEqual:  case ExpressionType.Or:  case ExpressionType.OrElse:  case ExpressionType.Power:  case ExpressionType.RightShift:  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked: {  	var ex = func (expr);  	if (ex != expr)  		return ex;  	var e = (BinaryExpression)expr;  	var c = Convert (e.Conversion' func);  	var l = Convert (e.Left' func);  	var r = Convert (e.Right' func);  	#if FW3  							return c != e.Conversion || l != e.Left || r != e.Right ? 							Expression.MakeBinary(expr.NodeType' l' r' e.IsLiftedToNull' e.Method' (LambdaExpression)c): 							expr; #else  	return e.Update (l' (LambdaExpression)c' r);  	#endif  }  case ExpressionType.ArrayLength:  case ExpressionType.Convert:  case ExpressionType.ConvertChecked:  case ExpressionType.Negate:  case ExpressionType.NegateChecked:  case ExpressionType.Not:  case ExpressionType.Quote:  case ExpressionType.TypeAs:  case ExpressionType.UnaryPlus: {  	var ex = func (expr);  	if (ex != expr)  		return ex;  	var e = (UnaryExpression)expr;  	var o = Convert (e.Operand' func);  	#if FW3  							return o != e.Operand ? 							Expression.MakeUnary(expr.NodeType' o' e.Type' e.Method) : 							expr; #else  	return e.Update (o);  	#endif  }  case ExpressionType.Call: {  	var ex = func (expr);  	if (ex != expr)  		return ex;  	var e = (MethodCallExpression)expr;  	var o = Convert (e.Object' func);  	var a = Convert (e.Arguments' func);  	#if FW3  							return o != e.Object || a != e.Arguments ?  							Expression.Call(o' e.Method' a) : 							expr; #else  	return e.Update (o' a);  	#endif  }  case ExpressionType.Conditional: {  	var ex = func (expr);  	if (ex != expr)  		return ex;  	var e = (ConditionalExpression)expr;  	var s = Convert (e.Test' func);  	var t = Convert (e.IfTrue' func);  	var f = Convert (e.IfFalse' func);  	#if FW3  							return s != e.Test || t != e.IfTrue || f != e.IfFalse ? 							Expression.Condition(s' t' f) : 							expr; #else  	return e.Update (s' t' f);  	#endif  }  case ExpressionType.Invoke: {  	var exp = func (expr);  	if (exp != expr)  		return exp;  	var e = (InvocationExpression)expr;  	var ex = Convert (e.Expression' func);  	var a = Convert (e.Arguments' func);  	#if FW3  							return ex != e.Expression || a != e.Arguments ? Expression.Invoke(ex' a) : expr; #else  	return e.Update (ex' a);  	#endif  }  case ExpressionType.Lambda: {  	var ex = func (expr);  	if (ex != expr)  		return ex;  	var e = (LambdaExpression)expr;  	var b = Convert (e.Body' func);  	var p = Convert (e.Parameters' func);  	return b != e.Body || p != e.Parameters ? Expression.Lambda (ex.Type' b' p.ToArray ()) : expr;  }  case ExpressionType.ListInit: {  	var ex = func (expr);  	if (ex != expr)  		return ex;  	var e = (ListInitExpression)expr;  	var n = Convert (e.NewExpression' func);  	var i = Convert (e.Initializers' p => {  		var args = Convert (p.Arguments' func);  		return args != p.Arguments ? Expression.ElementInit (p.AddMethod' args) : p;  	});  	#if FW3  							return n != e.NewExpression || i != e.Initializers ? 							Expression.ListInit((NewExpression)n' i) : 							expr; #else  	return e.Update ((NewExpression)n' i);  	#endif  }  case ExpressionType.MemberAccess: {  	var exp = func (expr);  	if (exp != expr)  		return exp;  	var e = (MemberExpression)expr;  	var ex = Convert (e.Expression' func);  	#if FW3  							return ex != e.Expression ? Expression.MakeMemberAccess(ex' e.Member) : expr; #else  	return e.Update (ex);  	#endif  }  case ExpressionType.MemberInit: {  	var exp = func (expr);  	if (exp != expr)  		return exp;  	Func<MemberBinding' MemberBinding> modify = null;  	modify = b => {  		switch (b.BindingType) {  		case MemberBindingType.Assignment: {  			var ma = (MemberAssignment)b;  			var ex = Convert (ma.Expression' func);  			if (ex != ma.Expression)  				ma = Expression.Bind (ma.Member' ex);  			return ma;  		}  		case MemberBindingType.ListBinding: {  			var ml = (MemberListBinding)b;  			var i = Convert (ml.Initializers' p => {  				var args = Convert (p.Arguments' func);  				return args != p.Arguments ? Expression.ElementInit (p.AddMethod' args) : p;  			});  			if (i != ml.Initializers)  				ml = Expression.ListBind (ml.Member' i);  			return ml;  		}  		case MemberBindingType.MemberBinding: {  			var mm = (MemberMemberBinding)b;  			var bs = Convert (mm.Bindings' modify);  			if (bs != mm.Bindings)  				mm = Expression.MemberBind (mm.Member);  			return mm;  		}  		}  		return b;  	};  	var e = (MemberInitExpression)expr;  	var ne = Convert (e.NewExpression' func);  	var bb = Convert (e.Bindings' modify);  	#if FW3  							return ne != e.NewExpression || bb != e.Bindings ? 							Expression.MemberInit((NewExpression)ne' bb) : 							expr; #else  	return e.Update ((NewExpression)ne' bb);  	#endif  }  case ExpressionType.New: {  	var ex = func (expr);  	if (ex != expr)  		return ex;  	var e = (NewExpression)expr;  	var a = Convert (e.Arguments' func);  	#if FW3  							return a != e.Arguments ? 							e.Members == null ? 								Expression.New(e.Constructor' a) : 								Expression.New(e.Constructor' a' e.Members) : 							expr; #else  	return e.Update (a);  	#endif  }  case ExpressionType.NewArrayBounds: {  	var exp = func (expr);  	if (exp != expr)  		return exp;  	var e = (NewArrayExpression)expr;  	var ex = Convert (e.Expressions' func);  	#if FW3  							return ex != e.Expressions ? Expression.NewArrayBounds(e.Type' ex) : expr; #else  	return e.Update (ex);  	#endif  }  case ExpressionType.NewArrayInit: {  	var exp = func (expr);  	if (exp != expr)  		return exp;  	var e = (NewArrayExpression)expr;  	var ex = Convert (e.Expressions' func);  	#if FW3  							return ex != e.Expressions ? 							Expression.NewArrayInit(e.Type.GetElementType()' ex) : 							expr; #else  	return e.Update (ex);  	#endif  }  case ExpressionType.TypeIs: {  	var exp = func (expr);  	if (exp != expr)  		return exp;  	var e = (TypeBinaryExpression)expr;  	var ex = Convert (e.Expression' func);  	#if FW3  							return ex != e.Expression ? Expression.TypeIs(ex' e.Type) : expr; #else  	return e.Update (ex);  	#endif  }  #if FW4 || SILVERLIGHT  case ExpressionType.Block: {  	var exp = func (expr);  	if (exp != expr)  		return exp;  	var e = (BlockExpression)expr;  	var ex = Convert (e.Expressions' func);  	var v = Convert (e.Variables' func);  	return e.Update (v' ex);  }  #endif  case ExpressionType.Constant:  	return func (expr);  case ExpressionType.Parameter:  	return func (expr);  case (ExpressionType)ChangeTypeExpression.ChangeTypeType: {  	var exp = func (expr);  	if (exp != expr)  		return exp;  	var e = expr as ChangeTypeExpression;  	var ex = Convert (e.Expression' func);  	if (ex == e.Expression)  		return expr;  	if (ex.Type == e.Type)  		return ex;  	return new ChangeTypeExpression (ex' e.Type);  }  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert,The following switch statement is missing a default case: switch (b.BindingType) {  case MemberBindingType.Assignment: {  	var ma = (MemberAssignment)b;  	var ex = Convert (ma.Expression' func);  	if (ex != ma.Expression)  		ma = Expression.Bind (ma.Member' ex);  	return ma;  }  case MemberBindingType.ListBinding: {  	var ml = (MemberListBinding)b;  	var i = Convert (ml.Initializers' p => {  		var args = Convert (p.Arguments' func);  		return args != p.Arguments ? Expression.ElementInit (p.AddMethod' args) : p;  	});  	if (i != ml.Initializers)  		ml = Expression.ListBind (ml.Member' i);  	return ml;  }  case MemberBindingType.MemberBinding: {  	var mm = (MemberMemberBinding)b;  	var bs = Convert (mm.Bindings' modify);  	if (bs != mm.Bindings)  		mm = Expression.MemberBind (mm.Member);  	return mm;  }  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert2,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.Add:  case ExpressionType.AddChecked:  case ExpressionType.And:  case ExpressionType.AndAlso:  case ExpressionType.ArrayIndex:  #if FW4 || SILVERLIGHT  case ExpressionType.Assign:  #endif  case ExpressionType.Coalesce:  case ExpressionType.Divide:  case ExpressionType.Equal:  case ExpressionType.ExclusiveOr:  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.LeftShift:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual:  case ExpressionType.Modulo:  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  case ExpressionType.NotEqual:  case ExpressionType.Or:  case ExpressionType.OrElse:  case ExpressionType.Power:  case ExpressionType.RightShift:  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as BinaryExpression;  	var c = Convert2 (e.Conversion' func);  	var l = Convert2 (e.Left' func);  	var r = Convert2 (e.Right' func);  	return c != e.Conversion || l != e.Left || r != e.Right ? Expression.MakeBinary (expr.NodeType' l' r' e.IsLiftedToNull' e.Method' (LambdaExpression)c) : expr;  }  case ExpressionType.ArrayLength:  case ExpressionType.Convert:  case ExpressionType.ConvertChecked:  case ExpressionType.Negate:  case ExpressionType.NegateChecked:  case ExpressionType.Not:  case ExpressionType.Quote:  case ExpressionType.TypeAs:  case ExpressionType.UnaryPlus: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as UnaryExpression;  	var o = Convert2 (e.Operand' func);  	return o != e.Operand ? Expression.MakeUnary (expr.NodeType' o' e.Type' e.Method) : expr;  }  case ExpressionType.Call: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as MethodCallExpression;  	var o = Convert2 (e.Object' func);  	var a = Convert2 (e.Arguments' func);  	return o != e.Object || a != e.Arguments ? Expression.Call (o' e.Method' ConvertMethodArguments (a' e.Method)) : expr;  }  case ExpressionType.Conditional: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as ConditionalExpression;  	var s = Convert2 (e.Test' func);  	var t = Convert2 (e.IfTrue' func);  	var f = Convert2 (e.IfFalse' func);  	return s != e.Test || t != e.IfTrue || f != e.IfFalse ? Expression.Condition (s' t' f) : expr;  }  case ExpressionType.Invoke: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as InvocationExpression;  	var ex = Convert2 (e.Expression' func);  	var a = Convert2 (e.Arguments' func);  	return ex != e.Expression || a != e.Arguments ? Expression.Invoke (ex' a) : expr;  }  case ExpressionType.Lambda: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as LambdaExpression;  	var b = Convert2 (e.Body' func);  	var p = Convert2 (e.Parameters' func);  	return b != e.Body || p != e.Parameters ? Expression.Lambda (ci.Expression.Type' b' p.ToArray ()) : expr;  }  case ExpressionType.ListInit: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as ListInitExpression;  	var n = Convert2 (e.NewExpression' func);  	var i = Convert2 (e.Initializers' p => {  		var args = Convert2 (p.Arguments' func);  		return args != p.Arguments ? Expression.ElementInit (p.AddMethod' args) : p;  	});  	return n != e.NewExpression || i != e.Initializers ? Expression.ListInit ((NewExpression)n' i) : expr;  }  case ExpressionType.MemberAccess: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as MemberExpression;  	var ex = Convert2 (e.Expression' func);  	return ex != e.Expression ? Expression.MakeMemberAccess (ex' e.Member) : expr;  }  case ExpressionType.MemberInit: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	Func<MemberBinding' MemberBinding> modify = null;  	modify = b => {  		switch (b.BindingType) {  		case MemberBindingType.Assignment: {  			var ma = (MemberAssignment)b;  			var ex = Convert2 (ma.Expression' func);  			if (ex != ma.Expression) {  				if (ex.Type != ma.Expression.Type) {  					ex = Expression.Convert (ex' ma.Expression.Type);  				}  				ma = Expression.Bind (ma.Member' ex);  			}  			return ma;  		}  		case MemberBindingType.ListBinding: {  			var ml = (MemberListBinding)b;  			var i = Convert (ml.Initializers' p => {  				var args = Convert2 (p.Arguments' func);  				return args != p.Arguments ? Expression.ElementInit (p.AddMethod' args) : p;  			});  			if (i != ml.Initializers)  				ml = Expression.ListBind (ml.Member' i);  			return ml;  		}  		case MemberBindingType.MemberBinding: {  			var mm = (MemberMemberBinding)b;  			var bs = Convert (mm.Bindings' modify);  			if (bs != mm.Bindings)  				mm = Expression.MemberBind (mm.Member);  			return mm;  		}  		}  		return b;  	};  	var e = expr as MemberInitExpression;  	var ne = Convert2 (e.NewExpression' func);  	var bb = Convert2 (e.Bindings' modify);  	return ne != e.NewExpression || bb != e.Bindings ? Expression.MemberInit ((NewExpression)ne' bb) : expr;  }  case ExpressionType.New: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as NewExpression;  	var a = Convert2 (e.Arguments' func);  	return a != e.Arguments ? e.Members == null ? Expression.New (e.Constructor' ConvertMethodArguments (a' e.Constructor)) : Expression.New (e.Constructor' ConvertMethodArguments (a' e.Constructor' e.Members)' e.Members) : expr;  }  case ExpressionType.NewArrayBounds: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as NewArrayExpression;  	var ex = Convert2 (e.Expressions' func);  	return ex != e.Expressions ? Expression.NewArrayBounds (e.Type' ex) : expr;  }  case ExpressionType.NewArrayInit: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as NewArrayExpression;  	var et = e.Type.GetElementType ();  	var ex = Convert2 (e.Expressions' func).Select (ee => et == typeof(object) && ee.Type.IsValueType ? Expression.Convert (ee' typeof(object)) : ee);  	return ex != e.Expressions ? Expression.NewArrayInit (et' ex) : expr;  }  case ExpressionType.TypeIs: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as TypeBinaryExpression;  	var ex = Convert2 (e.Expression' func);  	return ex != e.Expression ? Expression.TypeIs (ex' e.Type) : expr;  }  #if FW4 || SILVERLIGHT  case ExpressionType.Block: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as BlockExpression;  	var ex = Convert2 (e.Expressions' func);  	var v = Convert2 (e.Variables' func);  	return ex != e.Expressions || v != e.Variables ? Expression.Block (e.Type' v' ex) : expr;  }  #endif  case ExpressionType.Constant:  	return func (expr).Expression;  case ExpressionType.Parameter:  	return func (expr).Expression;  case (ExpressionType)ChangeTypeExpression.ChangeTypeType: {  	ci = func (expr);  	if (ci.Stop || ci.Expression != expr)  		return ci.Expression;  	var e = expr as ChangeTypeExpression;  	var ex = Convert2 (e.Expression' func);  	if (ex == e.Expression)  		return expr;  	if (ex.Type == e.Type)  		return ex;  	return new ChangeTypeExpression (ex' e.Type);  }  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Convert2,The following switch statement is missing a default case: switch (b.BindingType) {  case MemberBindingType.Assignment: {  	var ma = (MemberAssignment)b;  	var ex = Convert2 (ma.Expression' func);  	if (ex != ma.Expression) {  		if (ex.Type != ma.Expression.Type) {  			ex = Expression.Convert (ex' ma.Expression.Type);  		}  		ma = Expression.Bind (ma.Member' ex);  	}  	return ma;  }  case MemberBindingType.ListBinding: {  	var ml = (MemberListBinding)b;  	var i = Convert (ml.Initializers' p => {  		var args = Convert2 (p.Arguments' func);  		return args != p.Arguments ? Expression.ElementInit (p.AddMethod' args) : p;  	});  	if (i != ml.Initializers)  		ml = Expression.ListBind (ml.Member' i);  	return ml;  }  case MemberBindingType.MemberBinding: {  	var mm = (MemberMemberBinding)b;  	var bs = Convert (mm.Bindings' modify);  	if (bs != mm.Bindings)  		mm = Expression.MemberBind (mm.Member);  	return mm;  }  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,Unwrap,The following switch statement is missing a default case: switch (ex.NodeType) {  case ExpressionType.Quote:  	return ((UnaryExpression)ex).Operand.Unwrap ();  case ExpressionType.ConvertChecked:  case ExpressionType.Convert: {  	var ue = (UnaryExpression)ex;  	if (!ue.Operand.Type.IsEnum)  		return ue.Operand.Unwrap ();  	break;  }  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,GetExpressionAccessors,The following switch statement is missing a default case: switch (e.NodeType) {  case ExpressionType.Call:  case ExpressionType.MemberAccess:  case ExpressionType.New:  	if (!accessors.ContainsKey (e))  		accessors.Add (e' p);  	break;  case ExpressionType.Constant:  	if (!accessors.ContainsKey (e))  		accessors.Add (e' Expression.Property (p' ReflectionHelper.Constant.Value));  	break;  case ExpressionType.ConvertChecked:  case ExpressionType.Convert:  	if (!accessors.ContainsKey (e)) {  		var ue = (UnaryExpression)e;  		switch (ue.Operand.NodeType) {  		case ExpressionType.Call:  		case ExpressionType.MemberAccess:  		case ExpressionType.New:  		case ExpressionType.Constant:  			accessors.Add (e' p);  			break;  		}  	}  	break;  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,GetExpressionAccessors,The following switch statement is missing a default case: switch (ue.Operand.NodeType) {  case ExpressionType.Call:  case ExpressionType.MemberAccess:  case ExpressionType.New:  case ExpressionType.Constant:  	accessors.Add (e' p);  	break;  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,GetRootObject,The following switch statement is missing a default case: switch (expr.NodeType) {  case ExpressionType.Call: {  	var e = (MethodCallExpression)expr;  	if (e.Object != null)  		return GetRootObject (e.Object);  	if (e.Arguments != null && e.Arguments.Count > 0 && e.IsQueryable ())  		return GetRootObject (e.Arguments [0]);  	if (e.Arguments != null && e.Arguments.Count > 0 && e.Method.GetCustomAttributes (typeof(SqlFunctionAttribute)' true).Length == 0)  		for (int i = 0; i < e.Arguments.Count; i++) {  			var arg = e.Arguments [i];  			if (arg.Type == e.Type)  				return GetRootObject (arg);  		}  	break;  }  case ExpressionType.MemberAccess: {  	var e = (MemberExpression)expr;  	if (e.Expression != null)  		return GetRootObject (e.Expression.Unwrap ());  	break;  }  }  
Missing Default,BLToolkit.Linq,ExpressionHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Linq\ExpressionHelper.cs,FindLevel,The following switch statement is missing a default case: switch (expression.NodeType) {  case ExpressionType.Call: {  	var call = (MethodCallExpression)expression;  	var expr = call.Object;  	if (expr == null && call.IsQueryable () && call.Arguments.Count > 0)  		expr = call.Arguments [0];  	if (expr != null) {  		var ex = FindLevel (expr' level' ref current);  		if (level == current)  			return ex;  		current++;  	}  	break;  }  case ExpressionType.MemberAccess: {  	var e = ((MemberExpression)expression);  	if (e.Expression != null) {  		var expr = FindLevel (e.Expression.Unwrap ()' level' ref current);  		if (level == current)  			return expr;  		current++;  	}  	break;  }  }  
Missing Default,BLToolkit.Mapping,MemberMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,GetDbType,The following switch statement is missing a default case: switch (dataType.SqlDbType) {  case SqlDbType.BigInt:  	return DbType.Int64;  case SqlDbType.Binary:  	return DbType.Binary;  case SqlDbType.Bit:  	return DbType.Boolean;  case SqlDbType.Char:  	return DbType.AnsiStringFixedLength;  case SqlDbType.DateTime:  	return DbType.DateTime;  case SqlDbType.Decimal:  	return DbType.Decimal;  case SqlDbType.Float:  	return DbType.Double;  case SqlDbType.Image:  	return DbType.Binary;  case SqlDbType.Int:  	return DbType.Int32;  case SqlDbType.Money:  	return DbType.Currency;  case SqlDbType.NChar:  	return DbType.StringFixedLength;  case SqlDbType.NText:  	return DbType.String;  case SqlDbType.NVarChar:  	return DbType.String;  case SqlDbType.Real:  	return DbType.Single;  case SqlDbType.UniqueIdentifier:  	return DbType.Guid;  case SqlDbType.SmallDateTime:  	return DbType.DateTime;  case SqlDbType.SmallInt:  	return DbType.Int16;  case SqlDbType.SmallMoney:  	return DbType.Currency;  case SqlDbType.Text:  	return DbType.AnsiString;  case SqlDbType.Timestamp:  	return DbType.Binary;  case SqlDbType.TinyInt:  	return DbType.Byte;  case SqlDbType.VarBinary:  	return DbType.Binary;  case SqlDbType.VarChar:  	return DbType.AnsiString;  case SqlDbType.Variant:  	return DbType.Object;  case SqlDbType.Xml:  	return DbType.Xml;  case SqlDbType.Udt:  	return DbType.Binary;  case SqlDbType.Date:  	return DbType.Date;  case SqlDbType.Time:  	return DbType.Time;  #if !MONO  case SqlDbType.Structured:  	return DbType.Binary;  case SqlDbType.DateTime2:  	return DbType.DateTime2;  case SqlDbType.DateTimeOffset:  	return DbType.DateTimeOffset;  #endif  }  
Missing Default,BLToolkit.Mapping,MemberMapper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MemberMapper.generated.cs,GetDbSize,The following switch statement is missing a default case: switch (dataType.SqlDbType) {  case SqlDbType.BigInt:  	return 0;  case SqlDbType.Binary:  	return 0;  case SqlDbType.Bit:  	return 0;  case SqlDbType.Char:  	return 0;  case SqlDbType.DateTime:  	return 0;  case SqlDbType.Decimal:  	return 0;  case SqlDbType.Float:  	return 0;  case SqlDbType.Image:  	return 0;  case SqlDbType.Int:  	return 0;  case SqlDbType.Money:  	return 0;  case SqlDbType.NChar:  	return 0;  case SqlDbType.NText:  	return 0;  case SqlDbType.NVarChar:  	return 0;  case SqlDbType.Real:  	return 0;  case SqlDbType.UniqueIdentifier:  	return 0;  case SqlDbType.SmallDateTime:  	return 0;  case SqlDbType.SmallInt:  	return 0;  case SqlDbType.SmallMoney:  	return 0;  case SqlDbType.Text:  	return 0;  case SqlDbType.Timestamp:  	return 0;  case SqlDbType.TinyInt:  	return 0;  case SqlDbType.VarBinary:  	return 0;  case SqlDbType.VarChar:  	return 0;  case SqlDbType.Variant:  	return 0;  case SqlDbType.Xml:  	return 0;  case SqlDbType.Udt:  	return 0;  case SqlDbType.Date:  	return 0;  case SqlDbType.Time:  	return 0;  #if !MONO  case SqlDbType.Structured:  	return 0;  case SqlDbType.DateTime2:  	return 0;  case SqlDbType.DateTimeOffset:  	return 0;  #endif  }  
Missing Default,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,GetDefaultNullValue,The following switch statement is missing a default case: switch (Type.GetTypeCode (typeof(T))) {  case TypeCode.Boolean:  	return (T)(object)DefaultBooleanNullValue;  case TypeCode.Byte:  	return (T)(object)DefaultByteNullValue;  case TypeCode.Char:  	return (T)(object)DefaultCharNullValue;  case TypeCode.DateTime:  	return (T)(object)DefaultDateTimeNullValue;  case TypeCode.Decimal:  	return (T)(object)DefaultDecimalNullValue;  case TypeCode.Double:  	return (T)(object)DefaultDoubleNullValue;  case TypeCode.Int16:  	return (T)(object)DefaultInt16NullValue;  case TypeCode.Int32:  	return (T)(object)DefaultInt32NullValue;  case TypeCode.Int64:  	return (T)(object)DefaultInt64NullValue;  case TypeCode.SByte:  	return (T)(object)DefaultSByteNullValue;  case TypeCode.Single:  	return (T)(object)DefaultSingleNullValue;  case TypeCode.String:  	return (T)(object)DefaultStringNullValue;  case TypeCode.UInt16:  	return (T)(object)DefaultUInt16NullValue;  case TypeCode.UInt32:  	return (T)(object)DefaultUInt32NullValue;  case TypeCode.UInt64:  	return (T)(object)DefaultUInt64NullValue;  }  
Missing Default,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertChangeType,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.Boolean:  	return ConvertToNullableBoolean (value);  case TypeCode.Byte:  	return ConvertToNullableByte (value);  case TypeCode.Char:  	return ConvertToNullableChar (value);  case TypeCode.DateTime:  	return ConvertToNullableDateTime (value);  case TypeCode.Decimal:  	return ConvertToNullableDecimal (value);  case TypeCode.Double:  	return ConvertToNullableDouble (value);  case TypeCode.Int16:  	return ConvertToNullableInt16 (value);  case TypeCode.Int32:  	return ConvertToNullableInt32 (value);  case TypeCode.Int64:  	return ConvertToNullableInt64 (value);  case TypeCode.SByte:  	return ConvertToNullableSByte (value);  case TypeCode.Single:  	return ConvertToNullableSingle (value);  case TypeCode.UInt16:  	return ConvertToNullableUInt16 (value);  case TypeCode.UInt32:  	return ConvertToNullableUInt32 (value);  case TypeCode.UInt64:  	return ConvertToNullableUInt64 (value);  }  
Missing Default,BLToolkit.Mapping,MappingSchema,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Mapping\MappingSchema.cs,ConvertChangeType,The following switch statement is missing a default case: switch (Type.GetTypeCode (conversionType)) {  case TypeCode.Boolean:  	return ConvertToBoolean (value);  case TypeCode.Byte:  	return ConvertToByte (value);  case TypeCode.Char:  	return ConvertToChar (value);  case TypeCode.DateTime:  	return ConvertToDateTime (value);  case TypeCode.Decimal:  	return ConvertToDecimal (value);  case TypeCode.Double:  	return ConvertToDouble (value);  case TypeCode.Int16:  	return ConvertToInt16 (value);  case TypeCode.Int32:  	return ConvertToInt32 (value);  case TypeCode.Int64:  	return ConvertToInt64 (value);  case TypeCode.SByte:  	return ConvertToSByte (value);  case TypeCode.Single:  	return ConvertToSingle (value);  case TypeCode.String:  	return ConvertToString (value);  case TypeCode.UInt16:  	return ConvertToUInt16 (value);  case TypeCode.UInt32:  	return ConvertToUInt32 (value);  case TypeCode.UInt64:  	return ConvertToUInt64 (value);  }  
Missing Default,BLToolkit.EditableObjects,EditableXmlDocument,F:\newReposMay17\igor-tkachev_bltoolkit\Source\EditableObjects\EditableXmlDocument.cs,RejectChanges,The following switch statement is missing a default case: switch (nodeTrackBack.Action) {  case XmlNodeChangedAction.Insert:  	if (nodeTrackBack.Node.NodeType == XmlNodeType.Attribute)  		((XmlElement)nodeTrackBack.Value).Attributes.Remove ((XmlAttribute)nodeTrackBack.Node);  	else  		((XmlNode)nodeTrackBack.Value).RemoveChild (nodeTrackBack.Node);  	break;  case XmlNodeChangedAction.Remove:  	// NB: The order of children nodes may change.  	//  	if (nodeTrackBack.Node.NodeType == XmlNodeType.Attribute)  		((XmlElement)nodeTrackBack.Value).Attributes.Append ((XmlAttribute)nodeTrackBack.Node);  	else  		((XmlNode)nodeTrackBack.Value).AppendChild (nodeTrackBack.Node);  	break;  case XmlNodeChangedAction.Change:  	nodeTrackBack.Node.Value = (string)nodeTrackBack.Value;  	break;  }  
Missing Default,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,GetMemberType,The following switch statement is missing a default case: switch (memberInfo.MemberType) {  case MemberTypes.Property:  	return ((PropertyInfo)memberInfo).PropertyType;  case MemberTypes.Field:  	return ((FieldInfo)memberInfo).FieldType;  case MemberTypes.Method:  	return ((MethodInfo)memberInfo).ReturnType;  case MemberTypes.Constructor:  	return ((ConstructorInfo)memberInfo).DeclaringType;  }  
Missing Default,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,IsFloatType,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.Single:  case TypeCode.Double:  case TypeCode.Decimal:  	return true;  }  
Missing Default,BLToolkit.Reflection,TypeHelper,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Reflection\TypeHelper.cs,IsIntegerType,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  case TypeCode.Byte:  case TypeCode.Int16:  case TypeCode.UInt16:  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Int64:  case TypeCode.UInt64:  	return true;  }  
Missing Default,BLToolkit.ServiceModel,ServiceModelDataReader,F:\newReposMay17\igor-tkachev_bltoolkit\Source\ServiceModel\ServiceModelDataReader.cs,GetValue,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.String:  	return value;  case TypeCode.Double:  	return double.Parse (value' CultureInfo.InvariantCulture);  case TypeCode.Decimal:  	return decimal.Parse (value' CultureInfo.InvariantCulture);  case TypeCode.Single:  	return float.Parse (value' CultureInfo.InvariantCulture);  case TypeCode.DateTime:  	return DateTime.Parse (value' CultureInfo.InvariantCulture);  case TypeCode.Object:  	if (type == typeof(double?))  		return double.Parse (value' CultureInfo.InvariantCulture);  	if (type == typeof(decimal?))  		return decimal.Parse (value' CultureInfo.InvariantCulture);  	if (type == typeof(float?))  		return float.Parse (value' CultureInfo.InvariantCulture);  	if (type == typeof(DateTime?))  		return DateTime.Parse (value' CultureInfo.InvariantCulture);  	if (type == typeof(DateTimeOffset) || type == typeof(DateTimeOffset?))  		return DateTimeOffset.Parse (value' CultureInfo.InvariantCulture);  	break;  }  
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step) {  case BuildStep.Begin:  	BeginMethodBuild ();  	return;  case BuildStep.End:  	EndMethodBuild ();  	return;  }  
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.BuildElement) {  case BuildElement.Type:  	switch (context.Step) {  	case BuildStep.Before:  		BeforeBuildType ();  		break;  	case BuildStep.Build:  		BuildType ();  		break;  	case BuildStep.After:  		AfterBuildType ();  		break;  	case BuildStep.Catch:  		CatchBuildType ();  		break;  	case BuildStep.Finally:  		FinallyBuildType ();  		break;  	}  	break;  case BuildElement.AbstractGetter:  	switch (context.Step) {  	case BuildStep.Before:  		BeforeBuildAbstractGetter ();  		break;  	case BuildStep.Build:  		BuildAbstractGetter ();  		break;  	case BuildStep.After:  		AfterBuildAbstractGetter ();  		break;  	case BuildStep.Catch:  		CatchBuildAbstractGetter ();  		break;  	case BuildStep.Finally:  		FinallyBuildAbstractGetter ();  		break;  	}  	break;  case BuildElement.AbstractSetter:  	switch (context.Step) {  	case BuildStep.Before:  		BeforeBuildAbstractSetter ();  		break;  	case BuildStep.Build:  		BuildAbstractSetter ();  		break;  	case BuildStep.After:  		AfterBuildAbstractSetter ();  		break;  	case BuildStep.Catch:  		CatchBuildAbstractSetter ();  		break;  	case BuildStep.Finally:  		FinallyBuildAbstractSetter ();  		break;  	}  	break;  case BuildElement.AbstractMethod:  	switch (context.Step) {  	case BuildStep.Before:  		BeforeBuildAbstractMethod ();  		break;  	case BuildStep.Build:  		BuildAbstractMethod ();  		break;  	case BuildStep.After:  		AfterBuildAbstractMethod ();  		break;  	case BuildStep.Catch:  		CatchBuildAbstractMethod ();  		break;  	case BuildStep.Finally:  		FinallyBuildAbstractMethod ();  		break;  	}  	break;  case BuildElement.VirtualGetter:  	switch (context.Step) {  	case BuildStep.Before:  		BeforeBuildVirtualGetter ();  		break;  	case BuildStep.Build:  		BuildVirtualGetter ();  		break;  	case BuildStep.After:  		AfterBuildVirtualGetter ();  		break;  	case BuildStep.Catch:  		CatchBuildVirtualGetter ();  		break;  	case BuildStep.Finally:  		FinallyBuildVirtualGetter ();  		break;  	}  	break;  case BuildElement.VirtualSetter:  	switch (context.Step) {  	case BuildStep.Before:  		BeforeBuildVirtualSetter ();  		break;  	case BuildStep.Build:  		BuildVirtualSetter ();  		break;  	case BuildStep.After:  		AfterBuildVirtualSetter ();  		break;  	case BuildStep.Catch:  		CatchBuildVirtualSetter ();  		break;  	case BuildStep.Finally:  		FinallyBuildVirtualSetter ();  		break;  	}  	break;  case BuildElement.VirtualMethod:  	switch (context.Step) {  	case BuildStep.Before:  		BeforeBuildVirtualMethod ();  		break;  	case BuildStep.Build:  		BuildVirtualMethod ();  		break;  	case BuildStep.After:  		AfterBuildVirtualMethod ();  		break;  	case BuildStep.Catch:  		CatchBuildVirtualMethod ();  		break;  	case BuildStep.Finally:  		FinallyBuildVirtualMethod ();  		break;  	}  	break;  case BuildElement.InterfaceMethod:  	BuildInterfaceMethod ();  	break;  }  
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step) {  case BuildStep.Before:  	BeforeBuildType ();  	break;  case BuildStep.Build:  	BuildType ();  	break;  case BuildStep.After:  	AfterBuildType ();  	break;  case BuildStep.Catch:  	CatchBuildType ();  	break;  case BuildStep.Finally:  	FinallyBuildType ();  	break;  }  
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step) {  case BuildStep.Before:  	BeforeBuildAbstractGetter ();  	break;  case BuildStep.Build:  	BuildAbstractGetter ();  	break;  case BuildStep.After:  	AfterBuildAbstractGetter ();  	break;  case BuildStep.Catch:  	CatchBuildAbstractGetter ();  	break;  case BuildStep.Finally:  	FinallyBuildAbstractGetter ();  	break;  }  
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step) {  case BuildStep.Before:  	BeforeBuildAbstractSetter ();  	break;  case BuildStep.Build:  	BuildAbstractSetter ();  	break;  case BuildStep.After:  	AfterBuildAbstractSetter ();  	break;  case BuildStep.Catch:  	CatchBuildAbstractSetter ();  	break;  case BuildStep.Finally:  	FinallyBuildAbstractSetter ();  	break;  }  
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step) {  case BuildStep.Before:  	BeforeBuildAbstractMethod ();  	break;  case BuildStep.Build:  	BuildAbstractMethod ();  	break;  case BuildStep.After:  	AfterBuildAbstractMethod ();  	break;  case BuildStep.Catch:  	CatchBuildAbstractMethod ();  	break;  case BuildStep.Finally:  	FinallyBuildAbstractMethod ();  	break;  }  
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step) {  case BuildStep.Before:  	BeforeBuildVirtualGetter ();  	break;  case BuildStep.Build:  	BuildVirtualGetter ();  	break;  case BuildStep.After:  	AfterBuildVirtualGetter ();  	break;  case BuildStep.Catch:  	CatchBuildVirtualGetter ();  	break;  case BuildStep.Finally:  	FinallyBuildVirtualGetter ();  	break;  }  
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step) {  case BuildStep.Before:  	BeforeBuildVirtualSetter ();  	break;  case BuildStep.Build:  	BuildVirtualSetter ();  	break;  case BuildStep.After:  	AfterBuildVirtualSetter ();  	break;  case BuildStep.Catch:  	CatchBuildVirtualSetter ();  	break;  case BuildStep.Finally:  	FinallyBuildVirtualSetter ();  	break;  }  
Missing Default,BLToolkit.TypeBuilder.Builders,AbstractTypeBuilderBase,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\AbstractTypeBuilderBase.cs,Build,The following switch statement is missing a default case: switch (context.Step) {  case BuildStep.Before:  	BeforeBuildVirtualMethod ();  	break;  case BuildStep.Build:  	BuildVirtualMethod ();  	break;  case BuildStep.After:  	AfterBuildVirtualMethod ();  	break;  case BuildStep.Catch:  	CatchBuildVirtualMethod ();  	break;  case BuildStep.Finally:  	FinallyBuildVirtualMethod ();  	break;  }  
Missing Default,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,BuildAbstractGetter,The following switch statement is missing a default case: switch (index.Length) {  case 0:  	Context.MethodBuilder.Emitter.ldarg_0.ldfld (field).stloc (Context.ReturnValue);  	break;  case 1:  	Context.MethodBuilder.Emitter.ldarg_0.ldfld (field).ldarg_1.boxIfValueType (index [0].ParameterType).callvirt (typeof(Dictionary<object' object>)' "get_Item"' typeof(object)).castType (Context.CurrentProperty.PropertyType).stloc (Context.ReturnValue);  	break;  }  
Missing Default,BLToolkit.TypeBuilder.Builders,DefaultTypeBuilder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\TypeBuilder\Builders\DefaultTypeBuilder.cs,BuildAbstractSetter,The following switch statement is missing a default case: switch (index.Length) {  case 0:  	Context.MethodBuilder.Emitter.ldarg_0.ldarg_1.stfld (field);  	//Context.MethodBuilder.Emitter.AddMaxStackSize(6);  	break;  case 1:  	Context.MethodBuilder.Emitter.ldarg_0.ldfld (field).ldarg_1.boxIfValueType (index [0].ParameterType).ldarg_2.boxIfValueType (Context.CurrentProperty.PropertyType).callvirt (typeof(Dictionary<object' object>)' "set_Item"' typeof(object)' typeof(object));  	break;  }  
Missing Default,BLToolkit.Web.UI,WebObjectBinder,F:\newReposMay17\igor-tkachev_bltoolkit\Source\Web\UI\WebObjectBinder.cs,_objectBinder_ListChanged,The following switch statement is missing a default case: switch (e.ListChangedType) {  case ListChangedType.PropertyDescriptorAdded:  case ListChangedType.PropertyDescriptorChanged:  case ListChangedType.PropertyDescriptorDeleted:  	RaiseDataSourceChangedEvent (e);  	break;  }  
