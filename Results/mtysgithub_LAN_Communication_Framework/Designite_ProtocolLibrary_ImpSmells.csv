Implementation smell,Namespace,Class,File,Method,Description
Complex Method,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,Cyclomatic complexity of the method is 12
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,SerializeMessage,The following statement contains a magic number: if (null != content) {  	Buffer.BlockCopy (content' 0' finalMsg' 1 + ConstData.tokenStringLength * 2' content.Length);  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,SerializeMessage,The following statement contains a magic number: Buffer.BlockCopy (content' 0' finalMsg' 1 + ConstData.tokenStringLength * 2' content.Length);  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: switch ((int)msgTypeCodec) {  case ((int)MsgType.ScsRaw_Msg): {  	if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  		byte[] content = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  		Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' content' 0' content.Length);  		retMsg = new ScsRawDataMessage (content);  	}  	else {  		retMsg = new ScsRawDataMessage ();  	}  	((ScsRawDataMessage)retMsg).MessageId = msgId;  	((ScsRawDataMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  case ((int)MsgType.ScsText_Msg): {  	if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  		byte[] bytContent = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  		Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' bytContent' 0' bytContent.Length);  		string content = Encoding.UTF8.GetString (bytContent);  		retMsg = new ScsTextMessage (content);  	}  	else {  		retMsg = new ScsTextMessage ();  	}  	((ScsTextMessage)retMsg).MessageId = msgId;  	((ScsTextMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  case ((int)MsgType.ScsPing_Msg): {  	// N / A  	retMsg = new ScsPingMessage ();  	((ScsPingMessage)retMsg).MessageId = msgId;  	((ScsPingMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  default: {  	throw new NotImplementedException ();  }  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: switch ((int)msgTypeCodec) {  case ((int)MsgType.ScsRaw_Msg): {  	if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  		byte[] content = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  		Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' content' 0' content.Length);  		retMsg = new ScsRawDataMessage (content);  	}  	else {  		retMsg = new ScsRawDataMessage ();  	}  	((ScsRawDataMessage)retMsg).MessageId = msgId;  	((ScsRawDataMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  case ((int)MsgType.ScsText_Msg): {  	if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  		byte[] bytContent = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  		Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' bytContent' 0' bytContent.Length);  		string content = Encoding.UTF8.GetString (bytContent);  		retMsg = new ScsTextMessage (content);  	}  	else {  		retMsg = new ScsTextMessage ();  	}  	((ScsTextMessage)retMsg).MessageId = msgId;  	((ScsTextMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  case ((int)MsgType.ScsPing_Msg): {  	// N / A  	retMsg = new ScsPingMessage ();  	((ScsPingMessage)retMsg).MessageId = msgId;  	((ScsPingMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  default: {  	throw new NotImplementedException ();  }  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: switch ((int)msgTypeCodec) {  case ((int)MsgType.ScsRaw_Msg): {  	if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  		byte[] content = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  		Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' content' 0' content.Length);  		retMsg = new ScsRawDataMessage (content);  	}  	else {  		retMsg = new ScsRawDataMessage ();  	}  	((ScsRawDataMessage)retMsg).MessageId = msgId;  	((ScsRawDataMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  case ((int)MsgType.ScsText_Msg): {  	if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  		byte[] bytContent = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  		Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' bytContent' 0' bytContent.Length);  		string content = Encoding.UTF8.GetString (bytContent);  		retMsg = new ScsTextMessage (content);  	}  	else {  		retMsg = new ScsTextMessage ();  	}  	((ScsTextMessage)retMsg).MessageId = msgId;  	((ScsTextMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  case ((int)MsgType.ScsPing_Msg): {  	// N / A  	retMsg = new ScsPingMessage ();  	((ScsPingMessage)retMsg).MessageId = msgId;  	((ScsPingMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  default: {  	throw new NotImplementedException ();  }  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: switch ((int)msgTypeCodec) {  case ((int)MsgType.ScsRaw_Msg): {  	if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  		byte[] content = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  		Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' content' 0' content.Length);  		retMsg = new ScsRawDataMessage (content);  	}  	else {  		retMsg = new ScsRawDataMessage ();  	}  	((ScsRawDataMessage)retMsg).MessageId = msgId;  	((ScsRawDataMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  case ((int)MsgType.ScsText_Msg): {  	if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  		byte[] bytContent = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  		Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' bytContent' 0' bytContent.Length);  		string content = Encoding.UTF8.GetString (bytContent);  		retMsg = new ScsTextMessage (content);  	}  	else {  		retMsg = new ScsTextMessage ();  	}  	((ScsTextMessage)retMsg).MessageId = msgId;  	((ScsTextMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  case ((int)MsgType.ScsPing_Msg): {  	// N / A  	retMsg = new ScsPingMessage ();  	((ScsPingMessage)retMsg).MessageId = msgId;  	((ScsPingMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  default: {  	throw new NotImplementedException ();  }  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: switch ((int)msgTypeCodec) {  case ((int)MsgType.ScsRaw_Msg): {  	if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  		byte[] content = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  		Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' content' 0' content.Length);  		retMsg = new ScsRawDataMessage (content);  	}  	else {  		retMsg = new ScsRawDataMessage ();  	}  	((ScsRawDataMessage)retMsg).MessageId = msgId;  	((ScsRawDataMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  case ((int)MsgType.ScsText_Msg): {  	if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  		byte[] bytContent = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  		Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' bytContent' 0' bytContent.Length);  		string content = Encoding.UTF8.GetString (bytContent);  		retMsg = new ScsTextMessage (content);  	}  	else {  		retMsg = new ScsTextMessage ();  	}  	((ScsTextMessage)retMsg).MessageId = msgId;  	((ScsTextMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  case ((int)MsgType.ScsPing_Msg): {  	// N / A  	retMsg = new ScsPingMessage ();  	((ScsPingMessage)retMsg).MessageId = msgId;  	((ScsPingMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  default: {  	throw new NotImplementedException ();  }  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: switch ((int)msgTypeCodec) {  case ((int)MsgType.ScsRaw_Msg): {  	if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  		byte[] content = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  		Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' content' 0' content.Length);  		retMsg = new ScsRawDataMessage (content);  	}  	else {  		retMsg = new ScsRawDataMessage ();  	}  	((ScsRawDataMessage)retMsg).MessageId = msgId;  	((ScsRawDataMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  case ((int)MsgType.ScsText_Msg): {  	if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  		byte[] bytContent = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  		Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' bytContent' 0' bytContent.Length);  		string content = Encoding.UTF8.GetString (bytContent);  		retMsg = new ScsTextMessage (content);  	}  	else {  		retMsg = new ScsTextMessage ();  	}  	((ScsTextMessage)retMsg).MessageId = msgId;  	((ScsTextMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  case ((int)MsgType.ScsPing_Msg): {  	// N / A  	retMsg = new ScsPingMessage ();  	((ScsPingMessage)retMsg).MessageId = msgId;  	((ScsPingMessage)retMsg).RepliedMessageId = replyMsgId;  	break;  }  default: {  	throw new NotImplementedException ();  }  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  	byte[] content = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  	Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' content' 0' content.Length);  	retMsg = new ScsRawDataMessage (content);  }  else {  	retMsg = new ScsRawDataMessage ();  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  	byte[] content = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  	Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' content' 0' content.Length);  	retMsg = new ScsRawDataMessage (content);  }  else {  	retMsg = new ScsRawDataMessage ();  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  	byte[] content = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  	Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' content' 0' content.Length);  	retMsg = new ScsRawDataMessage (content);  }  else {  	retMsg = new ScsRawDataMessage ();  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' content' 0' content.Length);  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  	byte[] bytContent = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  	Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' bytContent' 0' bytContent.Length);  	string content = Encoding.UTF8.GetString (bytContent);  	retMsg = new ScsTextMessage (content);  }  else {  	retMsg = new ScsTextMessage ();  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  	byte[] bytContent = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  	Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' bytContent' 0' bytContent.Length);  	string content = Encoding.UTF8.GetString (bytContent);  	retMsg = new ScsTextMessage (content);  }  else {  	retMsg = new ScsTextMessage ();  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: if (0 < bytes.Length - (1 + ConstData.tokenStringLength * 2)) {  	byte[] bytContent = new byte[bytes.Length - (1 + ConstData.tokenStringLength * 2)];  	Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' bytContent' 0' bytContent.Length);  	string content = Encoding.UTF8.GetString (bytContent);  	retMsg = new ScsTextMessage (content);  }  else {  	retMsg = new ScsTextMessage ();  }  
Magic Number,ProtocolLibrary.CSProtocol,MyUnderScsWireProtocol,C:\repos\mtysgithub_LAN_Communication_Framework\ProtocolLibrary\CSProtocol\MyUnderScsWireProtocol.cs,DeserializeMessage,The following statement contains a magic number: Buffer.BlockCopy (bytes' 1 + ConstData.tokenStringLength * 2' bytContent' 0' bytContent.Length);  
