Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The method has 249 lines of code.
Complex Method,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,ServerOprInfoFilter,Cyclomatic complexity of the method is 20
Complex Method,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,Cyclomatic complexity of the method is 54
Long Parameter List,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,GroupSend,The method has 5 parameters.
Long Statement,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The length of the statement  "				string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}"; " is 156.
Long Statement,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The length of the statement  "				string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}"; " is 151.
Long Statement,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The length of the statement  "					string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}"; " is 162.
Long Statement,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The length of the statement  "					string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}"; " is 143.
Long Statement,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The length of the statement  "				string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}"; " is 143.
Long Statement,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The length of the statement  "		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Initialize_UNFINISH" + " ' " + "info:" + "{" + "OperatCodec:" + registContent [0] + "}" + "}"; " is 157.
Long Statement,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,GroupSend,The length of the statement  "			Buffer.BlockCopy (BitConverter.GetBytes ((byte)ClientHeadCodec.GroupTransport)' 0' bytTargetContent' pTargetContentBufOffset' 1); " is 129.
Long Statement,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,Send,The length of the statement  "			Buffer.BlockCopy (BitConverter.GetBytes ((byte)ClientHeadCodec.Transport)' 0' bytTargetContent' pTargetContentBufOffset' 1); " is 124.
Long Statement,Mty.LCF.Server,Program,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Program.cs,Main,The length of the statement  "	if (System.Diagnostics.Process.GetProcessesByName (System.Diagnostics.Process.GetCurrentProcess ().ProcessName).Length < 2) { " is 125.
Long Statement,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The length of the statement  "		AppErrorInfo ret = _server.Send (_token' parmMap ["Token"] as string' parmMap ["Content"] as byte[]' out oprFaildCodec); " is 120.
Long Statement,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The length of the statement  "			string logInfo = "{" + "ret:" + "P2pTransport => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}"; " is 197.
Long Statement,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The length of the statement  "				string logInfo = "{" + "ret:" + "P2pTransport => Target_UNCONNECT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}"; " is 203.
Long Statement,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The length of the statement  "				string logInfo = "{" + "ret:" + "P2pTransport => Token_UNPARSE" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}"; " is 200.
Long Statement,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The length of the statement  "				string logInfo = "{" + "ret:" + "P2pTransport => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}"; " is 203.
Long Statement,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The length of the statement  "				string logInfo = "{" + "ret:" + "CreateGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "group_token:" + token + "}" + "}"; " is 218.
Long Statement,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The length of the statement  "					string logInfo = "{" + "ret:" + "CreateGroup => Detail_REPEAT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}"; " is 196.
Long Statement,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The length of the statement  "					string logInfo = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}"; " is 199.
Long Statement,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The length of the statement  "			string logInfo = "{" + "ret:" + "CreateGroup => Detail_NULL" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}"; " is 194.
Long Statement,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The length of the statement  "			string logInfo = "{" + "ret:" + "JoinGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}"; " is 185.
Long Statement,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The length of the statement  "				string logInfo1 = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}"; " is 194.
Long Statement,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The length of the statement  "			string logInfo2 = "{" + "ret:" + "JoinGroup => JoinGroup_ReplyFaild" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}"; " is 196.
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,Server,The following statement contains a magic number: (this as IServer).Init (10086);  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if ((byte)ServerOprCodec.Initialize == registContent [0]) {  	int bIsRlink = Convert.ToInt32 (registContent [1]);  	if (0 == bIsRlink) {  		byte[] clientDetail = new byte[registContent.Length - 2];  		Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  		string strClientDetail = Encoding.UTF8.GetString (clientDetail);  		if (false == _detailClientMap.ContainsKey (strClientDetail)) {  			string guid = __MakeGuid ();  			BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  			_detailClientMap.Add (strClientDetail' client);  			_tokenClientMap.Add (guid' client);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reply app's token  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//detail repeat.  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		string token = string.Empty;  		if ((2 + ConstData.tokenLength) == registContent.Length) {  			byte[] bytToken = new byte[ConstData.tokenLength];  			Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  			token = Encoding.ASCII.GetString (bytToken);  			if (_tokenClientMap.ContainsKey (token)) {  				BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  				preClient.Relink (tmpServerClient);  				__RemoGlobalClientListener (tmpServerClient);  				_unTypeClientBuff.Remove (tmpServerClient);  				//reRlink sucessful  				byte[] sucReply = new byte[1];  				sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  				tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  				__AddLogItem (logInfo);  			}  			else {  				//重连操作所需Token不存在  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  				errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  				tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  				__AddLogItem (logInfo);  			}  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	return;  }  else {  	//若未进行注册便执行其他操作，则打回错误报文  	IScsServerClient _client = sender as IScsServerClient;  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Initialize_UNFINISH;  	_client.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Initialize_UNFINISH" + " ' " + "info:" + "{" + "OperatCodec:" + registContent [0] + "}" + "}";  	__AddLogItem (logInfo);  	return;  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if ((byte)ServerOprCodec.Initialize == registContent [0]) {  	int bIsRlink = Convert.ToInt32 (registContent [1]);  	if (0 == bIsRlink) {  		byte[] clientDetail = new byte[registContent.Length - 2];  		Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  		string strClientDetail = Encoding.UTF8.GetString (clientDetail);  		if (false == _detailClientMap.ContainsKey (strClientDetail)) {  			string guid = __MakeGuid ();  			BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  			_detailClientMap.Add (strClientDetail' client);  			_tokenClientMap.Add (guid' client);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reply app's token  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//detail repeat.  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		string token = string.Empty;  		if ((2 + ConstData.tokenLength) == registContent.Length) {  			byte[] bytToken = new byte[ConstData.tokenLength];  			Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  			token = Encoding.ASCII.GetString (bytToken);  			if (_tokenClientMap.ContainsKey (token)) {  				BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  				preClient.Relink (tmpServerClient);  				__RemoGlobalClientListener (tmpServerClient);  				_unTypeClientBuff.Remove (tmpServerClient);  				//reRlink sucessful  				byte[] sucReply = new byte[1];  				sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  				tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  				__AddLogItem (logInfo);  			}  			else {  				//重连操作所需Token不存在  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  				errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  				tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  				__AddLogItem (logInfo);  			}  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	return;  }  else {  	//若未进行注册便执行其他操作，则打回错误报文  	IScsServerClient _client = sender as IScsServerClient;  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Initialize_UNFINISH;  	_client.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Initialize_UNFINISH" + " ' " + "info:" + "{" + "OperatCodec:" + registContent [0] + "}" + "}";  	__AddLogItem (logInfo);  	return;  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if ((byte)ServerOprCodec.Initialize == registContent [0]) {  	int bIsRlink = Convert.ToInt32 (registContent [1]);  	if (0 == bIsRlink) {  		byte[] clientDetail = new byte[registContent.Length - 2];  		Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  		string strClientDetail = Encoding.UTF8.GetString (clientDetail);  		if (false == _detailClientMap.ContainsKey (strClientDetail)) {  			string guid = __MakeGuid ();  			BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  			_detailClientMap.Add (strClientDetail' client);  			_tokenClientMap.Add (guid' client);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reply app's token  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//detail repeat.  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		string token = string.Empty;  		if ((2 + ConstData.tokenLength) == registContent.Length) {  			byte[] bytToken = new byte[ConstData.tokenLength];  			Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  			token = Encoding.ASCII.GetString (bytToken);  			if (_tokenClientMap.ContainsKey (token)) {  				BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  				preClient.Relink (tmpServerClient);  				__RemoGlobalClientListener (tmpServerClient);  				_unTypeClientBuff.Remove (tmpServerClient);  				//reRlink sucessful  				byte[] sucReply = new byte[1];  				sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  				tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  				__AddLogItem (logInfo);  			}  			else {  				//重连操作所需Token不存在  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  				errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  				tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  				__AddLogItem (logInfo);  			}  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	return;  }  else {  	//若未进行注册便执行其他操作，则打回错误报文  	IScsServerClient _client = sender as IScsServerClient;  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Initialize_UNFINISH;  	_client.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Initialize_UNFINISH" + " ' " + "info:" + "{" + "OperatCodec:" + registContent [0] + "}" + "}";  	__AddLogItem (logInfo);  	return;  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if ((byte)ServerOprCodec.Initialize == registContent [0]) {  	int bIsRlink = Convert.ToInt32 (registContent [1]);  	if (0 == bIsRlink) {  		byte[] clientDetail = new byte[registContent.Length - 2];  		Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  		string strClientDetail = Encoding.UTF8.GetString (clientDetail);  		if (false == _detailClientMap.ContainsKey (strClientDetail)) {  			string guid = __MakeGuid ();  			BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  			_detailClientMap.Add (strClientDetail' client);  			_tokenClientMap.Add (guid' client);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reply app's token  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//detail repeat.  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		string token = string.Empty;  		if ((2 + ConstData.tokenLength) == registContent.Length) {  			byte[] bytToken = new byte[ConstData.tokenLength];  			Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  			token = Encoding.ASCII.GetString (bytToken);  			if (_tokenClientMap.ContainsKey (token)) {  				BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  				preClient.Relink (tmpServerClient);  				__RemoGlobalClientListener (tmpServerClient);  				_unTypeClientBuff.Remove (tmpServerClient);  				//reRlink sucessful  				byte[] sucReply = new byte[1];  				sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  				tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  				__AddLogItem (logInfo);  			}  			else {  				//重连操作所需Token不存在  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  				errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  				tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  				__AddLogItem (logInfo);  			}  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	return;  }  else {  	//若未进行注册便执行其他操作，则打回错误报文  	IScsServerClient _client = sender as IScsServerClient;  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Initialize_UNFINISH;  	_client.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Initialize_UNFINISH" + " ' " + "info:" + "{" + "OperatCodec:" + registContent [0] + "}" + "}";  	__AddLogItem (logInfo);  	return;  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if ((byte)ServerOprCodec.Initialize == registContent [0]) {  	int bIsRlink = Convert.ToInt32 (registContent [1]);  	if (0 == bIsRlink) {  		byte[] clientDetail = new byte[registContent.Length - 2];  		Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  		string strClientDetail = Encoding.UTF8.GetString (clientDetail);  		if (false == _detailClientMap.ContainsKey (strClientDetail)) {  			string guid = __MakeGuid ();  			BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  			_detailClientMap.Add (strClientDetail' client);  			_tokenClientMap.Add (guid' client);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reply app's token  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//detail repeat.  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		string token = string.Empty;  		if ((2 + ConstData.tokenLength) == registContent.Length) {  			byte[] bytToken = new byte[ConstData.tokenLength];  			Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  			token = Encoding.ASCII.GetString (bytToken);  			if (_tokenClientMap.ContainsKey (token)) {  				BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  				preClient.Relink (tmpServerClient);  				__RemoGlobalClientListener (tmpServerClient);  				_unTypeClientBuff.Remove (tmpServerClient);  				//reRlink sucessful  				byte[] sucReply = new byte[1];  				sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  				tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  				__AddLogItem (logInfo);  			}  			else {  				//重连操作所需Token不存在  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  				errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  				tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  				__AddLogItem (logInfo);  			}  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	return;  }  else {  	//若未进行注册便执行其他操作，则打回错误报文  	IScsServerClient _client = sender as IScsServerClient;  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Initialize_UNFINISH;  	_client.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Initialize_UNFINISH" + " ' " + "info:" + "{" + "OperatCodec:" + registContent [0] + "}" + "}";  	__AddLogItem (logInfo);  	return;  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if ((byte)ServerOprCodec.Initialize == registContent [0]) {  	int bIsRlink = Convert.ToInt32 (registContent [1]);  	if (0 == bIsRlink) {  		byte[] clientDetail = new byte[registContent.Length - 2];  		Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  		string strClientDetail = Encoding.UTF8.GetString (clientDetail);  		if (false == _detailClientMap.ContainsKey (strClientDetail)) {  			string guid = __MakeGuid ();  			BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  			_detailClientMap.Add (strClientDetail' client);  			_tokenClientMap.Add (guid' client);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reply app's token  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//detail repeat.  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		string token = string.Empty;  		if ((2 + ConstData.tokenLength) == registContent.Length) {  			byte[] bytToken = new byte[ConstData.tokenLength];  			Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  			token = Encoding.ASCII.GetString (bytToken);  			if (_tokenClientMap.ContainsKey (token)) {  				BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  				preClient.Relink (tmpServerClient);  				__RemoGlobalClientListener (tmpServerClient);  				_unTypeClientBuff.Remove (tmpServerClient);  				//reRlink sucessful  				byte[] sucReply = new byte[1];  				sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  				tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  				__AddLogItem (logInfo);  			}  			else {  				//重连操作所需Token不存在  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  				errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  				tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  				__AddLogItem (logInfo);  			}  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	return;  }  else {  	//若未进行注册便执行其他操作，则打回错误报文  	IScsServerClient _client = sender as IScsServerClient;  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Initialize_UNFINISH;  	_client.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Initialize_UNFINISH" + " ' " + "info:" + "{" + "OperatCodec:" + registContent [0] + "}" + "}";  	__AddLogItem (logInfo);  	return;  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if ((byte)ServerOprCodec.Initialize == registContent [0]) {  	int bIsRlink = Convert.ToInt32 (registContent [1]);  	if (0 == bIsRlink) {  		byte[] clientDetail = new byte[registContent.Length - 2];  		Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  		string strClientDetail = Encoding.UTF8.GetString (clientDetail);  		if (false == _detailClientMap.ContainsKey (strClientDetail)) {  			string guid = __MakeGuid ();  			BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  			_detailClientMap.Add (strClientDetail' client);  			_tokenClientMap.Add (guid' client);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reply app's token  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//detail repeat.  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		string token = string.Empty;  		if ((2 + ConstData.tokenLength) == registContent.Length) {  			byte[] bytToken = new byte[ConstData.tokenLength];  			Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  			token = Encoding.ASCII.GetString (bytToken);  			if (_tokenClientMap.ContainsKey (token)) {  				BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  				preClient.Relink (tmpServerClient);  				__RemoGlobalClientListener (tmpServerClient);  				_unTypeClientBuff.Remove (tmpServerClient);  				//reRlink sucessful  				byte[] sucReply = new byte[1];  				sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  				tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  				__AddLogItem (logInfo);  			}  			else {  				//重连操作所需Token不存在  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  				errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  				tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  				__AddLogItem (logInfo);  			}  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	return;  }  else {  	//若未进行注册便执行其他操作，则打回错误报文  	IScsServerClient _client = sender as IScsServerClient;  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Initialize_UNFINISH;  	_client.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Initialize_UNFINISH" + " ' " + "info:" + "{" + "OperatCodec:" + registContent [0] + "}" + "}";  	__AddLogItem (logInfo);  	return;  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if ((byte)ServerOprCodec.Initialize == registContent [0]) {  	int bIsRlink = Convert.ToInt32 (registContent [1]);  	if (0 == bIsRlink) {  		byte[] clientDetail = new byte[registContent.Length - 2];  		Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  		string strClientDetail = Encoding.UTF8.GetString (clientDetail);  		if (false == _detailClientMap.ContainsKey (strClientDetail)) {  			string guid = __MakeGuid ();  			BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  			_detailClientMap.Add (strClientDetail' client);  			_tokenClientMap.Add (guid' client);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reply app's token  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//detail repeat.  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		string token = string.Empty;  		if ((2 + ConstData.tokenLength) == registContent.Length) {  			byte[] bytToken = new byte[ConstData.tokenLength];  			Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  			token = Encoding.ASCII.GetString (bytToken);  			if (_tokenClientMap.ContainsKey (token)) {  				BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  				preClient.Relink (tmpServerClient);  				__RemoGlobalClientListener (tmpServerClient);  				_unTypeClientBuff.Remove (tmpServerClient);  				//reRlink sucessful  				byte[] sucReply = new byte[1];  				sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  				tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  				__AddLogItem (logInfo);  			}  			else {  				//重连操作所需Token不存在  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  				errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  				tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  				string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  				__AddLogItem (logInfo);  			}  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	return;  }  else {  	//若未进行注册便执行其他操作，则打回错误报文  	IScsServerClient _client = sender as IScsServerClient;  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Initialize_UNFINISH;  	_client.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Initialize_UNFINISH" + " ' " + "info:" + "{" + "OperatCodec:" + registContent [0] + "}" + "}";  	__AddLogItem (logInfo);  	return;  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if (0 == bIsRlink) {  	byte[] clientDetail = new byte[registContent.Length - 2];  	Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  	string strClientDetail = Encoding.UTF8.GetString (clientDetail);  	if (false == _detailClientMap.ContainsKey (strClientDetail)) {  		string guid = __MakeGuid ();  		BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  		_detailClientMap.Add (strClientDetail' client);  		_tokenClientMap.Add (guid' client);  		__RemoGlobalClientListener (tmpServerClient);  		_unTypeClientBuff.Remove (tmpServerClient);  		//reply app's token  		byte[] sucReply = new byte[1 + ConstData.tokenLength];  		sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  		Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  		tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  		__AddLogItem (logInfo);  	}  	else {  		//detail repeat.  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  		__AddLogItem (logInfo);  	}  }  else {  	string token = string.Empty;  	if ((2 + ConstData.tokenLength) == registContent.Length) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  		token = Encoding.ASCII.GetString (bytToken);  		if (_tokenClientMap.ContainsKey (token)) {  			BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  			preClient.Relink (tmpServerClient);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reRlink sucessful  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		//重连操作所需Token不存在  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  		__AddLogItem (logInfo);  	}  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if (0 == bIsRlink) {  	byte[] clientDetail = new byte[registContent.Length - 2];  	Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  	string strClientDetail = Encoding.UTF8.GetString (clientDetail);  	if (false == _detailClientMap.ContainsKey (strClientDetail)) {  		string guid = __MakeGuid ();  		BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  		_detailClientMap.Add (strClientDetail' client);  		_tokenClientMap.Add (guid' client);  		__RemoGlobalClientListener (tmpServerClient);  		_unTypeClientBuff.Remove (tmpServerClient);  		//reply app's token  		byte[] sucReply = new byte[1 + ConstData.tokenLength];  		sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  		Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  		tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  		__AddLogItem (logInfo);  	}  	else {  		//detail repeat.  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  		__AddLogItem (logInfo);  	}  }  else {  	string token = string.Empty;  	if ((2 + ConstData.tokenLength) == registContent.Length) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  		token = Encoding.ASCII.GetString (bytToken);  		if (_tokenClientMap.ContainsKey (token)) {  			BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  			preClient.Relink (tmpServerClient);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reRlink sucessful  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		//重连操作所需Token不存在  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  		__AddLogItem (logInfo);  	}  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if (0 == bIsRlink) {  	byte[] clientDetail = new byte[registContent.Length - 2];  	Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  	string strClientDetail = Encoding.UTF8.GetString (clientDetail);  	if (false == _detailClientMap.ContainsKey (strClientDetail)) {  		string guid = __MakeGuid ();  		BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  		_detailClientMap.Add (strClientDetail' client);  		_tokenClientMap.Add (guid' client);  		__RemoGlobalClientListener (tmpServerClient);  		_unTypeClientBuff.Remove (tmpServerClient);  		//reply app's token  		byte[] sucReply = new byte[1 + ConstData.tokenLength];  		sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  		Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  		tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  		__AddLogItem (logInfo);  	}  	else {  		//detail repeat.  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  		__AddLogItem (logInfo);  	}  }  else {  	string token = string.Empty;  	if ((2 + ConstData.tokenLength) == registContent.Length) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  		token = Encoding.ASCII.GetString (bytToken);  		if (_tokenClientMap.ContainsKey (token)) {  			BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  			preClient.Relink (tmpServerClient);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reRlink sucessful  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		//重连操作所需Token不存在  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  		__AddLogItem (logInfo);  	}  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if (0 == bIsRlink) {  	byte[] clientDetail = new byte[registContent.Length - 2];  	Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  	string strClientDetail = Encoding.UTF8.GetString (clientDetail);  	if (false == _detailClientMap.ContainsKey (strClientDetail)) {  		string guid = __MakeGuid ();  		BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  		_detailClientMap.Add (strClientDetail' client);  		_tokenClientMap.Add (guid' client);  		__RemoGlobalClientListener (tmpServerClient);  		_unTypeClientBuff.Remove (tmpServerClient);  		//reply app's token  		byte[] sucReply = new byte[1 + ConstData.tokenLength];  		sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  		Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  		tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  		__AddLogItem (logInfo);  	}  	else {  		//detail repeat.  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  		__AddLogItem (logInfo);  	}  }  else {  	string token = string.Empty;  	if ((2 + ConstData.tokenLength) == registContent.Length) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  		token = Encoding.ASCII.GetString (bytToken);  		if (_tokenClientMap.ContainsKey (token)) {  			BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  			preClient.Relink (tmpServerClient);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reRlink sucessful  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		//重连操作所需Token不存在  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  		__AddLogItem (logInfo);  	}  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if (0 == bIsRlink) {  	byte[] clientDetail = new byte[registContent.Length - 2];  	Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  	string strClientDetail = Encoding.UTF8.GetString (clientDetail);  	if (false == _detailClientMap.ContainsKey (strClientDetail)) {  		string guid = __MakeGuid ();  		BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  		_detailClientMap.Add (strClientDetail' client);  		_tokenClientMap.Add (guid' client);  		__RemoGlobalClientListener (tmpServerClient);  		_unTypeClientBuff.Remove (tmpServerClient);  		//reply app's token  		byte[] sucReply = new byte[1 + ConstData.tokenLength];  		sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  		Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  		tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  		__AddLogItem (logInfo);  	}  	else {  		//detail repeat.  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  		__AddLogItem (logInfo);  	}  }  else {  	string token = string.Empty;  	if ((2 + ConstData.tokenLength) == registContent.Length) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  		token = Encoding.ASCII.GetString (bytToken);  		if (_tokenClientMap.ContainsKey (token)) {  			BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  			preClient.Relink (tmpServerClient);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reRlink sucessful  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		//重连操作所需Token不存在  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  		__AddLogItem (logInfo);  	}  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if (0 == bIsRlink) {  	byte[] clientDetail = new byte[registContent.Length - 2];  	Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  	string strClientDetail = Encoding.UTF8.GetString (clientDetail);  	if (false == _detailClientMap.ContainsKey (strClientDetail)) {  		string guid = __MakeGuid ();  		BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  		_detailClientMap.Add (strClientDetail' client);  		_tokenClientMap.Add (guid' client);  		__RemoGlobalClientListener (tmpServerClient);  		_unTypeClientBuff.Remove (tmpServerClient);  		//reply app's token  		byte[] sucReply = new byte[1 + ConstData.tokenLength];  		sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  		Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  		tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  		__AddLogItem (logInfo);  	}  	else {  		//detail repeat.  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  		__AddLogItem (logInfo);  	}  }  else {  	string token = string.Empty;  	if ((2 + ConstData.tokenLength) == registContent.Length) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  		token = Encoding.ASCII.GetString (bytToken);  		if (_tokenClientMap.ContainsKey (token)) {  			BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  			preClient.Relink (tmpServerClient);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reRlink sucessful  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		//重连操作所需Token不存在  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  		__AddLogItem (logInfo);  	}  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if (0 == bIsRlink) {  	byte[] clientDetail = new byte[registContent.Length - 2];  	Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  	string strClientDetail = Encoding.UTF8.GetString (clientDetail);  	if (false == _detailClientMap.ContainsKey (strClientDetail)) {  		string guid = __MakeGuid ();  		BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  		_detailClientMap.Add (strClientDetail' client);  		_tokenClientMap.Add (guid' client);  		__RemoGlobalClientListener (tmpServerClient);  		_unTypeClientBuff.Remove (tmpServerClient);  		//reply app's token  		byte[] sucReply = new byte[1 + ConstData.tokenLength];  		sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  		Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  		tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  		__AddLogItem (logInfo);  	}  	else {  		//detail repeat.  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  		__AddLogItem (logInfo);  	}  }  else {  	string token = string.Empty;  	if ((2 + ConstData.tokenLength) == registContent.Length) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  		token = Encoding.ASCII.GetString (bytToken);  		if (_tokenClientMap.ContainsKey (token)) {  			BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  			preClient.Relink (tmpServerClient);  			__RemoGlobalClientListener (tmpServerClient);  			_unTypeClientBuff.Remove (tmpServerClient);  			//reRlink sucessful  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  			tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  			__AddLogItem (logInfo);  		}  		else {  			//重连操作所需Token不存在  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  			errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  			tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  			string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  			__AddLogItem (logInfo);  		}  	}  	else {  		//重连操作所需Token不存在  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  		__AddLogItem (logInfo);  	}  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: Buffer.BlockCopy (registContent' 2' clientDetail' 0' clientDetail.Length);  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if (false == _detailClientMap.ContainsKey (strClientDetail)) {  	string guid = __MakeGuid ();  	BaseServerClient client = new BaseServerClient (guid' tmpServerClient' this' strClientDetail);  	_detailClientMap.Add (strClientDetail' client);  	_tokenClientMap.Add (guid' client);  	__RemoGlobalClientListener (tmpServerClient);  	_unTypeClientBuff.Remove (tmpServerClient);  	//reply app's token  	byte[] sucReply = new byte[1 + ConstData.tokenLength];  	sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  	Buffer.BlockCopy (Encoding.ASCII.GetBytes (guid)' 0' sucReply' 1' ConstData.tokenLength);  	tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "新的套接字已建立:" + " ' " + "info:" + "{" + "client_detail:" + client.Detail + " ' " + "client_token:" + client.Token + "}" + "}";  	__AddLogItem (logInfo);  }  else {  	//detail repeat.  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Detail_REPEAT;  	tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Detail_REPEAT" + " ' " + "info:" + "{" + "client_detail:" + strClientDetail + "}" + "}";  	__AddLogItem (logInfo);  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if ((2 + ConstData.tokenLength) == registContent.Length) {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  	token = Encoding.ASCII.GetString (bytToken);  	if (_tokenClientMap.ContainsKey (token)) {  		BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  		preClient.Relink (tmpServerClient);  		__RemoGlobalClientListener (tmpServerClient);  		_unTypeClientBuff.Remove (tmpServerClient);  		//reRlink sucessful  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  		tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  		__AddLogItem (logInfo);  	}  	else {  		//重连操作所需Token不存在  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  		__AddLogItem (logInfo);  	}  }  else {  	//重连操作所需Token不存在  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  	tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  	__AddLogItem (logInfo);  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if ((2 + ConstData.tokenLength) == registContent.Length) {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  	token = Encoding.ASCII.GetString (bytToken);  	if (_tokenClientMap.ContainsKey (token)) {  		BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  		preClient.Relink (tmpServerClient);  		__RemoGlobalClientListener (tmpServerClient);  		_unTypeClientBuff.Remove (tmpServerClient);  		//reRlink sucessful  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  		tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  		__AddLogItem (logInfo);  	}  	else {  		//重连操作所需Token不存在  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  		__AddLogItem (logInfo);  	}  }  else {  	//重连操作所需Token不存在  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  	tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  	__AddLogItem (logInfo);  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if ((2 + ConstData.tokenLength) == registContent.Length) {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  	token = Encoding.ASCII.GetString (bytToken);  	if (_tokenClientMap.ContainsKey (token)) {  		BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  		preClient.Relink (tmpServerClient);  		__RemoGlobalClientListener (tmpServerClient);  		_unTypeClientBuff.Remove (tmpServerClient);  		//reRlink sucessful  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  		tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  		__AddLogItem (logInfo);  	}  	else {  		//重连操作所需Token不存在  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  		__AddLogItem (logInfo);  	}  }  else {  	//重连操作所需Token不存在  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  	tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  	__AddLogItem (logInfo);  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if ((2 + ConstData.tokenLength) == registContent.Length) {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  	token = Encoding.ASCII.GetString (bytToken);  	if (_tokenClientMap.ContainsKey (token)) {  		BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  		preClient.Relink (tmpServerClient);  		__RemoGlobalClientListener (tmpServerClient);  		_unTypeClientBuff.Remove (tmpServerClient);  		//reRlink sucessful  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  		tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  		__AddLogItem (logInfo);  	}  	else {  		//重连操作所需Token不存在  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  		errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  		tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  		string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  		__AddLogItem (logInfo);  	}  }  else {  	//重连操作所需Token不存在  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  	tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  	__AddLogItem (logInfo);  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: Buffer.BlockCopy (registContent' 2' bytToken' 0' ConstData.tokenLength);  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,__Global_client_TypeFilter,The following statement contains a magic number: if (_tokenClientMap.ContainsKey (token)) {  	BaseServerClient preClient = _tokenClientMap [token] as BaseServerClient;  	preClient.Relink (tmpServerClient);  	__RemoGlobalClientListener (tmpServerClient);  	_unTypeClientBuff.Remove (tmpServerClient);  	//reRlink sucessful  	byte[] sucReply = new byte[1];  	sucReply [0] = (byte)ClientHeadCodec.Init_ReplySucess;  	tmpServerClient.SendMessage (new ScsRawDataMessage (sucReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "套接字重链接成功:" + " ' " + "info:" + "{" + "client detail:" + preClient.Detail + " ' " + "client_token:" + preClient.Token + "}" + "}";  	__AddLogItem (logInfo);  }  else {  	//重连操作所需Token不存在  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.Init_ReplyFaild;  	errorReply [1] = (byte)InitFaildCodec.Relink_FORBIDDEN;  	tmpServerClient.SendMessage (new ScsRawDataMessage (errorReply' e.Message.MessageId));  	string logInfo = "{" + "ret:" + "__Global_client_TypeFilter => Relink_FORBIDDEN" + " ' " + "info:" + "{" + "client_token:" + token + "}" + "}";  	__AddLogItem (logInfo);  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,GroupSend,The following statement contains a magic number: if (null != dstClient) {  	if (dstClient.Online) {  		byte[] bytTargetContent = new byte[1 + (ConstData.tokenLength * 2) + content.Length];  		int pTargetContentBufOffset = 0;  		//ServerOprCodec  		Buffer.BlockCopy (BitConverter.GetBytes ((byte)ClientHeadCodec.GroupTransport)' 0' bytTargetContent' pTargetContentBufOffset' 1);  		++pTargetContentBufOffset;  		//GroupToken  		byte[] bytSrcGroupToken = Encoding.ASCII.GetBytes (srcGroupToken);  		Buffer.BlockCopy (bytSrcGroupToken' 0' bytTargetContent' pTargetContentBufOffset' ConstData.tokenLength);  		pTargetContentBufOffset += ConstData.tokenLength;  		//ClientToken  		byte[] bytSrcClientToken = Encoding.ASCII.GetBytes (srcClientToken);  		Buffer.BlockCopy (bytSrcClientToken' 0' bytTargetContent' pTargetContentBufOffset' ConstData.tokenLength);  		pTargetContentBufOffset += ConstData.tokenLength;  		//Main Content  		Buffer.BlockCopy (content' 0' bytTargetContent' pTargetContentBufOffset' content.Length);  		pTargetContentBufOffset += content.Length;  		dstClient.Send (bytTargetContent);  		oprFaildCodec = (byte)ClientHeadCodec.P2pTransport_ReplySucess;  		return AppErrorInfo.APP_SUCESS;  	}  	else {  		oprFaildCodec = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  		return AppErrorInfo.APP_FAILD;  	}  }  else {  	oprFaildCodec = (byte)P2pTransportFaildCodec.Token_UNPARSE;  	return AppErrorInfo.APP_FAILD;  }  
Magic Number,Mty.LCF.Server,Server,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Server.cs,GroupSend,The following statement contains a magic number: if (dstClient.Online) {  	byte[] bytTargetContent = new byte[1 + (ConstData.tokenLength * 2) + content.Length];  	int pTargetContentBufOffset = 0;  	//ServerOprCodec  	Buffer.BlockCopy (BitConverter.GetBytes ((byte)ClientHeadCodec.GroupTransport)' 0' bytTargetContent' pTargetContentBufOffset' 1);  	++pTargetContentBufOffset;  	//GroupToken  	byte[] bytSrcGroupToken = Encoding.ASCII.GetBytes (srcGroupToken);  	Buffer.BlockCopy (bytSrcGroupToken' 0' bytTargetContent' pTargetContentBufOffset' ConstData.tokenLength);  	pTargetContentBufOffset += ConstData.tokenLength;  	//ClientToken  	byte[] bytSrcClientToken = Encoding.ASCII.GetBytes (srcClientToken);  	Buffer.BlockCopy (bytSrcClientToken' 0' bytTargetContent' pTargetContentBufOffset' ConstData.tokenLength);  	pTargetContentBufOffset += ConstData.tokenLength;  	//Main Content  	Buffer.BlockCopy (content' 0' bytTargetContent' pTargetContentBufOffset' content.Length);  	pTargetContentBufOffset += content.Length;  	dstClient.Send (bytTargetContent);  	oprFaildCodec = (byte)ClientHeadCodec.P2pTransport_ReplySucess;  	return AppErrorInfo.APP_SUCESS;  }  else {  	oprFaildCodec = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  	return AppErrorInfo.APP_FAILD;  }  
Magic Number,Mty.LCF.Server,Program,C:\repos\mtysgithub_LAN_Communication_Framework\Server\Program.cs,Main,The following statement contains a magic number: if (System.Diagnostics.Process.GetProcessesByName (System.Diagnostics.Process.GetCurrentProcess ().ProcessName).Length < 2) {  	Application.EnableVisualStyles ();  	Application.SetCompatibleTextRenderingDefault (false);  	Form mainForm = new Server ();  	Application.Run (mainForm);  }  else {  	MessageBox.Show ("程序实例已经在运行"' "提示");  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,ServerOprInfoFilter,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	++pSourReadOffset;  	byte[] tmpBuf = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' pSourReadOffset' tmpBuf' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (tmpBuf);  	pSourReadOffset += ConstData.tokenLength;  	//Parse 分发 正文  	byte[] content = new byte[sourMsg.Length - pSourReadOffset];  	Buffer.BlockCopy (sourMsg' pSourReadOffset' content' 0' content.Length);  	pSourReadOffset += content.Length;  	//push parms  	parmMap.Add ("Token"' token);  	parmMap.Add ("Content"' content);  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	if (sourMsg.Length > 1) {  		byte[] bytGropDetail = new byte[sourMsg.Length - 1];  		Buffer.BlockCopy (sourMsg' 1' bytGropDetail' 0' bytGropDetail.Length);  		string strGropDetail = Encoding.UTF8.GetString (bytGropDetail);  		parmMap.Add ("GroupDetail"' strGropDetail);  	}  	else {  		parmMap.Add ("GroupDetail"' string.Empty);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	byte listOrRadioFlag = sourMsg [2];  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2 + 1' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	parmMap.Add ("ClientState"' listOrRadioFlag);  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = new List<string> ();  	int tokensCount = Convert.ToInt32 (sourMsg [1]);  	for (int i = 0; i < tokensCount; ++i) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (sourMsg' 2 + i * ConstData.tokenLength' bytToken' 0' ConstData.tokenLength);  		string token = Encoding.ASCII.GetString (bytToken);  		tokens.Add (token);  	}  	parmMap.Add ("Tokens"' tokens);  	byte[] content = new byte[sourMsg.Length - (2 + tokensCount * ConstData.tokenLength)];  	Buffer.BlockCopy (sourMsg' 2 + (tokensCount * ConstData.tokenLength)' content' 0' content.Length);  	parmMap.Add ("Content"' content);  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	// N/A  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 1' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	// N/A  	break;  }  default: {  	//throw new NotImplementedException();  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,ServerOprInfoFilter,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	++pSourReadOffset;  	byte[] tmpBuf = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' pSourReadOffset' tmpBuf' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (tmpBuf);  	pSourReadOffset += ConstData.tokenLength;  	//Parse 分发 正文  	byte[] content = new byte[sourMsg.Length - pSourReadOffset];  	Buffer.BlockCopy (sourMsg' pSourReadOffset' content' 0' content.Length);  	pSourReadOffset += content.Length;  	//push parms  	parmMap.Add ("Token"' token);  	parmMap.Add ("Content"' content);  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	if (sourMsg.Length > 1) {  		byte[] bytGropDetail = new byte[sourMsg.Length - 1];  		Buffer.BlockCopy (sourMsg' 1' bytGropDetail' 0' bytGropDetail.Length);  		string strGropDetail = Encoding.UTF8.GetString (bytGropDetail);  		parmMap.Add ("GroupDetail"' strGropDetail);  	}  	else {  		parmMap.Add ("GroupDetail"' string.Empty);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	byte listOrRadioFlag = sourMsg [2];  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2 + 1' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	parmMap.Add ("ClientState"' listOrRadioFlag);  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = new List<string> ();  	int tokensCount = Convert.ToInt32 (sourMsg [1]);  	for (int i = 0; i < tokensCount; ++i) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (sourMsg' 2 + i * ConstData.tokenLength' bytToken' 0' ConstData.tokenLength);  		string token = Encoding.ASCII.GetString (bytToken);  		tokens.Add (token);  	}  	parmMap.Add ("Tokens"' tokens);  	byte[] content = new byte[sourMsg.Length - (2 + tokensCount * ConstData.tokenLength)];  	Buffer.BlockCopy (sourMsg' 2 + (tokensCount * ConstData.tokenLength)' content' 0' content.Length);  	parmMap.Add ("Content"' content);  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	// N/A  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 1' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	// N/A  	break;  }  default: {  	//throw new NotImplementedException();  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,ServerOprInfoFilter,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	++pSourReadOffset;  	byte[] tmpBuf = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' pSourReadOffset' tmpBuf' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (tmpBuf);  	pSourReadOffset += ConstData.tokenLength;  	//Parse 分发 正文  	byte[] content = new byte[sourMsg.Length - pSourReadOffset];  	Buffer.BlockCopy (sourMsg' pSourReadOffset' content' 0' content.Length);  	pSourReadOffset += content.Length;  	//push parms  	parmMap.Add ("Token"' token);  	parmMap.Add ("Content"' content);  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	if (sourMsg.Length > 1) {  		byte[] bytGropDetail = new byte[sourMsg.Length - 1];  		Buffer.BlockCopy (sourMsg' 1' bytGropDetail' 0' bytGropDetail.Length);  		string strGropDetail = Encoding.UTF8.GetString (bytGropDetail);  		parmMap.Add ("GroupDetail"' strGropDetail);  	}  	else {  		parmMap.Add ("GroupDetail"' string.Empty);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	byte listOrRadioFlag = sourMsg [2];  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2 + 1' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	parmMap.Add ("ClientState"' listOrRadioFlag);  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = new List<string> ();  	int tokensCount = Convert.ToInt32 (sourMsg [1]);  	for (int i = 0; i < tokensCount; ++i) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (sourMsg' 2 + i * ConstData.tokenLength' bytToken' 0' ConstData.tokenLength);  		string token = Encoding.ASCII.GetString (bytToken);  		tokens.Add (token);  	}  	parmMap.Add ("Tokens"' tokens);  	byte[] content = new byte[sourMsg.Length - (2 + tokensCount * ConstData.tokenLength)];  	Buffer.BlockCopy (sourMsg' 2 + (tokensCount * ConstData.tokenLength)' content' 0' content.Length);  	parmMap.Add ("Content"' content);  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	// N/A  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 1' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	// N/A  	break;  }  default: {  	//throw new NotImplementedException();  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,ServerOprInfoFilter,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	++pSourReadOffset;  	byte[] tmpBuf = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' pSourReadOffset' tmpBuf' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (tmpBuf);  	pSourReadOffset += ConstData.tokenLength;  	//Parse 分发 正文  	byte[] content = new byte[sourMsg.Length - pSourReadOffset];  	Buffer.BlockCopy (sourMsg' pSourReadOffset' content' 0' content.Length);  	pSourReadOffset += content.Length;  	//push parms  	parmMap.Add ("Token"' token);  	parmMap.Add ("Content"' content);  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	if (sourMsg.Length > 1) {  		byte[] bytGropDetail = new byte[sourMsg.Length - 1];  		Buffer.BlockCopy (sourMsg' 1' bytGropDetail' 0' bytGropDetail.Length);  		string strGropDetail = Encoding.UTF8.GetString (bytGropDetail);  		parmMap.Add ("GroupDetail"' strGropDetail);  	}  	else {  		parmMap.Add ("GroupDetail"' string.Empty);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	byte listOrRadioFlag = sourMsg [2];  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2 + 1' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	parmMap.Add ("ClientState"' listOrRadioFlag);  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = new List<string> ();  	int tokensCount = Convert.ToInt32 (sourMsg [1]);  	for (int i = 0; i < tokensCount; ++i) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (sourMsg' 2 + i * ConstData.tokenLength' bytToken' 0' ConstData.tokenLength);  		string token = Encoding.ASCII.GetString (bytToken);  		tokens.Add (token);  	}  	parmMap.Add ("Tokens"' tokens);  	byte[] content = new byte[sourMsg.Length - (2 + tokensCount * ConstData.tokenLength)];  	Buffer.BlockCopy (sourMsg' 2 + (tokensCount * ConstData.tokenLength)' content' 0' content.Length);  	parmMap.Add ("Content"' content);  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	// N/A  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 1' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	// N/A  	break;  }  default: {  	//throw new NotImplementedException();  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,ServerOprInfoFilter,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	++pSourReadOffset;  	byte[] tmpBuf = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' pSourReadOffset' tmpBuf' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (tmpBuf);  	pSourReadOffset += ConstData.tokenLength;  	//Parse 分发 正文  	byte[] content = new byte[sourMsg.Length - pSourReadOffset];  	Buffer.BlockCopy (sourMsg' pSourReadOffset' content' 0' content.Length);  	pSourReadOffset += content.Length;  	//push parms  	parmMap.Add ("Token"' token);  	parmMap.Add ("Content"' content);  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	if (sourMsg.Length > 1) {  		byte[] bytGropDetail = new byte[sourMsg.Length - 1];  		Buffer.BlockCopy (sourMsg' 1' bytGropDetail' 0' bytGropDetail.Length);  		string strGropDetail = Encoding.UTF8.GetString (bytGropDetail);  		parmMap.Add ("GroupDetail"' strGropDetail);  	}  	else {  		parmMap.Add ("GroupDetail"' string.Empty);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	byte listOrRadioFlag = sourMsg [2];  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2 + 1' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	parmMap.Add ("ClientState"' listOrRadioFlag);  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = new List<string> ();  	int tokensCount = Convert.ToInt32 (sourMsg [1]);  	for (int i = 0; i < tokensCount; ++i) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (sourMsg' 2 + i * ConstData.tokenLength' bytToken' 0' ConstData.tokenLength);  		string token = Encoding.ASCII.GetString (bytToken);  		tokens.Add (token);  	}  	parmMap.Add ("Tokens"' tokens);  	byte[] content = new byte[sourMsg.Length - (2 + tokensCount * ConstData.tokenLength)];  	Buffer.BlockCopy (sourMsg' 2 + (tokensCount * ConstData.tokenLength)' content' 0' content.Length);  	parmMap.Add ("Content"' content);  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	// N/A  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 1' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	// N/A  	break;  }  default: {  	//throw new NotImplementedException();  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,ServerOprInfoFilter,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	++pSourReadOffset;  	byte[] tmpBuf = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' pSourReadOffset' tmpBuf' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (tmpBuf);  	pSourReadOffset += ConstData.tokenLength;  	//Parse 分发 正文  	byte[] content = new byte[sourMsg.Length - pSourReadOffset];  	Buffer.BlockCopy (sourMsg' pSourReadOffset' content' 0' content.Length);  	pSourReadOffset += content.Length;  	//push parms  	parmMap.Add ("Token"' token);  	parmMap.Add ("Content"' content);  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	if (sourMsg.Length > 1) {  		byte[] bytGropDetail = new byte[sourMsg.Length - 1];  		Buffer.BlockCopy (sourMsg' 1' bytGropDetail' 0' bytGropDetail.Length);  		string strGropDetail = Encoding.UTF8.GetString (bytGropDetail);  		parmMap.Add ("GroupDetail"' strGropDetail);  	}  	else {  		parmMap.Add ("GroupDetail"' string.Empty);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	byte listOrRadioFlag = sourMsg [2];  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2 + 1' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	parmMap.Add ("ClientState"' listOrRadioFlag);  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = new List<string> ();  	int tokensCount = Convert.ToInt32 (sourMsg [1]);  	for (int i = 0; i < tokensCount; ++i) {  		byte[] bytToken = new byte[ConstData.tokenLength];  		Buffer.BlockCopy (sourMsg' 2 + i * ConstData.tokenLength' bytToken' 0' ConstData.tokenLength);  		string token = Encoding.ASCII.GetString (bytToken);  		tokens.Add (token);  	}  	parmMap.Add ("Tokens"' tokens);  	byte[] content = new byte[sourMsg.Length - (2 + tokensCount * ConstData.tokenLength)];  	Buffer.BlockCopy (sourMsg' 2 + (tokensCount * ConstData.tokenLength)' content' 0' content.Length);  	parmMap.Add ("Content"' content);  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	// N/A  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 1' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	parmMap.Add ("Token"' token);  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	// N/A  	break;  }  default: {  	//throw new NotImplementedException();  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,ServerOprInfoFilter,The following statement contains a magic number: Buffer.BlockCopy (sourMsg' 2 + 1' bytToken' 0' ConstData.tokenLength);  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,ServerOprInfoFilter,The following statement contains a magic number: Buffer.BlockCopy (sourMsg' 2' bytToken' 0' ConstData.tokenLength);  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,ServerOprInfoFilter,The following statement contains a magic number: for (int i = 0; i < tokensCount; ++i) {  	byte[] bytToken = new byte[ConstData.tokenLength];  	Buffer.BlockCopy (sourMsg' 2 + i * ConstData.tokenLength' bytToken' 0' ConstData.tokenLength);  	string token = Encoding.ASCII.GetString (bytToken);  	tokens.Add (token);  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,ServerOprInfoFilter,The following statement contains a magic number: Buffer.BlockCopy (sourMsg' 2 + i * ConstData.tokenLength' bytToken' 0' ConstData.tokenLength);  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,ServerOprInfoFilter,The following statement contains a magic number: Buffer.BlockCopy (sourMsg' 2 + (tokensCount * ConstData.tokenLength)' content' 0' content.Length);  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	byte oprFaildCodec;  	AppErrorInfo ret = _server.Send (_token' parmMap ["Token"] as string' parmMap ["Content"] as byte[]' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		//Reply Suc  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "P2pTransport => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)P2pTransportFaildCodec.Target_UNCONNECT: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Target_UNCONNECT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		case (byte)P2pTransportFaildCodec.Token_UNPARSE: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Token_UNPARSE;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Token_UNPARSE" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		default: {  			string logInfo = "{" + "ret:" + "P2pTransport => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			return;  		}  		}  	}  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	string gropDetail = parmMap ["GroupDetail"] as string;  	if (false == string.IsNullOrEmpty (gropDetail)) {  		string token;  		byte oprFaildCodec;  		AppErrorInfo ret = _server.CreateGroup (gropDetail' out token' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (token)' 0' sucReply' 1' ConstData.tokenLength);  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  			string logInfo = "{" + "ret:" + "CreateGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo);  		}  		else {  			switch (oprFaildCodec) {  			case (byte)CreateGroupFaildCodec.Detail_REPEAT: {  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  				errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  				_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  				string logInfo = "{" + "ret:" + "CreateGroup => Detail_REPEAT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				break;  			}  			default: {  				string logInfo = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				return;  			}  			}  		}  	}  	else {  		//空名称视为非法detail  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  		errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo = "{" + "ret:" + "CreateGroup => Detail_NULL" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	string token = parmMap ["Token"] as string;  	byte listOrRadioFlag = Byte.Parse (parmMap ["ClientState"].ToString ());  	byte oprFaildCodec;  	AppErrorInfo ret = _server.JoinGroup (this' token' listOrRadioFlag' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "JoinGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)JoinGroupFaildCodec.Client_REPEAT: {  			break;  		}  		case (byte)JoinGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			string logInfo1 = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo1);  			return;  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo2 = "{" + "ret:" + "JoinGroup => JoinGroup_ReplyFaild" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo2);  	}  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	string token = parmMap ["Token"] as string;  	byte oprFaildCodec;  	AppErrorInfo ret = _server.ExitGroup (this' token' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  	}  	else {  		switch (oprFaildCodec) {  		case (byte)ExitGroupFaildCodec.Client_UNBELONG: {  			break;  		}  		case (byte)ExitGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			throw new NotImplementedException ();  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	}  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = parmMap ["Tokens"] as List<string>;  	byte[] content = parmMap ["Content"] as byte[];  	foreach (string gropToken in tokens) {  		byte oprFaildCodec;  		AppErrorInfo ret = _server.SendRadioMessage (this' gropToken' content' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplySucess;  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		}  		else {  			switch (oprFaildCodec) {  			case (byte)RadioTransportFaildCodec.Trans_FORBIDDEN: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Client_UNBELONG: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Group_INEXISTANCE: {  				break;  			}  			default: {  				throw new NotImplementedException ();  			}  			}  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	List<Group> grops = Server.Groups;  	List<CSCommunicateClass.GroupInfo> jsonGrops = new List<CSCommunicateClass.GroupInfo> ();  	foreach (Group grop in grops) {  		string token = grop.Token;  		string detail = grop.Detail;  		CSCommunicateClass.GroupInfo gropInfoInst = new CSCommunicateClass.GroupInfo (token' detail);  		jsonGrops.Add (gropInfoInst);  	}  	byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.GroupInfo> (jsonGrops);  	byte[] replyInfo = new byte[1 + bytJson.Length];  	replyInfo [0] = (byte)ClientHeadCodec.GetOnlineGroup_ReplySucess;  	Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  	_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	string gropToken = parmMap ["Token"] as string;  	Group gropInst;  	AppErrorInfo ret = _server.GetGroup (gropToken' out gropInst);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte oprFaildCodec;  		List<CSCommunicateClass.ClientInfo> jsonList;  		AppErrorInfo ret2 = gropInst.GetOnlineClient (_token' out oprFaildCodec' out jsonList);  		if (AppErrorInfo.APP_SUCESS == ret2) {  			byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.ClientInfo> (jsonList);  			byte[] replyInfo = new byte[1 + bytJson.Length];  			replyInfo [0] = (byte)ClientHeadCodec.GetGroupClient_ReplySucess;  			Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  			_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  		}  		else {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	else {  		if (null == gropInst) {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)GetGoupClientFaildCodec.Group_INEXISTENCE;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	byte[] sucReplyInfo = new byte[1];  	sucReplyInfo [0] = (byte)ClientHeadCodec.ClientCancle_ReplySucess;  	_client.SendMessage (new ScsRawDataMessage (sucReplyInfo' sourMessageid));  	this.Cancle ();  	break;  }  default: {  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	byte oprFaildCodec;  	AppErrorInfo ret = _server.Send (_token' parmMap ["Token"] as string' parmMap ["Content"] as byte[]' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		//Reply Suc  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "P2pTransport => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)P2pTransportFaildCodec.Target_UNCONNECT: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Target_UNCONNECT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		case (byte)P2pTransportFaildCodec.Token_UNPARSE: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Token_UNPARSE;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Token_UNPARSE" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		default: {  			string logInfo = "{" + "ret:" + "P2pTransport => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			return;  		}  		}  	}  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	string gropDetail = parmMap ["GroupDetail"] as string;  	if (false == string.IsNullOrEmpty (gropDetail)) {  		string token;  		byte oprFaildCodec;  		AppErrorInfo ret = _server.CreateGroup (gropDetail' out token' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (token)' 0' sucReply' 1' ConstData.tokenLength);  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  			string logInfo = "{" + "ret:" + "CreateGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo);  		}  		else {  			switch (oprFaildCodec) {  			case (byte)CreateGroupFaildCodec.Detail_REPEAT: {  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  				errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  				_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  				string logInfo = "{" + "ret:" + "CreateGroup => Detail_REPEAT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				break;  			}  			default: {  				string logInfo = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				return;  			}  			}  		}  	}  	else {  		//空名称视为非法detail  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  		errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo = "{" + "ret:" + "CreateGroup => Detail_NULL" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	string token = parmMap ["Token"] as string;  	byte listOrRadioFlag = Byte.Parse (parmMap ["ClientState"].ToString ());  	byte oprFaildCodec;  	AppErrorInfo ret = _server.JoinGroup (this' token' listOrRadioFlag' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "JoinGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)JoinGroupFaildCodec.Client_REPEAT: {  			break;  		}  		case (byte)JoinGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			string logInfo1 = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo1);  			return;  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo2 = "{" + "ret:" + "JoinGroup => JoinGroup_ReplyFaild" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo2);  	}  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	string token = parmMap ["Token"] as string;  	byte oprFaildCodec;  	AppErrorInfo ret = _server.ExitGroup (this' token' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  	}  	else {  		switch (oprFaildCodec) {  		case (byte)ExitGroupFaildCodec.Client_UNBELONG: {  			break;  		}  		case (byte)ExitGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			throw new NotImplementedException ();  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	}  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = parmMap ["Tokens"] as List<string>;  	byte[] content = parmMap ["Content"] as byte[];  	foreach (string gropToken in tokens) {  		byte oprFaildCodec;  		AppErrorInfo ret = _server.SendRadioMessage (this' gropToken' content' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplySucess;  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		}  		else {  			switch (oprFaildCodec) {  			case (byte)RadioTransportFaildCodec.Trans_FORBIDDEN: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Client_UNBELONG: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Group_INEXISTANCE: {  				break;  			}  			default: {  				throw new NotImplementedException ();  			}  			}  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	List<Group> grops = Server.Groups;  	List<CSCommunicateClass.GroupInfo> jsonGrops = new List<CSCommunicateClass.GroupInfo> ();  	foreach (Group grop in grops) {  		string token = grop.Token;  		string detail = grop.Detail;  		CSCommunicateClass.GroupInfo gropInfoInst = new CSCommunicateClass.GroupInfo (token' detail);  		jsonGrops.Add (gropInfoInst);  	}  	byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.GroupInfo> (jsonGrops);  	byte[] replyInfo = new byte[1 + bytJson.Length];  	replyInfo [0] = (byte)ClientHeadCodec.GetOnlineGroup_ReplySucess;  	Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  	_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	string gropToken = parmMap ["Token"] as string;  	Group gropInst;  	AppErrorInfo ret = _server.GetGroup (gropToken' out gropInst);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte oprFaildCodec;  		List<CSCommunicateClass.ClientInfo> jsonList;  		AppErrorInfo ret2 = gropInst.GetOnlineClient (_token' out oprFaildCodec' out jsonList);  		if (AppErrorInfo.APP_SUCESS == ret2) {  			byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.ClientInfo> (jsonList);  			byte[] replyInfo = new byte[1 + bytJson.Length];  			replyInfo [0] = (byte)ClientHeadCodec.GetGroupClient_ReplySucess;  			Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  			_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  		}  		else {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	else {  		if (null == gropInst) {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)GetGoupClientFaildCodec.Group_INEXISTENCE;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	byte[] sucReplyInfo = new byte[1];  	sucReplyInfo [0] = (byte)ClientHeadCodec.ClientCancle_ReplySucess;  	_client.SendMessage (new ScsRawDataMessage (sucReplyInfo' sourMessageid));  	this.Cancle ();  	break;  }  default: {  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	byte oprFaildCodec;  	AppErrorInfo ret = _server.Send (_token' parmMap ["Token"] as string' parmMap ["Content"] as byte[]' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		//Reply Suc  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "P2pTransport => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)P2pTransportFaildCodec.Target_UNCONNECT: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Target_UNCONNECT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		case (byte)P2pTransportFaildCodec.Token_UNPARSE: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Token_UNPARSE;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Token_UNPARSE" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		default: {  			string logInfo = "{" + "ret:" + "P2pTransport => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			return;  		}  		}  	}  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	string gropDetail = parmMap ["GroupDetail"] as string;  	if (false == string.IsNullOrEmpty (gropDetail)) {  		string token;  		byte oprFaildCodec;  		AppErrorInfo ret = _server.CreateGroup (gropDetail' out token' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (token)' 0' sucReply' 1' ConstData.tokenLength);  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  			string logInfo = "{" + "ret:" + "CreateGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo);  		}  		else {  			switch (oprFaildCodec) {  			case (byte)CreateGroupFaildCodec.Detail_REPEAT: {  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  				errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  				_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  				string logInfo = "{" + "ret:" + "CreateGroup => Detail_REPEAT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				break;  			}  			default: {  				string logInfo = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				return;  			}  			}  		}  	}  	else {  		//空名称视为非法detail  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  		errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo = "{" + "ret:" + "CreateGroup => Detail_NULL" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	string token = parmMap ["Token"] as string;  	byte listOrRadioFlag = Byte.Parse (parmMap ["ClientState"].ToString ());  	byte oprFaildCodec;  	AppErrorInfo ret = _server.JoinGroup (this' token' listOrRadioFlag' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "JoinGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)JoinGroupFaildCodec.Client_REPEAT: {  			break;  		}  		case (byte)JoinGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			string logInfo1 = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo1);  			return;  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo2 = "{" + "ret:" + "JoinGroup => JoinGroup_ReplyFaild" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo2);  	}  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	string token = parmMap ["Token"] as string;  	byte oprFaildCodec;  	AppErrorInfo ret = _server.ExitGroup (this' token' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  	}  	else {  		switch (oprFaildCodec) {  		case (byte)ExitGroupFaildCodec.Client_UNBELONG: {  			break;  		}  		case (byte)ExitGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			throw new NotImplementedException ();  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	}  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = parmMap ["Tokens"] as List<string>;  	byte[] content = parmMap ["Content"] as byte[];  	foreach (string gropToken in tokens) {  		byte oprFaildCodec;  		AppErrorInfo ret = _server.SendRadioMessage (this' gropToken' content' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplySucess;  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		}  		else {  			switch (oprFaildCodec) {  			case (byte)RadioTransportFaildCodec.Trans_FORBIDDEN: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Client_UNBELONG: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Group_INEXISTANCE: {  				break;  			}  			default: {  				throw new NotImplementedException ();  			}  			}  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	List<Group> grops = Server.Groups;  	List<CSCommunicateClass.GroupInfo> jsonGrops = new List<CSCommunicateClass.GroupInfo> ();  	foreach (Group grop in grops) {  		string token = grop.Token;  		string detail = grop.Detail;  		CSCommunicateClass.GroupInfo gropInfoInst = new CSCommunicateClass.GroupInfo (token' detail);  		jsonGrops.Add (gropInfoInst);  	}  	byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.GroupInfo> (jsonGrops);  	byte[] replyInfo = new byte[1 + bytJson.Length];  	replyInfo [0] = (byte)ClientHeadCodec.GetOnlineGroup_ReplySucess;  	Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  	_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	string gropToken = parmMap ["Token"] as string;  	Group gropInst;  	AppErrorInfo ret = _server.GetGroup (gropToken' out gropInst);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte oprFaildCodec;  		List<CSCommunicateClass.ClientInfo> jsonList;  		AppErrorInfo ret2 = gropInst.GetOnlineClient (_token' out oprFaildCodec' out jsonList);  		if (AppErrorInfo.APP_SUCESS == ret2) {  			byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.ClientInfo> (jsonList);  			byte[] replyInfo = new byte[1 + bytJson.Length];  			replyInfo [0] = (byte)ClientHeadCodec.GetGroupClient_ReplySucess;  			Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  			_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  		}  		else {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	else {  		if (null == gropInst) {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)GetGoupClientFaildCodec.Group_INEXISTENCE;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	byte[] sucReplyInfo = new byte[1];  	sucReplyInfo [0] = (byte)ClientHeadCodec.ClientCancle_ReplySucess;  	_client.SendMessage (new ScsRawDataMessage (sucReplyInfo' sourMessageid));  	this.Cancle ();  	break;  }  default: {  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	byte oprFaildCodec;  	AppErrorInfo ret = _server.Send (_token' parmMap ["Token"] as string' parmMap ["Content"] as byte[]' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		//Reply Suc  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "P2pTransport => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)P2pTransportFaildCodec.Target_UNCONNECT: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Target_UNCONNECT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		case (byte)P2pTransportFaildCodec.Token_UNPARSE: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Token_UNPARSE;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Token_UNPARSE" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		default: {  			string logInfo = "{" + "ret:" + "P2pTransport => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			return;  		}  		}  	}  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	string gropDetail = parmMap ["GroupDetail"] as string;  	if (false == string.IsNullOrEmpty (gropDetail)) {  		string token;  		byte oprFaildCodec;  		AppErrorInfo ret = _server.CreateGroup (gropDetail' out token' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (token)' 0' sucReply' 1' ConstData.tokenLength);  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  			string logInfo = "{" + "ret:" + "CreateGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo);  		}  		else {  			switch (oprFaildCodec) {  			case (byte)CreateGroupFaildCodec.Detail_REPEAT: {  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  				errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  				_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  				string logInfo = "{" + "ret:" + "CreateGroup => Detail_REPEAT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				break;  			}  			default: {  				string logInfo = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				return;  			}  			}  		}  	}  	else {  		//空名称视为非法detail  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  		errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo = "{" + "ret:" + "CreateGroup => Detail_NULL" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	string token = parmMap ["Token"] as string;  	byte listOrRadioFlag = Byte.Parse (parmMap ["ClientState"].ToString ());  	byte oprFaildCodec;  	AppErrorInfo ret = _server.JoinGroup (this' token' listOrRadioFlag' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "JoinGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)JoinGroupFaildCodec.Client_REPEAT: {  			break;  		}  		case (byte)JoinGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			string logInfo1 = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo1);  			return;  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo2 = "{" + "ret:" + "JoinGroup => JoinGroup_ReplyFaild" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo2);  	}  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	string token = parmMap ["Token"] as string;  	byte oprFaildCodec;  	AppErrorInfo ret = _server.ExitGroup (this' token' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  	}  	else {  		switch (oprFaildCodec) {  		case (byte)ExitGroupFaildCodec.Client_UNBELONG: {  			break;  		}  		case (byte)ExitGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			throw new NotImplementedException ();  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	}  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = parmMap ["Tokens"] as List<string>;  	byte[] content = parmMap ["Content"] as byte[];  	foreach (string gropToken in tokens) {  		byte oprFaildCodec;  		AppErrorInfo ret = _server.SendRadioMessage (this' gropToken' content' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplySucess;  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		}  		else {  			switch (oprFaildCodec) {  			case (byte)RadioTransportFaildCodec.Trans_FORBIDDEN: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Client_UNBELONG: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Group_INEXISTANCE: {  				break;  			}  			default: {  				throw new NotImplementedException ();  			}  			}  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	List<Group> grops = Server.Groups;  	List<CSCommunicateClass.GroupInfo> jsonGrops = new List<CSCommunicateClass.GroupInfo> ();  	foreach (Group grop in grops) {  		string token = grop.Token;  		string detail = grop.Detail;  		CSCommunicateClass.GroupInfo gropInfoInst = new CSCommunicateClass.GroupInfo (token' detail);  		jsonGrops.Add (gropInfoInst);  	}  	byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.GroupInfo> (jsonGrops);  	byte[] replyInfo = new byte[1 + bytJson.Length];  	replyInfo [0] = (byte)ClientHeadCodec.GetOnlineGroup_ReplySucess;  	Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  	_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	string gropToken = parmMap ["Token"] as string;  	Group gropInst;  	AppErrorInfo ret = _server.GetGroup (gropToken' out gropInst);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte oprFaildCodec;  		List<CSCommunicateClass.ClientInfo> jsonList;  		AppErrorInfo ret2 = gropInst.GetOnlineClient (_token' out oprFaildCodec' out jsonList);  		if (AppErrorInfo.APP_SUCESS == ret2) {  			byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.ClientInfo> (jsonList);  			byte[] replyInfo = new byte[1 + bytJson.Length];  			replyInfo [0] = (byte)ClientHeadCodec.GetGroupClient_ReplySucess;  			Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  			_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  		}  		else {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	else {  		if (null == gropInst) {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)GetGoupClientFaildCodec.Group_INEXISTENCE;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	byte[] sucReplyInfo = new byte[1];  	sucReplyInfo [0] = (byte)ClientHeadCodec.ClientCancle_ReplySucess;  	_client.SendMessage (new ScsRawDataMessage (sucReplyInfo' sourMessageid));  	this.Cancle ();  	break;  }  default: {  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	byte oprFaildCodec;  	AppErrorInfo ret = _server.Send (_token' parmMap ["Token"] as string' parmMap ["Content"] as byte[]' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		//Reply Suc  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "P2pTransport => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)P2pTransportFaildCodec.Target_UNCONNECT: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Target_UNCONNECT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		case (byte)P2pTransportFaildCodec.Token_UNPARSE: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Token_UNPARSE;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Token_UNPARSE" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		default: {  			string logInfo = "{" + "ret:" + "P2pTransport => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			return;  		}  		}  	}  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	string gropDetail = parmMap ["GroupDetail"] as string;  	if (false == string.IsNullOrEmpty (gropDetail)) {  		string token;  		byte oprFaildCodec;  		AppErrorInfo ret = _server.CreateGroup (gropDetail' out token' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (token)' 0' sucReply' 1' ConstData.tokenLength);  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  			string logInfo = "{" + "ret:" + "CreateGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo);  		}  		else {  			switch (oprFaildCodec) {  			case (byte)CreateGroupFaildCodec.Detail_REPEAT: {  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  				errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  				_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  				string logInfo = "{" + "ret:" + "CreateGroup => Detail_REPEAT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				break;  			}  			default: {  				string logInfo = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				return;  			}  			}  		}  	}  	else {  		//空名称视为非法detail  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  		errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo = "{" + "ret:" + "CreateGroup => Detail_NULL" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	string token = parmMap ["Token"] as string;  	byte listOrRadioFlag = Byte.Parse (parmMap ["ClientState"].ToString ());  	byte oprFaildCodec;  	AppErrorInfo ret = _server.JoinGroup (this' token' listOrRadioFlag' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "JoinGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)JoinGroupFaildCodec.Client_REPEAT: {  			break;  		}  		case (byte)JoinGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			string logInfo1 = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo1);  			return;  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo2 = "{" + "ret:" + "JoinGroup => JoinGroup_ReplyFaild" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo2);  	}  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	string token = parmMap ["Token"] as string;  	byte oprFaildCodec;  	AppErrorInfo ret = _server.ExitGroup (this' token' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  	}  	else {  		switch (oprFaildCodec) {  		case (byte)ExitGroupFaildCodec.Client_UNBELONG: {  			break;  		}  		case (byte)ExitGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			throw new NotImplementedException ();  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	}  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = parmMap ["Tokens"] as List<string>;  	byte[] content = parmMap ["Content"] as byte[];  	foreach (string gropToken in tokens) {  		byte oprFaildCodec;  		AppErrorInfo ret = _server.SendRadioMessage (this' gropToken' content' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplySucess;  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		}  		else {  			switch (oprFaildCodec) {  			case (byte)RadioTransportFaildCodec.Trans_FORBIDDEN: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Client_UNBELONG: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Group_INEXISTANCE: {  				break;  			}  			default: {  				throw new NotImplementedException ();  			}  			}  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	List<Group> grops = Server.Groups;  	List<CSCommunicateClass.GroupInfo> jsonGrops = new List<CSCommunicateClass.GroupInfo> ();  	foreach (Group grop in grops) {  		string token = grop.Token;  		string detail = grop.Detail;  		CSCommunicateClass.GroupInfo gropInfoInst = new CSCommunicateClass.GroupInfo (token' detail);  		jsonGrops.Add (gropInfoInst);  	}  	byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.GroupInfo> (jsonGrops);  	byte[] replyInfo = new byte[1 + bytJson.Length];  	replyInfo [0] = (byte)ClientHeadCodec.GetOnlineGroup_ReplySucess;  	Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  	_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	string gropToken = parmMap ["Token"] as string;  	Group gropInst;  	AppErrorInfo ret = _server.GetGroup (gropToken' out gropInst);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte oprFaildCodec;  		List<CSCommunicateClass.ClientInfo> jsonList;  		AppErrorInfo ret2 = gropInst.GetOnlineClient (_token' out oprFaildCodec' out jsonList);  		if (AppErrorInfo.APP_SUCESS == ret2) {  			byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.ClientInfo> (jsonList);  			byte[] replyInfo = new byte[1 + bytJson.Length];  			replyInfo [0] = (byte)ClientHeadCodec.GetGroupClient_ReplySucess;  			Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  			_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  		}  		else {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	else {  		if (null == gropInst) {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)GetGoupClientFaildCodec.Group_INEXISTENCE;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	byte[] sucReplyInfo = new byte[1];  	sucReplyInfo [0] = (byte)ClientHeadCodec.ClientCancle_ReplySucess;  	_client.SendMessage (new ScsRawDataMessage (sucReplyInfo' sourMessageid));  	this.Cancle ();  	break;  }  default: {  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	byte oprFaildCodec;  	AppErrorInfo ret = _server.Send (_token' parmMap ["Token"] as string' parmMap ["Content"] as byte[]' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		//Reply Suc  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "P2pTransport => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)P2pTransportFaildCodec.Target_UNCONNECT: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Target_UNCONNECT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		case (byte)P2pTransportFaildCodec.Token_UNPARSE: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Token_UNPARSE;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Token_UNPARSE" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		default: {  			string logInfo = "{" + "ret:" + "P2pTransport => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			return;  		}  		}  	}  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	string gropDetail = parmMap ["GroupDetail"] as string;  	if (false == string.IsNullOrEmpty (gropDetail)) {  		string token;  		byte oprFaildCodec;  		AppErrorInfo ret = _server.CreateGroup (gropDetail' out token' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (token)' 0' sucReply' 1' ConstData.tokenLength);  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  			string logInfo = "{" + "ret:" + "CreateGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo);  		}  		else {  			switch (oprFaildCodec) {  			case (byte)CreateGroupFaildCodec.Detail_REPEAT: {  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  				errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  				_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  				string logInfo = "{" + "ret:" + "CreateGroup => Detail_REPEAT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				break;  			}  			default: {  				string logInfo = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				return;  			}  			}  		}  	}  	else {  		//空名称视为非法detail  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  		errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo = "{" + "ret:" + "CreateGroup => Detail_NULL" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	string token = parmMap ["Token"] as string;  	byte listOrRadioFlag = Byte.Parse (parmMap ["ClientState"].ToString ());  	byte oprFaildCodec;  	AppErrorInfo ret = _server.JoinGroup (this' token' listOrRadioFlag' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "JoinGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)JoinGroupFaildCodec.Client_REPEAT: {  			break;  		}  		case (byte)JoinGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			string logInfo1 = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo1);  			return;  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo2 = "{" + "ret:" + "JoinGroup => JoinGroup_ReplyFaild" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo2);  	}  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	string token = parmMap ["Token"] as string;  	byte oprFaildCodec;  	AppErrorInfo ret = _server.ExitGroup (this' token' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  	}  	else {  		switch (oprFaildCodec) {  		case (byte)ExitGroupFaildCodec.Client_UNBELONG: {  			break;  		}  		case (byte)ExitGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			throw new NotImplementedException ();  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	}  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = parmMap ["Tokens"] as List<string>;  	byte[] content = parmMap ["Content"] as byte[];  	foreach (string gropToken in tokens) {  		byte oprFaildCodec;  		AppErrorInfo ret = _server.SendRadioMessage (this' gropToken' content' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplySucess;  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		}  		else {  			switch (oprFaildCodec) {  			case (byte)RadioTransportFaildCodec.Trans_FORBIDDEN: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Client_UNBELONG: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Group_INEXISTANCE: {  				break;  			}  			default: {  				throw new NotImplementedException ();  			}  			}  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	List<Group> grops = Server.Groups;  	List<CSCommunicateClass.GroupInfo> jsonGrops = new List<CSCommunicateClass.GroupInfo> ();  	foreach (Group grop in grops) {  		string token = grop.Token;  		string detail = grop.Detail;  		CSCommunicateClass.GroupInfo gropInfoInst = new CSCommunicateClass.GroupInfo (token' detail);  		jsonGrops.Add (gropInfoInst);  	}  	byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.GroupInfo> (jsonGrops);  	byte[] replyInfo = new byte[1 + bytJson.Length];  	replyInfo [0] = (byte)ClientHeadCodec.GetOnlineGroup_ReplySucess;  	Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  	_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	string gropToken = parmMap ["Token"] as string;  	Group gropInst;  	AppErrorInfo ret = _server.GetGroup (gropToken' out gropInst);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte oprFaildCodec;  		List<CSCommunicateClass.ClientInfo> jsonList;  		AppErrorInfo ret2 = gropInst.GetOnlineClient (_token' out oprFaildCodec' out jsonList);  		if (AppErrorInfo.APP_SUCESS == ret2) {  			byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.ClientInfo> (jsonList);  			byte[] replyInfo = new byte[1 + bytJson.Length];  			replyInfo [0] = (byte)ClientHeadCodec.GetGroupClient_ReplySucess;  			Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  			_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  		}  		else {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	else {  		if (null == gropInst) {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)GetGoupClientFaildCodec.Group_INEXISTENCE;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	byte[] sucReplyInfo = new byte[1];  	sucReplyInfo [0] = (byte)ClientHeadCodec.ClientCancle_ReplySucess;  	_client.SendMessage (new ScsRawDataMessage (sucReplyInfo' sourMessageid));  	this.Cancle ();  	break;  }  default: {  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: switch (oprCodec) {  case (int)ServerOprCodec.P2pTransport: {  	byte oprFaildCodec;  	AppErrorInfo ret = _server.Send (_token' parmMap ["Token"] as string' parmMap ["Content"] as byte[]' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		//Reply Suc  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "P2pTransport => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)P2pTransportFaildCodec.Target_UNCONNECT: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Target_UNCONNECT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		case (byte)P2pTransportFaildCodec.Token_UNPARSE: {  			//向源头打回错误报文  			byte[] erroReply = new byte[2];  			erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  			erroReply [1] = (byte)P2pTransportFaildCodec.Token_UNPARSE;  			_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  			string logInfo = "{" + "ret:" + "P2pTransport => Token_UNPARSE" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		default: {  			string logInfo = "{" + "ret:" + "P2pTransport => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  			_server.__AddLogItem (logInfo);  			return;  		}  		}  	}  	break;  }  case (int)ServerOprCodec.CreateGroup: {  	string gropDetail = parmMap ["GroupDetail"] as string;  	if (false == string.IsNullOrEmpty (gropDetail)) {  		string token;  		byte oprFaildCodec;  		AppErrorInfo ret = _server.CreateGroup (gropDetail' out token' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1 + ConstData.tokenLength];  			sucReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplySucess;  			Buffer.BlockCopy (Encoding.ASCII.GetBytes (token)' 0' sucReply' 1' ConstData.tokenLength);  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  			string logInfo = "{" + "ret:" + "CreateGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo);  		}  		else {  			switch (oprFaildCodec) {  			case (byte)CreateGroupFaildCodec.Detail_REPEAT: {  				byte[] errorReply = new byte[2];  				errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  				errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  				_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  				string logInfo = "{" + "ret:" + "CreateGroup => Detail_REPEAT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				break;  			}  			default: {  				string logInfo = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  				_server.__AddLogItem (logInfo);  				return;  			}  			}  		}  	}  	else {  		//空名称视为非法detail  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  		errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo = "{" + "ret:" + "CreateGroup => Detail_NULL" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	break;  }  case (int)ServerOprCodec.JoinGroup: {  	string token = parmMap ["Token"] as string;  	byte listOrRadioFlag = Byte.Parse (parmMap ["ClientState"].ToString ());  	byte oprFaildCodec;  	AppErrorInfo ret = _server.JoinGroup (this' token' listOrRadioFlag' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "JoinGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)JoinGroupFaildCodec.Client_REPEAT: {  			break;  		}  		case (byte)JoinGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			string logInfo1 = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  			_server.__AddLogItem (logInfo1);  			return;  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.JoinGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo2 = "{" + "ret:" + "JoinGroup => JoinGroup_ReplyFaild" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo2);  	}  	break;  }  case (int)ServerOprCodec.ExitGroup: {  	string token = parmMap ["Token"] as string;  	byte oprFaildCodec;  	AppErrorInfo ret = _server.ExitGroup (this' token' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  	}  	else {  		switch (oprFaildCodec) {  		case (byte)ExitGroupFaildCodec.Client_UNBELONG: {  			break;  		}  		case (byte)ExitGroupFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			throw new NotImplementedException ();  		}  		}  		byte[] errorReply = new byte[1 + 1];  		errorReply [0] = (byte)ClientHeadCodec.ExitGroup_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	}  	break;  }  case (int)ServerOprCodec.RadioTransport: {  	List<string> tokens = parmMap ["Tokens"] as List<string>;  	byte[] content = parmMap ["Content"] as byte[];  	foreach (string gropToken in tokens) {  		byte oprFaildCodec;  		AppErrorInfo ret = _server.SendRadioMessage (this' gropToken' content' out oprFaildCodec);  		if (AppErrorInfo.APP_SUCESS == ret) {  			byte[] sucReply = new byte[1];  			sucReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplySucess;  			_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		}  		else {  			switch (oprFaildCodec) {  			case (byte)RadioTransportFaildCodec.Trans_FORBIDDEN: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Client_UNBELONG: {  				break;  			}  			case (byte)RadioTransportFaildCodec.Group_INEXISTANCE: {  				break;  			}  			default: {  				throw new NotImplementedException ();  			}  			}  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.GroupOnlineList: {  	List<Group> grops = Server.Groups;  	List<CSCommunicateClass.GroupInfo> jsonGrops = new List<CSCommunicateClass.GroupInfo> ();  	foreach (Group grop in grops) {  		string token = grop.Token;  		string detail = grop.Detail;  		CSCommunicateClass.GroupInfo gropInfoInst = new CSCommunicateClass.GroupInfo (token' detail);  		jsonGrops.Add (gropInfoInst);  	}  	byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.GroupInfo> (jsonGrops);  	byte[] replyInfo = new byte[1 + bytJson.Length];  	replyInfo [0] = (byte)ClientHeadCodec.GetOnlineGroup_ReplySucess;  	Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  	_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  	break;  }  case (int)ServerOprCodec.GroupClientOnlineList: {  	string gropToken = parmMap ["Token"] as string;  	Group gropInst;  	AppErrorInfo ret = _server.GetGroup (gropToken' out gropInst);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte oprFaildCodec;  		List<CSCommunicateClass.ClientInfo> jsonList;  		AppErrorInfo ret2 = gropInst.GetOnlineClient (_token' out oprFaildCodec' out jsonList);  		if (AppErrorInfo.APP_SUCESS == ret2) {  			byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.ClientInfo> (jsonList);  			byte[] replyInfo = new byte[1 + bytJson.Length];  			replyInfo [0] = (byte)ClientHeadCodec.GetGroupClient_ReplySucess;  			Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  			_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  		}  		else {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)oprFaildCodec;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	else {  		if (null == gropInst) {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  			errorReply [1] = (byte)GetGoupClientFaildCodec.Group_INEXISTENCE;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		}  	}  	break;  }  case (int)ServerOprCodec.ClientCancle: {  	byte[] sucReplyInfo = new byte[1];  	sucReplyInfo [0] = (byte)ClientHeadCodec.ClientCancle_ReplySucess;  	_client.SendMessage (new ScsRawDataMessage (sucReplyInfo' sourMessageid));  	this.Cancle ();  	break;  }  default: {  	break;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: if (AppErrorInfo.APP_SUCESS == ret) {  	//Reply Suc  	byte[] sucReply = new byte[1];  	sucReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplySucess;  	_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  	string logInfo = "{" + "ret:" + "P2pTransport => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  	_server.__AddLogItem (logInfo);  }  else {  	switch (oprFaildCodec) {  	case (byte)P2pTransportFaildCodec.Target_UNCONNECT: {  		//向源头打回错误报文  		byte[] erroReply = new byte[2];  		erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  		erroReply [1] = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  		_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  		string logInfo = "{" + "ret:" + "P2pTransport => Target_UNCONNECT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  		break;  	}  	case (byte)P2pTransportFaildCodec.Token_UNPARSE: {  		//向源头打回错误报文  		byte[] erroReply = new byte[2];  		erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  		erroReply [1] = (byte)P2pTransportFaildCodec.Token_UNPARSE;  		_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  		string logInfo = "{" + "ret:" + "P2pTransport => Token_UNPARSE" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  		break;  	}  	default: {  		string logInfo = "{" + "ret:" + "P2pTransport => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  		return;  	}  	}  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: if (AppErrorInfo.APP_SUCESS == ret) {  	//Reply Suc  	byte[] sucReply = new byte[1];  	sucReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplySucess;  	_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  	string logInfo = "{" + "ret:" + "P2pTransport => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  	_server.__AddLogItem (logInfo);  }  else {  	switch (oprFaildCodec) {  	case (byte)P2pTransportFaildCodec.Target_UNCONNECT: {  		//向源头打回错误报文  		byte[] erroReply = new byte[2];  		erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  		erroReply [1] = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  		_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  		string logInfo = "{" + "ret:" + "P2pTransport => Target_UNCONNECT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  		break;  	}  	case (byte)P2pTransportFaildCodec.Token_UNPARSE: {  		//向源头打回错误报文  		byte[] erroReply = new byte[2];  		erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  		erroReply [1] = (byte)P2pTransportFaildCodec.Token_UNPARSE;  		_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  		string logInfo = "{" + "ret:" + "P2pTransport => Token_UNPARSE" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  		break;  	}  	default: {  		string logInfo = "{" + "ret:" + "P2pTransport => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  		_server.__AddLogItem (logInfo);  		return;  	}  	}  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: switch (oprFaildCodec) {  case (byte)P2pTransportFaildCodec.Target_UNCONNECT: {  	//向源头打回错误报文  	byte[] erroReply = new byte[2];  	erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  	erroReply [1] = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  	_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  	string logInfo = "{" + "ret:" + "P2pTransport => Target_UNCONNECT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  	_server.__AddLogItem (logInfo);  	break;  }  case (byte)P2pTransportFaildCodec.Token_UNPARSE: {  	//向源头打回错误报文  	byte[] erroReply = new byte[2];  	erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  	erroReply [1] = (byte)P2pTransportFaildCodec.Token_UNPARSE;  	_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  	string logInfo = "{" + "ret:" + "P2pTransport => Token_UNPARSE" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  	_server.__AddLogItem (logInfo);  	break;  }  default: {  	string logInfo = "{" + "ret:" + "P2pTransport => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  	_server.__AddLogItem (logInfo);  	return;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: switch (oprFaildCodec) {  case (byte)P2pTransportFaildCodec.Target_UNCONNECT: {  	//向源头打回错误报文  	byte[] erroReply = new byte[2];  	erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  	erroReply [1] = (byte)P2pTransportFaildCodec.Target_UNCONNECT;  	_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  	string logInfo = "{" + "ret:" + "P2pTransport => Target_UNCONNECT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  	_server.__AddLogItem (logInfo);  	break;  }  case (byte)P2pTransportFaildCodec.Token_UNPARSE: {  	//向源头打回错误报文  	byte[] erroReply = new byte[2];  	erroReply [0] = (byte)ClientHeadCodec.P2pTransport_ReplyFaild;  	erroReply [1] = (byte)P2pTransportFaildCodec.Token_UNPARSE;  	_client.SendMessage (new ScsRawDataMessage (erroReply' sourMessageid));  	string logInfo = "{" + "ret:" + "P2pTransport => Token_UNPARSE" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  	_server.__AddLogItem (logInfo);  	break;  }  default: {  	string logInfo = "{" + "ret:" + "P2pTransport => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "to_token:" + parmMap ["Token"] + "}" + "}";  	_server.__AddLogItem (logInfo);  	return;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: if (false == string.IsNullOrEmpty (gropDetail)) {  	string token;  	byte oprFaildCodec;  	AppErrorInfo ret = _server.CreateGroup (gropDetail' out token' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1 + ConstData.tokenLength];  		sucReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplySucess;  		Buffer.BlockCopy (Encoding.ASCII.GetBytes (token)' 0' sucReply' 1' ConstData.tokenLength);  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "CreateGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)CreateGroupFaildCodec.Detail_REPEAT: {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  			errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  			string logInfo = "{" + "ret:" + "CreateGroup => Detail_REPEAT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		default: {  			string logInfo = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  			_server.__AddLogItem (logInfo);  			return;  		}  		}  	}  }  else {  	//空名称视为非法detail  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  	errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  	_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	string logInfo = "{" + "ret:" + "CreateGroup => Detail_NULL" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  	_server.__AddLogItem (logInfo);  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: if (false == string.IsNullOrEmpty (gropDetail)) {  	string token;  	byte oprFaildCodec;  	AppErrorInfo ret = _server.CreateGroup (gropDetail' out token' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1 + ConstData.tokenLength];  		sucReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplySucess;  		Buffer.BlockCopy (Encoding.ASCII.GetBytes (token)' 0' sucReply' 1' ConstData.tokenLength);  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  		string logInfo = "{" + "ret:" + "CreateGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "group_token:" + token + "}" + "}";  		_server.__AddLogItem (logInfo);  	}  	else {  		switch (oprFaildCodec) {  		case (byte)CreateGroupFaildCodec.Detail_REPEAT: {  			byte[] errorReply = new byte[2];  			errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  			errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  			_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  			string logInfo = "{" + "ret:" + "CreateGroup => Detail_REPEAT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  			_server.__AddLogItem (logInfo);  			break;  		}  		default: {  			string logInfo = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  			_server.__AddLogItem (logInfo);  			return;  		}  		}  	}  }  else {  	//空名称视为非法detail  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  	errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  	_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	string logInfo = "{" + "ret:" + "CreateGroup => Detail_NULL" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  	_server.__AddLogItem (logInfo);  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: if (AppErrorInfo.APP_SUCESS == ret) {  	byte[] sucReply = new byte[1 + ConstData.tokenLength];  	sucReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplySucess;  	Buffer.BlockCopy (Encoding.ASCII.GetBytes (token)' 0' sucReply' 1' ConstData.tokenLength);  	_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  	string logInfo = "{" + "ret:" + "CreateGroup => APP_SUCESS" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "group_token:" + token + "}" + "}";  	_server.__AddLogItem (logInfo);  }  else {  	switch (oprFaildCodec) {  	case (byte)CreateGroupFaildCodec.Detail_REPEAT: {  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  		errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  		string logInfo = "{" + "ret:" + "CreateGroup => Detail_REPEAT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  		_server.__AddLogItem (logInfo);  		break;  	}  	default: {  		string logInfo = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  		_server.__AddLogItem (logInfo);  		return;  	}  	}  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: switch (oprFaildCodec) {  case (byte)CreateGroupFaildCodec.Detail_REPEAT: {  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.CreateGroup_ReplyFaild;  	errorReply [1] = (byte)CreateGroupFaildCodec.Detail_REPEAT;  	_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	string logInfo = "{" + "ret:" + "CreateGroup => Detail_REPEAT" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  	_server.__AddLogItem (logInfo);  	break;  }  default: {  	string logInfo = "{" + "ret:" + "CreateGroup => default:错误码分支未实现" + " ' " + "info:" + "{" + "from_detail:" + this.Detail + "from_token:" + this.Token + "'" + "group_detail:" + gropDetail + "}" + "}";  	_server.__AddLogItem (logInfo);  	return;  }  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: foreach (string gropToken in tokens) {  	byte oprFaildCodec;  	AppErrorInfo ret = _server.SendRadioMessage (this' gropToken' content' out oprFaildCodec);  	if (AppErrorInfo.APP_SUCESS == ret) {  		byte[] sucReply = new byte[1];  		sucReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplySucess;  		_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  	}  	else {  		switch (oprFaildCodec) {  		case (byte)RadioTransportFaildCodec.Trans_FORBIDDEN: {  			break;  		}  		case (byte)RadioTransportFaildCodec.Client_UNBELONG: {  			break;  		}  		case (byte)RadioTransportFaildCodec.Group_INEXISTANCE: {  			break;  		}  		default: {  			throw new NotImplementedException ();  		}  		}  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	}  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: if (AppErrorInfo.APP_SUCESS == ret) {  	byte[] sucReply = new byte[1];  	sucReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplySucess;  	_client.SendMessage (new ScsRawDataMessage (sucReply' sourMessageid));  }  else {  	switch (oprFaildCodec) {  	case (byte)RadioTransportFaildCodec.Trans_FORBIDDEN: {  		break;  	}  	case (byte)RadioTransportFaildCodec.Client_UNBELONG: {  		break;  	}  	case (byte)RadioTransportFaildCodec.Group_INEXISTANCE: {  		break;  	}  	default: {  		throw new NotImplementedException ();  	}  	}  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.RadioTransport_ReplyFaild;  	errorReply [1] = (byte)oprFaildCodec;  	_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: if (AppErrorInfo.APP_SUCESS == ret) {  	byte oprFaildCodec;  	List<CSCommunicateClass.ClientInfo> jsonList;  	AppErrorInfo ret2 = gropInst.GetOnlineClient (_token' out oprFaildCodec' out jsonList);  	if (AppErrorInfo.APP_SUCESS == ret2) {  		byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.ClientInfo> (jsonList);  		byte[] replyInfo = new byte[1 + bytJson.Length];  		replyInfo [0] = (byte)ClientHeadCodec.GetGroupClient_ReplySucess;  		Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  		_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  	}  	else {  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	}  }  else {  	if (null == gropInst) {  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  		errorReply [1] = (byte)GetGoupClientFaildCodec.Group_INEXISTENCE;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	}  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: if (AppErrorInfo.APP_SUCESS == ret) {  	byte oprFaildCodec;  	List<CSCommunicateClass.ClientInfo> jsonList;  	AppErrorInfo ret2 = gropInst.GetOnlineClient (_token' out oprFaildCodec' out jsonList);  	if (AppErrorInfo.APP_SUCESS == ret2) {  		byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.ClientInfo> (jsonList);  		byte[] replyInfo = new byte[1 + bytJson.Length];  		replyInfo [0] = (byte)ClientHeadCodec.GetGroupClient_ReplySucess;  		Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  		_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  	}  	else {  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  		errorReply [1] = (byte)oprFaildCodec;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	}  }  else {  	if (null == gropInst) {  		byte[] errorReply = new byte[2];  		errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  		errorReply [1] = (byte)GetGoupClientFaildCodec.Group_INEXISTENCE;  		_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  	}  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: if (AppErrorInfo.APP_SUCESS == ret2) {  	byte[] bytJson = JsonSerializtionFactory.JSON<CSCommunicateClass.ClientInfo> (jsonList);  	byte[] replyInfo = new byte[1 + bytJson.Length];  	replyInfo [0] = (byte)ClientHeadCodec.GetGroupClient_ReplySucess;  	Buffer.BlockCopy (bytJson' 0' replyInfo' 1' bytJson.Length);  	_client.SendMessage (new ScsRawDataMessage (replyInfo' sourMessageid));  }  else {  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  	errorReply [1] = (byte)oprFaildCodec;  	_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  }  
Magic Number,Mty.LCF.Server.ServerClient,BaseServerClient,C:\repos\mtysgithub_LAN_Communication_Framework\Server\ServerClient\BaseServerClient.cs,Client_MessageRecevied,The following statement contains a magic number: if (null == gropInst) {  	byte[] errorReply = new byte[2];  	errorReply [0] = (byte)ClientHeadCodec.GetGroupClient_ReplyFaild;  	errorReply [1] = (byte)GetGoupClientFaildCodec.Group_INEXISTENCE;  	_client.SendMessage (new ScsRawDataMessage (errorReply' sourMessageid));  }  
