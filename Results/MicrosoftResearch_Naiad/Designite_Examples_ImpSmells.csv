Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Microsoft.Research.Naiad.Examples.Throughput,ProducerVertex,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Throughput.cs,MakeStage,The method has 5 parameters. Parameters: numberToSend' startProcess' endProcess' numberOfWorkers' input
Long Parameter List,Microsoft.Research.Naiad.Examples.Throughput,ConsumerVertex,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Throughput.cs,MakeStage,The method has 6 parameters. Parameters: numberToConsume' startProcess' endProcess' numberOfWorkers' exchange' stream
Long Statement,Microsoft.Research.Naiad.Examples.DifferentialDataflow,ConnectedComponents,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\ConnectedComponents.cs,Execute,The length of the statement  "                Func<IntPair' int> priorityFunction = node => 65536 * (node.t < 10 ? node.t : 10 + Convert.ToInt32(Math.Log(1 + node.t) / Math.Log(2.0))); " is 138.
Long Statement,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SearchIndex,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\SearchIndex.cs,Execute,The length of the statement  "                var qTerms = queries.SelectMany(query => query.text.Split(' ').Select(term => new Query(term' query.id' query.threshold))) " is 122.
Long Statement,Microsoft.Research.Naiad.Examples.DifferentialDataflow,StronglyConnectedComponentsExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\StronglyConnectedComponents.cs,TrimAndTranspose,The length of the statement  "                        .Join(labels' x => x.edge.source' node => node.name' x => x.edge.target' y => y.label' (k' x' y) => new SCC.LabeledEdge(new SCC.Edge(k' x)' y' 0)) " is 146.
Long Statement,Microsoft.Research.Naiad.Examples.DifferentialDataflow,StronglyConnectedComponentsExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\StronglyConnectedComponents.cs,TrimAndTranspose,The length of the statement  "                        .Join(labels' x => x.edge.target' node => node.name' x => new IntPair(x.edge.source' x.label1)' y => y.label' (k' x' y) => new SCC.LabeledEdge(new SCC.Edge(x.s' k)' x.t' y)) " is 173.
Long Statement,Microsoft.Research.Naiad.Examples.DifferentialDataflow,StronglyConnectedComponentsExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\StronglyConnectedComponents.cs,BroadcastMin,The length of the statement  "            Func<SCC.Node' int> priority = node => 65536 * (node.label < keep ? node.label : keep + Convert.ToInt32(Math.Log(1 + node.label))); " is 131.
Long Statement,Microsoft.Research.Naiad.Examples.DifferentialDataflow,StronglyConnectedComponentsExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\StronglyConnectedComponents.cs,BroadcastMin,The length of the statement  "                                                           .Join(x' edge => edge.source' node => node.name' edge => edge.target' node => node.label' (source' target' label) => new SCC.Node(target' label)' true) " is 151.
Long Statement,Microsoft.Research.Naiad.Examples.GraphLINQ,PageRank,C:\repos\MicrosoftResearch_Naiad\Examples\GraphLINQ\PageRank.cs,Execute,The length of the statement  "                computation.OnFrontierChange += (x' y) => { Console.WriteLine(stopwatch.Elapsed + "\t" + string.Join("' "' y.NewFrontier)); Console.Out.Flush(); }; " is 147.
Long Statement,Microsoft.Research.Naiad.Examples.ConnectedComponents,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\ConnectedComponents.cs,StreamingAggregate,The length of the statement  "            return Foundry.NewUnaryStage(input' (i' s) => new StreamingAggregateVertex<TKey' TValue' TTime>(i' s' aggregate)' x => x.First.GetHashCode()' x => x.First.GetHashCode()' "StreamingAggregate"); " is 192.
Long Statement,Microsoft.Research.Naiad.Examples.ConnectedComponents,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\ConnectedComponents.cs,BlockingAggregate,The length of the statement  "            return Foundry.NewUnaryStage(input' (i' s) => new BlockingAggregateVertex<TKey' TValue' TTime>(i' s' aggregate)' x => x.First.GetHashCode()' x => x.First.GetHashCode()' "BlockingAggregate"); " is 190.
Long Statement,Microsoft.Research.Naiad.Examples.ConnectedComponents,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\ConnectedComponents.cs,GraphJoin,The length of the statement  "            return Foundry.NewBinaryStage(edges' values' (i' s) => new GraphJoinVertex<TVertex' TState' TTime>(i' s)' x => x.First.GetHashCode()' y => y.First.GetHashCode()' null' "GraphJoin"); " is 181.
Long Statement,Microsoft.Research.Naiad.Examples.KeyValueLookup,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\KeyValueLookup.cs,KeyValueLookup,The length of the statement  "            return Foundry.NewBinaryStage(kvpairs' requests' (i' s) => new KeyValueLookupVertex<TKey' TValue>(i' s)' x => x.First.GetHashCode()' y => y.GetHashCode()' null' "Lookup"); " is 171.
Long Statement,Microsoft.Research.Naiad.Examples.Latency,Barrier,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,MakeStage,The length of the statement  "            var stage = new Stage<Barrier' IterationIn<Epoch>>(ingress.Context' (i' s) => new Barrier(i' s' iterations)' "Barrier"); " is 120.
Long Statement,Microsoft.Research.Naiad.Examples.Latency,Latency,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,Execute,The length of the statement  "                Console.WriteLine("Running barrier latency test with {0} iterations' vertices={1}"' iterations' ingress.ForStage.Placement.Count); " is 130.
Long Statement,Microsoft.Research.Naiad.Examples.Latency,Latency,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,Execute,The length of the statement  "                Console.WriteLine("Ran {0} iterations on {1} processes; this is process {2}"' times.Count - 1' computation.Configuration.Processes' computation.Configuration.ProcessID); " is 169.
Long Statement,Microsoft.Research.Naiad.Examples.Throughput,ProducerVertex,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Throughput.cs,MakeStage,The length of the statement  "            Stage<ProducerVertex' Epoch> stage = Foundry.NewStage(placement' input.Context' (i' s) => new ProducerVertex(i' s' numberToSend)' "Producer"); " is 142.
Long Statement,Microsoft.Research.Naiad.Examples.Throughput,ConsumerVertex,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Throughput.cs,MakeStage,The length of the statement  "            Stage<ConsumerVertex' Epoch> stage = Foundry.NewStage(placement' stream.Context' (i' s) => new ConsumerVertex(i' s' numberToConsume)' "Consumer"); " is 146.
Long Statement,Microsoft.Research.Naiad.Examples.Throughput,Throughput,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Throughput.cs,Execute,The length of the statement  "                Stream<Pair<int' int>' Epoch> stream = ProducerVertex.MakeStage(numToExchange' 0' producers' computation.Configuration.WorkerCount' input); " is 139.
Long Statement,Microsoft.Research.Naiad.Examples.Throughput,Throughput,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Throughput.cs,Execute,The length of the statement  "                Stage<ConsumerVertex' Epoch> consumer = ConsumerVertex.MakeStage(numToExchange' computation.Configuration.Processes - consumers' computation.Configuration.Processes' computation.Configuration.WorkerCount' exchange' stream); " is 223.
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,ConnectedComponents,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\ConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // establish numbers of nodes and edges from input or from defaults.                  if (args.Length == 3)                  {                      nodeCount = Convert.ToInt32(args[1]);                      edgeCount = Convert.ToInt32(args[2]);                  }                    // generate a random graph                  var random = new Random(0);                  var graph = new IntPair[edgeCount];                  for (int i = 0; i < edgeCount; i++)                      graph[i] = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    // set up the CC computation                  var edges = computation.NewInputCollection<IntPair>();                    //Func<IntPair' int> priorityFunction = node => 0;                  //Func<IntPair' int> priorityFunction = node => Math.Min(node.t' 100);                  Func<IntPair' int> priorityFunction = node => 65536 * (node.t < 10 ? node.t : 10 + Convert.ToInt32(Math.Log(1 + node.t) / Math.Log(2.0)));                    var output = edges.ConnectedComponents(priorityFunction)                                    .Count(n => n.t' (l' c) => c)  // counts results with each label                                    .Consolidate()                                    .Subscribe(l =>                                               {                                                   Console.Error.WriteLine("Time to process: {0}"' stopwatch.Elapsed);                                                   foreach (var result in l.OrderBy(x => x.record))                                                       Console.Error.WriteLine(result);                                               });                    Console.Error.WriteLine("Running connected components on a random graph ({0} nodes' {1} edges)"' nodeCount' edgeCount);                  Console.Error.WriteLine("For each size' the number of components of that size (may take a moment):");                    computation.Activate();                    edges.OnNext(computation.Configuration.ProcessID == 0 ? graph : Enumerable.Empty<IntPair>());                    // if we are up for interactive access ...                  if (computation.Configuration.Processes == 1)                  {                      output.Sync(0);                        Console.WriteLine();                      Console.WriteLine("Next: sequentially rewiring random edges (press [enter] each time):");                        for (int i = 0; true; i++)                      {                          Console.ReadLine();                          stopwatch.Restart();                          var newEdge = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                          Console.WriteLine("Rewiring edge: {0} -> {1}"' graph[i]' newEdge);                          edges.OnNext(new[] { new Weighted<IntPair>(graph[i]' -1)' new Weighted<IntPair>(newEdge' 1) });                          output.Sync(i + 1);                      }                  }                    edges.OnCompleted();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,ConnectedComponents,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\ConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // establish numbers of nodes and edges from input or from defaults.                  if (args.Length == 3)                  {                      nodeCount = Convert.ToInt32(args[1]);                      edgeCount = Convert.ToInt32(args[2]);                  }                    // generate a random graph                  var random = new Random(0);                  var graph = new IntPair[edgeCount];                  for (int i = 0; i < edgeCount; i++)                      graph[i] = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    // set up the CC computation                  var edges = computation.NewInputCollection<IntPair>();                    //Func<IntPair' int> priorityFunction = node => 0;                  //Func<IntPair' int> priorityFunction = node => Math.Min(node.t' 100);                  Func<IntPair' int> priorityFunction = node => 65536 * (node.t < 10 ? node.t : 10 + Convert.ToInt32(Math.Log(1 + node.t) / Math.Log(2.0)));                    var output = edges.ConnectedComponents(priorityFunction)                                    .Count(n => n.t' (l' c) => c)  // counts results with each label                                    .Consolidate()                                    .Subscribe(l =>                                               {                                                   Console.Error.WriteLine("Time to process: {0}"' stopwatch.Elapsed);                                                   foreach (var result in l.OrderBy(x => x.record))                                                       Console.Error.WriteLine(result);                                               });                    Console.Error.WriteLine("Running connected components on a random graph ({0} nodes' {1} edges)"' nodeCount' edgeCount);                  Console.Error.WriteLine("For each size' the number of components of that size (may take a moment):");                    computation.Activate();                    edges.OnNext(computation.Configuration.ProcessID == 0 ? graph : Enumerable.Empty<IntPair>());                    // if we are up for interactive access ...                  if (computation.Configuration.Processes == 1)                  {                      output.Sync(0);                        Console.WriteLine();                      Console.WriteLine("Next: sequentially rewiring random edges (press [enter] each time):");                        for (int i = 0; true; i++)                      {                          Console.ReadLine();                          stopwatch.Restart();                          var newEdge = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                          Console.WriteLine("Rewiring edge: {0} -> {1}"' graph[i]' newEdge);                          edges.OnNext(new[] { new Weighted<IntPair>(graph[i]' -1)' new Weighted<IntPair>(newEdge' 1) });                          output.Sync(i + 1);                      }                  }                    edges.OnCompleted();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,ConnectedComponents,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\ConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // establish numbers of nodes and edges from input or from defaults.                  if (args.Length == 3)                  {                      nodeCount = Convert.ToInt32(args[1]);                      edgeCount = Convert.ToInt32(args[2]);                  }                    // generate a random graph                  var random = new Random(0);                  var graph = new IntPair[edgeCount];                  for (int i = 0; i < edgeCount; i++)                      graph[i] = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    // set up the CC computation                  var edges = computation.NewInputCollection<IntPair>();                    //Func<IntPair' int> priorityFunction = node => 0;                  //Func<IntPair' int> priorityFunction = node => Math.Min(node.t' 100);                  Func<IntPair' int> priorityFunction = node => 65536 * (node.t < 10 ? node.t : 10 + Convert.ToInt32(Math.Log(1 + node.t) / Math.Log(2.0)));                    var output = edges.ConnectedComponents(priorityFunction)                                    .Count(n => n.t' (l' c) => c)  // counts results with each label                                    .Consolidate()                                    .Subscribe(l =>                                               {                                                   Console.Error.WriteLine("Time to process: {0}"' stopwatch.Elapsed);                                                   foreach (var result in l.OrderBy(x => x.record))                                                       Console.Error.WriteLine(result);                                               });                    Console.Error.WriteLine("Running connected components on a random graph ({0} nodes' {1} edges)"' nodeCount' edgeCount);                  Console.Error.WriteLine("For each size' the number of components of that size (may take a moment):");                    computation.Activate();                    edges.OnNext(computation.Configuration.ProcessID == 0 ? graph : Enumerable.Empty<IntPair>());                    // if we are up for interactive access ...                  if (computation.Configuration.Processes == 1)                  {                      output.Sync(0);                        Console.WriteLine();                      Console.WriteLine("Next: sequentially rewiring random edges (press [enter] each time):");                        for (int i = 0; true; i++)                      {                          Console.ReadLine();                          stopwatch.Restart();                          var newEdge = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                          Console.WriteLine("Rewiring edge: {0} -> {1}"' graph[i]' newEdge);                          edges.OnNext(new[] { new Weighted<IntPair>(graph[i]' -1)' new Weighted<IntPair>(newEdge' 1) });                          output.Sync(i + 1);                      }                  }                    edges.OnCompleted();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,ConnectedComponents,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\ConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // establish numbers of nodes and edges from input or from defaults.                  if (args.Length == 3)                  {                      nodeCount = Convert.ToInt32(args[1]);                      edgeCount = Convert.ToInt32(args[2]);                  }                    // generate a random graph                  var random = new Random(0);                  var graph = new IntPair[edgeCount];                  for (int i = 0; i < edgeCount; i++)                      graph[i] = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    // set up the CC computation                  var edges = computation.NewInputCollection<IntPair>();                    //Func<IntPair' int> priorityFunction = node => 0;                  //Func<IntPair' int> priorityFunction = node => Math.Min(node.t' 100);                  Func<IntPair' int> priorityFunction = node => 65536 * (node.t < 10 ? node.t : 10 + Convert.ToInt32(Math.Log(1 + node.t) / Math.Log(2.0)));                    var output = edges.ConnectedComponents(priorityFunction)                                    .Count(n => n.t' (l' c) => c)  // counts results with each label                                    .Consolidate()                                    .Subscribe(l =>                                               {                                                   Console.Error.WriteLine("Time to process: {0}"' stopwatch.Elapsed);                                                   foreach (var result in l.OrderBy(x => x.record))                                                       Console.Error.WriteLine(result);                                               });                    Console.Error.WriteLine("Running connected components on a random graph ({0} nodes' {1} edges)"' nodeCount' edgeCount);                  Console.Error.WriteLine("For each size' the number of components of that size (may take a moment):");                    computation.Activate();                    edges.OnNext(computation.Configuration.ProcessID == 0 ? graph : Enumerable.Empty<IntPair>());                    // if we are up for interactive access ...                  if (computation.Configuration.Processes == 1)                  {                      output.Sync(0);                        Console.WriteLine();                      Console.WriteLine("Next: sequentially rewiring random edges (press [enter] each time):");                        for (int i = 0; true; i++)                      {                          Console.ReadLine();                          stopwatch.Restart();                          var newEdge = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                          Console.WriteLine("Rewiring edge: {0} -> {1}"' graph[i]' newEdge);                          edges.OnNext(new[] { new Weighted<IntPair>(graph[i]' -1)' new Weighted<IntPair>(newEdge' 1) });                          output.Sync(i + 1);                      }                  }                    edges.OnCompleted();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,ConnectedComponents,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\ConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // establish numbers of nodes and edges from input or from defaults.                  if (args.Length == 3)                  {                      nodeCount = Convert.ToInt32(args[1]);                      edgeCount = Convert.ToInt32(args[2]);                  }                    // generate a random graph                  var random = new Random(0);                  var graph = new IntPair[edgeCount];                  for (int i = 0; i < edgeCount; i++)                      graph[i] = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    // set up the CC computation                  var edges = computation.NewInputCollection<IntPair>();                    //Func<IntPair' int> priorityFunction = node => 0;                  //Func<IntPair' int> priorityFunction = node => Math.Min(node.t' 100);                  Func<IntPair' int> priorityFunction = node => 65536 * (node.t < 10 ? node.t : 10 + Convert.ToInt32(Math.Log(1 + node.t) / Math.Log(2.0)));                    var output = edges.ConnectedComponents(priorityFunction)                                    .Count(n => n.t' (l' c) => c)  // counts results with each label                                    .Consolidate()                                    .Subscribe(l =>                                               {                                                   Console.Error.WriteLine("Time to process: {0}"' stopwatch.Elapsed);                                                   foreach (var result in l.OrderBy(x => x.record))                                                       Console.Error.WriteLine(result);                                               });                    Console.Error.WriteLine("Running connected components on a random graph ({0} nodes' {1} edges)"' nodeCount' edgeCount);                  Console.Error.WriteLine("For each size' the number of components of that size (may take a moment):");                    computation.Activate();                    edges.OnNext(computation.Configuration.ProcessID == 0 ? graph : Enumerable.Empty<IntPair>());                    // if we are up for interactive access ...                  if (computation.Configuration.Processes == 1)                  {                      output.Sync(0);                        Console.WriteLine();                      Console.WriteLine("Next: sequentially rewiring random edges (press [enter] each time):");                        for (int i = 0; true; i++)                      {                          Console.ReadLine();                          stopwatch.Restart();                          var newEdge = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                          Console.WriteLine("Rewiring edge: {0} -> {1}"' graph[i]' newEdge);                          edges.OnNext(new[] { new Weighted<IntPair>(graph[i]' -1)' new Weighted<IntPair>(newEdge' 1) });                          output.Sync(i + 1);                      }                  }                    edges.OnCompleted();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,ConnectedComponents,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\ConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // establish numbers of nodes and edges from input or from defaults.                  if (args.Length == 3)                  {                      nodeCount = Convert.ToInt32(args[1]);                      edgeCount = Convert.ToInt32(args[2]);                  }                    // generate a random graph                  var random = new Random(0);                  var graph = new IntPair[edgeCount];                  for (int i = 0; i < edgeCount; i++)                      graph[i] = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    // set up the CC computation                  var edges = computation.NewInputCollection<IntPair>();                    //Func<IntPair' int> priorityFunction = node => 0;                  //Func<IntPair' int> priorityFunction = node => Math.Min(node.t' 100);                  Func<IntPair' int> priorityFunction = node => 65536 * (node.t < 10 ? node.t : 10 + Convert.ToInt32(Math.Log(1 + node.t) / Math.Log(2.0)));                    var output = edges.ConnectedComponents(priorityFunction)                                    .Count(n => n.t' (l' c) => c)  // counts results with each label                                    .Consolidate()                                    .Subscribe(l =>                                               {                                                   Console.Error.WriteLine("Time to process: {0}"' stopwatch.Elapsed);                                                   foreach (var result in l.OrderBy(x => x.record))                                                       Console.Error.WriteLine(result);                                               });                    Console.Error.WriteLine("Running connected components on a random graph ({0} nodes' {1} edges)"' nodeCount' edgeCount);                  Console.Error.WriteLine("For each size' the number of components of that size (may take a moment):");                    computation.Activate();                    edges.OnNext(computation.Configuration.ProcessID == 0 ? graph : Enumerable.Empty<IntPair>());                    // if we are up for interactive access ...                  if (computation.Configuration.Processes == 1)                  {                      output.Sync(0);                        Console.WriteLine();                      Console.WriteLine("Next: sequentially rewiring random edges (press [enter] each time):");                        for (int i = 0; true; i++)                      {                          Console.ReadLine();                          stopwatch.Restart();                          var newEdge = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                          Console.WriteLine("Rewiring edge: {0} -> {1}"' graph[i]' newEdge);                          edges.OnNext(new[] { new Weighted<IntPair>(graph[i]' -1)' new Weighted<IntPair>(newEdge' 1) });                          output.Sync(i + 1);                      }                  }                    edges.OnCompleted();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,GraphColoring,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\GraphColoring.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // establish numbers of nodes and edges from input or from defaults.                  if (args.Length == 3)                  {                      nodeCount = Convert.ToInt32(args[1]);                      edgeCount = Convert.ToInt32(args[2]);                  }                    // generate a random graph                  var random = new Random(0);                  var graph = new IntPair[edgeCount];                  for (int i = 0; i < edgeCount; i++)                      graph[i] = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                    // set up the CC computation                  var edges = computation.NewInputCollection<IntPair>();                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    var colors = edges.Where(x => x.s != x.t)                                    .Color();                    var output = colors.Select(x => x.t)          // just keep the color (to count)                                     .Output                                     .Subscribe((i' l) => Console.WriteLine("Time to process: {0}"' stopwatch.Elapsed));                    // set to enable a correctness test' at the cost of more memory and computation.                  var testCorrectness = false;                  if (testCorrectness)                  {                      edges.Where(x => x.s != x.t)                           .Join(colors' e => e.s' c => c.s' e => e.t' c => c.t' (s' t' c) => new IntPair(c' t))                           .Join(colors' e => e.t' c => c.s' e => e.s' c => c.t' (t' s' c) => new IntPair(s' c))                           .Where(p => p.s == p.t)                           .Consolidate()                           .Subscribe(l => Console.WriteLine("Coloring errors: {0}"' l.Length));                  }                    Console.WriteLine("Running graph coloring on a random graph ({0} nodes' {1} edges)"' nodeCount' edgeCount);                  Console.WriteLine("For each color' the nodes with that color:");                    computation.Activate();                    edges.OnNext(computation.Configuration.ProcessID == 0 ? graph : Enumerable.Empty<IntPair>());                    output.Sync(0);                    // if we are up for interactive access ...                  if (computation.Configuration.Processes == 1)                  {                      Console.WriteLine();                      Console.WriteLine("Next: sequentially rewiring random edges (press [enter] each time):");                        for (int i = 0; i < graph.Length; i++)                      {                          Console.ReadLine();                          stopwatch.Restart();                          var newEdge = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                          Console.WriteLine("Rewiring edge: {0} -> {1}"' graph[i]' newEdge);                          edges.OnNext(new[] { new Weighted<IntPair>(graph[i]' -1)' new Weighted<IntPair>(newEdge' 1) });                          output.Sync(i + 1);                      }                  }                    edges.OnCompleted();                    computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,GraphColoring,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\GraphColoring.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // establish numbers of nodes and edges from input or from defaults.                  if (args.Length == 3)                  {                      nodeCount = Convert.ToInt32(args[1]);                      edgeCount = Convert.ToInt32(args[2]);                  }                    // generate a random graph                  var random = new Random(0);                  var graph = new IntPair[edgeCount];                  for (int i = 0; i < edgeCount; i++)                      graph[i] = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                    // set up the CC computation                  var edges = computation.NewInputCollection<IntPair>();                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    var colors = edges.Where(x => x.s != x.t)                                    .Color();                    var output = colors.Select(x => x.t)          // just keep the color (to count)                                     .Output                                     .Subscribe((i' l) => Console.WriteLine("Time to process: {0}"' stopwatch.Elapsed));                    // set to enable a correctness test' at the cost of more memory and computation.                  var testCorrectness = false;                  if (testCorrectness)                  {                      edges.Where(x => x.s != x.t)                           .Join(colors' e => e.s' c => c.s' e => e.t' c => c.t' (s' t' c) => new IntPair(c' t))                           .Join(colors' e => e.t' c => c.s' e => e.s' c => c.t' (t' s' c) => new IntPair(s' c))                           .Where(p => p.s == p.t)                           .Consolidate()                           .Subscribe(l => Console.WriteLine("Coloring errors: {0}"' l.Length));                  }                    Console.WriteLine("Running graph coloring on a random graph ({0} nodes' {1} edges)"' nodeCount' edgeCount);                  Console.WriteLine("For each color' the nodes with that color:");                    computation.Activate();                    edges.OnNext(computation.Configuration.ProcessID == 0 ? graph : Enumerable.Empty<IntPair>());                    output.Sync(0);                    // if we are up for interactive access ...                  if (computation.Configuration.Processes == 1)                  {                      Console.WriteLine();                      Console.WriteLine("Next: sequentially rewiring random edges (press [enter] each time):");                        for (int i = 0; i < graph.Length; i++)                      {                          Console.ReadLine();                          stopwatch.Restart();                          var newEdge = new IntPair(random.Next(nodeCount)' random.Next(nodeCount));                          Console.WriteLine("Rewiring edge: {0} -> {1}"' graph[i]' newEdge);                          edges.OnNext(new[] { new Weighted<IntPair>(graph[i]' -1)' new Weighted<IntPair>(newEdge' 1) });                          output.Sync(i + 1);                      }                  }                    edges.OnCompleted();                    computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SearchIndex,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\SearchIndex.cs,Execute,The following statement contains a magic number: int documentCount = 100000;
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SearchIndex,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\SearchIndex.cs,Execute,The following statement contains a magic number: int vocabulary = 100000;
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SearchIndex,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\SearchIndex.cs,Execute,The following statement contains a magic number: int batchSize = 10000;
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SearchIndex,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\SearchIndex.cs,Execute,The following statement contains a magic number: int iterations = 10;
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SearchIndex,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\SearchIndex.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  #region building up input data                    if (args.Length == 5)                  {                      documentCount = Convert.ToInt32(args[1]);                      vocabulary = Convert.ToInt32(args[2]);                      batchSize = Convert.ToInt32(args[3]);                      iterations = Convert.ToInt32(args[4]);                  }                    var random = new Random(0);                  List<Document> docs = Enumerable.Range(0' documentCount)                                                 .Select(i => new Document(Enumerable.Range(0' 10)                                                 .Select(j => String.Format("{0}"' random.Next(vocabulary)))                                                 .Aggregate((x' y) => x + " " + y)' i)).ToList<Document>();                    List<Query>[] queryBatches = new List<Query>[iterations];                    for (int i = 0; i < iterations; i++)                  {                      queryBatches[i] = Enumerable.Range(i * batchSize' batchSize)                                                     .Select(j => new Query(String.Format("{0}"' j % vocabulary)' j' 1))                                                     .ToList();                  }                    #endregion                    // declare inputs for documents and queries.                  var documents = computation.NewInputCollection<Document>();                  var queries = computation.NewInputCollection<Query>();                    // each document is broken down into a collection of terms' each with associated identifier.                  var dTerms = documents.SelectMany(doc => doc.text.Split(' ').Select(term => new Document(term' doc.id)))                                        .Distinct();                    // each query is broken down into a collection of terms' each with associated identifier and threshold.                  var qTerms = queries.SelectMany(query => query.text.Split(' ').Select(term => new Query(term' query.id' query.threshold)))                                      .Distinct();                    // doc terms and query terms are joined' matching pairs are counted and returned if the count exceeds the threshold.                  var results = dTerms.Join(qTerms' d => d.text' q => q.text' (d' q) => new Match(d.id' q.id' q.threshold))                                      .Count(match => match)                                      .Select(pair => new Match(pair.First.document' pair.First.query' pair.First.threshold - (int)pair.Second))                                      .Where(match => match.threshold <= 0)                                      .Select(match => new Pair<int' int>(match.document' match.query));                    // subscribe to the output in case we are interested in the results                  var subscription = results.Subscribe(list => Console.WriteLine("matches found: {0}"' list.Length));                    computation.Activate();                    #region Prepare some fake documents to put in the collection                    // creates many documents each containing 10 words from [0' ... vocabulary-1].                  int share_size = docs.Count / computation.Configuration.Processes;                    documents.OnNext(docs.GetRange(computation.Configuration.ProcessID * share_size' share_size));                  queries.OnNext();                    //Console.WriteLine("Example SearchIndex in Naiad. Step 1: indexing documents' step 2: issuing queries.");                  Console.WriteLine("Indexing {0} random documents' {1} terms (please wait)"' documentCount' 10 * documentCount);                  subscription.Sync(0);                    #endregion                    #region Issue batches of queries and assess performance                    if (computation.Configuration.ProcessID == 0)                  {                      Console.WriteLine("Issuing {0} rounds of batches of {1} queries (press [enter] to start)"' iterations' batchSize);                      Console.ReadLine();                  }                    for (int i = 0; i < iterations; i++)                  {                      // we round-robin through query terms. more advanced queries are possible.                      if (computation.Configuration.ProcessID == 0)                          queries.OnNext(queryBatches[i]); // introduce new queries.                      else                          queries.OnNext();                        documents.OnNext();                     // indicate no new docs.                      subscription.Sync(i + 1);    // block until round is done.                  }                    documents.OnCompleted();                  queries.OnCompleted();                    #endregion                    computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SearchIndex,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\SearchIndex.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  #region building up input data                    if (args.Length == 5)                  {                      documentCount = Convert.ToInt32(args[1]);                      vocabulary = Convert.ToInt32(args[2]);                      batchSize = Convert.ToInt32(args[3]);                      iterations = Convert.ToInt32(args[4]);                  }                    var random = new Random(0);                  List<Document> docs = Enumerable.Range(0' documentCount)                                                 .Select(i => new Document(Enumerable.Range(0' 10)                                                 .Select(j => String.Format("{0}"' random.Next(vocabulary)))                                                 .Aggregate((x' y) => x + " " + y)' i)).ToList<Document>();                    List<Query>[] queryBatches = new List<Query>[iterations];                    for (int i = 0; i < iterations; i++)                  {                      queryBatches[i] = Enumerable.Range(i * batchSize' batchSize)                                                     .Select(j => new Query(String.Format("{0}"' j % vocabulary)' j' 1))                                                     .ToList();                  }                    #endregion                    // declare inputs for documents and queries.                  var documents = computation.NewInputCollection<Document>();                  var queries = computation.NewInputCollection<Query>();                    // each document is broken down into a collection of terms' each with associated identifier.                  var dTerms = documents.SelectMany(doc => doc.text.Split(' ').Select(term => new Document(term' doc.id)))                                        .Distinct();                    // each query is broken down into a collection of terms' each with associated identifier and threshold.                  var qTerms = queries.SelectMany(query => query.text.Split(' ').Select(term => new Query(term' query.id' query.threshold)))                                      .Distinct();                    // doc terms and query terms are joined' matching pairs are counted and returned if the count exceeds the threshold.                  var results = dTerms.Join(qTerms' d => d.text' q => q.text' (d' q) => new Match(d.id' q.id' q.threshold))                                      .Count(match => match)                                      .Select(pair => new Match(pair.First.document' pair.First.query' pair.First.threshold - (int)pair.Second))                                      .Where(match => match.threshold <= 0)                                      .Select(match => new Pair<int' int>(match.document' match.query));                    // subscribe to the output in case we are interested in the results                  var subscription = results.Subscribe(list => Console.WriteLine("matches found: {0}"' list.Length));                    computation.Activate();                    #region Prepare some fake documents to put in the collection                    // creates many documents each containing 10 words from [0' ... vocabulary-1].                  int share_size = docs.Count / computation.Configuration.Processes;                    documents.OnNext(docs.GetRange(computation.Configuration.ProcessID * share_size' share_size));                  queries.OnNext();                    //Console.WriteLine("Example SearchIndex in Naiad. Step 1: indexing documents' step 2: issuing queries.");                  Console.WriteLine("Indexing {0} random documents' {1} terms (please wait)"' documentCount' 10 * documentCount);                  subscription.Sync(0);                    #endregion                    #region Issue batches of queries and assess performance                    if (computation.Configuration.ProcessID == 0)                  {                      Console.WriteLine("Issuing {0} rounds of batches of {1} queries (press [enter] to start)"' iterations' batchSize);                      Console.ReadLine();                  }                    for (int i = 0; i < iterations; i++)                  {                      // we round-robin through query terms. more advanced queries are possible.                      if (computation.Configuration.ProcessID == 0)                          queries.OnNext(queryBatches[i]); // introduce new queries.                      else                          queries.OnNext();                        documents.OnNext();                     // indicate no new docs.                      subscription.Sync(i + 1);    // block until round is done.                  }                    documents.OnCompleted();                  queries.OnCompleted();                    #endregion                    computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SearchIndex,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\SearchIndex.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  #region building up input data                    if (args.Length == 5)                  {                      documentCount = Convert.ToInt32(args[1]);                      vocabulary = Convert.ToInt32(args[2]);                      batchSize = Convert.ToInt32(args[3]);                      iterations = Convert.ToInt32(args[4]);                  }                    var random = new Random(0);                  List<Document> docs = Enumerable.Range(0' documentCount)                                                 .Select(i => new Document(Enumerable.Range(0' 10)                                                 .Select(j => String.Format("{0}"' random.Next(vocabulary)))                                                 .Aggregate((x' y) => x + " " + y)' i)).ToList<Document>();                    List<Query>[] queryBatches = new List<Query>[iterations];                    for (int i = 0; i < iterations; i++)                  {                      queryBatches[i] = Enumerable.Range(i * batchSize' batchSize)                                                     .Select(j => new Query(String.Format("{0}"' j % vocabulary)' j' 1))                                                     .ToList();                  }                    #endregion                    // declare inputs for documents and queries.                  var documents = computation.NewInputCollection<Document>();                  var queries = computation.NewInputCollection<Query>();                    // each document is broken down into a collection of terms' each with associated identifier.                  var dTerms = documents.SelectMany(doc => doc.text.Split(' ').Select(term => new Document(term' doc.id)))                                        .Distinct();                    // each query is broken down into a collection of terms' each with associated identifier and threshold.                  var qTerms = queries.SelectMany(query => query.text.Split(' ').Select(term => new Query(term' query.id' query.threshold)))                                      .Distinct();                    // doc terms and query terms are joined' matching pairs are counted and returned if the count exceeds the threshold.                  var results = dTerms.Join(qTerms' d => d.text' q => q.text' (d' q) => new Match(d.id' q.id' q.threshold))                                      .Count(match => match)                                      .Select(pair => new Match(pair.First.document' pair.First.query' pair.First.threshold - (int)pair.Second))                                      .Where(match => match.threshold <= 0)                                      .Select(match => new Pair<int' int>(match.document' match.query));                    // subscribe to the output in case we are interested in the results                  var subscription = results.Subscribe(list => Console.WriteLine("matches found: {0}"' list.Length));                    computation.Activate();                    #region Prepare some fake documents to put in the collection                    // creates many documents each containing 10 words from [0' ... vocabulary-1].                  int share_size = docs.Count / computation.Configuration.Processes;                    documents.OnNext(docs.GetRange(computation.Configuration.ProcessID * share_size' share_size));                  queries.OnNext();                    //Console.WriteLine("Example SearchIndex in Naiad. Step 1: indexing documents' step 2: issuing queries.");                  Console.WriteLine("Indexing {0} random documents' {1} terms (please wait)"' documentCount' 10 * documentCount);                  subscription.Sync(0);                    #endregion                    #region Issue batches of queries and assess performance                    if (computation.Configuration.ProcessID == 0)                  {                      Console.WriteLine("Issuing {0} rounds of batches of {1} queries (press [enter] to start)"' iterations' batchSize);                      Console.ReadLine();                  }                    for (int i = 0; i < iterations; i++)                  {                      // we round-robin through query terms. more advanced queries are possible.                      if (computation.Configuration.ProcessID == 0)                          queries.OnNext(queryBatches[i]); // introduce new queries.                      else                          queries.OnNext();                        documents.OnNext();                     // indicate no new docs.                      subscription.Sync(i + 1);    // block until round is done.                  }                    documents.OnCompleted();                  queries.OnCompleted();                    #endregion                    computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SearchIndex,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\SearchIndex.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  #region building up input data                    if (args.Length == 5)                  {                      documentCount = Convert.ToInt32(args[1]);                      vocabulary = Convert.ToInt32(args[2]);                      batchSize = Convert.ToInt32(args[3]);                      iterations = Convert.ToInt32(args[4]);                  }                    var random = new Random(0);                  List<Document> docs = Enumerable.Range(0' documentCount)                                                 .Select(i => new Document(Enumerable.Range(0' 10)                                                 .Select(j => String.Format("{0}"' random.Next(vocabulary)))                                                 .Aggregate((x' y) => x + " " + y)' i)).ToList<Document>();                    List<Query>[] queryBatches = new List<Query>[iterations];                    for (int i = 0; i < iterations; i++)                  {                      queryBatches[i] = Enumerable.Range(i * batchSize' batchSize)                                                     .Select(j => new Query(String.Format("{0}"' j % vocabulary)' j' 1))                                                     .ToList();                  }                    #endregion                    // declare inputs for documents and queries.                  var documents = computation.NewInputCollection<Document>();                  var queries = computation.NewInputCollection<Query>();                    // each document is broken down into a collection of terms' each with associated identifier.                  var dTerms = documents.SelectMany(doc => doc.text.Split(' ').Select(term => new Document(term' doc.id)))                                        .Distinct();                    // each query is broken down into a collection of terms' each with associated identifier and threshold.                  var qTerms = queries.SelectMany(query => query.text.Split(' ').Select(term => new Query(term' query.id' query.threshold)))                                      .Distinct();                    // doc terms and query terms are joined' matching pairs are counted and returned if the count exceeds the threshold.                  var results = dTerms.Join(qTerms' d => d.text' q => q.text' (d' q) => new Match(d.id' q.id' q.threshold))                                      .Count(match => match)                                      .Select(pair => new Match(pair.First.document' pair.First.query' pair.First.threshold - (int)pair.Second))                                      .Where(match => match.threshold <= 0)                                      .Select(match => new Pair<int' int>(match.document' match.query));                    // subscribe to the output in case we are interested in the results                  var subscription = results.Subscribe(list => Console.WriteLine("matches found: {0}"' list.Length));                    computation.Activate();                    #region Prepare some fake documents to put in the collection                    // creates many documents each containing 10 words from [0' ... vocabulary-1].                  int share_size = docs.Count / computation.Configuration.Processes;                    documents.OnNext(docs.GetRange(computation.Configuration.ProcessID * share_size' share_size));                  queries.OnNext();                    //Console.WriteLine("Example SearchIndex in Naiad. Step 1: indexing documents' step 2: issuing queries.");                  Console.WriteLine("Indexing {0} random documents' {1} terms (please wait)"' documentCount' 10 * documentCount);                  subscription.Sync(0);                    #endregion                    #region Issue batches of queries and assess performance                    if (computation.Configuration.ProcessID == 0)                  {                      Console.WriteLine("Issuing {0} rounds of batches of {1} queries (press [enter] to start)"' iterations' batchSize);                      Console.ReadLine();                  }                    for (int i = 0; i < iterations; i++)                  {                      // we round-robin through query terms. more advanced queries are possible.                      if (computation.Configuration.ProcessID == 0)                          queries.OnNext(queryBatches[i]); // introduce new queries.                      else                          queries.OnNext();                        documents.OnNext();                     // indicate no new docs.                      subscription.Sync(i + 1);    // block until round is done.                  }                    documents.OnCompleted();                  queries.OnCompleted();                    #endregion                    computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SearchIndex,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\SearchIndex.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  #region building up input data                    if (args.Length == 5)                  {                      documentCount = Convert.ToInt32(args[1]);                      vocabulary = Convert.ToInt32(args[2]);                      batchSize = Convert.ToInt32(args[3]);                      iterations = Convert.ToInt32(args[4]);                  }                    var random = new Random(0);                  List<Document> docs = Enumerable.Range(0' documentCount)                                                 .Select(i => new Document(Enumerable.Range(0' 10)                                                 .Select(j => String.Format("{0}"' random.Next(vocabulary)))                                                 .Aggregate((x' y) => x + " " + y)' i)).ToList<Document>();                    List<Query>[] queryBatches = new List<Query>[iterations];                    for (int i = 0; i < iterations; i++)                  {                      queryBatches[i] = Enumerable.Range(i * batchSize' batchSize)                                                     .Select(j => new Query(String.Format("{0}"' j % vocabulary)' j' 1))                                                     .ToList();                  }                    #endregion                    // declare inputs for documents and queries.                  var documents = computation.NewInputCollection<Document>();                  var queries = computation.NewInputCollection<Query>();                    // each document is broken down into a collection of terms' each with associated identifier.                  var dTerms = documents.SelectMany(doc => doc.text.Split(' ').Select(term => new Document(term' doc.id)))                                        .Distinct();                    // each query is broken down into a collection of terms' each with associated identifier and threshold.                  var qTerms = queries.SelectMany(query => query.text.Split(' ').Select(term => new Query(term' query.id' query.threshold)))                                      .Distinct();                    // doc terms and query terms are joined' matching pairs are counted and returned if the count exceeds the threshold.                  var results = dTerms.Join(qTerms' d => d.text' q => q.text' (d' q) => new Match(d.id' q.id' q.threshold))                                      .Count(match => match)                                      .Select(pair => new Match(pair.First.document' pair.First.query' pair.First.threshold - (int)pair.Second))                                      .Where(match => match.threshold <= 0)                                      .Select(match => new Pair<int' int>(match.document' match.query));                    // subscribe to the output in case we are interested in the results                  var subscription = results.Subscribe(list => Console.WriteLine("matches found: {0}"' list.Length));                    computation.Activate();                    #region Prepare some fake documents to put in the collection                    // creates many documents each containing 10 words from [0' ... vocabulary-1].                  int share_size = docs.Count / computation.Configuration.Processes;                    documents.OnNext(docs.GetRange(computation.Configuration.ProcessID * share_size' share_size));                  queries.OnNext();                    //Console.WriteLine("Example SearchIndex in Naiad. Step 1: indexing documents' step 2: issuing queries.");                  Console.WriteLine("Indexing {0} random documents' {1} terms (please wait)"' documentCount' 10 * documentCount);                  subscription.Sync(0);                    #endregion                    #region Issue batches of queries and assess performance                    if (computation.Configuration.ProcessID == 0)                  {                      Console.WriteLine("Issuing {0} rounds of batches of {1} queries (press [enter] to start)"' iterations' batchSize);                      Console.ReadLine();                  }                    for (int i = 0; i < iterations; i++)                  {                      // we round-robin through query terms. more advanced queries are possible.                      if (computation.Configuration.ProcessID == 0)                          queries.OnNext(queryBatches[i]); // introduce new queries.                      else                          queries.OnNext();                        documents.OnNext();                     // indicate no new docs.                      subscription.Sync(i + 1);    // block until round is done.                  }                    documents.OnCompleted();                  queries.OnCompleted();                    #endregion                    computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SearchIndex,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\SearchIndex.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  #region building up input data                    if (args.Length == 5)                  {                      documentCount = Convert.ToInt32(args[1]);                      vocabulary = Convert.ToInt32(args[2]);                      batchSize = Convert.ToInt32(args[3]);                      iterations = Convert.ToInt32(args[4]);                  }                    var random = new Random(0);                  List<Document> docs = Enumerable.Range(0' documentCount)                                                 .Select(i => new Document(Enumerable.Range(0' 10)                                                 .Select(j => String.Format("{0}"' random.Next(vocabulary)))                                                 .Aggregate((x' y) => x + " " + y)' i)).ToList<Document>();                    List<Query>[] queryBatches = new List<Query>[iterations];                    for (int i = 0; i < iterations; i++)                  {                      queryBatches[i] = Enumerable.Range(i * batchSize' batchSize)                                                     .Select(j => new Query(String.Format("{0}"' j % vocabulary)' j' 1))                                                     .ToList();                  }                    #endregion                    // declare inputs for documents and queries.                  var documents = computation.NewInputCollection<Document>();                  var queries = computation.NewInputCollection<Query>();                    // each document is broken down into a collection of terms' each with associated identifier.                  var dTerms = documents.SelectMany(doc => doc.text.Split(' ').Select(term => new Document(term' doc.id)))                                        .Distinct();                    // each query is broken down into a collection of terms' each with associated identifier and threshold.                  var qTerms = queries.SelectMany(query => query.text.Split(' ').Select(term => new Query(term' query.id' query.threshold)))                                      .Distinct();                    // doc terms and query terms are joined' matching pairs are counted and returned if the count exceeds the threshold.                  var results = dTerms.Join(qTerms' d => d.text' q => q.text' (d' q) => new Match(d.id' q.id' q.threshold))                                      .Count(match => match)                                      .Select(pair => new Match(pair.First.document' pair.First.query' pair.First.threshold - (int)pair.Second))                                      .Where(match => match.threshold <= 0)                                      .Select(match => new Pair<int' int>(match.document' match.query));                    // subscribe to the output in case we are interested in the results                  var subscription = results.Subscribe(list => Console.WriteLine("matches found: {0}"' list.Length));                    computation.Activate();                    #region Prepare some fake documents to put in the collection                    // creates many documents each containing 10 words from [0' ... vocabulary-1].                  int share_size = docs.Count / computation.Configuration.Processes;                    documents.OnNext(docs.GetRange(computation.Configuration.ProcessID * share_size' share_size));                  queries.OnNext();                    //Console.WriteLine("Example SearchIndex in Naiad. Step 1: indexing documents' step 2: issuing queries.");                  Console.WriteLine("Indexing {0} random documents' {1} terms (please wait)"' documentCount' 10 * documentCount);                  subscription.Sync(0);                    #endregion                    #region Issue batches of queries and assess performance                    if (computation.Configuration.ProcessID == 0)                  {                      Console.WriteLine("Issuing {0} rounds of batches of {1} queries (press [enter] to start)"' iterations' batchSize);                      Console.ReadLine();                  }                    for (int i = 0; i < iterations; i++)                  {                      // we round-robin through query terms. more advanced queries are possible.                      if (computation.Configuration.ProcessID == 0)                          queries.OnNext(queryBatches[i]); // introduce new queries.                      else                          queries.OnNext();                        documents.OnNext();                     // indicate no new docs.                      subscription.Sync(i + 1);    // block until round is done.                  }                    documents.OnCompleted();                  queries.OnCompleted();                    #endregion                    computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,StronglyConnectedComponentsExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\StronglyConnectedComponents.cs,BroadcastMin,The following statement contains a magic number: var keep = 10;
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,StronglyConnectedComponentsExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\StronglyConnectedComponents.cs,BroadcastMin,The following statement contains a magic number: Func<SCC.Node' int> priority = node => 65536 * (node.label < keep ? node.label : keep + Convert.ToInt32(Math.Log(1 + node.label)));
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SCC,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\StronglyConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // establish numbers of nodes and edges from input or from defaults.                  if (args.Length == 3)                  {                      nodeCount = Convert.ToInt32(args[1]);                      edgeCount = Convert.ToInt32(args[2]);                  }                    // generate a random graph                  var random = new Random(0);                  var graph = new Edge[edgeCount];                  for (int i = 0; i < edgeCount; i++)                      graph[i] = new Edge(random.Next(nodeCount)' random.Next(nodeCount));                    // set up the SCC computation                  var edges = computation.NewInputCollection<Edge>();                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    var result = edges.TrimLeavesAndFlip()                                    .TrimLeavesAndFlip()                                    .SCC()                                    .Subscribe(x => Console.WriteLine("{1}\tNet edge changes within SCCs: {0}"' x.Sum(y => y.weight)' stopwatch.Elapsed));                    Console.WriteLine("Strongly connected components on a random graph ({0} nodes' {1} edges)"' nodeCount' edgeCount);                  Console.WriteLine("Reporting the numbers of edges within SCCs (may take a moment):");                    computation.Activate();                    // input graph and wait                  if (computation.Configuration.ProcessID == 0)                      edges.OnNext(graph);                  else                      edges.OnNext();                    result.Sync(0);                    Console.WriteLine("Computation completed");                    // if we are up for interactive access ...                  if (computation.Configuration.Processes == 1)                  {                      Console.WriteLine();                      Console.WriteLine("Press [enter] repeatedly to rewire random edges in the graph. (\"done\" to exit)");                        for (int i = 0; i < graph.Length; i++)                      {                          var line = Console.ReadLine();                          if (line == "done")                              break;                          stopwatch.Restart();                          var newEdge = new Edge(random.Next(nodeCount)' random.Next(nodeCount));                          Console.WriteLine("Rewiring edge: {0} -> {1}"' graph[i]' newEdge);                          edges.OnNext(new[] { new Weighted<Edge>(graph[i]' -1)' new Weighted<Edge>(newEdge' 1) });                          result.Sync(i + 1);                      }                  }                    edges.OnCompleted();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,SCC,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\StronglyConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // establish numbers of nodes and edges from input or from defaults.                  if (args.Length == 3)                  {                      nodeCount = Convert.ToInt32(args[1]);                      edgeCount = Convert.ToInt32(args[2]);                  }                    // generate a random graph                  var random = new Random(0);                  var graph = new Edge[edgeCount];                  for (int i = 0; i < edgeCount; i++)                      graph[i] = new Edge(random.Next(nodeCount)' random.Next(nodeCount));                    // set up the SCC computation                  var edges = computation.NewInputCollection<Edge>();                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                    var result = edges.TrimLeavesAndFlip()                                    .TrimLeavesAndFlip()                                    .SCC()                                    .Subscribe(x => Console.WriteLine("{1}\tNet edge changes within SCCs: {0}"' x.Sum(y => y.weight)' stopwatch.Elapsed));                    Console.WriteLine("Strongly connected components on a random graph ({0} nodes' {1} edges)"' nodeCount' edgeCount);                  Console.WriteLine("Reporting the numbers of edges within SCCs (may take a moment):");                    computation.Activate();                    // input graph and wait                  if (computation.Configuration.ProcessID == 0)                      edges.OnNext(graph);                  else                      edges.OnNext();                    result.Sync(0);                    Console.WriteLine("Computation completed");                    // if we are up for interactive access ...                  if (computation.Configuration.Processes == 1)                  {                      Console.WriteLine();                      Console.WriteLine("Press [enter] repeatedly to rewire random edges in the graph. (\"done\" to exit)");                        for (int i = 0; i < graph.Length; i++)                      {                          var line = Console.ReadLine();                          if (line == "done")                              break;                          stopwatch.Restart();                          var newEdge = new Edge(random.Next(nodeCount)' random.Next(nodeCount));                          Console.WriteLine("Rewiring edge: {0} -> {1}"' graph[i]' newEdge);                          edges.OnNext(new[] { new Weighted<Edge>(graph[i]' -1)' new Weighted<Edge>(newEdge' 1) });                          result.Sync(i + 1);                      }                  }                    edges.OnCompleted();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,Node,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\StronglyConnectedComponents.cs,GetHashCode,The following statement contains a magic number: return 13241 * name + 312 * label;
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,Node,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\StronglyConnectedComponents.cs,GetHashCode,The following statement contains a magic number: return 13241 * name + 312 * label;
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,Edge,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\StronglyConnectedComponents.cs,GetHashCode,The following statement contains a magic number: return 12312 * source + 1231 * target;
Magic Number,Microsoft.Research.Naiad.Examples.DifferentialDataflow,Edge,C:\repos\MicrosoftResearch_Naiad\Examples\DifferentialDataflow\StronglyConnectedComponents.cs,GetHashCode,The following statement contains a magic number: return 12312 * source + 1231 * target;
Magic Number,Microsoft.Research.Naiad.Examples.GraphLINQ,PageRank,C:\repos\MicrosoftResearch_Naiad\Examples\GraphLINQ\PageRank.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // either read inputs from a file' or generate them randomly.                  Stream<Edge' Epoch> edges;                  if (args.Length == 1)                  {                      // generate a random graph in each process; pagerank computation is performed on the union of edges.                      edges = GenerateEdges(1000000' 20000000' computation.Configuration.ProcessID).AsNaiadStream(computation);                  }                  else                  {                      var text = args.Skip(1)                                     .AsNaiadStream(computation)                                     .Distinct()                                     .SelectMany(x => x.ReadLinesOfText());                        edges = text.Where(x => !x.StartsWith("#"))                                  .Select(x => x.Split())                                  .Select(x => new Edge(new Node(Int32.Parse(x[0]))' new Node(Int32.Parse(x[1]))));                  }                    Console.Out.WriteLine("Started up!");                  Console.Out.Flush();                    edges = edges.PartitionBy(x => x.source);                    // capture degrees before trimming leaves.                  var degrees = edges.Select(x => x.source)                                     .CountNodes();                    // removes edges to pages with zero out-degree.                  var trim = false;                  if (trim)                      edges = edges.Select(x => x.target.WithValue(x.source))                                   .FilterBy(degrees.Select(x => x.node))                                   .Select(x => new Edge(x.value' x.node));                    // initial distribution of ranks.                  var start = degrees.Select(x => x.node.WithValue(0.15f))                                     .PartitionBy(x => x.node.index);                    // define an iterative pagerank computation' add initial values' aggregate up the results and print them to the screen.                  var iterations = 10;                  var ranks = start.IterateAndAccumulate((lc' deltas) => deltas.PageRankStep(lc.EnterLoop(degrees)'                                                                                             lc.EnterLoop(edges))'                                                          x => x.node.index'                                                          iterations'                                                          "PageRank")                                   .Concat(start)                             // add initial ranks in for correctness.                                   .NodeAggregate((x' y) => x + y)            // accumulate up the ranks.                                   .Where(x => x.value > 0.0f);               // report only positive ranks.                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                  computation.OnFrontierChange += (x' y) => { Console.WriteLine(stopwatch.Elapsed + "\t" + string.Join("' "' y.NewFrontier)); Console.Out.Flush(); };                    // start computation' and block until completion.                  computation.Activate();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.GraphLINQ,PageRank,C:\repos\MicrosoftResearch_Naiad\Examples\GraphLINQ\PageRank.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // either read inputs from a file' or generate them randomly.                  Stream<Edge' Epoch> edges;                  if (args.Length == 1)                  {                      // generate a random graph in each process; pagerank computation is performed on the union of edges.                      edges = GenerateEdges(1000000' 20000000' computation.Configuration.ProcessID).AsNaiadStream(computation);                  }                  else                  {                      var text = args.Skip(1)                                     .AsNaiadStream(computation)                                     .Distinct()                                     .SelectMany(x => x.ReadLinesOfText());                        edges = text.Where(x => !x.StartsWith("#"))                                  .Select(x => x.Split())                                  .Select(x => new Edge(new Node(Int32.Parse(x[0]))' new Node(Int32.Parse(x[1]))));                  }                    Console.Out.WriteLine("Started up!");                  Console.Out.Flush();                    edges = edges.PartitionBy(x => x.source);                    // capture degrees before trimming leaves.                  var degrees = edges.Select(x => x.source)                                     .CountNodes();                    // removes edges to pages with zero out-degree.                  var trim = false;                  if (trim)                      edges = edges.Select(x => x.target.WithValue(x.source))                                   .FilterBy(degrees.Select(x => x.node))                                   .Select(x => new Edge(x.value' x.node));                    // initial distribution of ranks.                  var start = degrees.Select(x => x.node.WithValue(0.15f))                                     .PartitionBy(x => x.node.index);                    // define an iterative pagerank computation' add initial values' aggregate up the results and print them to the screen.                  var iterations = 10;                  var ranks = start.IterateAndAccumulate((lc' deltas) => deltas.PageRankStep(lc.EnterLoop(degrees)'                                                                                             lc.EnterLoop(edges))'                                                          x => x.node.index'                                                          iterations'                                                          "PageRank")                                   .Concat(start)                             // add initial ranks in for correctness.                                   .NodeAggregate((x' y) => x + y)            // accumulate up the ranks.                                   .Where(x => x.value > 0.0f);               // report only positive ranks.                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                  computation.OnFrontierChange += (x' y) => { Console.WriteLine(stopwatch.Elapsed + "\t" + string.Join("' "' y.NewFrontier)); Console.Out.Flush(); };                    // start computation' and block until completion.                  computation.Activate();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.GraphLINQ,PageRank,C:\repos\MicrosoftResearch_Naiad\Examples\GraphLINQ\PageRank.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // either read inputs from a file' or generate them randomly.                  Stream<Edge' Epoch> edges;                  if (args.Length == 1)                  {                      // generate a random graph in each process; pagerank computation is performed on the union of edges.                      edges = GenerateEdges(1000000' 20000000' computation.Configuration.ProcessID).AsNaiadStream(computation);                  }                  else                  {                      var text = args.Skip(1)                                     .AsNaiadStream(computation)                                     .Distinct()                                     .SelectMany(x => x.ReadLinesOfText());                        edges = text.Where(x => !x.StartsWith("#"))                                  .Select(x => x.Split())                                  .Select(x => new Edge(new Node(Int32.Parse(x[0]))' new Node(Int32.Parse(x[1]))));                  }                    Console.Out.WriteLine("Started up!");                  Console.Out.Flush();                    edges = edges.PartitionBy(x => x.source);                    // capture degrees before trimming leaves.                  var degrees = edges.Select(x => x.source)                                     .CountNodes();                    // removes edges to pages with zero out-degree.                  var trim = false;                  if (trim)                      edges = edges.Select(x => x.target.WithValue(x.source))                                   .FilterBy(degrees.Select(x => x.node))                                   .Select(x => new Edge(x.value' x.node));                    // initial distribution of ranks.                  var start = degrees.Select(x => x.node.WithValue(0.15f))                                     .PartitionBy(x => x.node.index);                    // define an iterative pagerank computation' add initial values' aggregate up the results and print them to the screen.                  var iterations = 10;                  var ranks = start.IterateAndAccumulate((lc' deltas) => deltas.PageRankStep(lc.EnterLoop(degrees)'                                                                                             lc.EnterLoop(edges))'                                                          x => x.node.index'                                                          iterations'                                                          "PageRank")                                   .Concat(start)                             // add initial ranks in for correctness.                                   .NodeAggregate((x' y) => x + y)            // accumulate up the ranks.                                   .Where(x => x.value > 0.0f);               // report only positive ranks.                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();                  computation.OnFrontierChange += (x' y) => { Console.WriteLine(stopwatch.Elapsed + "\t" + string.Join("' "' y.NewFrontier)); Console.Out.Flush(); };                    // start computation' and block until completion.                  computation.Activate();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.GraphLINQ,Reachability,C:\repos\MicrosoftResearch_Naiad\Examples\GraphLINQ\Reachability.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  // define a graph input from a filename and some transformations.                  var edgeStrings = new[] { args[1] }.AsNaiadStream(computation)                                                     .SelectMany(x => ReadLines(x))                                                     .Select(x => x.Split())                                                     .Select(x => x[0].PairWith(x[1]));                    // define reachability roots from a second filename.                  var rootStrings = new[] { args[2] }.AsNaiadStream(computation)                                                     .SelectMany(x => ReadLines(x));                    // convert (string' string) -> edge and string -> node.                  Stream<Edge' Epoch> edges;  // will eventually hold stream of edges                  Stream<Node' Epoch> roots;  // will eventually hold stream of roots                    // an autorenamer context is used to consistently rename identifiers.                  using (var renamer = new AutoRenamer<string>())                  {                      var tempEdges = edgeStrings.RenameUsing(renamer' x => x.First)              // use the first string to find a name                                                 .Select(x => x.node.WithValue(x.value.Second))   // discard the first string                                                 .RenameUsing(renamer' x => x.value)              // use the second string to find a name                                                 .Select(x => new Edge(x.value.node' x.node));    // discard the second string and form an edge                                                               var tempRoots = rootStrings.RenameUsing(renamer' x => x)                    // use the string itself to find a name                                                 .Select(x => x.node);                            // discard the string and keep the node                        // FinishRenaming only after all RenameUsing                      edges = tempEdges.FinishRenaming(renamer);                      roots = tempRoots.FinishRenaming(renamer);                  }                    // iteratively expand reachable set as pairs (node' isReachable).                  var limit = roots.Select(x => x.WithValue(true))                                   .IterateAndAccumulate((lc' x) => x.TransmitAlong(lc.EnterLoop(edges))      // transmit (node' true) values along edges                                                                     .StateMachine((bool b' bool s) => true)' // any received value sets the state to true                                                          x => x.node.index'                                  // partitioning information                                                          Int32.MaxValue'                                     // the number of iterations                                                          "Reachability")                                     // a nice descriptive name                                   .Concat(roots.Select(x => x.WithValue(true)))                              // add the original trusted nodes                                   .NodeAggregate((a' b) => true)                                   .Where(x => x.value);                                                      // aggregate' for the originals                    // print the results onto the screen (or write to file' as appopriate)                  limit.Select(x => x.node.index)                       .Subscribe(x => Console.WriteLine(x.Count()));                    // start the computation and wait until it finishes                  computation.Activate();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.ConnectedComponents,StreamingAggregateVertex<TKey;TValue;TTime>,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\ConnectedComponents.cs,StreamingAggregateVertex,The following statement contains a magic number: this.Entrancy = 5;
Magic Number,Microsoft.Research.Naiad.Examples.ConnectedComponents,GraphJoinVertex<TVertex;TState;TTime>,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\ConnectedComponents.cs,GraphJoinVertex,The following statement contains a magic number: this.Entrancy = 5;
Magic Number,Microsoft.Research.Naiad.Examples.ConnectedComponents,ConnectedComponents,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\ConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  var nodeCount = args.Length == 3 ? Convert.ToInt32(args[1]) : 1000;                  var edgeCount = args.Length == 3 ? Convert.ToInt32(args[2]) : 2000;                    #region Generate a local fraction of input data                    var random = new Random(0);                  var processes = computation.Configuration.Processes;                  var thisProcess = computation.Configuration.ProcessID;                  var graphFragmentList = new List<Pair<int' int>>();                  for (int i = 0; i < edgeCount; i++)                  {                      // ensure we generate the same graph no matter how many processes there are                      var edge = new Pair<int' int>(random.Next(nodeCount)' random.Next(nodeCount));                      if ((i % processes) == thisProcess)                      {                          graphFragmentList.Add(edge);                      }                  }                                        var graphFragment = graphFragmentList.ToArray();                    #endregion                    Console.WriteLine("Computing components of a random graph on {0} nodes and {1} edges"' nodeCount' edgeCount);                    Stopwatch stopwatch = new Stopwatch();                    // convert array of edges to single-epoch stream.                  var edges = graphFragment.AsNaiadStream(computation)                                           .Synchronize(x => true);                    // symmetrize the graph by adding in transposed edges.                  edges = edges.Select(x => new Pair<int' int>(x.Second' x.First))                               .Concat(edges);                    edges.DirectedReachability()                       .Subscribe(list => Console.WriteLine("labeled {0} nodes in {1}"' list.Count()' stopwatch.Elapsed));                    stopwatch.Start();                  computation.Activate();     // start graph computation                  computation.Join();         // block until computation completes              }
Magic Number,Microsoft.Research.Naiad.Examples.ConnectedComponents,ConnectedComponents,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\ConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  var nodeCount = args.Length == 3 ? Convert.ToInt32(args[1]) : 1000;                  var edgeCount = args.Length == 3 ? Convert.ToInt32(args[2]) : 2000;                    #region Generate a local fraction of input data                    var random = new Random(0);                  var processes = computation.Configuration.Processes;                  var thisProcess = computation.Configuration.ProcessID;                  var graphFragmentList = new List<Pair<int' int>>();                  for (int i = 0; i < edgeCount; i++)                  {                      // ensure we generate the same graph no matter how many processes there are                      var edge = new Pair<int' int>(random.Next(nodeCount)' random.Next(nodeCount));                      if ((i % processes) == thisProcess)                      {                          graphFragmentList.Add(edge);                      }                  }                                        var graphFragment = graphFragmentList.ToArray();                    #endregion                    Console.WriteLine("Computing components of a random graph on {0} nodes and {1} edges"' nodeCount' edgeCount);                    Stopwatch stopwatch = new Stopwatch();                    // convert array of edges to single-epoch stream.                  var edges = graphFragment.AsNaiadStream(computation)                                           .Synchronize(x => true);                    // symmetrize the graph by adding in transposed edges.                  edges = edges.Select(x => new Pair<int' int>(x.Second' x.First))                               .Concat(edges);                    edges.DirectedReachability()                       .Subscribe(list => Console.WriteLine("labeled {0} nodes in {1}"' list.Count()' stopwatch.Elapsed));                    stopwatch.Start();                  computation.Activate();     // start graph computation                  computation.Join();         // block until computation completes              }
Magic Number,Microsoft.Research.Naiad.Examples.ConnectedComponents,ConnectedComponents,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\ConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  var nodeCount = args.Length == 3 ? Convert.ToInt32(args[1]) : 1000;                  var edgeCount = args.Length == 3 ? Convert.ToInt32(args[2]) : 2000;                    #region Generate a local fraction of input data                    var random = new Random(0);                  var processes = computation.Configuration.Processes;                  var thisProcess = computation.Configuration.ProcessID;                  var graphFragmentList = new List<Pair<int' int>>();                  for (int i = 0; i < edgeCount; i++)                  {                      // ensure we generate the same graph no matter how many processes there are                      var edge = new Pair<int' int>(random.Next(nodeCount)' random.Next(nodeCount));                      if ((i % processes) == thisProcess)                      {                          graphFragmentList.Add(edge);                      }                  }                                        var graphFragment = graphFragmentList.ToArray();                    #endregion                    Console.WriteLine("Computing components of a random graph on {0} nodes and {1} edges"' nodeCount' edgeCount);                    Stopwatch stopwatch = new Stopwatch();                    // convert array of edges to single-epoch stream.                  var edges = graphFragment.AsNaiadStream(computation)                                           .Synchronize(x => true);                    // symmetrize the graph by adding in transposed edges.                  edges = edges.Select(x => new Pair<int' int>(x.Second' x.First))                               .Concat(edges);                    edges.DirectedReachability()                       .Subscribe(list => Console.WriteLine("labeled {0} nodes in {1}"' list.Count()' stopwatch.Elapsed));                    stopwatch.Start();                  computation.Activate();     // start graph computation                  computation.Join();         // block until computation completes              }
Magic Number,Microsoft.Research.Naiad.Examples.ConnectedComponents,ConnectedComponents,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\ConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  var nodeCount = args.Length == 3 ? Convert.ToInt32(args[1]) : 1000;                  var edgeCount = args.Length == 3 ? Convert.ToInt32(args[2]) : 2000;                    #region Generate a local fraction of input data                    var random = new Random(0);                  var processes = computation.Configuration.Processes;                  var thisProcess = computation.Configuration.ProcessID;                  var graphFragmentList = new List<Pair<int' int>>();                  for (int i = 0; i < edgeCount; i++)                  {                      // ensure we generate the same graph no matter how many processes there are                      var edge = new Pair<int' int>(random.Next(nodeCount)' random.Next(nodeCount));                      if ((i % processes) == thisProcess)                      {                          graphFragmentList.Add(edge);                      }                  }                                        var graphFragment = graphFragmentList.ToArray();                    #endregion                    Console.WriteLine("Computing components of a random graph on {0} nodes and {1} edges"' nodeCount' edgeCount);                    Stopwatch stopwatch = new Stopwatch();                    // convert array of edges to single-epoch stream.                  var edges = graphFragment.AsNaiadStream(computation)                                           .Synchronize(x => true);                    // symmetrize the graph by adding in transposed edges.                  edges = edges.Select(x => new Pair<int' int>(x.Second' x.First))                               .Concat(edges);                    edges.DirectedReachability()                       .Subscribe(list => Console.WriteLine("labeled {0} nodes in {1}"' list.Count()' stopwatch.Elapsed));                    stopwatch.Start();                  computation.Activate();     // start graph computation                  computation.Join();         // block until computation completes              }
Magic Number,Microsoft.Research.Naiad.Examples.ConnectedComponents,ConnectedComponents,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\ConnectedComponents.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  var nodeCount = args.Length == 3 ? Convert.ToInt32(args[1]) : 1000;                  var edgeCount = args.Length == 3 ? Convert.ToInt32(args[2]) : 2000;                    #region Generate a local fraction of input data                    var random = new Random(0);                  var processes = computation.Configuration.Processes;                  var thisProcess = computation.Configuration.ProcessID;                  var graphFragmentList = new List<Pair<int' int>>();                  for (int i = 0; i < edgeCount; i++)                  {                      // ensure we generate the same graph no matter how many processes there are                      var edge = new Pair<int' int>(random.Next(nodeCount)' random.Next(nodeCount));                      if ((i % processes) == thisProcess)                      {                          graphFragmentList.Add(edge);                      }                  }                                        var graphFragment = graphFragmentList.ToArray();                    #endregion                    Console.WriteLine("Computing components of a random graph on {0} nodes and {1} edges"' nodeCount' edgeCount);                    Stopwatch stopwatch = new Stopwatch();                    // convert array of edges to single-epoch stream.                  var edges = graphFragment.AsNaiadStream(computation)                                           .Synchronize(x => true);                    // symmetrize the graph by adding in transposed edges.                  edges = edges.Select(x => new Pair<int' int>(x.Second' x.First))                               .Concat(edges);                    edges.DirectedReachability()                       .Subscribe(list => Console.WriteLine("labeled {0} nodes in {1}"' list.Count()' stopwatch.Elapsed));                    stopwatch.Start();                  computation.Activate();     // start graph computation                  computation.Join();         // block until computation completes              }
Magic Number,Microsoft.Research.Naiad.Examples.KeyValueLookup,KeyValueLookup,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\KeyValueLookup.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  var keyvals = new BatchedDataSource<Pair<string' string>>();                  var queries = new BatchedDataSource<string>();                    computation.NewInput(keyvals)                         .KeyValueLookup(computation.NewInput(queries))                         .Subscribe(list => { foreach (var l in list) Console.WriteLine("value[\"{0}\"]:\t\"{1}\""' l.First' l.Second); });                    computation.Activate();                    if (computation.Configuration.ProcessID == 0)                  {                      Console.WriteLine("Enter two strings to insert/overwrite a (key' value) pairs.");                      Console.WriteLine("Enter one string to look up a key.");                        // repeatedly read lines and introduce records based on their structure.                      // note: it is important to advance both inputs in order to make progress.                      for (var line = Console.ReadLine(); line.Length > 0; line = Console.ReadLine())                      {                          var split = line.Split();                            if (split.Length == 1)                          {                              queries.OnNext(line);                              keyvals.OnNext();                          }                          if (split.Length == 2)                          {                              queries.OnNext();                              keyvals.OnNext(split[0].PairWith(split[1]));                          }                          if (split.Length > 2)                              Console.Error.WriteLine("error: lines with three or more strings are not understood.");                      }                  }                    keyvals.OnCompleted();                  queries.OnCompleted();                    computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.KeyValueLookup,KeyValueLookup,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\KeyValueLookup.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  var keyvals = new BatchedDataSource<Pair<string' string>>();                  var queries = new BatchedDataSource<string>();                    computation.NewInput(keyvals)                         .KeyValueLookup(computation.NewInput(queries))                         .Subscribe(list => { foreach (var l in list) Console.WriteLine("value[\"{0}\"]:\t\"{1}\""' l.First' l.Second); });                    computation.Activate();                    if (computation.Configuration.ProcessID == 0)                  {                      Console.WriteLine("Enter two strings to insert/overwrite a (key' value) pairs.");                      Console.WriteLine("Enter one string to look up a key.");                        // repeatedly read lines and introduce records based on their structure.                      // note: it is important to advance both inputs in order to make progress.                      for (var line = Console.ReadLine(); line.Length > 0; line = Console.ReadLine())                      {                          var split = line.Split();                            if (split.Length == 1)                          {                              queries.OnNext(line);                              keyvals.OnNext();                          }                          if (split.Length == 2)                          {                              queries.OnNext();                              keyvals.OnNext(split[0].PairWith(split[1]));                          }                          if (split.Length > 2)                              Console.Error.WriteLine("error: lines with three or more strings are not understood.");                      }                  }                    keyvals.OnCompleted();                  queries.OnCompleted();                    computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.Latency,Latency,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  int iterations = int.Parse(args[1]);                    // first construct a simple graph with a feedback loop.                  var inputStream = (new int[] { }).AsNaiadStream(computation);                    var loopContext = new LoopContext<Epoch>(inputStream.Context' "loop");                  var feedback = loopContext.Delay<int>();                  var ingress = loopContext.EnterLoop(inputStream);                    feedback.Input = Barrier.MakeStage(ingress' feedback.Output' iterations);                    // prepare measurement callbacks                  var sw = new Stopwatch();                  var lastTime = 0L;                  var times = new List<double>(iterations);                    computation.OnStartup += (c' y) => { sw.Start(); };                  computation.OnFrontierChange += (v' b) =>                  {                      var now = sw.ElapsedTicks;                        if (lastTime > 0)                          times.Add(1000.0 * (now - lastTime) / (double)Stopwatch.Frequency);                        lastTime = now;                  };                    Console.WriteLine("Running barrier latency test with {0} iterations' vertices={1}"' iterations' ingress.ForStage.Placement.Count);                    // start computation and block                  computation.Activate();                  computation.Join();                    // print results                  times.Sort();                    var percentiles = new[] { 0.00' 0.01' 0.05' 0.10' 0.25' 0.50' 0.75' 0.90' 0.95' 0.99 };                  var latencies = percentiles.Select(f => times[(int)(iterations * f)]).ToArray();                    Console.WriteLine("Ran {0} iterations on {1} processes; this is process {2}"' times.Count - 1' computation.Configuration.Processes' computation.Configuration.ProcessID);                    Console.WriteLine("%-ile\tLatency (ms)");                  for (int i = 0; i < latencies.Length; i++)                      Console.WriteLine("{0:0.00}:\t{1:0.00}"' percentiles[i]' latencies[i]);                    Console.WriteLine("max:\t{0:0.00}"' latencies[latencies.Length - 1]);                }
Magic Number,Microsoft.Research.Naiad.Examples.Latency,Latency,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  int iterations = int.Parse(args[1]);                    // first construct a simple graph with a feedback loop.                  var inputStream = (new int[] { }).AsNaiadStream(computation);                    var loopContext = new LoopContext<Epoch>(inputStream.Context' "loop");                  var feedback = loopContext.Delay<int>();                  var ingress = loopContext.EnterLoop(inputStream);                    feedback.Input = Barrier.MakeStage(ingress' feedback.Output' iterations);                    // prepare measurement callbacks                  var sw = new Stopwatch();                  var lastTime = 0L;                  var times = new List<double>(iterations);                    computation.OnStartup += (c' y) => { sw.Start(); };                  computation.OnFrontierChange += (v' b) =>                  {                      var now = sw.ElapsedTicks;                        if (lastTime > 0)                          times.Add(1000.0 * (now - lastTime) / (double)Stopwatch.Frequency);                        lastTime = now;                  };                    Console.WriteLine("Running barrier latency test with {0} iterations' vertices={1}"' iterations' ingress.ForStage.Placement.Count);                    // start computation and block                  computation.Activate();                  computation.Join();                    // print results                  times.Sort();                    var percentiles = new[] { 0.00' 0.01' 0.05' 0.10' 0.25' 0.50' 0.75' 0.90' 0.95' 0.99 };                  var latencies = percentiles.Select(f => times[(int)(iterations * f)]).ToArray();                    Console.WriteLine("Ran {0} iterations on {1} processes; this is process {2}"' times.Count - 1' computation.Configuration.Processes' computation.Configuration.ProcessID);                    Console.WriteLine("%-ile\tLatency (ms)");                  for (int i = 0; i < latencies.Length; i++)                      Console.WriteLine("{0:0.00}:\t{1:0.00}"' percentiles[i]' latencies[i]);                    Console.WriteLine("max:\t{0:0.00}"' latencies[latencies.Length - 1]);                }
Magic Number,Microsoft.Research.Naiad.Examples.Latency,Latency,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  int iterations = int.Parse(args[1]);                    // first construct a simple graph with a feedback loop.                  var inputStream = (new int[] { }).AsNaiadStream(computation);                    var loopContext = new LoopContext<Epoch>(inputStream.Context' "loop");                  var feedback = loopContext.Delay<int>();                  var ingress = loopContext.EnterLoop(inputStream);                    feedback.Input = Barrier.MakeStage(ingress' feedback.Output' iterations);                    // prepare measurement callbacks                  var sw = new Stopwatch();                  var lastTime = 0L;                  var times = new List<double>(iterations);                    computation.OnStartup += (c' y) => { sw.Start(); };                  computation.OnFrontierChange += (v' b) =>                  {                      var now = sw.ElapsedTicks;                        if (lastTime > 0)                          times.Add(1000.0 * (now - lastTime) / (double)Stopwatch.Frequency);                        lastTime = now;                  };                    Console.WriteLine("Running barrier latency test with {0} iterations' vertices={1}"' iterations' ingress.ForStage.Placement.Count);                    // start computation and block                  computation.Activate();                  computation.Join();                    // print results                  times.Sort();                    var percentiles = new[] { 0.00' 0.01' 0.05' 0.10' 0.25' 0.50' 0.75' 0.90' 0.95' 0.99 };                  var latencies = percentiles.Select(f => times[(int)(iterations * f)]).ToArray();                    Console.WriteLine("Ran {0} iterations on {1} processes; this is process {2}"' times.Count - 1' computation.Configuration.Processes' computation.Configuration.ProcessID);                    Console.WriteLine("%-ile\tLatency (ms)");                  for (int i = 0; i < latencies.Length; i++)                      Console.WriteLine("{0:0.00}:\t{1:0.00}"' percentiles[i]' latencies[i]);                    Console.WriteLine("max:\t{0:0.00}"' latencies[latencies.Length - 1]);                }
Magic Number,Microsoft.Research.Naiad.Examples.Latency,Latency,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  int iterations = int.Parse(args[1]);                    // first construct a simple graph with a feedback loop.                  var inputStream = (new int[] { }).AsNaiadStream(computation);                    var loopContext = new LoopContext<Epoch>(inputStream.Context' "loop");                  var feedback = loopContext.Delay<int>();                  var ingress = loopContext.EnterLoop(inputStream);                    feedback.Input = Barrier.MakeStage(ingress' feedback.Output' iterations);                    // prepare measurement callbacks                  var sw = new Stopwatch();                  var lastTime = 0L;                  var times = new List<double>(iterations);                    computation.OnStartup += (c' y) => { sw.Start(); };                  computation.OnFrontierChange += (v' b) =>                  {                      var now = sw.ElapsedTicks;                        if (lastTime > 0)                          times.Add(1000.0 * (now - lastTime) / (double)Stopwatch.Frequency);                        lastTime = now;                  };                    Console.WriteLine("Running barrier latency test with {0} iterations' vertices={1}"' iterations' ingress.ForStage.Placement.Count);                    // start computation and block                  computation.Activate();                  computation.Join();                    // print results                  times.Sort();                    var percentiles = new[] { 0.00' 0.01' 0.05' 0.10' 0.25' 0.50' 0.75' 0.90' 0.95' 0.99 };                  var latencies = percentiles.Select(f => times[(int)(iterations * f)]).ToArray();                    Console.WriteLine("Ran {0} iterations on {1} processes; this is process {2}"' times.Count - 1' computation.Configuration.Processes' computation.Configuration.ProcessID);                    Console.WriteLine("%-ile\tLatency (ms)");                  for (int i = 0; i < latencies.Length; i++)                      Console.WriteLine("{0:0.00}:\t{1:0.00}"' percentiles[i]' latencies[i]);                    Console.WriteLine("max:\t{0:0.00}"' latencies[latencies.Length - 1]);                }
Magic Number,Microsoft.Research.Naiad.Examples.Latency,Latency,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  int iterations = int.Parse(args[1]);                    // first construct a simple graph with a feedback loop.                  var inputStream = (new int[] { }).AsNaiadStream(computation);                    var loopContext = new LoopContext<Epoch>(inputStream.Context' "loop");                  var feedback = loopContext.Delay<int>();                  var ingress = loopContext.EnterLoop(inputStream);                    feedback.Input = Barrier.MakeStage(ingress' feedback.Output' iterations);                    // prepare measurement callbacks                  var sw = new Stopwatch();                  var lastTime = 0L;                  var times = new List<double>(iterations);                    computation.OnStartup += (c' y) => { sw.Start(); };                  computation.OnFrontierChange += (v' b) =>                  {                      var now = sw.ElapsedTicks;                        if (lastTime > 0)                          times.Add(1000.0 * (now - lastTime) / (double)Stopwatch.Frequency);                        lastTime = now;                  };                    Console.WriteLine("Running barrier latency test with {0} iterations' vertices={1}"' iterations' ingress.ForStage.Placement.Count);                    // start computation and block                  computation.Activate();                  computation.Join();                    // print results                  times.Sort();                    var percentiles = new[] { 0.00' 0.01' 0.05' 0.10' 0.25' 0.50' 0.75' 0.90' 0.95' 0.99 };                  var latencies = percentiles.Select(f => times[(int)(iterations * f)]).ToArray();                    Console.WriteLine("Ran {0} iterations on {1} processes; this is process {2}"' times.Count - 1' computation.Configuration.Processes' computation.Configuration.ProcessID);                    Console.WriteLine("%-ile\tLatency (ms)");                  for (int i = 0; i < latencies.Length; i++)                      Console.WriteLine("{0:0.00}:\t{1:0.00}"' percentiles[i]' latencies[i]);                    Console.WriteLine("max:\t{0:0.00}"' latencies[latencies.Length - 1]);                }
Magic Number,Microsoft.Research.Naiad.Examples.Latency,Latency,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  int iterations = int.Parse(args[1]);                    // first construct a simple graph with a feedback loop.                  var inputStream = (new int[] { }).AsNaiadStream(computation);                    var loopContext = new LoopContext<Epoch>(inputStream.Context' "loop");                  var feedback = loopContext.Delay<int>();                  var ingress = loopContext.EnterLoop(inputStream);                    feedback.Input = Barrier.MakeStage(ingress' feedback.Output' iterations);                    // prepare measurement callbacks                  var sw = new Stopwatch();                  var lastTime = 0L;                  var times = new List<double>(iterations);                    computation.OnStartup += (c' y) => { sw.Start(); };                  computation.OnFrontierChange += (v' b) =>                  {                      var now = sw.ElapsedTicks;                        if (lastTime > 0)                          times.Add(1000.0 * (now - lastTime) / (double)Stopwatch.Frequency);                        lastTime = now;                  };                    Console.WriteLine("Running barrier latency test with {0} iterations' vertices={1}"' iterations' ingress.ForStage.Placement.Count);                    // start computation and block                  computation.Activate();                  computation.Join();                    // print results                  times.Sort();                    var percentiles = new[] { 0.00' 0.01' 0.05' 0.10' 0.25' 0.50' 0.75' 0.90' 0.95' 0.99 };                  var latencies = percentiles.Select(f => times[(int)(iterations * f)]).ToArray();                    Console.WriteLine("Ran {0} iterations on {1} processes; this is process {2}"' times.Count - 1' computation.Configuration.Processes' computation.Configuration.ProcessID);                    Console.WriteLine("%-ile\tLatency (ms)");                  for (int i = 0; i < latencies.Length; i++)                      Console.WriteLine("{0:0.00}:\t{1:0.00}"' percentiles[i]' latencies[i]);                    Console.WriteLine("max:\t{0:0.00}"' latencies[latencies.Length - 1]);                }
Magic Number,Microsoft.Research.Naiad.Examples.Latency,Latency,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  int iterations = int.Parse(args[1]);                    // first construct a simple graph with a feedback loop.                  var inputStream = (new int[] { }).AsNaiadStream(computation);                    var loopContext = new LoopContext<Epoch>(inputStream.Context' "loop");                  var feedback = loopContext.Delay<int>();                  var ingress = loopContext.EnterLoop(inputStream);                    feedback.Input = Barrier.MakeStage(ingress' feedback.Output' iterations);                    // prepare measurement callbacks                  var sw = new Stopwatch();                  var lastTime = 0L;                  var times = new List<double>(iterations);                    computation.OnStartup += (c' y) => { sw.Start(); };                  computation.OnFrontierChange += (v' b) =>                  {                      var now = sw.ElapsedTicks;                        if (lastTime > 0)                          times.Add(1000.0 * (now - lastTime) / (double)Stopwatch.Frequency);                        lastTime = now;                  };                    Console.WriteLine("Running barrier latency test with {0} iterations' vertices={1}"' iterations' ingress.ForStage.Placement.Count);                    // start computation and block                  computation.Activate();                  computation.Join();                    // print results                  times.Sort();                    var percentiles = new[] { 0.00' 0.01' 0.05' 0.10' 0.25' 0.50' 0.75' 0.90' 0.95' 0.99 };                  var latencies = percentiles.Select(f => times[(int)(iterations * f)]).ToArray();                    Console.WriteLine("Ran {0} iterations on {1} processes; this is process {2}"' times.Count - 1' computation.Configuration.Processes' computation.Configuration.ProcessID);                    Console.WriteLine("%-ile\tLatency (ms)");                  for (int i = 0; i < latencies.Length; i++)                      Console.WriteLine("{0:0.00}:\t{1:0.00}"' percentiles[i]' latencies[i]);                    Console.WriteLine("max:\t{0:0.00}"' latencies[latencies.Length - 1]);                }
Magic Number,Microsoft.Research.Naiad.Examples.Latency,Latency,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  int iterations = int.Parse(args[1]);                    // first construct a simple graph with a feedback loop.                  var inputStream = (new int[] { }).AsNaiadStream(computation);                    var loopContext = new LoopContext<Epoch>(inputStream.Context' "loop");                  var feedback = loopContext.Delay<int>();                  var ingress = loopContext.EnterLoop(inputStream);                    feedback.Input = Barrier.MakeStage(ingress' feedback.Output' iterations);                    // prepare measurement callbacks                  var sw = new Stopwatch();                  var lastTime = 0L;                  var times = new List<double>(iterations);                    computation.OnStartup += (c' y) => { sw.Start(); };                  computation.OnFrontierChange += (v' b) =>                  {                      var now = sw.ElapsedTicks;                        if (lastTime > 0)                          times.Add(1000.0 * (now - lastTime) / (double)Stopwatch.Frequency);                        lastTime = now;                  };                    Console.WriteLine("Running barrier latency test with {0} iterations' vertices={1}"' iterations' ingress.ForStage.Placement.Count);                    // start computation and block                  computation.Activate();                  computation.Join();                    // print results                  times.Sort();                    var percentiles = new[] { 0.00' 0.01' 0.05' 0.10' 0.25' 0.50' 0.75' 0.90' 0.95' 0.99 };                  var latencies = percentiles.Select(f => times[(int)(iterations * f)]).ToArray();                    Console.WriteLine("Ran {0} iterations on {1} processes; this is process {2}"' times.Count - 1' computation.Configuration.Processes' computation.Configuration.ProcessID);                    Console.WriteLine("%-ile\tLatency (ms)");                  for (int i = 0; i < latencies.Length; i++)                      Console.WriteLine("{0:0.00}:\t{1:0.00}"' percentiles[i]' latencies[i]);                    Console.WriteLine("max:\t{0:0.00}"' latencies[latencies.Length - 1]);                }
Magic Number,Microsoft.Research.Naiad.Examples.Latency,Latency,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  int iterations = int.Parse(args[1]);                    // first construct a simple graph with a feedback loop.                  var inputStream = (new int[] { }).AsNaiadStream(computation);                    var loopContext = new LoopContext<Epoch>(inputStream.Context' "loop");                  var feedback = loopContext.Delay<int>();                  var ingress = loopContext.EnterLoop(inputStream);                    feedback.Input = Barrier.MakeStage(ingress' feedback.Output' iterations);                    // prepare measurement callbacks                  var sw = new Stopwatch();                  var lastTime = 0L;                  var times = new List<double>(iterations);                    computation.OnStartup += (c' y) => { sw.Start(); };                  computation.OnFrontierChange += (v' b) =>                  {                      var now = sw.ElapsedTicks;                        if (lastTime > 0)                          times.Add(1000.0 * (now - lastTime) / (double)Stopwatch.Frequency);                        lastTime = now;                  };                    Console.WriteLine("Running barrier latency test with {0} iterations' vertices={1}"' iterations' ingress.ForStage.Placement.Count);                    // start computation and block                  computation.Activate();                  computation.Join();                    // print results                  times.Sort();                    var percentiles = new[] { 0.00' 0.01' 0.05' 0.10' 0.25' 0.50' 0.75' 0.90' 0.95' 0.99 };                  var latencies = percentiles.Select(f => times[(int)(iterations * f)]).ToArray();                    Console.WriteLine("Ran {0} iterations on {1} processes; this is process {2}"' times.Count - 1' computation.Configuration.Processes' computation.Configuration.ProcessID);                    Console.WriteLine("%-ile\tLatency (ms)");                  for (int i = 0; i < latencies.Length; i++)                      Console.WriteLine("{0:0.00}:\t{1:0.00}"' percentiles[i]' latencies[i]);                    Console.WriteLine("max:\t{0:0.00}"' latencies[latencies.Length - 1]);                }
Magic Number,Microsoft.Research.Naiad.Examples.Latency,Latency,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Latency.cs,Execute,The following statement contains a magic number: using (var computation = NewComputation.FromArgs(ref args))              {                  int iterations = int.Parse(args[1]);                    // first construct a simple graph with a feedback loop.                  var inputStream = (new int[] { }).AsNaiadStream(computation);                    var loopContext = new LoopContext<Epoch>(inputStream.Context' "loop");                  var feedback = loopContext.Delay<int>();                  var ingress = loopContext.EnterLoop(inputStream);                    feedback.Input = Barrier.MakeStage(ingress' feedback.Output' iterations);                    // prepare measurement callbacks                  var sw = new Stopwatch();                  var lastTime = 0L;                  var times = new List<double>(iterations);                    computation.OnStartup += (c' y) => { sw.Start(); };                  computation.OnFrontierChange += (v' b) =>                  {                      var now = sw.ElapsedTicks;                        if (lastTime > 0)                          times.Add(1000.0 * (now - lastTime) / (double)Stopwatch.Frequency);                        lastTime = now;                  };                    Console.WriteLine("Running barrier latency test with {0} iterations' vertices={1}"' iterations' ingress.ForStage.Placement.Count);                    // start computation and block                  computation.Activate();                  computation.Join();                    // print results                  times.Sort();                    var percentiles = new[] { 0.00' 0.01' 0.05' 0.10' 0.25' 0.50' 0.75' 0.90' 0.95' 0.99 };                  var latencies = percentiles.Select(f => times[(int)(iterations * f)]).ToArray();                    Console.WriteLine("Ran {0} iterations on {1} processes; this is process {2}"' times.Count - 1' computation.Configuration.Processes' computation.Configuration.ProcessID);                    Console.WriteLine("%-ile\tLatency (ms)");                  for (int i = 0; i < latencies.Length; i++)                      Console.WriteLine("{0:0.00}:\t{1:0.00}"' percentiles[i]' latencies[i]);                    Console.WriteLine("max:\t{0:0.00}"' latencies[latencies.Length - 1]);                }
Magic Number,Microsoft.Research.Naiad.Examples.Throughput,Throughput,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Throughput.cs,Execute,The following statement contains a magic number: using (OneOffComputation computation = NewComputation.FromArgs(ref args))              {                  int numToExchange = args.Length > 1 ? int.Parse(args[1]) : 1000000;                  int producers = Int32.Parse(args[2]);                  int consumers = Int32.Parse(args[3]);                    var exchange = args.Length > 4 && args[4] == "exchange";                    var input = new Pair<int' int>[] { }.AsNaiadStream(computation);                    Stream<Pair<int' int>' Epoch> stream = ProducerVertex.MakeStage(numToExchange' 0' producers' computation.Configuration.WorkerCount' input);                  Stage<ConsumerVertex' Epoch> consumer = ConsumerVertex.MakeStage(numToExchange' computation.Configuration.Processes - consumers' computation.Configuration.Processes' computation.Configuration.WorkerCount' exchange' stream);                    computation.Activate();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.Throughput,Throughput,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Throughput.cs,Execute,The following statement contains a magic number: using (OneOffComputation computation = NewComputation.FromArgs(ref args))              {                  int numToExchange = args.Length > 1 ? int.Parse(args[1]) : 1000000;                  int producers = Int32.Parse(args[2]);                  int consumers = Int32.Parse(args[3]);                    var exchange = args.Length > 4 && args[4] == "exchange";                    var input = new Pair<int' int>[] { }.AsNaiadStream(computation);                    Stream<Pair<int' int>' Epoch> stream = ProducerVertex.MakeStage(numToExchange' 0' producers' computation.Configuration.WorkerCount' input);                  Stage<ConsumerVertex' Epoch> consumer = ConsumerVertex.MakeStage(numToExchange' computation.Configuration.Processes - consumers' computation.Configuration.Processes' computation.Configuration.WorkerCount' exchange' stream);                    computation.Activate();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.Throughput,Throughput,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Throughput.cs,Execute,The following statement contains a magic number: using (OneOffComputation computation = NewComputation.FromArgs(ref args))              {                  int numToExchange = args.Length > 1 ? int.Parse(args[1]) : 1000000;                  int producers = Int32.Parse(args[2]);                  int consumers = Int32.Parse(args[3]);                    var exchange = args.Length > 4 && args[4] == "exchange";                    var input = new Pair<int' int>[] { }.AsNaiadStream(computation);                    Stream<Pair<int' int>' Epoch> stream = ProducerVertex.MakeStage(numToExchange' 0' producers' computation.Configuration.WorkerCount' input);                  Stage<ConsumerVertex' Epoch> consumer = ConsumerVertex.MakeStage(numToExchange' computation.Configuration.Processes - consumers' computation.Configuration.Processes' computation.Configuration.WorkerCount' exchange' stream);                    computation.Activate();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.Throughput,Throughput,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Throughput.cs,Execute,The following statement contains a magic number: using (OneOffComputation computation = NewComputation.FromArgs(ref args))              {                  int numToExchange = args.Length > 1 ? int.Parse(args[1]) : 1000000;                  int producers = Int32.Parse(args[2]);                  int consumers = Int32.Parse(args[3]);                    var exchange = args.Length > 4 && args[4] == "exchange";                    var input = new Pair<int' int>[] { }.AsNaiadStream(computation);                    Stream<Pair<int' int>' Epoch> stream = ProducerVertex.MakeStage(numToExchange' 0' producers' computation.Configuration.WorkerCount' input);                  Stage<ConsumerVertex' Epoch> consumer = ConsumerVertex.MakeStage(numToExchange' computation.Configuration.Processes - consumers' computation.Configuration.Processes' computation.Configuration.WorkerCount' exchange' stream);                    computation.Activate();                  computation.Join();              }
Magic Number,Microsoft.Research.Naiad.Examples.Throughput,Throughput,C:\repos\MicrosoftResearch_Naiad\Examples\Naiad\Throughput.cs,Execute,The following statement contains a magic number: using (OneOffComputation computation = NewComputation.FromArgs(ref args))              {                  int numToExchange = args.Length > 1 ? int.Parse(args[1]) : 1000000;                  int producers = Int32.Parse(args[2]);                  int consumers = Int32.Parse(args[3]);                    var exchange = args.Length > 4 && args[4] == "exchange";                    var input = new Pair<int' int>[] { }.AsNaiadStream(computation);                    Stream<Pair<int' int>' Epoch> stream = ProducerVertex.MakeStage(numToExchange' 0' producers' computation.Configuration.WorkerCount' input);                  Stage<ConsumerVertex' Epoch> consumer = ConsumerVertex.MakeStage(numToExchange' computation.Configuration.Processes - consumers' computation.Configuration.Processes' computation.Configuration.WorkerCount' exchange' stream);                    computation.Activate();                  computation.Join();              }
