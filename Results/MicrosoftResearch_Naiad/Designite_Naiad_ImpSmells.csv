Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The method has 334 lines of code.
Long Method,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessSendThread,The method has 232 lines of code.
Long Method,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessRecvThread,The method has 152 lines of code.
Long Method,Microsoft.Research.Naiad.Scheduling,EventCount,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\EventCount.cs,Await,The method has 103 lines of code.
Complex Method,Microsoft.Research.Naiad.Serialization,AutoSerialization,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,TypeSize,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Research.Naiad.Dataflow.Channels,PostOfficeChannel<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,PostOfficeChannel,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Research.Naiad.Dataflow,PostOfficeChannel<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,PostOfficeChannel,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Research.Naiad.Runtime.Progress,PointstampFrontier,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\MinimalAntichain.cs,Add,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Research.Naiad.Runtime.Progress,PointstampFrontier,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\MinimalAntichain.cs,Remove,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Research.Naiad.Runtime.Progress,Reachability,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Reachability.cs,UpdateReachabilityPartialOrder,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Research.Naiad.Runtime.Progress,Reachability,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Reachability.cs,DetermineReachabilityList,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessSendThread,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessRecvThread,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Research.Naiad.Scheduling,Scheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,RunWorkItem,Cyclomatic complexity of the method is 9
Long Parameter List,Microsoft.Research.Naiad.Serialization,MessageHeader,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,MessageHeader,The method has 5 parameters. Parameters: fromVertexID' sequenceNumber' channelID' destVertexID' type
Long Parameter List,Microsoft.Research.Naiad.Serialization,MessageHeader,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,MessageHeader,The method has 6 parameters. Parameters: fromVertexID' sequenceNumber' channelID' destVertexID' length' type
Long Parameter List,Microsoft.Research.Naiad.Serialization,SerializedMessage,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,SpecialMessage,The method has 6 parameters. Parameters: fromProcessID' channelID' fromVertexID' destVertexID' seqNum' type
Long Parameter List,Microsoft.Research.Naiad.Serialization,SerializedMessage,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,SerializedMessage,The method has 6 parameters. Parameters: fromProcessID' channelID' fromVertexID' destVertexID' seqNum' type
Long Parameter List,Microsoft.Research.Naiad.Serialization,AutoSerializedMessageEncoder<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,AutoSerializedMessageEncoder,The method has 7 parameters. Parameters: destVertexId' destMailboxId' pool' pageSize' codeGenerator' messageType' seqNumGen
Long Parameter List,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GeneratePrimitiveSerializeInstructions,The method has 5 parameters. Parameters: currentPosition' bytesRemaining' toSerialize' t' failureReturnExpression
Long Parameter List,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateEnumSerializeInstructions,The method has 5 parameters. Parameters: currentPosition' bytesRemaining' toSerialize' t' failureReturnExpression
Long Parameter List,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateCustomSerializeInstructions,The method has 5 parameters. Parameters: currentPosition' bytesRemaining' toSerialize' t' failureReturnExpression
Long Parameter List,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTupleSerializeInstructions,The method has 5 parameters. Parameters: currentPosition' bytesRemaining' toSerialize' t' failureReturnExpression
Long Parameter List,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateArraySerializeInstructions,The method has 5 parameters. Parameters: currentPosition' bytesRemaining' toSerialize' t' failureReturnExpression
Long Parameter List,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateLegacyStructSerializeInstructions,The method has 5 parameters. Parameters: currentPosition' bytesRemaining' toSerialize' t' failureReturnExpression
Long Parameter List,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateDotnetBinarySerializeInstructions,The method has 5 parameters. Parameters: currentPosition' bytesRemaining' toSerialize' t' failureReturnExpression
Long Parameter List,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateSerializeInstructions,The method has 5 parameters. Parameters: currentPosition' bytesRemaining' toSerialize' t' failureReturnExpression
Long Parameter List,Microsoft.Research.Naiad.Dataflow.Channels,ProgressChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\ProgressChannel.cs,ProgressChannel,The method has 6 parameters. Parameters: producerPlacementCount' consumerVertex' stream' recvPort' controller' channelId
Long Parameter List,Microsoft.Research.Naiad.Dataflow.Channels,Mailbox,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\ProgressChannel.cs,Mailbox,The method has 5 parameters. Parameters: postOffice' consumer' id' vertexId' numProducers
Long Parameter List,Microsoft.Research.Naiad.Dataflow.Channels,Fiber,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\ProgressChannel.cs,Fiber,The method has 5 parameters. Parameters: channelID' vertexID' sender' localMailbox' controller
Long Parameter List,Microsoft.Research.Naiad.Dataflow.Channels,Fiber,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\ProgressChannel.cs,Fiber,The method has 7 parameters. Parameters: channelID' vertexID' sender' localMailbox' controller' receiverVertexId' receiverProcessId
Long Parameter List,Microsoft.Research.Naiad.Dataflow.Channels,CentralizedProgressChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\CentralizedProgressChannel.cs,CentralizedProgressChannel,The method has 5 parameters. Parameters: consumer' stream' recvPort' controller' channelId
Long Parameter List,Microsoft.Research.Naiad.Dataflow.Channels,PostOfficeChannel<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,PostOfficeChannel,The method has 6 parameters. Parameters: sendBundle' recvBundle' routingHashcodeFunction' networkChannel' channelId' flags
Long Parameter List,Microsoft.Research.Naiad.Dataflow.Channels,Postbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,Postbox,The method has 7 parameters. Parameters: channelID' sender' receiverBundle' mailboxes' routingHashcodeFunction' networkChannel' progressBuffer
Long Parameter List,Microsoft.Research.Naiad.Dataflow.Channels,Postbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,Postbox,The method has 6 parameters. Parameters: channelID' sender' receiverBundle' mailboxes' routingHashcodeFunction' networkChannel
Long Parameter List,Microsoft.Research.Naiad.Dataflow.Channels,BufferingPostbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,BufferingPostbox,The method has 7 parameters. Parameters: channelID' sender' receiverBundle' mailboxes' routingHashcodeFunction' networkChannel' progressBuffer
Long Parameter List,Microsoft.Research.Naiad.Dataflow.Channels,NoHashCodePostbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,NoHashCodePostbox,The method has 6 parameters. Parameters: channelID' sender' receiverBundle' mailboxes' networkChannel' progressBuffer
Long Parameter List,Microsoft.Research.Naiad.Dataflow.Channels,LocalMailbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,LocalMailbox,The method has 5 parameters. Parameters: postOffice' endpoint' channelId' vertexId' progressBuffer
Long Parameter List,Microsoft.Research.Naiad.Dataflow,IReporting,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,LogAggregate,The method has 5 parameters. Parameters: name' type' value' count' time
Long Parameter List,Microsoft.Research.Naiad.Dataflow,IReporting,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,LogAggregate,The method has 5 parameters. Parameters: name' type' value' count' time
Long Parameter List,Microsoft.Research.Naiad.Dataflow,Reporting<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,LogAggregate,The method has 5 parameters. Parameters: name' type' value' count' time
Long Parameter List,Microsoft.Research.Naiad.Dataflow,Reporting<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,LogAggregate,The method has 5 parameters. Parameters: name' type' value' count' time
Long Parameter List,Microsoft.Research.Naiad.Dataflow,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,StageContext,The method has 5 parameters. Parameters: name' p' inlineStats' aggInt' aggDouble
Long Parameter List,Microsoft.Research.Naiad.Dataflow,Subscription<R>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Subscribe.cs,Subscription,The method has 6 parameters. Parameters: input' placement' context' onRecv' onNotify' onComplete
Long Parameter List,Microsoft.Research.Naiad.Dataflow,SubscribeStreamingVertex<R>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Subscribe.cs,SubscribeStreamingVertex,The method has 6 parameters. Parameters: index' stage' parent' onrecv' onnotify' oncomplete
Long Parameter List,Microsoft.Research.Naiad.Dataflow,UnaryVertex<TInput;TOutput;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,MakeStage,The method has 5 parameters. Parameters: stream' factory' inputPartitionBy' outputPartitionBy' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow,UnaryVertex<TInput;TOutput;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,MakeStage,The method has 6 parameters. Parameters: placement' stream' factory' inputPartitionBy' outputPartitionBy' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow,BinaryVertex<TInput1;TInput2;TOutput;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,MakeStage,The method has 7 parameters. Parameters: stream1' stream2' factory' input1PartitionBy' input2PartitionBy' outputPartitionBy' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow,BinaryVertex<TInput1;TInput2;TOutput;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,MakeStage,The method has 8 parameters. Parameters: placement' stream1' stream2' factory' input1PartitionBy' input2PartitionBy' outputPartitionBy' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow,Foundry,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,NewUnaryStage,The method has 5 parameters. Parameters: source' factory' inputPartitionBy' outputPartitionBy' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow,Foundry,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,NewBinaryStage,The method has 7 parameters. Parameters: source' other' factory' input1PartitionBy' input2PartitionBy' outputPartitionBy' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,BinaryExpression,The method has 6 parameters. Parameters: stream1' stream2' keyFunction1' keyFunction2' transformation' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow,PostOfficeChannel<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,PostOfficeChannel,The method has 6 parameters. Parameters: sendBundle' recvBundle' routingHashcodeFunction' networkChannel' channelId' flags
Long Parameter List,Microsoft.Research.Naiad.Dataflow,Postbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,Postbox,The method has 7 parameters. Parameters: channelID' sender' receiverBundle' mailboxes' routingHashcodeFunction' networkChannel' progressBuffer
Long Parameter List,Microsoft.Research.Naiad.Dataflow,Postbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,Postbox,The method has 6 parameters. Parameters: channelID' sender' receiverBundle' mailboxes' routingHashcodeFunction' networkChannel
Long Parameter List,Microsoft.Research.Naiad.Dataflow,BufferingPostbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,BufferingPostbox,The method has 7 parameters. Parameters: channelID' sender' receiverBundle' mailboxes' routingHashcodeFunction' networkChannel' progressBuffer
Long Parameter List,Microsoft.Research.Naiad.Dataflow,NoHashCodePostbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,NoHashCodePostbox,The method has 6 parameters. Parameters: channelID' sender' receiverBundle' mailboxes' networkChannel' progressBuffer
Long Parameter List,Microsoft.Research.Naiad.Dataflow,LocalMailbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,LocalMailbox,The method has 5 parameters. Parameters: postOffice' endpoint' channelId' vertexId' progressBuffer
Long Parameter List,Microsoft.Research.Naiad.Dataflow,Stage<TVertex;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Stage.cs,Stage,The method has 5 parameters. Parameters: placement' context' optype' factory' name
Long Parameter List,Microsoft.Research.Naiad,Subscription<R>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Subscribe.cs,Subscription,The method has 6 parameters. Parameters: input' placement' context' onRecv' onNotify' onComplete
Long Parameter List,Microsoft.Research.Naiad,SubscribeStreamingVertex<R>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Subscribe.cs,SubscribeStreamingVertex,The method has 6 parameters. Parameters: index' stage' parent' onrecv' onnotify' oncomplete
Long Parameter List,Microsoft.Research.Naiad.Runtime.Networking,NetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,SendBufferSegment,The method has 5 parameters. Parameters: header' destProcessID' segment' HighPriority' wakeUp
Long Parameter List,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,SendBufferSegment,The method has 5 parameters. Parameters: header' destProcessID' segment' HighPriority' wakeUp
Long Parameter List,Microsoft.Research.Naiad.Diagnostics,NaiadTracing,C:\repos\MicrosoftResearch_Naiad\Naiad\Tracing.cs,ChannelInfo,The method has 5 parameters. Parameters: channel' src' dst' isExchange' isProgress
Long Parameter List,Microsoft.Research.Naiad.Diagnostics,NaiadTracing,C:\repos\MicrosoftResearch_Naiad\Naiad\Tracing.cs,MsgSend,The method has 5 parameters. Parameters: channel' seqno' len' src' dst
Long Parameter List,Microsoft.Research.Naiad.Diagnostics,NaiadTracing,C:\repos\MicrosoftResearch_Naiad\Naiad\Tracing.cs,MsgRecv,The method has 5 parameters. Parameters: channel' seqno' len' src' dst
Long Parameter List,Microsoft.Research.Naiad.Diagnostics,LogInfo,C:\repos\MicrosoftResearch_Naiad\Naiad\Logging.cs,LogInfo,The method has 6 parameters. Parameters: threadId' operatorName' className' methodName' fileName' lineNumber
Long Parameter List,Reporting,IReporting,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,LogAggregate,The method has 5 parameters. Parameters: name' type' value' count' time
Long Parameter List,Reporting,IReporting,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,LogAggregate,The method has 5 parameters. Parameters: name' type' value' count' time
Long Parameter List,Reporting,Reporting<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,LogAggregate,The method has 5 parameters. Parameters: name' type' value' count' time
Long Parameter List,Reporting,Reporting<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,LogAggregate,The method has 5 parameters. Parameters: name' type' value' count' time
Long Parameter List,Reporting,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,StageContext,The method has 5 parameters. Parameters: name' p' inlineStats' aggInt' aggDouble
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalReduce,The method has 7 parameters. Parameters: stream' key' val' factory' name' inPlacement' outPlacement
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalTimeReduce,The method has 7 parameters. Parameters: stream' key' val' factory' name' inPlacement' outPlacement
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalReduce,The method has 5 parameters. Parameters: stream' key' val' factory' name
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,Reduce,The method has 5 parameters. Parameters: stream' key' val' factory' name
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalReduce,The method has 7 parameters. Parameters: stream' key' val' factory' name' inPlacement' outPlacement
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalTimeReduce,The method has 7 parameters. Parameters: stream' key' val' factory' name' inPlacement' outPlacement
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalReduce,The method has 5 parameters. Parameters: stream' key' val' factory' name
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,Reduce,The method has 5 parameters. Parameters: stream' key' val' factory' name
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,Aggregation<X;R;S>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,Aggregation,The method has 5 parameters. Parameters: a' ia' c' ic' f
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,Aggregation<X;R;S>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,Aggregation,The method has 5 parameters. Parameters: a' ia' c' ic' f
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,LocalKeyedReduceVertex<A;X;R;S;K;I;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalKeyedReduceVertex,The method has 5 parameters. Parameters: i' stage' k' v' f
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,LocalKeyedReduceVertex<A;X;R;S;K;I;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalKeyedReduceVertex,The method has 5 parameters. Parameters: i' stage' k' v' f
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,LocalTimeKeyedReduceVertex<A;X;R;S;K;I;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalTimeKeyedReduceVertex,The method has 5 parameters. Parameters: i' stage' k' v' f
Long Parameter List,Microsoft.Research.Naiad.Frameworks.Reduction,LocalTimeKeyedReduceVertex<A;X;R;S;K;I;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalTimeKeyedReduceVertex,The method has 5 parameters. Parameters: i' stage' k' v' f
Long Parameter List,Microsoft.Research.Naiad.Dataflow.StandardVertices,UnaryVertex<TInput;TOutput;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,MakeStage,The method has 5 parameters. Parameters: stream' factory' inputPartitionBy' outputPartitionBy' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow.StandardVertices,UnaryVertex<TInput;TOutput;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,MakeStage,The method has 6 parameters. Parameters: placement' stream' factory' inputPartitionBy' outputPartitionBy' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow.StandardVertices,BinaryVertex<TInput1;TInput2;TOutput;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,MakeStage,The method has 7 parameters. Parameters: stream1' stream2' factory' input1PartitionBy' input2PartitionBy' outputPartitionBy' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow.StandardVertices,BinaryVertex<TInput1;TInput2;TOutput;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,MakeStage,The method has 8 parameters. Parameters: placement' stream1' stream2' factory' input1PartitionBy' input2PartitionBy' outputPartitionBy' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow.StandardVertices,Foundry,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,NewUnaryStage,The method has 5 parameters. Parameters: source' factory' inputPartitionBy' outputPartitionBy' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow.StandardVertices,Foundry,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,NewBinaryStage,The method has 7 parameters. Parameters: source' other' factory' input1PartitionBy' input2PartitionBy' outputPartitionBy' name
Long Parameter List,Microsoft.Research.Naiad.Dataflow.StandardVertices,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,BinaryExpression,The method has 6 parameters. Parameters: stream1' stream2' keyFunction1' keyFunction2' transformation' name
Long Parameter List,Microsoft.Research.Naiad.Utilities,Win32,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\Win32.cs,WSAIoctl,The method has 9 parameters. Parameters: Socket' controlcode' inBuf' cbInBuf' outBuf' cbOutBuf' pBytesRet' lpOverlapped' lpCompletionRoutine
Long Identifier,Microsoft.Research.Naiad.Runtime.Networking,ConnectionState,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,,The length of the parameter EverReceivedIncomingConnection is 30.
Long Statement,Microsoft.Research.Naiad.Serialization,RecvBufferPage,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,ConsumeBytesUpto,The length of the statement  "            //Console.Error.WriteLine("$$$ Consumed {0} bytes from page; new consumePointer = {1}"' bytesToConsume' this.consumePointer); " is 125.
Long Statement,Microsoft.Research.Naiad.Serialization,RecvBufferSheaf,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,GetFreeSegment,The length of the statement  "                Logging.Debug("RecvPage {0}: was allocated to satisfy demand ({1} bytes free) (after blocking for a page)"' page.Id' page.Buffer.Length - page.producePointer); " is 159.
Long Statement,Microsoft.Research.Naiad.Serialization,RecvBufferSheaf,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,ConsumeMessages,The length of the statement  "                    int bytesConsumed = this.ConsumeBytes(this.currentSplitMessageBody' this.currentSplitMessagePosition' this.currentMessageHeader.Length - this.currentSplitMessagePosition); " is 171.
Long Statement,Microsoft.Research.Naiad.Serialization,RecvBufferSheaf,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,ConsumeMessages,The length of the statement  "                    //Console.Error.WriteLine("&&& Consumed {0} bytes into split message' now at {1} / {2}"' bytesConsumed' this.currentSplitMessagePosition' this.currentMessageHeader.Length); " is 172.
Long Statement,Microsoft.Research.Naiad.Serialization,RecvBufferSheaf,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,ConsumeMessages,The length of the statement  "                        yield return new SerializedMessage(this.ForProcessID' this.currentMessageHeader' new RecvBuffer(this.currentSplitMessageBody' 0' this.currentSplitMessagePosition)); " is 164.
Long Statement,Microsoft.Research.Naiad.Serialization,NaiadWriter,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,Write,The length of the statement  "                this.currentPage.WriteHeader(new MessageHeader(this.versionNumber' this.sequenceNumber++' NaiadSerializationConstants.CHANNEL_ID' NaiadSerializationConstants.DEST_VERTEX_ID' SerializedMessageType.CheckpointData)' this.headerSerializer); " is 236.
Long Statement,Microsoft.Research.Naiad.Serialization,NaiadWriter,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,Write,The length of the statement  "                this.currentPage.WriteHeader(new MessageHeader(this.versionNumber' this.sequenceNumber++' NaiadSerializationConstants.CHANNEL_ID' NaiadSerializationConstants.DEST_VERTEX_ID' SerializedMessageType.CheckpointData)' this.headerSerializer); " is 236.
Long Statement,Microsoft.Research.Naiad.Serialization,NaiadReader,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,TryGetNextPage,The length of the statement  "                    throw new InvalidDataException(string.Format("Cannot deserialize this file with serializer version {0}.{1} (file uses version {2}.{3})"' this.SerializationFormat.MajorVersion' this.SerializationFormat.MinorVersion' parsedHeader.FromVertexID >> 16' parsedHeader.FromVertexID & 0xFFFF)); " is 285.
Long Statement,Microsoft.Research.Naiad.Serialization,NaiadReader<TElement>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,TryGetNextPage,The length of the statement  "                // XXX : This means to drop out if zero read at the beginning (indicating end of stream) but we should discover the correct way to identify this. " is 145.
Long Statement,Microsoft.Research.Naiad.Serialization,NaiadReader<TElement>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,TryGetNextPage,The length of the statement  "                //    throw new InvalidDataException(string.Format("Error parsing file: read only {0} bytes when frame length was {1} (bytes)"' bytesRead' parsedHeader.Length)); " is 161.
Long Statement,Microsoft.Research.Naiad.Serialization,NaiadWriter<TElement>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,Write,The length of the statement  "                this.currentPage.WriteHeader(new MessageHeader(this.versionNumber' this.sequenceNumber++' NaiadSerializationConstants.CHANNEL_ID' NaiadSerializationConstants.DEST_VERTEX_ID' SerializedMessageType.Data)' this.headerSerializer); " is 226.
Long Statement,Microsoft.Research.Naiad.Serialization,NaiadWriter<TElement>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,Write,The length of the statement  "                this.currentPage.WriteHeader(new MessageHeader(this.versionNumber' this.sequenceNumber++' NaiadSerializationConstants.CHANNEL_ID' NaiadSerializationConstants.DEST_VERTEX_ID' SerializedMessageType.Data)' this.headerSerializer); " is 226.
Long Statement,Microsoft.Research.Naiad.Serialization,NaiadWriter<TElement>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,Write,The length of the statement  "                    this.currentPage.WriteHeader(new MessageHeader(this.versionNumber' this.sequenceNumber' NaiadSerializationConstants.CHANNEL_ID' NaiadSerializationConstants.DEST_VERTEX_ID' SerializedMessageType.Data)' this.headerSerializer); " is 224.
Long Statement,Microsoft.Research.Naiad.Serialization,AutoSerializedMessageEncoder<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,CreateNextPage,The length of the statement  "            //Console.Error.WriteLine("Next page mode (for mailbox {1}:{2}) is {0}"' this.currentMode' this.destMailboxId' this.destVertexId); " is 130.
Long Statement,Microsoft.Research.Naiad.Serialization,CustomSerializationWrapper<TElement;TCustomSerialization>,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,TrySerializeMany,The length of the statement  "                    int bytesWritten = this.innerSerializer.TrySerialize(values.Array[values.Offset + i]' destinationPtr + totalBytesWritten' bytesRemaining - totalBytesWritten); " is 158.
Long Statement,Microsoft.Research.Naiad.Serialization,CustomSerializationWrapper<TElement;TCustomSerialization>,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,TryDeserializeMany,The length of the statement  "                    int bytesRead = this.innerSerializer.Deserialize(out target.Array[target.Offset + i]' sourcePtr' bytesRemaining - totalBytesRead); " is 130.
Long Statement,Microsoft.Research.Naiad.Serialization,BaseSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GetSerializationForMinorVersion,The length of the statement  "                throw new ArgumentOutOfRangeException("minorVersion"' minorVersion' string.Format("Cannot generate serializer for version {0}.{1} (highest supported is {0}.{2})"' this.MajorVersion' minorVersion' this.MinorVersion)); " is 216.
Long Statement,Microsoft.Research.Naiad.Serialization,SerializationFactory,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GetCodeGeneratorForVersion,The length of the statement  "            //    throw new InvalidOperationException(string.Format("No code generator available for version {0}.{1}"' majorVersion' minorVersion)); " is 136.
Long Statement,Microsoft.Research.Naiad.Serialization,SerializationFactory,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GetCodeGeneratorForVersion,The length of the statement  "                    throw new InvalidOperationException(string.Format("No code generator available for version {0}.{1}"' majorVersion' minorVersion)); " is 130.
Long Statement,Microsoft.Research.Naiad.Serialization,AutoSerialization,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,HasBuiltinDeserializer,The length of the statement  "            return typeof(Deserializers).GetMethod("TryDeserialize"' new Type[] { typeof(RecvBuffer).MakeByRefType()' t.MakeByRefType() }) != null; " is 135.
Long Statement,Microsoft.Research.Naiad.Serialization,AutoSerialization,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,LogIt,The length of the statement  "            //return new CodeExpressionStatement(new CodeMethodInvokeExpression(new CodeMethodReferenceExpression(new CodeTypeReferenceExpression(typeof(Console))' "WriteLine")' e)); //Stmt(""); " is 182.
Long Statement,Microsoft.Research.Naiad.Serialization,AutoSerialization,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,WriteLine,The length of the statement  "            return new CodeExpressionStatement(new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(typeof (Console))' "WriteLine"' " is 129.
Long Statement,Microsoft.Research.Naiad.Serialization,SerializationCodeGeneratorForType,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateSerializer,The length of the statement  "                            Console.Error.WriteLine("Fatal: errors occurred during the generation of a serializer for type {0}:\n{1}"' typeof(T).FullName' errorMsg); " is 137.
Long Statement,Microsoft.Research.Naiad.Serialization,SerializationCodeGeneratorForType,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateSerializer,The length of the statement  "                        return (NaiadSerialization<T>)res.CompiledAssembly.CreateInstance(String.Format("Microsoft.Research.Naiad.Serialization.AutoGenerated.{0}"' this.GeneratedClassName)); " is 166.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateSpaceCheck,The length of the statement  "                return If(new CodeBinaryOperatorExpression(bytesRemaining' CodeBinaryOperatorType.LessThan' targetSize)' Return(failureReturnExpression)); " is 138.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTryDeserializeManyMethod,The length of the statement  "                m.Add(If(new CodeBinaryOperatorExpression(Var("bytesRemaining")' CodeBinaryOperatorType.ValueEquality' new CodePrimitiveExpression(0))' Return(new CodePrimitiveExpression(0)))); " is 177.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTryDeserializeManyMethod,The length of the statement  "                            new CodePrimitiveExpression(0))' new CodeStatement[] { Assign(Expr("source.CurrentPos")' Expr("source.End"))' Return("i") })); " is 126.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTryDeserializeManyMethod,The length of the statement  "                forLoop.Statements.AddRange(this.GenerateDeserializeInstructions(new CodeVariableReferenceExpression("currentPosition")' new CodeVariableReferenceExpression("bytesRemaining")' Expr("target.Array[i + target.Offset]")' this.Type).ToArray()); " is 239.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTryDeserializeManyMethod,The length of the statement  "                m.Add(If(new CodeBinaryOperatorExpression(Var("bytesRemaining")' CodeBinaryOperatorType.ValueEquality' new CodePrimitiveExpression(0))' new CodeStatement[] {  " is 157.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTryDeserializeManyMethod,The length of the statement  "                Assign(Expr("value")' new CodeDefaultValueExpression(new CodeTypeReference(this.Type)))' Return(new CodePrimitiveExpression(false)) })); " is 136.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTryDeserializeManyMethod,The length of the statement  "                m.AddAll(this.GenerateDeserializeInstructions(new CodeVariableReferenceExpression("currentPosition")' new CodeVariableReferenceExpression("bytesRemaining")' Expr("value")' this.Type)); " is 184.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTryDeserializeManyMethod,The length of the statement  "                m.Add(If(new CodeBinaryOperatorExpression(Var("bytesRemaining")' CodeBinaryOperatorType.LessThanOrEqual' new CodePrimitiveExpression(0))' Return(new CodePrimitiveExpression(0)))); " is 179.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTryDeserializeManyMethod,The length of the statement  "                forLoop.Statements.AddRange(this.GenerateSerializeInstructions(new CodeVariableReferenceExpression("currentPosition")' new CodeVariableReferenceExpression("bytesRemaining")' Expr("value")' this.Type' Expr("numWritten")).ToArray()); " is 231.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateStringSerializeInstructions,The length of the statement  "                CodeExpression lengthBytes = BinOp(BinOp(length' CodeBinaryOperatorType.Multiply' Expr("sizeof(char)")) ' CodeBinaryOperatorType.Add' Expr("sizeof(int)")); " is 155.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateStringSerializeInstructions,The length of the statement  "                foreach (CodeStatement stmt in this.GeneratePrimitiveSerializeInstructions(currentPosition' bytesRemaining' new CodePrimitiveExpression(NULL_ARRAY_MARKER)' typeof(int)' failureReturnExpression)) " is 194.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateStringSerializeInstructions,The length of the statement  "                CodeExpression totalLengthInBytes = BinOp(Expr("sizeof(int)")' CodeBinaryOperatorType.Add' BinOp(length' CodeBinaryOperatorType.Multiply' Expr("sizeof(char)"))); " is 161.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateStringSerializeInstructions,The length of the statement  "                foreach (CodeStatement stmt in this.GeneratePrimitiveSerializeInstructionsWithoutCheck(currentPosition' length' typeof(int))) " is 125.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateStringSerializeInstructions,The length of the statement  "                CodeIterationStatement loop = new CodeIterationStatement(Decl(iterationVar' typeof(int)' new CodePrimitiveExpression(0))' new CodeBinaryOperatorExpression(Var(iterationVar)' CodeBinaryOperatorType.LessThan' length)' Assign(Var(iterationVar)' new CodeBinaryOperatorExpression(Var(iterationVar)' CodeBinaryOperatorType.Add' new CodePrimitiveExpression(1)))); " is 356.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateStringSerializeInstructions,The length of the statement  "                stringStmts.Add(Assign(currentPosition' new CodeBinaryOperatorExpression(currentPosition' CodeBinaryOperatorType.Add' BinOp(length' CodeBinaryOperatorType.Multiply' Expr("sizeof(char)"))))); " is 190.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateStringSerializeInstructions,The length of the statement  "                stringStmts.Add(Assign(bytesRemaining' new CodeBinaryOperatorExpression(bytesRemaining' CodeBinaryOperatorType.Subtract' totalLengthInBytes))); " is 143.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateStringDeserializeInstructions,The length of the statement  "                foreach (CodeStatement stmt in this.GeneratePrimitiveDeserializeInstructions(currentPosition' bytesRemaining' Var(lengthVar)' typeof(int))) " is 139.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateStringDeserializeInstructions,The length of the statement  "                    new CodeObjectCreateExpression(typeof(string)' new CodeCastExpression(typeof(char*)' currentPosition)' Expr("0")' Var(lengthVar)))); " is 132.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateStringDeserializeInstructions,The length of the statement  "                stringStmts.Add(Assign(currentPosition' new CodeBinaryOperatorExpression(currentPosition' CodeBinaryOperatorType.Add' BinOp(Var(lengthVar)' CodeBinaryOperatorType.Multiply' Expr("sizeof(char)"))))); " is 198.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateStringDeserializeInstructions,The length of the statement  "                stringStmts.Add(Assign(bytesRemaining' new CodeBinaryOperatorExpression(bytesRemaining' CodeBinaryOperatorType.Subtract' BinOp(Var(lengthVar)' CodeBinaryOperatorType.Multiply' Expr("sizeof(char)"))))); " is 201.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateStringDeserializeInstructions,The length of the statement  "                yield return IfElse(new CodeBinaryOperatorExpression(Var(lengthVar)' CodeBinaryOperatorType.ValueEquality' new CodePrimitiveExpression(NULL_ARRAY_MARKER))' " is 155.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GeneratePrimitiveSerializeInstructionsWithoutCheck,The length of the statement  "                yield return Assign(currentPosition' new CodeBinaryOperatorExpression(currentPosition' CodeBinaryOperatorType.Add' size)); " is 122.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GeneratePrimitiveSerializeInstructions,The length of the statement  "                yield return If(new CodeBinaryOperatorExpression(bytesRemaining' CodeBinaryOperatorType.LessThan' size)' Return(failureReturnExpression)); " is 138.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GeneratePrimitiveSerializeInstructions,The length of the statement  "                yield return Assign(currentPosition' new CodeBinaryOperatorExpression(currentPosition' CodeBinaryOperatorType.Add' size)); " is 122.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GeneratePrimitiveSerializeInstructions,The length of the statement  "                yield return Assign(bytesRemaining' new CodeBinaryOperatorExpression(bytesRemaining' CodeBinaryOperatorType.Subtract' size)); " is 125.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GeneratePrimitiveDeserializeInstructions,The length of the statement  "                yield return Assign(currentPosition' new CodeBinaryOperatorExpression(currentPosition' CodeBinaryOperatorType.Add' size)); " is 122.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GeneratePrimitiveDeserializeInstructions,The length of the statement  "                yield return Assign(bytesRemaining' new CodeBinaryOperatorExpression(bytesRemaining' CodeBinaryOperatorType.Subtract' size)); " is 125.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateEnumSerializeInstructions,The length of the statement  "                return this.GeneratePrimitiveSerializeInstructions(currentPosition' bytesRemaining' new CodeCastExpression(typeof(int)' toSerialize)' typeof(int)' failureReturnExpression); " is 172.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateEnumDeserializeInstructions,The length of the statement  "                yield return Assign(currentPosition' new CodeBinaryOperatorExpression(currentPosition' CodeBinaryOperatorType.Add' size)); " is 122.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateEnumDeserializeInstructions,The length of the statement  "                yield return Assign(bytesRemaining' new CodeBinaryOperatorExpression(bytesRemaining' CodeBinaryOperatorType.Subtract' size)); " is 125.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateCustomSerializeInstructions,The length of the statement  "                yield return Assign(currentPosition' new CodeBinaryOperatorExpression(currentPosition' CodeBinaryOperatorType.Add' Expr(byteCounterName))); " is 139.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateCustomSerializeInstructions,The length of the statement  "                yield return Assign(bytesRemaining' new CodeBinaryOperatorExpression(bytesRemaining' CodeBinaryOperatorType.Subtract' Expr(byteCounterName))); " is 142.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateCustomDeserializeInstructions,The length of the statement  "                yield return Assign(currentPosition' new CodeBinaryOperatorExpression(currentPosition' CodeBinaryOperatorType.Add' Expr(byteCounterName))); " is 139.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateCustomDeserializeInstructions,The length of the statement  "                yield return Assign(bytesRemaining' new CodeBinaryOperatorExpression(bytesRemaining' CodeBinaryOperatorType.Subtract' Expr(byteCounterName))); " is 142.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateArraySerializeInstructions,The length of the statement  "                foreach (CodeStatement stmt in this.GeneratePrimitiveSerializeInstructions(currentPosition' bytesRemaining' new CodePrimitiveExpression(NULL_ARRAY_MARKER)' typeof(int)' failureReturnExpression)) " is 194.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateArraySerializeInstructions,The length of the statement  "                foreach (CodeStatement stmt in this.GeneratePrimitiveSerializeInstructions(currentPosition' bytesRemaining' arrayLength' typeof(int)' failureReturnExpression)) " is 159.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateArraySerializeInstructions,The length of the statement  "                CodeIterationStatement loop = new CodeIterationStatement(Decl(iterationVar' typeof(int)' new CodePrimitiveExpression(0))' new CodeBinaryOperatorExpression(Var(iterationVar)' CodeBinaryOperatorType.LessThan' arrayLength)' Assign(Var(iterationVar)' new CodeBinaryOperatorExpression(Var(iterationVar)' CodeBinaryOperatorType.Add' new CodePrimitiveExpression(1)))); " is 361.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateArraySerializeInstructions,The length of the statement  "                foreach (CodeStatement stmt in this.GenerateSerializeInstructions(currentPosition' bytesRemaining' new CodeArrayIndexerExpression(toSerialize' Var(iterationVar))' t.GetElementType()' failureReturnExpression)) " is 208.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateArraySerializeInstructions,The length of the statement  "                yield return IfElse(new CodeBinaryOperatorExpression(toSerialize' CodeBinaryOperatorType.ValueEquality' new CodePrimitiveExpression(null))' " is 139.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateArrayDeserializeInstructions,The length of the statement  "                foreach (CodeStatement stmt in this.GeneratePrimitiveDeserializeInstructions(currentPosition' bytesRemaining' Var(lengthVar)' typeof(int))) " is 139.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateArrayDeserializeInstructions,The length of the statement  "                CodeIterationStatement loop = new CodeIterationStatement(Decl(iterationVar' typeof(int)' new CodePrimitiveExpression(0))' new CodeBinaryOperatorExpression(Var(iterationVar)' CodeBinaryOperatorType.LessThan' arrayLength)' Assign(Var(iterationVar)' new CodeBinaryOperatorExpression(Var(iterationVar)' CodeBinaryOperatorType.Add' new CodePrimitiveExpression(1)))); " is 361.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateArrayDeserializeInstructions,The length of the statement  "                foreach (CodeStatement stmt in this.GenerateDeserializeInstructions(currentPosition' bytesRemaining' new CodeArrayIndexerExpression(toDeserialize' Var(iterationVar))' t.GetElementType())) " is 187.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateArrayDeserializeInstructions,The length of the statement  "                yield return IfElse(new CodeBinaryOperatorExpression(Var(lengthVar)' CodeBinaryOperatorType.ValueEquality' new CodePrimitiveExpression(NULL_ARRAY_MARKER))' " is 155.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateLegacyStructSerializeInstructions,The length of the statement  "                    foreach (CodeStatement stmt in this.GenerateSerializeInstructions(currentPosition' bytesRemaining' new CodeFieldReferenceExpression(toSerialize' field.Name)' field.FieldType' failureReturnExpression)) " is 200.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateLegacyStructDeserializeInstructions,The length of the statement  "                    foreach (CodeStatement stmt in this.GenerateDeserializeInstructions(currentPosition' bytesRemaining' new CodeFieldReferenceExpression(toDeserialize' field.Name)' field.FieldType)) " is 179.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateDotnetBinarySerializeInstructions,The length of the statement  "                foreach (CodeStatement stmt in this.GeneratePrimitiveSerializeInstructions(currentPosition' bytesRemaining' new CodePrimitiveExpression(NULL_ARRAY_MARKER)' typeof(int)' failureReturnExpression)) " is 194.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateDotnetBinarySerializeInstructions,The length of the statement  "                objectStmts.Add(new CodeSnippetStatement(string.Format("using (System.IO.MemoryStream {0} = new System.IO.MemoryStream()) {{"' memoryStreamVar))); " is 146.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateDotnetBinarySerializeInstructions,The length of the statement  "                objectStmts.Add(new CodeExpressionStatement(new CodeMethodInvokeExpression(Var(formatterVar)' "Serialize"' Var(memoryStreamVar)' toSerialize))); " is 144.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateDotnetBinarySerializeInstructions,The length of the statement  "                foreach (CodeStatement stmt in this.GenerateArraySerializeInstructions(currentPosition' bytesRemaining' Var(tempBufferVar)' typeof(byte[])' failureReturnExpression)) " is 165.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateDotnetBinaryDeserializeInstructions,The length of the statement  "                foreach (CodeStatement stmt in this.GenerateArrayDeserializeInstructions(currentPosition' bytesRemaining' Var(tempBufferVar)' typeof(byte[]))) " is 142.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateDotnetBinaryDeserializeInstructions,The length of the statement  "                objectStmts.Add(IfElse(new CodeBinaryOperatorExpression(Var(tempBufferVar)' CodeBinaryOperatorType.ValueEquality' Expr("null"))' " is 128.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateDotnetBinaryDeserializeInstructions,The length of the statement  "                        new CodeSnippetStatement(string.Format("using (System.IO.MemoryStream {0} = new System.IO.MemoryStream({1})) {{"' memoryStreamVar' tempBufferVar))' " is 147.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateDotnetBinaryDeserializeInstructions,The length of the statement  "                        Assign(toDeserialize' new CodeCastExpression(t' new CodeMethodInvokeExpression(Var(formatterVar)' "Deserialize"' Var(memoryStreamVar))))' " is 137.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateSerializeMethod,The length of the statement  "                m.Add(If(new CodeBinaryOperatorExpression(Var("bytesRemaining")' CodeBinaryOperatorType.LessThanOrEqual' new CodePrimitiveExpression(0))' Return(new CodePrimitiveExpression(false)))); " is 183.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateSerializeMethod,The length of the statement  "                m.AddAll(this.GenerateSerializeInstructions(new CodeVariableReferenceExpression("currentPosition")' new CodeVariableReferenceExpression("bytesRemaining")' value' this.Type' new CodePrimitiveExpression(false))); " is 210.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTrySerializeManyMethod,The length of the statement  "                m.Add(If(new CodeBinaryOperatorExpression(Var("bytesRemaining")' CodeBinaryOperatorType.LessThanOrEqual' new CodePrimitiveExpression(0))' Return(new CodePrimitiveExpression(0)))); " is 179.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTrySerializeManyMethod,The length of the statement  "                forLoop.Statements.AddRange(this.GenerateSerializeInstructions(new CodeVariableReferenceExpression("currentPosition")' new CodeVariableReferenceExpression("bytesRemaining")' Expr("value")' this.Type' Expr("numWritten")).ToArray()); " is 231.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTryDeserializeMethod,The length of the statement  "                m.Add(If(new CodeBinaryOperatorExpression(Var("bytesRemaining")' CodeBinaryOperatorType.ValueEquality' new CodePrimitiveExpression(0))' new CodeStatement[] {  " is 157.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTryDeserializeMethod,The length of the statement  "                Assign(Expr("value")' new CodeDefaultValueExpression(new CodeTypeReference(this.Type)))' Return(new CodePrimitiveExpression(false)) })); " is 136.
Long Statement,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTryDeserializeMethod,The length of the statement  "                m.AddAll(this.GenerateDeserializeInstructions(new CodeVariableReferenceExpression("currentPosition")' new CodeVariableReferenceExpression("bytesRemaining")' Expr("value")' this.Type)); " is 184.
Long Statement,Microsoft.Research.Naiad.Serialization,NaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateSerializeMethod,The length of the statement  "                var m = new MethodHelper("_Serialize"' typeof(bool)' MemberAttributes.Static | MemberAttributes.Final | MemberAttributes.Public); " is 129.
Long Statement,Microsoft.Research.Naiad.Dataflow.Channels,Mailbox,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\ProgressChannel.cs,DeliverSerializedMessage,The length of the statement  "                        //Console.Error.WriteLine("Delivering message {0} L = {1} A = {2}"' message.Header.SequenceNumber' message.Header.Length' message.Body.Available); " is 146.
Long Statement,Microsoft.Research.Naiad.Dataflow.Channels,Mailbox,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\ProgressChannel.cs,DeliverSerializedMessage,The length of the statement  "                        //Console.Error.WriteLine("Discarding message {0} (expecting {1}) L = {2} A = {3}"' message.Header.SequenceNumber' this.nextSequenceNumber' message.Header.Length' message.Body.Available); " is 187.
Long Statement,Microsoft.Research.Naiad.Dataflow.Channels,Fiber,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\ProgressChannel.cs,Send,The length of the statement  "                        Console.Error.WriteLine("  IncastChannel Send {0}->{1}  {2} {3}"' vertexID' 0' records.payload[i].Delta' records.payload[i].Pointstamp); " is 136.
Long Statement,Microsoft.Research.Naiad.Dataflow.Channels,RemoteMailbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,Send,The length of the statement  "            this.encodersFromLocalVertices[from.ThreadIndex].Write(new ArraySegment<S>(message.payload' 0' message.length)' from.VertexID); " is 127.
Long Statement,Microsoft.Research.Naiad.Dataflow.Channels,RemoteMailbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,DeliverSerializedMessage,The length of the statement  "            throw new NotImplementedException("Attempted to deliver message from a remote sender to a remote recipient' which is not currently supported."); " is 144.
Long Statement,Microsoft.Research.Naiad.Dataflow,Receiver<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Endpoints.cs,LogMessage,The length of the statement  "            var encoder = new AutoSerializedMessageEncoder<S' T>(this.Vertex.VertexId' this.channelId' DummyBufferPool<byte>.Pool' this.Vertex.Stage.InternalComputation.Controller.Configuration.SendPageSize' this.Vertex.SerializationFormat); " is 229.
Long Statement,Microsoft.Research.Naiad.Dataflow,Receiver<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Endpoints.cs,LogMessage,The length of the statement  "            this.Vertex.LoggingOutput.Write(message.Body.Buffer' message.Body.CurrentPos' message.Body.End - message.Body.CurrentPos); " is 122.
Long Statement,Microsoft.Research.Naiad.Dataflow,Vertex<TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Vertex.cs,Restore,The length of the statement  "                this.Scheduler.EnqueueNotify(this' time' time' false);    // could be set to true if we are sure this executes under the worker " is 127.
Long Statement,Microsoft.Research.Naiad.Dataflow,InputStage<TRecord>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Input.cs,GetInputVertex,The length of the statement  "            throw new Exception(String.Format("Vertex {0} not found in Input {1} on Process {2}"' vertexId' stage.StageId' stage.InternalComputation.Controller.Configuration.ProcessID)); " is 174.
Long Statement,Microsoft.Research.Naiad.Dataflow,InputStage<TRecord>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Input.cs,Restore,The length of the statement  "            this.hasActivatedProgressTracker = reader.Read<bool>(this.InternalComputation.SerializationFormat.GetSerializer<bool>()); " is 121.
Long Statement,Microsoft.Research.Naiad.Dataflow,InputVertex<S>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Input.cs,PerformAction,The length of the statement  "                    this.Scheduler.State(this.Stage.InternalComputation).Producer.UpdateRecordCounts(new Runtime.Progress.Pointstamp(this.Stage.StageId' new int[] { i + 1 })' +1); " is 159.
Long Statement,Microsoft.Research.Naiad.Dataflow,InputVertex<S>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Input.cs,PerformAction,The length of the statement  "                this.scheduler.State(this.Stage.InternalComputation).Producer.UpdateRecordCounts(new Runtime.Progress.Pointstamp(this.Stage.StageId' new int[] { i })' -1); " is 155.
Long Statement,Microsoft.Research.Naiad.Dataflow,StreamingInputVertex<S>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Input.cs,PerformAction,The length of the statement  "                        this.scheduler.State(this.Stage.InternalComputation).Producer.UpdateRecordCounts(new Runtime.Progress.Pointstamp(this.Stage.StageId' new int[] { this.currentVertexHold })' -1); " is 176.
Long Statement,Microsoft.Research.Naiad.Dataflow,StreamingInputVertex<S>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Input.cs,PerformAction,The length of the statement  "                        this.scheduler.State(this.Stage.InternalComputation).Producer.UpdateRecordCounts(new Runtime.Progress.Pointstamp(this.Stage.StageId' new int[] { nextInstruction.Epoch + 1 })' +1); " is 179.
Long Statement,Microsoft.Research.Naiad.Dataflow,StreamingInputVertex<S>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Input.cs,PerformAction,The length of the statement  "                        this.scheduler.State(this.Stage.InternalComputation).Producer.UpdateRecordCounts(new Runtime.Progress.Pointstamp(this.Stage.StageId' new int[] { this.currentVertexHold })' -1); " is 176.
Long Statement,Microsoft.Research.Naiad.Dataflow,StreamingInputVertex<S>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Input.cs,PerformAction,The length of the statement  "                        Logging.Error("WARNING: input ignored redundant notification for epoch {0} when current epoch was {1}."' nextInstruction.Epoch' this.currentVertexHold); " is 152.
Long Statement,Microsoft.Research.Naiad.Dataflow,StreamingInputVertex<S>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Input.cs,PerformAction,The length of the statement  "                        Logging.Error("WARNING: input ignored invalid data for epoch {0} when current epoch was {1}"' nextInstruction.Epoch' this.currentVertexHold); " is 141.
Long Statement,Microsoft.Research.Naiad.Dataflow,StreamingInputStage<R>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Input.cs,GetInputVertex,The length of the statement  "            throw new Exception(String.Format("Vertex {0} not found in Input {1} on Process {2}"' vertexId' stage.StageId' stage.InternalComputation.Controller.Configuration.ProcessID)); " is 174.
Long Statement,Microsoft.Research.Naiad.Dataflow,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,MakeAggregates,The length of the statement  "                Reporting.IntReportingReducer' Reporting.ReportingRecord<Int64>' Reporting.ReportingRecord<Int64>' Reporting.ReportingRecord<Int64>' " is 132.
Long Statement,Microsoft.Research.Naiad.Dataflow,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,MakeAggregates,The length of the statement  "                string' Pair<string' Reporting.ReportingRecord<Int64>>' T>(x => x.First' x => x.Second' () => new Reporting.IntReportingReducer()' " is 130.
Long Statement,Microsoft.Research.Naiad.Dataflow,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,MakeAggregates,The length of the statement  "                Reporting.IntReportingReducer' Reporting.ReportingRecord<Int64>' Reporting.ReportingRecord<Int64>' Reporting.ReportingRecord<Int64>' " is 132.
Long Statement,Microsoft.Research.Naiad.Dataflow,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,MakeAggregates,The length of the statement  "                Reporting.DoubleReportingReducer' Reporting.ReportingRecord<double>' Reporting.ReportingRecord<double>' Reporting.ReportingRecord<double>' " is 138.
Long Statement,Microsoft.Research.Naiad.Dataflow,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,MakeAggregates,The length of the statement  "                string' Pair<string' Reporting.ReportingRecord<double>>' T>(x => x.First' x => x.Second' () => new Reporting.DoubleReportingReducer()' " is 134.
Long Statement,Microsoft.Research.Naiad.Dataflow,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,MakeAggregates,The length of the statement  "                Reporting.DoubleReportingReducer' Reporting.ReportingRecord<double>' Reporting.ReportingRecord<double>' Reporting.ReportingRecord<double>' " is 138.
Long Statement,Microsoft.Research.Naiad.Dataflow,Edge<R;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Edge.cs,Materialize,The length of the statement  "                this.bundle = new PostOfficeChannel<R' T>(Source' Target' PartitionFunction' controller.NetworkChannel' this.ChannelId' this.Flags); " is 132.
Long Statement,Microsoft.Research.Naiad.Dataflow,Edge<R;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Edge.cs,Materialize,The length of the statement  "                Logging.Info("Allocated exchange channel {2}: {0} -> {1}"' this.bundle.SourceStage' this.bundle.DestinationStage' this.bundle.ChannelId); " is 137.
Long Statement,Microsoft.Research.Naiad.Dataflow,Edge<R;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Edge.cs,Materialize,The length of the statement  "            Diagnostics.NaiadTracing.Trace.ChannelInfo(this.ChannelId' this.SourceStage.StageId' this.bundle.DestinationStage.StageId' this.Exchanges' false); " is 146.
Long Statement,Microsoft.Research.Naiad.Dataflow,VertexInputBuffer<TRecord;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,SerializedMessageReceived,The length of the statement  "            if (this.decoder == null) this.decoder = new AutoSerializedMessageDecoder<TRecord' TTime>(this.Vertex.SerializationFormat); " is 123.
Long Statement,Microsoft.Research.Naiad.Dataflow,Foundry,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,NewBinaryStage,The length of the statement  "            return BinaryVertex<TInput1' TInput2' TOutput' TTime>.MakeStage(source' other' factory' input1PartitionBy' input2PartitionBy' outputPartitionBy' name); " is 151.
Long Statement,Microsoft.Research.Naiad.Dataflow,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,UnaryExpression,The length of the statement  "            return UnaryBufferingVertex<TInput' TOutput' TTime>.MakeStage(stream' (i' v) => new UnaryBufferingVertex<TInput' TOutput' TTime>(i' v' transformation)' keyFunction' null' name); " is 177.
Long Statement,Microsoft.Research.Naiad.Dataflow,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,BinaryExpression,The length of the statement  "            return BinaryBufferingVertex<TInput1' TInput2' TOutput' TTime>.MakeStage(stream1' stream2' (i' v) => new BinaryBufferingVertex<TInput1' TInput2' TOutput' TTime>(i' v' transformation)' keyFunction1' keyFunction2' null' name); " is 224.
Long Statement,Microsoft.Research.Naiad.Dataflow,RemoteMailbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,Send,The length of the statement  "            this.encodersFromLocalVertices[from.ThreadIndex].Write(new ArraySegment<S>(message.payload' 0' message.length)' from.VertexID); " is 127.
Long Statement,Microsoft.Research.Naiad.Dataflow,RemoteMailbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,DeliverSerializedMessage,The length of the statement  "            throw new NotImplementedException("Attempted to deliver message from a remote sender to a remote recipient' which is not currently supported."); " is 144.
Long Statement,Microsoft.Research.Naiad.Dataflow,Stage,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Stage.cs,NewInput,The length of the statement  "                Action<TRecord[]' int[]' int> vectoredPartitioning = (data' dsts' len) => { for (int i = 0; i < len; i++) dsts[i] = compiled(data[i]); }; " is 137.
Long Statement,Microsoft.Research.Naiad.Dataflow,Stage<TVertex;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Stage.cs,NewInput,The length of the statement  "            return this.NewInput<TRecord>(stream' s => new ActionReceiver<TRecord' TTime>(s' m => onReceive(m' s))' partitionedBy' vectoredPartitionedBy); " is 142.
Long Statement,Microsoft.Research.Naiad.Dataflow,Stage<TVertex;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Stage.cs,NewUnconnectedInput,The length of the statement  "            return this.NewUnconnectedInput<S>(vertex => new ActionReceiver<S' TTime>(vertex' message => onRecv(message' vertex))' partitionedBy); " is 134.
Long Statement,Microsoft.Research.Naiad.Dataflow,Stage<TVertex;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Stage.cs,NewOutput,The length of the statement  "            return this.NewOutput<R>(vertex => new ActionSubscriber<R' TTime>(vertex' listener => { newListener(listener' vertex); vertex.AddOnFlushAction(() => listener.Flush()); })' partitionedBy); " is 187.
Long Statement,Microsoft.Research.Naiad,BaseController,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Controlling\Controller.cs,Checkpoint,The length of the statement  "                using (FileStream collectionFile = File.OpenWrite(Path.Combine(path' string.Format("input_{0}_{1}.vertex"' input.InputId' epoch)))) " is 131.
Long Statement,Microsoft.Research.Naiad,BaseController,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Controlling\Controller.cs,Checkpoint,The length of the statement  "                using (FileStream vertexFile = File.OpenWrite(Path.Combine(path' string.Format("{0}_{1}_{2}.vertex"' vertex.Stage.StageId' vertex.VertexId' epoch)))) " is 149.
Long Statement,Microsoft.Research.Naiad,BaseController,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Controlling\Controller.cs,Restore,The length of the statement  "                using (FileStream collectionFile = File.OpenRead(Path.Combine(path' string.Format("input_{0}_{1}.vertex"' input.InputId' epoch)))) " is 130.
Long Statement,Microsoft.Research.Naiad,BaseController,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Controlling\Controller.cs,Restore,The length of the statement  "                using (FileStream vertexFile = File.OpenRead(Path.Combine(path' string.Format("{0}_{1}_{2}.vertex"' vertex.Stage.StageId' vertex.VertexId' epoch)))) " is 148.
Long Statement,Microsoft.Research.Naiad,BaseWorkerGroup,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Controlling\Controller.cs,NotifyVertexStarting,The length of the statement  "                    this.WorkItemStarting(this' new VertexStartArgs(scheduler.Index' work.Vertex.Stage' work.Vertex.VertexId' work.Requirement)); " is 125.
Long Statement,Microsoft.Research.Naiad,BaseWorkerGroup,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Controlling\Controller.cs,NotifyVertexEnding,The length of the statement  "                    this.WorkItemEnding(this' new VertexEndArgs(scheduler.Index' work.Vertex.Stage' work.Vertex.VertexId' work.Requirement)); " is 121.
Long Statement,Microsoft.Research.Naiad,BaseWorkerGroup,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Controlling\Controller.cs,NotifyVertexEnqueued,The length of the statement  "                    this.WorkItemEnqueued(this' new VertexEnqueuedArgs(scheduler.Index' work.Vertex.Stage' work.Vertex.VertexId' work.Requirement)); " is 128.
Long Statement,Microsoft.Research.Naiad,BaseComputation,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\SubgraphManager.cs,Join,The length of the statement  "                    Logging.Info("Largest real epoch " + largestRealInputEpoch + " current stats " + RootDomainStatisticsStage.CurrentEpoch); " is 121.
Long Statement,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,GetIPAddressForHostname,The length of the statement  "            IPAddress ipv4Address = ipAddresses.FirstOrDefault(x => x.AddressFamily == AddressFamily.InterNetwork && !IsAutoConf(x)); " is 121.
Long Statement,Microsoft.Research.Naiad,Pair,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\Pair.cs,GetHashCode,The length of the statement  "            return (this.First == null ? 0 : this.First.GetHashCode()) + 123412324 * (this.Second == null ? 0 : this.Second.GetHashCode()); " is 127.
Long Statement,Microsoft.Research.Naiad,Pair,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\Pair.cs,Equals,The length of the statement  "            return (EqualityComparer<TFirst>.Default.Equals(this.First' other.First) && EqualityComparer<TSecond>.Default.Equals(this.Second' other.Second)); " is 145.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,ProgressUpdateConsumer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,ProcessCountChange,The length of the statement  "                frontierChanged = PCS.UpdatePointstampCount(updates.payload[i].Pointstamp' updates.payload[i].Delta) || frontierChanged; " is 120.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,ProgressUpdateConsumer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,Checkpoint,The length of the statement  "            this.PCS.Checkpoint(writer' this.SerializationFormat.GetSerializer<long>()' this.SerializationFormat.GetSerializer<Pointstamp>()' this.SerializationFormat.GetSerializer<int>()); " is 177.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,ProgressUpdateConsumer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,Restore,The length of the statement  "            this.PCS.Restore(reader' this.SerializationFormat.GetSerializer<long>()' this.SerializationFormat.GetSerializer<Pointstamp>()' this.SerializationFormat.GetSerializer<int>()); " is 174.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,ProgressUpdateCentralizer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,InjectElement,The length of the statement  "            // by directly modifying the PCS' we don't risk sending anything from the centralizer. Used only for initializing inputs. " is 121.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,ProgressUpdateCentralizer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,ProcessCountChange,The length of the statement  "                frontierChanged = PCS.UpdatePointstampCount(updates.payload[i].Pointstamp' updates.payload[i].Delta) || frontierChanged; " is 120.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,ProgressUpdateCentralizer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,Checkpoint,The length of the statement  "{ this.PCS.Checkpoint(writer' this.SerializationFormat.GetSerializer<long>()' this.SerializationFormat.GetSerializer<Pointstamp>()' this.SerializationFormat.GetSerializer<int>()); }" is 181.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,ProgressUpdateCentralizer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,Restore,The length of the statement  "{ this.PCS.Restore(reader' this.SerializationFormat.GetSerializer<long>()' this.SerializationFormat.GetSerializer<Pointstamp>()' this.SerializationFormat.GetSerializer<int>()); }" is 178.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,ProgressUpdateProducer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateProducer.cs,UpdateRecordCounts,The length of the statement  "                //if (this.Stage.InternalComputation.Controller.Configuration.Impersonation && !this.Stage.InternalComputation.Reachability.NoImpersonation.Contains(time.Location) && this.Stage.InternalComputation.Reachability.Impersonations[time.Location] != null) " is 249.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,PointstampFrontier,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\MinimalAntichain.cs,Add,The length of the statement  "                if (this.Reachability.LessThan(element' elements[i]) && this.Reachability.LessThan(elements[i]' element) && !elements[i].Equals(element)) " is 137.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,Reachability,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Reachability.cs,UpdateReachabilityPartialOrder,The length of the statement  "                var versionList = new Pointstamp[] { new Pointstamp(i' Enumerable.Repeat(magicNumber' this.Graph[i].Depth).ToArray()) }; " is 120.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,Reachability,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Reachability.cs,UpdateReachabilityPartialOrder,The length of the statement  "                            for (int l = 0; l < reachabilityResults[j][k].Timestamp.Length && reachabilityResults[j][k].Timestamp[l] >= magicNumber; l++) " is 125.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,Reachability,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Reachability.cs,DetermineReachabilityList,The length of the statement  "                        // For each immediately downstream collection from the current collection' attempt to improve the antichain for the downstream. " is 127.
Long Statement,Microsoft.Research.Naiad.Runtime.Progress,Reachability,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Reachability.cs,DetermineReachabilityList,The length of the statement  "                            // For each element of the current collection's antichain' evaluate the minimal caused version at the downstream collection. " is 124.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PrintTrafficMatrix,The length of the statement  "                    writer.WriteLine("{0} S = {1}\tR = {2}\tQ = {3}\tState = {4}\tIFS = {5}"' i' this.connections[i].RecordsSent' this.connections[i].RecordsRecv' this.connections[i].SegmentQueue.Count' this.connections[i].Status.ToString()' "DEPRECATED"); " is 236.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,UdpReceiveThread,The length of the statement  "                //Console.Error.WriteLine("UdpReceiveThread: got {0} bytes from {1}. Sequence number = {2}' count = {3}"' bytes.Length' from' header.SequenceNumber' count++); " is 158.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,UdpReceiveThread,The length of the statement  "                SerializedMessage message = new SerializedMessage(0' header' new RecvBuffer(bytes' MessageHeader.SizeOf' bytes.Length)); " is 120.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,AddEndPointIncoming,The length of the statement  "                    Logging.Error("WARNING: already accepted a connection from process {0}' so shutting down existing recvThread"' processId); " is 122.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,AddEndPointIncoming,The length of the statement  "                this.connections[processId].RecvBufferSheaf = new RecvBufferSheaf(processId' (1 << 22) / RecvBufferPage.PAGE_SIZE' GlobalBufferPool<byte>.pool); " is 144.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PeerConnect,The length of the statement  "            Logging.Progress("Accept()ed connection from {0}. Endpoints {1} -> {2}"' peerID' socket.RemoteEndPoint' socket.LocalEndPoint); " is 126.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,AnnounceStartup,The length of the statement  "            SendBufferPage startupPage = SendBufferPage.CreateSpecialPage(MessageHeader.GenerateBarrierMessageHeader(barrierId)' seqno); " is 124.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessSendThread,The length of the statement  "                this.connections[destProcessID].SendSocket = new Socket(this.connections[destProcessID].EndPoint.AddressFamily' SocketType.Stream' ProtocolType.Tcp); " is 149.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessSendThread,The length of the statement  "                    //Logging.Error("Sending message to {0}: sequence number {1}' type {2}"' destProcessID' header.SequenceNumber' header.Type); " is 124.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessSendThread,The length of the statement  "                    //Logging.Error("Sending message to {0}: sequence number {1}' type {2}"' destProcessID' header.SequenceNumber' header.Type); " is 124.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessRecvThread,The length of the statement  "                    if (message.Header.SequenceNumber != this.connections[srcProcessID].SequenceNumberReceived + 1 && message.Header.Type != SerializedMessageType.Ack) " is 147.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessRecvThread,The length of the statement  "                        Logging.Error("Dropping duplicated received message from {0}: sequence number {1}' type {2}"' srcProcessID' message.Header.SequenceNumber' message.Header.Type); " is 160.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessRecvThread,The length of the statement  "                        //Logging.Error("Receiving message from {0}: sequence number {1}' type {2}"' srcProcessID' message.Header.SequenceNumber' message.Header.Type); " is 143.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessRecvThread,The length of the statement  "                            this.Controller.GetInternalComputation(message.Header.ChannelID).Cancel(new Exception(string.Format("Received graph failure message from {0}"' srcProcessID))); " is 159.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessRecvThread,The length of the statement  "                            Logging.Info("PerProcessRecvThread[{0}]: numRecvs {1} avgBytesIn {2} avgBytesOut {3}"' srcProcessID' numRecvs' recvBytesIn / numRecvs' recvBytesOut / numRecvs); " is 160.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,AttemptDelivery,The length of the statement  "                NaiadTracing.Trace.MsgRecv(channelId' message.Header.SequenceNumber' message.Header.Length' message.Header.FromVertexID' this.localProcessID); " is 142.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,AttemptDelivery,The length of the statement  "                    this.graphmailboxes[graphId][channelId][this.localProcessID].DeliverSerializedMessage(message' new ReturnAddress(peerID' message.Header.FromVertexID)); " is 151.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,AttemptDelivery,The length of the statement  "                NaiadTracing.Trace.MsgRecv(channelId' message.Header.SequenceNumber' message.Header.Length' message.Header.FromVertexID' message.Header.DestVertexID); " is 150.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,AttemptDelivery,The length of the statement  "                this.graphmailboxes[graphId][channelId][message.Header.DestVertexID].DeliverSerializedMessage(message' new ReturnAddress(peerID' message.Header.FromVertexID)); " is 159.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,GetBufferPool,The length of the statement  "                    return (processID == -1  || processID == this.localProcessID) ? GlobalBufferPool<byte>.pool : this.connections[processID].SendPool; " is 131.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,BroadcastBufferSegment,The length of the statement  "                if (this.Controller.Configuration.Broadcast == Configuration.BroadcastProtocol.UdpOnly || this.Controller.Configuration.Broadcast == Configuration.BroadcastProtocol.TcpUdp) " is 172.
Long Statement,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,BroadcastBufferSegment,The length of the statement  "                if (this.Controller.Configuration.Broadcast == Configuration.BroadcastProtocol.TcpOnly || this.Controller.Configuration.Broadcast == Configuration.BroadcastProtocol.TcpUdp) " is 172.
Long Statement,Microsoft.Research.Naiad.Diagnostics,ProgressUpdateConsumer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,ProcessCountChange,The length of the statement  "                frontierChanged = PCS.UpdatePointstampCount(updates.payload[i].Pointstamp' updates.payload[i].Delta) || frontierChanged; " is 120.
Long Statement,Microsoft.Research.Naiad.Diagnostics,ProgressUpdateConsumer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,Checkpoint,The length of the statement  "            this.PCS.Checkpoint(writer' this.SerializationFormat.GetSerializer<long>()' this.SerializationFormat.GetSerializer<Pointstamp>()' this.SerializationFormat.GetSerializer<int>()); " is 177.
Long Statement,Microsoft.Research.Naiad.Diagnostics,ProgressUpdateConsumer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,Restore,The length of the statement  "            this.PCS.Restore(reader' this.SerializationFormat.GetSerializer<long>()' this.SerializationFormat.GetSerializer<Pointstamp>()' this.SerializationFormat.GetSerializer<int>()); " is 174.
Long Statement,Microsoft.Research.Naiad.Diagnostics,ProgressUpdateCentralizer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,InjectElement,The length of the statement  "            // by directly modifying the PCS' we don't risk sending anything from the centralizer. Used only for initializing inputs. " is 121.
Long Statement,Microsoft.Research.Naiad.Diagnostics,ProgressUpdateCentralizer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,ProcessCountChange,The length of the statement  "                frontierChanged = PCS.UpdatePointstampCount(updates.payload[i].Pointstamp' updates.payload[i].Delta) || frontierChanged; " is 120.
Long Statement,Microsoft.Research.Naiad.Diagnostics,ProgressUpdateCentralizer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,Checkpoint,The length of the statement  "{ this.PCS.Checkpoint(writer' this.SerializationFormat.GetSerializer<long>()' this.SerializationFormat.GetSerializer<Pointstamp>()' this.SerializationFormat.GetSerializer<int>()); }" is 181.
Long Statement,Microsoft.Research.Naiad.Diagnostics,ProgressUpdateCentralizer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\UpdateConsumer.cs,Restore,The length of the statement  "{ this.PCS.Restore(reader' this.SerializationFormat.GetSerializer<long>()' this.SerializationFormat.GetSerializer<Pointstamp>()' this.SerializationFormat.GetSerializer<int>()); }" is 178.
Long Statement,Reporting,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,MakeAggregates,The length of the statement  "                Reporting.IntReportingReducer' Reporting.ReportingRecord<Int64>' Reporting.ReportingRecord<Int64>' Reporting.ReportingRecord<Int64>' " is 132.
Long Statement,Reporting,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,MakeAggregates,The length of the statement  "                string' Pair<string' Reporting.ReportingRecord<Int64>>' T>(x => x.First' x => x.Second' () => new Reporting.IntReportingReducer()' " is 130.
Long Statement,Reporting,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,MakeAggregates,The length of the statement  "                Reporting.IntReportingReducer' Reporting.ReportingRecord<Int64>' Reporting.ReportingRecord<Int64>' Reporting.ReportingRecord<Int64>' " is 132.
Long Statement,Reporting,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,MakeAggregates,The length of the statement  "                Reporting.DoubleReportingReducer' Reporting.ReportingRecord<double>' Reporting.ReportingRecord<double>' Reporting.ReportingRecord<double>' " is 138.
Long Statement,Reporting,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,MakeAggregates,The length of the statement  "                string' Pair<string' Reporting.ReportingRecord<double>>' T>(x => x.First' x => x.Second' () => new Reporting.DoubleReportingReducer()' " is 134.
Long Statement,Reporting,StageContext<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,MakeAggregates,The length of the statement  "                Reporting.DoubleReportingReducer' Reporting.ReportingRecord<double>' Reporting.ReportingRecord<double>' Reporting.ReportingRecord<double>' " is 138.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalReduce,The length of the statement  "            return Foundry.NewUnaryStage(stream' (i' v) => new LocalReduceVertex<TReducer' TState' TInput' TOutput' TTime>(i' v' factory)' null' null' name); " is 145.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalCombine,The length of the statement  "            return Foundry.NewUnaryStage(stream' (i' v) => new LocalCombineVertex<TReducer' TState' TInput' TOutput' TTime>(i' v' factory)' null' null' name); " is 146.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalReduce,The length of the statement  "            return Foundry.NewUnaryStage(stream' (i' v) => new LocalKeyedReduceVertex<TReducer' TState' TValue' TOutput' TKey' TInput' TTime>(i' v' key' val' factory)' inPlacement' outPlacement' name); " is 189.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalTimeReduce,The length of the statement  "            return Foundry.NewUnaryStage(stream' (i' v) => new LocalTimeKeyedReduceVertex<A' X' R' S' K' I' T>(i' v' key' val' factory)' inPlacement' outPlacement' name); " is 158.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalCombine,The length of the statement  "            return Foundry.NewUnaryStage(stream' (i' v) => new LocalKeyedCombineVertex<A' X' R' S' K' T>(i' v' factory)' inPlacement' outPlacement' name); " is 142.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalTimeCombine,The length of the statement  "            return Foundry.NewUnaryStage(stream' (i' v) => new LocalTimeKeyedCombineVertex<A' X' R' S' K' T>(i' v' factory)' inPlacement' outPlacement' name); " is 146.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,Broadcast,The length of the statement  "            var processDests = stream.ForStage.InternalComputation.DefaultPlacement.Where(x => x.ThreadId == 0).Select(x => x.VertexId).ToArray(); " is 134.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,Broadcast,The length of the statement  "            var boutput = Foundry.NewUnaryStage(stream' (i' v) => new BroadcastSendVertex<R' T>(i' v' processDests)' null' null' "BroadcastProcessSend"); " is 141.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,Broadcast,The length of the statement  "            if (stream.ForStage.InternalComputation.DefaultPlacement.Where(x => x.ProcessId == controller.Configuration.ProcessID).Count() > 1) " is 131.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,Broadcast,The length of the statement  "                collectable = Foundry.NewUnaryStage(boutput' (i' v) => new BroadcastForwardVertex<R' T>(i' v' threadDests)' x => x.First' null' "BroadcastVertexSend"); " is 151.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,BroadcastReduce,The length of the statement  "            return stream.LocalReduce<A' X' R' S' T>(factory' name + "Reduce").Broadcast().LocalCombine<A' X' R' S' T>(factory' name + "Combine"); " is 134.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,BroadcastReduce,The length of the statement  "            return stream.LocalReduce<A' X' X' X' T>(factory' name + "Reduce").Broadcast().LocalCombine<A' X' X' X' T>(factory' name + "Combine"); " is 134.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalReduce,The length of the statement  "            return Foundry.NewUnaryStage(stream' (i' v) => new LocalReduceVertex<TReducer' TState' TInput' TOutput' TTime>(i' v' factory)' null' null' name); " is 145.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalCombine,The length of the statement  "            return Foundry.NewUnaryStage(stream' (i' v) => new LocalCombineVertex<TReducer' TState' TInput' TOutput' TTime>(i' v' factory)' null' null' name); " is 146.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalReduce,The length of the statement  "            return Foundry.NewUnaryStage(stream' (i' v) => new LocalKeyedReduceVertex<TReducer' TState' TValue' TOutput' TKey' TInput' TTime>(i' v' key' val' factory)' inPlacement' outPlacement' name); " is 189.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalTimeReduce,The length of the statement  "            return Foundry.NewUnaryStage(stream' (i' v) => new LocalTimeKeyedReduceVertex<A' X' R' S' K' I' T>(i' v' key' val' factory)' inPlacement' outPlacement' name); " is 158.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalCombine,The length of the statement  "            return Foundry.NewUnaryStage(stream' (i' v) => new LocalKeyedCombineVertex<A' X' R' S' K' T>(i' v' factory)' inPlacement' outPlacement' name); " is 142.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,LocalTimeCombine,The length of the statement  "            return Foundry.NewUnaryStage(stream' (i' v) => new LocalTimeKeyedCombineVertex<A' X' R' S' K' T>(i' v' factory)' inPlacement' outPlacement' name); " is 146.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,Broadcast,The length of the statement  "            var processDests = stream.ForStage.InternalComputation.DefaultPlacement.Where(x => x.ThreadId == 0).Select(x => x.VertexId).ToArray(); " is 134.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,Broadcast,The length of the statement  "            var boutput = Foundry.NewUnaryStage(stream' (i' v) => new BroadcastSendVertex<R' T>(i' v' processDests)' null' null' "BroadcastProcessSend"); " is 141.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,Broadcast,The length of the statement  "            if (stream.ForStage.InternalComputation.DefaultPlacement.Where(x => x.ProcessId == controller.Configuration.ProcessID).Count() > 1) " is 131.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,Broadcast,The length of the statement  "                collectable = Foundry.NewUnaryStage(boutput' (i' v) => new BroadcastForwardVertex<R' T>(i' v' threadDests)' x => x.First' null' "BroadcastVertexSend"); " is 151.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,BroadcastReduce,The length of the statement  "            return stream.LocalReduce<A' X' R' S' T>(factory' name + "Reduce").Broadcast().LocalCombine<A' X' R' S' T>(factory' name + "Combine"); " is 134.
Long Statement,Microsoft.Research.Naiad.Frameworks.Reduction,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,BroadcastReduce,The length of the statement  "            return stream.LocalReduce<A' X' X' X' T>(factory' name + "Reduce").Broadcast().LocalCombine<A' X' X' X' T>(factory' name + "Combine"); " is 134.
Long Statement,Microsoft.Research.Naiad.Dataflow.PartitionBy,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\PartitionBy.cs,PartitionBy,The length of the statement  "            if (partitionBy == null || Microsoft.Research.Naiad.Utilities.ExpressionComparer.Instance.Equals(stream.PartitionedBy' partitionBy)) " is 132.
Long Statement,Microsoft.Research.Naiad.Dataflow.PartitionBy,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\PartitionBy.cs,PartitionBy,The length of the statement  "            return stream.NewUnaryStage((i' v) => new PartitionByVertex<TRecord' TTime>(i' v' null)' partitionBy' partitionBy' "PartitionBy"); " is 130.
Long Statement,Microsoft.Research.Naiad.Dataflow.PartitionBy,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\PartitionBy.cs,AssumePartitionedBy,The length of the statement  "            return stream.NewUnaryStage((i' v) => new PartitionByVertex<TRecord' TTime>(i' v' null)' null' partitionBy' "PartitionBy"); " is 123.
Long Statement,Microsoft.Research.Naiad.Dataflow.PartitionBy,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\PartitionBy.cs,AssertPartitionedBy,The length of the statement  "            return stream.NewUnaryStage((i' v) => new PartitionByVertex<TRecord' TTime>(i' v' partitionBy)' null' partitionBy' "PartitionBy"); " is 130.
Long Statement,Microsoft.Research.Naiad.Dataflow.Iteration,IngressVertex<R;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Iteration.cs,MessageReceived,The length of the statement  "                    this.Output.GetBufferForTime(new IterationIn<T>(message.time' InitialIteration(message.payload[i]))).Send(message.payload[i]); " is 126.
Long Statement,Microsoft.Research.Naiad.Dataflow.Iteration,IngressVertex<R;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Iteration.cs,NewStage,The length of the statement  "            var stage = new Stage<IngressVertex<R' T>' IterationIn<T>>(new TimeContext<IterationIn<T>>(internalContext)' Stage.OperatorType.IterationIngress' (i' v) => new IngressVertex<R' T>(i' v' initialIteration)' "FixedPoint.Ingress"); " is 227.
Long Statement,Microsoft.Research.Naiad.Dataflow.Iteration,IngressVertex<R;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Iteration.cs,NewStage,The length of the statement  "            stage.NewSurprisingTimeTypeInput(input' vertex => new ActionReceiver<R' T>(vertex' m => vertex.MessageReceived(m))' input.PartitionedBy); " is 137.
Long Statement,Microsoft.Research.Naiad.Dataflow.Iteration,Feedback<TRecord;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Iteration.cs,AttachInput,The length of the statement  "                Action<TRecord[]' int[]' int> vectoredPartitioning = (data' dsts' len) => { for (int i = 0; i < len; i++) dsts[i] = compiled(data[i]); }; " is 137.
Long Statement,Microsoft.Research.Naiad.Dataflow.Iteration,EgressVertex<R;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Iteration.cs,NewStage,The length of the statement  "            var stage = new Stage<EgressVertex<R' T>' T>(new TimeContext<T>(externalContext)' Stage.OperatorType.IterationEgress' (i' v) => new EgressVertex<R' T>(i' v' iterationNumber)' "FixedPoint.Egress"); " is 196.
Long Statement,Microsoft.Research.Naiad.Dataflow.Iteration,EgressVertex<R;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Iteration.cs,NewStage,The length of the statement  "            stage.NewSurprisingTimeTypeInput(input' vertex => new ActionReceiver<R' IterationIn<T>>(vertex' m => vertex.OnReceive(m))' input.PartitionedBy); " is 144.
Long Statement,Microsoft.Research.Naiad.Dataflow.Iteration,ReportingEgressStage<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Iteration.cs,ConnectInline,The length of the statement  "            receivers.Add(stage.NewSurprisingTimeTypeInput(sender' vertex => new ActionReceiver<string' IterationIn<T>>(vertex' (m'p) => vertex.OnReceive(m' p))' null)); " is 157.
Long Statement,Microsoft.Research.Naiad.Dataflow.Iteration,ReportingEgressStage<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Iteration.cs,ConnectIntAggregator,The length of the statement  "            intAggregator = stage.NewSurprisingTimeTypeInput(sender' vertex => new ActionReceiver<Pair<string' ReportingRecord<Int64>>' IterationIn<T>>(vertex' (m'p) => vertex.ForwardIntAggregate(m' p))' null); " is 198.
Long Statement,Microsoft.Research.Naiad.Dataflow.Iteration,ReportingEgressStage<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Iteration.cs,ConnectDoubleAggregator,The length of the statement  "            doubleAggregator = stage.NewSurprisingTimeTypeInput(sender' vertex => new ActionReceiver<Pair<string' ReportingRecord<double>>' IterationIn<T>>(vertex' (m'p) => vertex.ForwardDoubleAggregate(m' p))' null); " is 205.
Long Statement,Microsoft.Research.Naiad.Dataflow.StandardVertices,VertexInputBuffer<TRecord;TTime>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,SerializedMessageReceived,The length of the statement  "            if (this.decoder == null) this.decoder = new AutoSerializedMessageDecoder<TRecord' TTime>(this.Vertex.SerializationFormat); " is 123.
Long Statement,Microsoft.Research.Naiad.Dataflow.StandardVertices,Foundry,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,NewBinaryStage,The length of the statement  "            return BinaryVertex<TInput1' TInput2' TOutput' TTime>.MakeStage(source' other' factory' input1PartitionBy' input2PartitionBy' outputPartitionBy' name); " is 151.
Long Statement,Microsoft.Research.Naiad.Dataflow.StandardVertices,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,UnaryExpression,The length of the statement  "            return UnaryBufferingVertex<TInput' TOutput' TTime>.MakeStage(stream' (i' v) => new UnaryBufferingVertex<TInput' TOutput' TTime>(i' v' transformation)' keyFunction' null' name); " is 177.
Long Statement,Microsoft.Research.Naiad.Dataflow.StandardVertices,ExtensionMethods,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\StandardVertices.cs,BinaryExpression,The length of the statement  "            return BinaryBufferingVertex<TInput1' TInput2' TOutput' TTime>.MakeStage(stream1' stream2' (i' v) => new BinaryBufferingVertex<TInput1' TInput2' TOutput' TTime>(i' v' transformation)' keyFunction1' keyFunction2' null' name); " is 224.
Long Statement,Microsoft.Research.Naiad.Scheduling,Scheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,State,The length of the statement  "            if (this.computationStates.Count <= internalComputation.Index || this.computationStates[internalComputation.Index].InternalComputation == null) " is 143.
Long Statement,Microsoft.Research.Naiad.Scheduling,Scheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,Schedule,The length of the statement  "            if (Logging.LogLevel <= LoggingLevel.Info) Logging.Info("Vertex {2}: Running @ {1}:\t{0}"' workItem.Vertex' workItem.Requirement' this.Index); " is 142.
Long Statement,Microsoft.Research.Naiad.Scheduling,Scheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,Schedule,The length of the statement  "            if (Logging.LogLevel <= LoggingLevel.Info) Logging.Info("Vertex {2}: Finishing @ {1}:\t{0}"' workItem.Vertex' workItem.Requirement' this.Index); " is 144.
Long Statement,Microsoft.Research.Naiad.Scheduling,Scheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,InternalStart,The length of the statement  "            this.reachabilityTime = this.Controller.Stopwatch.ElapsedMilliseconds - this.Controller.Configuration.CompactionInterval; " is 121.
Long Statement,Microsoft.Research.Naiad.Scheduling,Scheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,TestComputationsForShutdown,The length of the statement  "            if (this.ComputationActive(computationIndex) && this.computationStates[computationIndex].InternalComputation.ProgressTracker.GetInfoForWorker(this.Index).PointstampCountSet.Frontier.Length == 0) " is 194.
Long Statement,Microsoft.Research.Naiad.Scheduling,Scheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,ConsiderAssesingGlobalReachability,The length of the statement  "            if (this.Controller.Configuration.CompactionInterval > 0 && this.Controller.Stopwatch.ElapsedMilliseconds - this.reachabilityTime > this.Controller.Configuration.CompactionInterval) " is 181.
Long Statement,Microsoft.Research.Naiad.Scheduling,Scheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,AssessAndNotifyGlobalReachability,The length of the statement  "                var frontiers = this.computationStates[computationIndex].InternalComputation.ProgressTracker.GetInfoForWorker(0).PointstampCountSet.Frontier.Concat(this.computationStates[computationIndex].Producer.LocalPCS.Frontier).ToArray(); " is 227.
Long Statement,Microsoft.Research.Naiad.Scheduling,Scheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,AssessAndNotifyGlobalReachability,The length of the statement  "                this.computationStates[computationIndex].InternalComputation.Reachability.UpdateReachability(this.Controller' frontiers' this.computationStates[computationIndex].Vertices); " is 172.
Long Statement,Microsoft.Research.Naiad.Scheduling,Scheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,RunWorkItem,The length of the statement  "                if (itemToRun == workItems.Count || computation.Reachability.CompareTo(workItems[itemToRun].Capability' workItems[i].Capability) > 0) " is 133.
Long Statement,Microsoft.Research.Naiad.Scheduling,Scheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,Report,The length of the statement  "                    writer.WriteLine("{0}\t{1}\t{3}\t{2}"' this.Index' Stopwatches.Array[collections[i]].Elapsed' this.Controller.InternalGraphManager.Stages[collections[i]]' ScheduleCount.Array[collections[i]]); " is 192.
Long Statement,Microsoft.Research.Naiad.Scheduling,PinnedScheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,InternalStart,The length of the statement  "            int CPUIndex = this.Controller.Configuration.MultipleLocalProcesses ? this.Index + this.Controller.Configuration.ProcessID * this.Controller.Workers.Count : this.Index; " is 168.
Long Statement,Microsoft.Research.Naiad.Scheduling,PinnedScheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,InternalStart,The length of the statement  "                Logging.Info("Starting scheduler {0} on CPU {1}' .NET thread {2} mapped to Windows thread {3}"' this.Name' CPUIndex' thrd.runtimeThreadId' thrd.OSThreadId); " is 156.
Long Statement,Microsoft.Research.Naiad.Scheduling,PinnedScheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,InternalStart,The length of the statement  "                //Console.Error.WriteLine("Starting scheduler {0}({4}) on CPU {1}' .NET thread {2} mapped to Windows thread {3}"' this.Name' CPUIndex' thrd.runtimeThreadId' thrd.OSThreadId' this.Index); " is 186.
Long Statement,Microsoft.Research.Naiad.Utilities,ExpressionComparer,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\ExpressionComparer.cs,VisitBinary,The length of the statement  "            return this.Visit(b.Left' other.Left) && this.Visit(b.Right' other.Right) && this.Visit(b.Conversion' other.Conversion); " is 120.
Long Statement,Microsoft.Research.Naiad.Utilities,ExpressionComparer,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\ExpressionComparer.cs,VisitMethodCall,The length of the statement  "            return this.Visit(m.Object' other.Object) && m.Method.Equals(other.Method) && this.VisitExpressionList(m.Arguments' other.Arguments); " is 133.
Long Statement,Microsoft.Research.Naiad.Utilities,ExpressionComparer,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\ExpressionComparer.cs,VisitMemberListBinding,The length of the statement  "            return this.VisitElementInitializerList(binding.Initializers' other.Initializers) && binding.Member.Equals(other.Member); " is 121.
Long Statement,Microsoft.Research.Naiad.Utilities,ExpressionComparer,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\ExpressionComparer.cs,VisitLambda,The length of the statement  "            return this.Visit(lambda.Body' other.Body) && lambda.Type.Equals(other.Type) && this.VisitExpressionList(lambda.Parameters' other.Parameters); " is 142.
Long Statement,Microsoft.Research.Naiad.Utilities,ExpressionComparer,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\ExpressionComparer.cs,VisitListInit,The length of the statement  "            return this.VisitNew(init.NewExpression' other.NewExpression) && this.VisitElementInitializerList(init.Initializers' other.Initializers); " is 137.
Long Statement,Microsoft.Research.Naiad.Utilities,ExpressionComparer,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\ExpressionComparer.cs,VisitNewArray,The length of the statement  "            return this.VisitExpressionList(na.Expressions' other.Expressions) && na.Type.GetElementType().Equals(na.Type.GetElementType()); " is 128.
Long Statement,Microsoft.Research.Naiad.Utilities,DependencyLister,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\DependencyLister.cs,Dependencies,The length of the statement  "                    if (!visited.Contains(referencedAssembly) && !FrameworkAssemblyNames.Contains(name.Name) && !(name.Name.StartsWith("System"))) " is 126.
Long Statement,Microsoft.Research.Naiad.Utilities,Win32,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\Win32.cs,SetKeepaliveOptions,The length of the statement  "             * If the onoff member is set to a nonzero value' TCP keep-alive is enabled and the other members in the structure are used.  " is 123.
Long Statement,Microsoft.Research.Naiad.Utilities,Win32,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\Win32.cs,SetKeepaliveOptions,The length of the statement  "             * The keepalivetime member specifies the timeout' in milliseconds' with no activity until the first keep-alive packet is sent.  " is 126.
Long Statement,Microsoft.Research.Naiad.Utilities,Win32,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\Win32.cs,SetKeepaliveOptions,The length of the statement  "             * The keepaliveinterval member specifies the interval' in milliseconds' between when successive keep-alive packets are sent  " is 123.
Complex Conditional,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,AttemptDelivery,The conditional expression  "graphId >= this.graphmailboxes.Count ||                  this.graphmailboxes[graphId] == null ||                  channelId >= this.graphmailboxes[graphId].Count ||                  this.graphmailboxes[graphId][channelId] == null ||                  message.Header.DestVertexID >= this.graphmailboxes[graphId][channelId].Count ||                  this.graphmailboxes[graphId][channelId][message.Header.DestVertexID] == null"  is complex.
Virtual Method Call from Constructor,Microsoft.Research.Naiad.Dataflow,InputStage<TRecord>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Input.cs,InputStage,The constructor "InputStage" calls a virtual method "Materialize".
Virtual Method Call from Constructor,Microsoft.Research.Naiad.Dataflow,StreamingInputStage<R>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Input.cs,StreamingInputStage,The constructor "StreamingInputStage" calls a virtual method "Materialize".
Virtual Method Call from Constructor,Microsoft.Research.Naiad.Runtime.Progress,DistributedProgressTracker,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\ProgressTracker.cs,DistributedProgressTracker,The constructor "DistributedProgressTracker" calls a virtual method "Materialize".
Virtual Method Call from Constructor,Microsoft.Research.Naiad.Runtime.Progress,DistributedProgressTracker,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\ProgressTracker.cs,DistributedProgressTracker,The constructor "DistributedProgressTracker" calls a virtual method "Materialize".
Virtual Method Call from Constructor,Microsoft.Research.Naiad.Runtime.Progress,CentralizedProgressTracker,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\ProgressTracker.cs,CentralizedProgressTracker,The constructor "CentralizedProgressTracker" calls a virtual method "Materialize".
Virtual Method Call from Constructor,Microsoft.Research.Naiad.Runtime.Progress,CentralizedProgressTracker,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\ProgressTracker.cs,CentralizedProgressTracker,The constructor "CentralizedProgressTracker" calls a virtual method "Materialize".
Virtual Method Call from Constructor,Microsoft.Research.Naiad.Runtime.Progress,CentralizedProgressTracker,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Progress\ProgressTracker.cs,CentralizedProgressTracker,The constructor "CentralizedProgressTracker" calls a virtual method "Materialize".
Magic Number,Microsoft.Research.Naiad.Serialization,Serializer,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,TrySerialize,The following statement contains a magic number: if (limit < (6 * sizeof(int)))                  {                      return 0;      }
Magic Number,Microsoft.Research.Naiad.Serialization,Serializer,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,TrySerialize,The following statement contains a magic number: intBuffer[2] = value.FromVertexID;
Magic Number,Microsoft.Research.Naiad.Serialization,Serializer,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,TrySerialize,The following statement contains a magic number: intBuffer[3] = value.Length;
Magic Number,Microsoft.Research.Naiad.Serialization,Serializer,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,TrySerialize,The following statement contains a magic number: intBuffer[4] = value.SequenceNumber;
Magic Number,Microsoft.Research.Naiad.Serialization,Serializer,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,TrySerialize,The following statement contains a magic number: intBuffer[5] = (int)value.Type;
Magic Number,Microsoft.Research.Naiad.Serialization,Serializer,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,TrySerialize,The following statement contains a magic number: return 6 * sizeof(int);
Magic Number,Microsoft.Research.Naiad.Serialization,Serializer,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,Deserialize,The following statement contains a magic number: if (limit < (6 * sizeof(int)))                  {                      return 0;                  }
Magic Number,Microsoft.Research.Naiad.Serialization,Serializer,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,Deserialize,The following statement contains a magic number: value.FromVertexID = intBuffer[2];
Magic Number,Microsoft.Research.Naiad.Serialization,Serializer,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,Deserialize,The following statement contains a magic number: value.Length = intBuffer[3];
Magic Number,Microsoft.Research.Naiad.Serialization,Serializer,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,Deserialize,The following statement contains a magic number: value.SequenceNumber = intBuffer[4];
Magic Number,Microsoft.Research.Naiad.Serialization,Serializer,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,Deserialize,The following statement contains a magic number: value.Type = (SerializedMessageType) intBuffer[5];
Magic Number,Microsoft.Research.Naiad.Serialization,Serializer,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,Deserialize,The following statement contains a magic number: return 6 * sizeof(int);
Magic Number,Microsoft.Research.Naiad.Serialization,NaiadWriter,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,NaiadWriter,The following statement contains a magic number: this.versionNumber = (codeGenerator.MajorVersion << 16) + codeGenerator.MinorVersion;
Magic Number,Microsoft.Research.Naiad.Serialization,NaiadReader,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,NaiadReader,The following statement contains a magic number: this.versionNumber = (serializationFormat.MajorVersion << 16) + serializationFormat.MinorVersion;
Magic Number,Microsoft.Research.Naiad.Serialization,NaiadReader,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,TryGetNextPage,The following statement contains a magic number: if (bytesRead == 0)              {                  result = default(RecvBuffer);                  return false;              }              else              {                  MessageHeader parsedHeader = default(MessageHeader);                  MessageHeader.ReadHeaderFromBuffer(this.buffer' 0' ref parsedHeader);                    if (parsedHeader.FromVertexID != this.versionNumber)                  {                      throw new InvalidDataException(string.Format("Cannot deserialize this file with serializer version {0}.{1} (file uses version {2}.{3})"' this.SerializationFormat.MajorVersion' this.SerializationFormat.MinorVersion' parsedHeader.FromVertexID >> 16' parsedHeader.FromVertexID & 0xFFFF));                  }                      result = new RecvBuffer(this.buffer' MessageHeader.SizeOf' MessageHeader.SizeOf + parsedHeader.Length);                  return true;              }
Magic Number,Microsoft.Research.Naiad.Serialization,NaiadReader<TElement>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,NaiadReader,The following statement contains a magic number: int majorNumber = this.currentHeader.FromVertexID >> 16;
Magic Number,Microsoft.Research.Naiad.Serialization,NaiadWriter<TElement>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,NaiadWriter,The following statement contains a magic number: this.versionNumber = (serializationFormat.MajorVersion << 16) + serializationFormat.MinorVersion;
Magic Number,Microsoft.Research.Naiad.Serialization,Serializers,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\Serialization.cs,Serialize,The following statement contains a magic number: if (target.EnsureAvailable(4))              {                  fixed (byte* ptr = &target.Array[target.Count])                  {                      *(ulong*)ptr = source;                  }                  target.Count += 4;              }
Magic Number,Microsoft.Research.Naiad.Serialization,Serializers,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\Serialization.cs,Serialize,The following statement contains a magic number: if (target.EnsureAvailable(4))              {                  fixed (byte* ptr = &target.Array[target.Count])                  {                      *(ulong*)ptr = source;                  }                  target.Count += 4;              }
Magic Number,Microsoft.Research.Naiad.Serialization,Serializers,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\Serialization.cs,Serialize,The following statement contains a magic number: if (target.EnsureAvailable(4))              {                  fixed (byte* ptr = &target.Array[target.Count])                  {                      *(int*)ptr = source;                  }                  target.Count += 4;                  /*                  target.Array[target.Count++] = (byte)((source >> 0) % 256);                  target.Array[target.Count++] = (byte)((source >> 8) % 256);                  target.Array[target.Count++] = (byte)((source >> 16) % 256);                  target.Array[target.Count++] = (byte)((source >> 24) % 256);*/              }
Magic Number,Microsoft.Research.Naiad.Serialization,Serializers,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\Serialization.cs,Serialize,The following statement contains a magic number: if (target.EnsureAvailable(4))              {                  fixed (byte* ptr = &target.Array[target.Count])                  {                      *(int*)ptr = source;                  }                  target.Count += 4;                  /*                  target.Array[target.Count++] = (byte)((source >> 0) % 256);                  target.Array[target.Count++] = (byte)((source >> 8) % 256);                  target.Array[target.Count++] = (byte)((source >> 16) % 256);                  target.Array[target.Count++] = (byte)((source >> 24) % 256);*/              }
Magic Number,Microsoft.Research.Naiad.Serialization,Serializers,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\Serialization.cs,Serialize,The following statement contains a magic number: if (target.EnsureAvailable(4))              {                  fixed (byte* ptr = &target.Array[target.Count])                  {                      *(uint*)ptr = source;                  }                  target.Count += 4;              }
Magic Number,Microsoft.Research.Naiad.Serialization,Serializers,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\Serialization.cs,Serialize,The following statement contains a magic number: if (target.EnsureAvailable(4))              {                  fixed (byte* ptr = &target.Array[target.Count])                  {                      *(uint*)ptr = source;                  }                  target.Count += 4;              }
Magic Number,Microsoft.Research.Naiad.Serialization,Serializers,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\Serialization.cs,Serialize,The following statement contains a magic number: if (target.EnsureAvailable(8))              {                  fixed (byte* ptr = &target.Array[target.Count])                  {                      *(double*)ptr = source;                  }                  target.Count += 8;                  /*byte[] bytes = BitConverter.GetBytes(source);                  for (int i = 0; i < bytes.Length; ++i)                      target.Array[target.Count++] = bytes[i];*/              }
Magic Number,Microsoft.Research.Naiad.Serialization,Serializers,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\Serialization.cs,Serialize,The following statement contains a magic number: if (target.EnsureAvailable(8))              {                  fixed (byte* ptr = &target.Array[target.Count])                  {                      *(double*)ptr = source;                  }                  target.Count += 8;                  /*byte[] bytes = BitConverter.GetBytes(source);                  for (int i = 0; i < bytes.Length; ++i)                      target.Array[target.Count++] = bytes[i];*/              }
Magic Number,Microsoft.Research.Naiad.Serialization,SerializationFactory,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GetCodeGeneratorForVersion,The following statement contains a magic number: switch (majorVersion)              {                  case 1:                      return new LegacySerializationCodeGenerator();                  case 2:                      return new InlineSerializationCodeGenerator(minorVersion);                  default:                      throw new InvalidOperationException(string.Format("No code generator available for version {0}.{1}"' majorVersion' minorVersion));              }
Magic Number,Microsoft.Research.Naiad.Serialization,InlineSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,InlineSerializationCodeGenerator,The following statement contains a magic number: if (minorVersion > 2)                  throw new ArgumentOutOfRangeException("minorVersion"' minorVersion' string.Format("Minor version {0} not supported"' minorVersion));
Magic Number,Microsoft.Research.Naiad.Serialization,CompileCache,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,Store,The following statement contains a magic number: while (!copied)              {                  try                  {                      if (File.Exists(pathToPdb))                          File.Copy(pathToPdb' cacheName + ".pdb"' true);                        File.Copy(pathToDll' cacheName + ".dll"' true);                      copied = true;                  }                  catch                  {                      System.Threading.Thread.Sleep(100);                  }              }
Magic Number,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTupleSerializeInstructions,The following statement contains a magic number: Debug.Assert(genericArgs.Length <= 8);
Magic Number,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTupleSerializeInstructions,The following statement contains a magic number: for (int i = 0; i < genericArgs.Length; ++i)                  {                      string itemName = i < 7 ? string.Format("Item{0}"' i + 1) : "Rest";                      foreach (var stmt in  this.GenerateSerializeInstructions(currentPosition' bytesRemaining'                          new CodePropertyReferenceExpression(toSerialize' itemName)' genericArgs[i]'                          failureReturnExpression))                          yield return stmt;                  }
Magic Number,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateTupleDeserializeInstructions,The following statement contains a magic number: Debug.Assert(genericArgs.Length <= 8);
Magic Number,Microsoft.Research.Naiad.Serialization,InlineNaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,GenerateDotnetBinarySerializeInstructions,The following statement contains a magic number: if (this.minorVersion >= 2)                  {                      yield return                          IfElse(BinOp(toSerialize' CodeBinaryOperatorType.ValueEquality' new CodePrimitiveExpression(null))'                              nullObjectStmts.ToArray()' objectStmts.ToArray());                  }                  else                  {                      foreach (var stmt in objectStmts)                          yield return stmt;                  }
Magic Number,Microsoft.Research.Naiad.Serialization,NaiadSerializationCodeGenerator,C:\repos\MicrosoftResearch_Naiad\Naiad\CodeGeneration\AutoSerialization.cs,SerializeOrReturn,The following statement contains a magic number: if (HasCustomSerialization(t))                  {                      yield return IfElse(Invoke(value' "Serialize"' Ref(dest))'                          new CodeStatement[] { }'                          new[] { Return("false") });                  }                  else if (t.IsEnum)                  {                      // Cast to an int and serialize.                      yield return CheckForSpace(                          dest' 4' Assign(dest' Invoke(dest' "Serialize"' Cast(typeof(int)' value))));                  }                      /*                  else if (t == typeof(String))                  {                      CodeBinaryOperatorExpression needed =                          BinOp(Field(value' "Length")' CodeBinaryOperatorType.Add' Literal(4));                      yield return CheckForSpace(                          dest' needed' Assign(dest' Invoke(dest' "Serialize"' value)));                  }                       */                  else if (IsPrimitive(t))                  {                      yield return CheckForSpace(dest' TypeSize(t)'                                                 Assign(dest' Invoke(dest' "Serialize"' value)));                  }                  else if (HasBuiltinSerializer(t))                  {                      yield return IfElse(new CodePrimitiveExpression(true)'                          CallBuiltinSerialize(dest' t' value)' new CodeStatement[] {});                  }                  else if (t.IsArray)                  {                      AddType(t.GetElementType());                      yield return CallSerialize(dest' Field(value' "Length"));                      yield return ForLoop(                          Stmt("int i = 0")' BinOp(Expr("i")' CodeBinaryOperatorType.LessThan' Field(value' "Length"))'                          Stmt("++i")'                          new CodeStatement[]                              {                                  CallSerialize(dest' Idx(value' Var("i")))                              });                    }                  else                  {                      foreach (FieldInfo field in FieldMetadata(t))                      {                          AddType(field.FieldType);                          yield return CallSerialize(dest' Field(value' field.Name));                                           }                  }
Magic Number,Microsoft.Research.Naiad.Dataflow.Channels,Fiber,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\ProgressChannel.cs,Fiber,The following statement contains a magic number: if (this.networkChannel != null)                  {                      this.encoder = new AutoSerializedMessageEncoder<Update' Empty>(-1' this.sender.Vertex.Stage.InternalComputation.Index << 16 | this.channelID' this.networkChannel.GetBufferPool(-1' -1)' this.networkChannel.SendPageSize' controller.SerializationFormat' SerializedMessageType.Data' () => this.GetNextSequenceNumber());                      this.encoder.CompletedMessage += (o' a) => { this.BroadcastPageContents(a.Hdr' a.Segment); /* Console.WriteLine("Sending progress message"); */};                  }
Magic Number,Microsoft.Research.Naiad.Dataflow.Channels,Fiber,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\ProgressChannel.cs,Fiber,The following statement contains a magic number: if (this.networkChannel != null)                  {                      this.encoder = new AutoSerializedMessageEncoder<Update' Empty>(0' this.sender.Vertex.Stage.InternalComputation.Index << 16 | this.channelID' this.networkChannel.GetBufferPool(0' -1)' this.networkChannel.SendPageSize' controller.SerializationFormat' SerializedMessageType.Data' () => this.networkChannel.GetSequenceNumber(-1));                      this.encoder.CompletedMessage += (o' a) => { this.SendPageContents(a.Hdr' a.Segment); };                  }
Magic Number,Microsoft.Research.Naiad.Dataflow.Channels,RemoteMailbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,RemoteMailbox,The following statement contains a magic number: for (int i = 0; i < controller.Workers.Count; ++i)              {                  this.encodersFromLocalVertices[i] = new AutoSerializedMessageEncoder<S' T>(this.vertexID' this.graphID << 16 | this.channelID' this.networkChannel.GetBufferPool(this.processID' i)' this.networkChannel.SendPageSize' manager.SerializationFormat' SerializedMessageType.Data' () => this.networkChannel.GetSequenceNumber(this.processID));                  this.encodersFromLocalVertices[i].CompletedMessage += (o' a) => { this.networkChannel.SendBufferSegment(a.Hdr' this.processID' a.Segment); };              }
Magic Number,Microsoft.Research.Naiad.Input,ConstantDataSource<TRecord>,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\DataSources.cs,Activate,The following statement contains a magic number: var currentBuffer = new TRecord[1024];
Magic Number,Microsoft.Research.Naiad.Dataflow,RemoteMailbox<S;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\MessageDelivery.cs,RemoteMailbox,The following statement contains a magic number: for (int i = 0; i < controller.Workers.Count; ++i)              {                  this.encodersFromLocalVertices[i] = new AutoSerializedMessageEncoder<S' T>(this.vertexID' this.graphID << 16 | this.channelID' this.networkChannel.GetBufferPool(this.processID' i)' this.networkChannel.SendPageSize' manager.SerializationFormat' SerializedMessageType.Data' () => this.networkChannel.GetSequenceNumber(this.processID));                  this.encodersFromLocalVertices[i].CompletedMessage += (o' a) => { this.networkChannel.SendBufferSegment(a.Hdr' this.processID' a.Segment); };              }
Magic Number,Microsoft.Research.Naiad.Dataflow,IterationIn,C:\repos\MicrosoftResearch_Naiad\Naiad\Time.cs,GetHashCode,The following statement contains a magic number: return 134123 * outerTime.GetHashCode() + iteration;
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: while (i < args.Length)              {                  switch (args[i])                  {                      case "--usage":                      case "--help":                      case "-?":                          Usage();                          ++i;                          break;                      case "--procid":                      case "-p":                          if (usePPM)                          {                              Logging.Error("Error: --procid can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ProcessID = Int32.Parse(args[i + 1]);                          i += 2;                          procIDSet = true;                          break;                      case "--threads":                      case "-t":                          config.WorkerCount = Int32.Parse(args[i + 1]);                          i += 2;                          break;                      case "--inlineserializer":                          config.UseInlineSerialization = true;                          ++i;                          break;                      case "--numprocs":                      case "-n":                          if (usePPM)                          {                              Logging.Error("Error: --numprocs can't be used with --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          processes = Int32.Parse(args[i + 1]);                          i += 2;                          numProcsSet = true;                          break;                      case "--hosts":                      case "-h":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --hosts");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --hosts cannot be combined with --local or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = new string[processes];                          if (args[i + 1].StartsWith("@"))                          {                              string hostsFilename = args[i + 1].Substring(1);                              try                              {                                  using (StreamReader reader = File.OpenText(hostsFilename))                                  {                                      for (int j = 0; j < processes; ++j)                                      {                                          if (reader.EndOfStream)                                          {                                              Logging.Error("Error: insufficient number of hosts in the given hosts file' {0}"' hostsFilename);                                              System.Environment.Exit(-1);                                          }                                          prefixes[j] = reader.ReadLine().Trim();                                      }                                  }                              }                              catch (Exception)                              {                                  Logging.Error("Error: cannot read hosts file' {0}"' hostsFilename);                                  System.Environment.Exit(-1);                              }                              i += 2;                          }                          else                          {                              Array.Copy(args' i + 1' prefixes' 0' processes);                              i += 1 + processes;                          }                          hostsSet = true;                          break;                      case "--local":                          if (!numProcsSet)                          {                              Logging.Error("Error: --numprocs must be specified before --local");                              Usage();                              System.Environment.Exit(-1);                          }                          if (hostsSet)                          {                              Logging.Error("Error: --local cannot be combined with --hosts or --ppm");                              Usage();                              System.Environment.Exit(-1);                          }                          prefixes = Enumerable.Range(2101' processes).Select(x => string.Format("localhost:{0}"' x)).ToArray();                          i++;                          hostsSet = true;                          break;                      case "--ppm":                          if (hostsSet || numProcsSet || procIDSet)                          {                              Logging.Error("Error: --ppm cannot be combined with --hosts or --local' or --numprocs or --procid");                              Usage();                              System.Environment.Exit(-1);                          }                          config.ReadEndpointsFromPPM = true;                          hostsSet = true;                          usePPM = true;                          i++;                          break;                      case "--reachability":                          config.CompactionInterval = Convert.ToInt32(args[i + 1]);                          i += 2;                          break;                      case "--deadlocktimeout":                          config.DeadlockTimeout = int.Parse(args[i + 1]);                          i += 2;                          break;                      case "--distributedprogresstracker":                          config.DistributedProgressTracker = true;                          i++;                          break;                      case "--impersonation":                          config.Impersonation = true;                          i++;                          break;                      case "--duplex":                          config.DuplexSockets = true;                          i++;                          break;                      case "--nagling":                          config.Nagling = true;                          i++;                          break;                      case "--keepalives":                          config.KeepAlives = true;                          Logging.Progress("TCP keep-alives enabled");                          i++;                          break;                      case "--nothighpriorityqueue":                          config.DontUseHighPriorityQueue = true;                          i++;                          break;                      case "--domainreporting":                          config.DomainReporting = true;                          i++;                          break;                      case "--inlinereporting":                          config.InlineReporting = true;                          i++;                          break;                      case "--aggregatereporting":                          config.AggregateReporting = true;                          i++;                          break;                      case "--broadcastprotocol":                          switch (args[i + 1].ToLower())                          {                              case "tcp":                              case "tcponly":                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                              case "udp":                              case "udponly":                                  config.Broadcast = BroadcastProtocol.UdpOnly;                                  break;                              case "tcpudp":                              case "udptcp":                              case "both":                                  config.Broadcast = BroadcastProtocol.TcpUdp;                                  break;                              default:                                  Logging.Error("Warning: unknown broadcast protocol ({0})"' args[i + 1]);                                  Logging.Error("Valid broadcast protocols are: tcp' udp' both");                                  config.Broadcast = BroadcastProtocol.TcpOnly;                                  break;                          }                          i += 2;                          break;                      case "--broadcastaddress":                          {                              string broadcastHostname;                              int broadcastPort = 2101;                              bool success = ParseName(args[i + 1]' out broadcastHostname' ref broadcastPort);                              if (!success)                              {                                  Logging.Error("Error: cannot set broadcast address to {0}"' args[i + 1]);                                  System.Environment.Exit(-1);                              }                              config.BroadcastAddress = new IPEndPoint(GetIPAddressForHostname(broadcastHostname)' broadcastPort);                          }                          i += 2;                          break;                      case "--broadcastwakeup":                          {                              config.UseBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup");                              i++;                              break;                          }                      case "--netbroadcastwakeup":                          {                              config.UseNetworkBroadcastWakeup = true;                              Console.Error.WriteLine("Using broadcast wakeup for networking threads");                              i++;                              break;                          }                      case "--sendpool":                          {                              switch (args[i + 1].ToLower())                              {                                  case "global":                                      config.SendBufferPolicy = SendBufferMode.Global;                                      break;                                  case "process":                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                                  case "worker":                                      config.SendBufferPolicy = SendBufferMode.PerWorker;                                      break;                                  default:                                      Logging.Error("Warning: send buffer policy ({0})"' args[i + 1]);                                      Logging.Error("Valid broadcast protocols are: global' process' worker");                                      config.SendBufferPolicy = SendBufferMode.PerRemoteProcess;                                      break;                              }                              i += 2;                              break;                          }                      case "--sendpagesize":                          {                              config.SendPageSize = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--sendpagecount":                          {                              config.SendPageCount = int.Parse(args[i + 1]);                              i += 2;                              break;                          }                      case "--addsetting":                          {                              config.AdditionalSettings.Add(args[i + 1]' args[i + 2]);                              i += 3;                              break;                          }                      default:                          strippedArgs.Add(args[i]);                          i++;                          break;                  }              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,FromArgs,The following statement contains a magic number: if (!usePPM)              {                  IPEndPoint[] endpoints = new IPEndPoint[processes];                    // Check whether we have multiple processes on the same machine (used for affinitizing purposes)                  string prevHostName = prefixes[0].Split(':')[0];                    for (int j = 0; j < endpoints.Length; ++j)                  {                      string hostname;                      int port = 2101;                      bool success = ParseName(prefixes[j]' out hostname' ref port);                      if (!success)                          System.Environment.Exit(-1);                      if (hostname != prevHostName)                          multipleProcsSingleMachine = false;                      else prevHostName = hostname;                        IPAddress ipv4Address = GetIPAddressForHostname(hostname);                        try                      {                          endpoints[j] = new System.Net.IPEndPoint(ipv4Address' port);                      }                      catch (ArgumentOutOfRangeException)                      {                          Logging.Error("Error: invalid port ({0}) for process {1}"' port' j);                          System.Environment.Exit(-1);                      }                  }                  config.Endpoints = endpoints;              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,ParseName,The following statement contains a magic number: if (splitName.Length == 2 && !int.TryParse(splitName[1]' out port))              {                  Logging.Error("Error: invalid port number ({0})"' splitName[1]);                  return false;              }
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,IsAutoConf,The following statement contains a magic number: if (bytes[0] == 169 && bytes[1] == 254) return true;
Magic Number,Microsoft.Research.Naiad,Configuration,C:\repos\MicrosoftResearch_Naiad\Naiad\Configuration.cs,IsAutoConf,The following statement contains a magic number: if (bytes[0] == 169 && bytes[1] == 254) return true;
Magic Number,Microsoft.Research.Naiad,IterationIn,C:\repos\MicrosoftResearch_Naiad\Naiad\Time.cs,GetHashCode,The following statement contains a magic number: return 134123 * outerTime.GetHashCode() + iteration;
Magic Number,Microsoft.Research.Naiad,ThreadLocalAllocationCounters<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\BufferPool.cs,Increment,The following statement contains a magic number: if (Math.Abs(pair.Second) > Math.Abs(pair.First) * 2 || Math.Abs(pair.Second) < Math.Abs(pair.First) / 2)              {                  if (Math.Abs(pair.Second) > 256)                  {                      Console.WriteLine("{0} Allocations; {1}' {2}"' pair.Second' tag' typeof(T).GetHashCode());                      pair.First = pair.Second;                  }              }
Magic Number,Microsoft.Research.Naiad,ThreadLocalAllocationCounters<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\BufferPool.cs,Increment,The following statement contains a magic number: if (Math.Abs(pair.Second) > Math.Abs(pair.First) * 2 || Math.Abs(pair.Second) < Math.Abs(pair.First) / 2)              {                  if (Math.Abs(pair.Second) > 256)                  {                      Console.WriteLine("{0} Allocations; {1}' {2}"' pair.Second' tag' typeof(T).GetHashCode());                      pair.First = pair.Second;                  }              }
Magic Number,Microsoft.Research.Naiad,ThreadLocalAllocationCounters<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\BufferPool.cs,Increment,The following statement contains a magic number: if (Math.Abs(pair.Second) > Math.Abs(pair.First) * 2 || Math.Abs(pair.Second) < Math.Abs(pair.First) / 2)              {                  if (Math.Abs(pair.Second) > 256)                  {                      Console.WriteLine("{0} Allocations; {1}' {2}"' pair.Second' tag' typeof(T).GetHashCode());                      pair.First = pair.Second;                  }              }
Magic Number,Microsoft.Research.Naiad,ThreadLocalAllocationCounters<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\BufferPool.cs,Decrement,The following statement contains a magic number: if (Math.Abs(pair.Second) > Math.Abs(pair.First) * 2 || Math.Abs(pair.Second) < Math.Abs(pair.First) / 2)              {                  if (Math.Abs(pair.Second) > 256)                  {                      Console.WriteLine("{0} Allocations; {1}' {2}"' pair.Second' tag' typeof(T).GetHashCode());                      pair.First = pair.Second;                  }              }
Magic Number,Microsoft.Research.Naiad,ThreadLocalAllocationCounters<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\BufferPool.cs,Decrement,The following statement contains a magic number: if (Math.Abs(pair.Second) > Math.Abs(pair.First) * 2 || Math.Abs(pair.Second) < Math.Abs(pair.First) / 2)              {                  if (Math.Abs(pair.Second) > 256)                  {                      Console.WriteLine("{0} Allocations; {1}' {2}"' pair.Second' tag' typeof(T).GetHashCode());                      pair.First = pair.Second;                  }              }
Magic Number,Microsoft.Research.Naiad,ThreadLocalAllocationCounters<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\BufferPool.cs,Decrement,The following statement contains a magic number: if (Math.Abs(pair.Second) > Math.Abs(pair.First) * 2 || Math.Abs(pair.Second) < Math.Abs(pair.First) / 2)              {                  if (Math.Abs(pair.Second) > 256)                  {                      Console.WriteLine("{0} Allocations; {1}' {2}"' pair.Second' tag' typeof(T).GetHashCode());                      pair.First = pair.Second;                  }              }
Magic Number,Microsoft.Research.Naiad,ThreadLocalMessageBufferPool<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\BufferPool.cs,CheckOut,The following statement contains a magic number: if (this.stacks.Count == 0)              {                  lock (GlobalStack)                  {                      for (int i = 0; i < 16; i++)                          this.stacks.Push(GlobalStack.Count > 0 ? GlobalStack.Pop() : new T[256]);                  }              }
Magic Number,Microsoft.Research.Naiad,ThreadLocalMessageBufferPool<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\BufferPool.cs,CheckOut,The following statement contains a magic number: if (this.stacks.Count == 0)              {                  lock (GlobalStack)                  {                      for (int i = 0; i < 16; i++)                          this.stacks.Push(GlobalStack.Count > 0 ? GlobalStack.Pop() : new T[256]);                  }              }
Magic Number,Microsoft.Research.Naiad,ThreadLocalMessageBufferPool<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\BufferPool.cs,CheckIn,The following statement contains a magic number: if (this.stacks.Count > MaximumStackLength)              {                  lock (GlobalStack)                  {                      for (int i = 0; i < MaximumStackLength / 2; i++)                          GlobalStack.Push(this.stacks.Pop());                  }              }
Magic Number,Microsoft.Research.Naiad,BoundedBufferPool2<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\BufferPool.cs,BoundedBufferPool2,The following statement contains a magic number: this.waiters = new Queue<Waiter>(16);
Magic Number,Microsoft.Research.Naiad,Pair,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\Pair.cs,GetHashCode,The following statement contains a magic number: return (this.First == null ? 0 : this.First.GetHashCode()) + 123412324 * (this.Second == null ? 0 : this.Second.GetHashCode());
Magic Number,Microsoft.Research.Naiad.Runtime.Progress,Reachability,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Reachability.cs,UpdateReachabilityPartialOrder,The following statement contains a magic number: var magicNumber = 37;
Magic Number,Microsoft.Research.Naiad.Runtime.Progress,FakeArray,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Version.cs,FakeArray,The following statement contains a magic number: if (Length > 4)                      spillover = new int[Length - 4];                  else                      spillover = null;
Magic Number,Microsoft.Research.Naiad.Runtime.Progress,FakeArray,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Version.cs,FakeArray,The following statement contains a magic number: if (Length > 4)                      spillover = new int[Length - 4];                  else                      spillover = null;
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,TcpNetworkChannel,The following statement contains a magic number: if (this.Controller.Configuration.Broadcast == Configuration.BroadcastProtocol.UdpOnly              || this.Controller.Configuration.Broadcast == Configuration.BroadcastProtocol.TcpUdp)              {                    this.udpClient = new UdpClient(new IPEndPoint(this.Controller.Configuration.Endpoints[this.Controller.Configuration.ProcessID].Address' this.Controller.Configuration.BroadcastAddress.Port));                                    IPEndPoint multicastGroupEndpoint = this.Controller.Configuration.BroadcastAddress;                  byte[] addrbytes = multicastGroupEndpoint.Address.GetAddressBytes();                    Logging.Progress("Configuring UDP broadcast channel using address {0}"' multicastGroupEndpoint);                    if (this.Controller.Configuration.ProcessID != 0)                  {                      if ((addrbytes[0] & 0xF0) == 224)                      {                          //Console.WriteLine("Multicast!");                          this.udpClient.JoinMulticastGroup(multicastGroupEndpoint.Address);                      }                      else                      {                          //Console.WriteLine("Broadcast?");                      }                      Thread udpclientThread = new Thread(() => this.UdpReceiveThread(multicastGroupEndpoint));                      udpclientThread.IsBackground = true;                      udpclientThread.Start();                  }                  else                  {                      if ((addrbytes[0] & 0xF0) == 224)                      {                          //Console.WriteLine("Multicast!");                          this.udpClient.Connect(multicastGroupEndpoint);                      }                      else                      {                          //Console.WriteLine("Broadcast?");                          this.udpClient.Connect(multicastGroupEndpoint);                          this.udpClient.EnableBroadcast = true;                      }                  }              }
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,TcpNetworkChannel,The following statement contains a magic number: if (this.Controller.Configuration.Broadcast == Configuration.BroadcastProtocol.UdpOnly              || this.Controller.Configuration.Broadcast == Configuration.BroadcastProtocol.TcpUdp)              {                    this.udpClient = new UdpClient(new IPEndPoint(this.Controller.Configuration.Endpoints[this.Controller.Configuration.ProcessID].Address' this.Controller.Configuration.BroadcastAddress.Port));                                    IPEndPoint multicastGroupEndpoint = this.Controller.Configuration.BroadcastAddress;                  byte[] addrbytes = multicastGroupEndpoint.Address.GetAddressBytes();                    Logging.Progress("Configuring UDP broadcast channel using address {0}"' multicastGroupEndpoint);                    if (this.Controller.Configuration.ProcessID != 0)                  {                      if ((addrbytes[0] & 0xF0) == 224)                      {                          //Console.WriteLine("Multicast!");                          this.udpClient.JoinMulticastGroup(multicastGroupEndpoint.Address);                      }                      else                      {                          //Console.WriteLine("Broadcast?");                      }                      Thread udpclientThread = new Thread(() => this.UdpReceiveThread(multicastGroupEndpoint));                      udpclientThread.IsBackground = true;                      udpclientThread.Start();                  }                  else                  {                      if ((addrbytes[0] & 0xF0) == 224)                      {                          //Console.WriteLine("Multicast!");                          this.udpClient.Connect(multicastGroupEndpoint);                      }                      else                      {                          //Console.WriteLine("Broadcast?");                          this.udpClient.Connect(multicastGroupEndpoint);                          this.udpClient.EnableBroadcast = true;                      }                  }              }
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,TcpNetworkChannel,The following statement contains a magic number: this.MAX_SEND_SIZE = 32 * this.sendPageSize;
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,AllocateConnectionState,The following statement contains a magic number: if (this.connections[processId] == null)              {                  this.connections[processId] = new ConnectionState(processId' ConnectionStatus.Initialized' 1 << 22'                      this.Controller.Configuration.SendBufferPolicy == Configuration.SendBufferMode.PerRemoteProcess                      ? new BoundedBufferPool2<byte>(this.sendPageSize' this.Controller.Configuration.SendPageCount) : null);              }
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,AddEndPointIncoming,The following statement contains a magic number: lock (this)              {                  this.AllocateConnectionState(processId);                    if (this.connections[processId].RecvSocket != null)                  {                      Logging.Error("WARNING: already accepted a connection from process {0}' so shutting down existing recvThread"' processId);                        this.connections[processId].RecvSocket.Close();                      this.connections[processId].RecvThread.Join();                        this.connections[processId].RecvSocket = null;                      this.connections[processId].RecvThread = null;                        //                      //System.Environment.Exit(-1);                  }                    if (!this.connections[processId].EverReceivedIncomingConnection)                  {                      this.recvConnectionCountdown.Signal();                      this.connections[processId].EverReceivedIncomingConnection = true;                  }                    this.connections[processId].RecvSocket = recvSocket;                  this.connections[processId].RecvThread = new Thread(() => this.PerProcessRecvThread(processId));                  this.connections[processId].RecvBufferSheaf = new RecvBufferSheaf(processId' (1 << 22) / RecvBufferPage.PAGE_SIZE' GlobalBufferPool<byte>.pool);  #if RECV_HIGH_PRIORITY                  this.connections[processId].RecvThread.Priority = ThreadPriority.Highest;  #endif                  this.connections[processId].RecvThread.Start();              }
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,WaitForAllConnections,The following statement contains a magic number: while (!this.sendConnectionCountdown.Wait(1000))                  ;
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,WaitForAllConnections,The following statement contains a magic number: while (!this.recvConnectionCountdown.Wait(1000))                  ;
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,WaitForShutdown,The following statement contains a magic number: while (!this.shutdownSendCountdown.Wait(1000))                  ;
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,WaitForShutdown,The following statement contains a magic number: while (!this.shutdownRecvCountdown.Wait(1000))                  ;
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,OnRecvBarrierMessageAndBlock,The following statement contains a magic number: while (!countdown.Wait(1000))                  ;
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessSendThread,The following statement contains a magic number: try_connecting_again:                // Connect to the destination socket.              while (true)               {                  Logging.Info("Connect({0}' ...' {1})"' this.connections[destProcessID].EndPoint' destProcessID);                    this.connections[destProcessID].SendSocket = new Socket(this.connections[destProcessID].EndPoint.AddressFamily' SocketType.Stream' ProtocolType.Tcp);                  if (!this.Controller.Configuration.Nagling)                  {                      this.connections[destProcessID].SendSocket.NoDelay = true;                  }                                    try                  {                      this.connections[destProcessID].SendSocket.Connect(this.connections[destProcessID].EndPoint);                      break;                  }                  catch (SocketException se)                  {                      if (se.SocketErrorCode == SocketError.TimedOut || se.SocketErrorCode == SocketError.ConnectionRefused)                      {                          // Remote process hasn't started yet' so retry in a second.                          this.connections[destProcessID].SendSocket.Dispose();                          Thread.Sleep(1000); // FIXME: Better to use a timer if we do lots of these?                      }                      else                      {                          Logging.Fatal("Fatal error connecting to {0} {1}"' this.connections[destProcessID].EndPoint' se.SocketErrorCode);                          Logging.Fatal(se.Message);                          System.Environment.Exit(-1);                      }                  }              }
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,HandleSocketError,The following statement contains a magic number: switch (errorCode)              {                  default:                      Logging.Fatal("Got socket error from peer {0}: {1} {2}\nDying..."' peerID' (int)errorCode' errorCode.ToString());                      Logging.Fatal(new SocketException((int)errorCode).ToString());                      Logging.Stop();                      //Debugger.Break();                      Thread.Sleep(1000); // Wait a bit before causing all network connections to abort!                      System.Environment.Exit((int)errorCode);                      break;              }
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,AttemptDelivery,The following statement contains a magic number: int graphId = message.Header.ChannelID >> 16;
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,ConnectionState,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,Dispose,The following statement contains a magic number: this.SendSocket.Close(5);
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,ConnectionState,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,Dispose,The following statement contains a magic number: if (this.RecvSocket != this.SendSocket) {                      this.RecvSocket.Shutdown(SocketShutdown.Both);                      this.RecvSocket.Close(5);                  }
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,NaiadServer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\NaiadServer.cs,NaiadServer,The following statement contains a magic number: this.serverActions[NaiadProtocolOpcode.Kill] = new GuardedAction(s => { using (TextWriter writer = new StreamWriter(new NetworkStream(s))) writer.WriteLine("Killed"); s.Close(); System.Environment.Exit(-9); }' false);
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,NaiadServer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\NaiadServer.cs,BindSocket,The following statement contains a magic number: if (endpoint == null)              {                  int port = 2101;                  for (int i = 0; socket == null && i < 1000; ++i)                  {                      endpoint = new IPEndPoint(IPAddress.Any' port + i);                      socket = TryToBind(endpoint);                  }              }              else              {                  socket = TryToBind(endpoint);              }
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,NaiadServer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\NaiadServer.cs,BindSocket,The following statement contains a magic number: if (endpoint == null)              {                  int port = 2101;                  for (int i = 0; socket == null && i < 1000; ++i)                  {                      endpoint = new IPEndPoint(IPAddress.Any' port + i);                      socket = TryToBind(endpoint);                  }              }              else              {                  socket = TryToBind(endpoint);              }
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,NaiadServer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\NaiadServer.cs,ThreadStart,The following statement contains a magic number: this.listeningSocket.Listen(100);
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,NaiadServer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\NaiadServer.cs,ReceiveInt,The following statement contains a magic number: byte[] intBuffer = new byte[4];
Magic Number,Microsoft.Research.Naiad.Runtime.Networking,NaiadServer,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\NaiadServer.cs,ReceiveInt,The following statement contains a magic number: Debug.Assert(n == 4);
Magic Number,Microsoft.Research.Naiad.Diagnostics,Logging,C:\repos\MicrosoftResearch_Naiad\Naiad\Logging.cs,initFileLogging,The following statement contains a magic number: lock (logLock)              {                  if (!Inited)                  {                      buf = new CircularLogBuffer<string>(4' "");                      buf.OverwriteIfFull = false; // don't lose any entries                        LogFileStream = new FileStream(LogFileName' FileMode.Create);                      LogWriter = new StreamWriter(LogFileStream);                      LogWriter.Write(preamble);                      LogWriter.Flush();                        Inited = true;                      res = true;                  }              }
Magic Number,Microsoft.Research.Naiad.Diagnostics,Logging,C:\repos\MicrosoftResearch_Naiad\Naiad\Logging.cs,initInMemoryLogging,The following statement contains a magic number: lock (logLock)              {                  if (!Inited)                  {                      buf = new CircularLogBuffer<string>(64' "");                      buf.OverwriteIfFull = true;                      Inited = true;                      res = true;                  }              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,Add,The following statement contains a magic number: if (Count < SmallLimit)              {                  if (Count == Small.Length)                  {                      T[] old = this.Small;                      this.Small = new T[old.Length * 2];                      var extra = old.Length * elementSize;                        old.CopyTo(this.Small' 0);                        this.size += extra;                  }                  Small[Count] = element;              }              else              {                  if (Count == SmallLimit)                  {                      var extra = 0;                        this.Spine = new T[65536][];                      extra += 8 * 65536;                        Spine[0] = Small;                        this.size += extra;                  }                    if (Count % 65536 == 0)                  {                      //if (Spine[Count / 65536] == null)                      Spine[Count / 65536] = new T[65536];                      this.size += 65536 * elementSize;                  }                  Spine[Count / 65536][Count % 65536] = element;              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,Add,The following statement contains a magic number: if (Count < SmallLimit)              {                  if (Count == Small.Length)                  {                      T[] old = this.Small;                      this.Small = new T[old.Length * 2];                      var extra = old.Length * elementSize;                        old.CopyTo(this.Small' 0);                        this.size += extra;                  }                  Small[Count] = element;              }              else              {                  if (Count == SmallLimit)                  {                      var extra = 0;                        this.Spine = new T[65536][];                      extra += 8 * 65536;                        Spine[0] = Small;                        this.size += extra;                  }                    if (Count % 65536 == 0)                  {                      //if (Spine[Count / 65536] == null)                      Spine[Count / 65536] = new T[65536];                      this.size += 65536 * elementSize;                  }                  Spine[Count / 65536][Count % 65536] = element;              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,Add,The following statement contains a magic number: if (Count < SmallLimit)              {                  if (Count == Small.Length)                  {                      T[] old = this.Small;                      this.Small = new T[old.Length * 2];                      var extra = old.Length * elementSize;                        old.CopyTo(this.Small' 0);                        this.size += extra;                  }                  Small[Count] = element;              }              else              {                  if (Count == SmallLimit)                  {                      var extra = 0;                        this.Spine = new T[65536][];                      extra += 8 * 65536;                        Spine[0] = Small;                        this.size += extra;                  }                    if (Count % 65536 == 0)                  {                      //if (Spine[Count / 65536] == null)                      Spine[Count / 65536] = new T[65536];                      this.size += 65536 * elementSize;                  }                  Spine[Count / 65536][Count % 65536] = element;              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,Add,The following statement contains a magic number: if (Count < SmallLimit)              {                  if (Count == Small.Length)                  {                      T[] old = this.Small;                      this.Small = new T[old.Length * 2];                      var extra = old.Length * elementSize;                        old.CopyTo(this.Small' 0);                        this.size += extra;                  }                  Small[Count] = element;              }              else              {                  if (Count == SmallLimit)                  {                      var extra = 0;                        this.Spine = new T[65536][];                      extra += 8 * 65536;                        Spine[0] = Small;                        this.size += extra;                  }                    if (Count % 65536 == 0)                  {                      //if (Spine[Count / 65536] == null)                      Spine[Count / 65536] = new T[65536];                      this.size += 65536 * elementSize;                  }                  Spine[Count / 65536][Count % 65536] = element;              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,Add,The following statement contains a magic number: if (Count < SmallLimit)              {                  if (Count == Small.Length)                  {                      T[] old = this.Small;                      this.Small = new T[old.Length * 2];                      var extra = old.Length * elementSize;                        old.CopyTo(this.Small' 0);                        this.size += extra;                  }                  Small[Count] = element;              }              else              {                  if (Count == SmallLimit)                  {                      var extra = 0;                        this.Spine = new T[65536][];                      extra += 8 * 65536;                        Spine[0] = Small;                        this.size += extra;                  }                    if (Count % 65536 == 0)                  {                      //if (Spine[Count / 65536] == null)                      Spine[Count / 65536] = new T[65536];                      this.size += 65536 * elementSize;                  }                  Spine[Count / 65536][Count % 65536] = element;              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,Add,The following statement contains a magic number: if (Count < SmallLimit)              {                  if (Count == Small.Length)                  {                      T[] old = this.Small;                      this.Small = new T[old.Length * 2];                      var extra = old.Length * elementSize;                        old.CopyTo(this.Small' 0);                        this.size += extra;                  }                  Small[Count] = element;              }              else              {                  if (Count == SmallLimit)                  {                      var extra = 0;                        this.Spine = new T[65536][];                      extra += 8 * 65536;                        Spine[0] = Small;                        this.size += extra;                  }                    if (Count % 65536 == 0)                  {                      //if (Spine[Count / 65536] == null)                      Spine[Count / 65536] = new T[65536];                      this.size += 65536 * elementSize;                  }                  Spine[Count / 65536][Count % 65536] = element;              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,Add,The following statement contains a magic number: if (Count < SmallLimit)              {                  if (Count == Small.Length)                  {                      T[] old = this.Small;                      this.Small = new T[old.Length * 2];                      var extra = old.Length * elementSize;                        old.CopyTo(this.Small' 0);                        this.size += extra;                  }                  Small[Count] = element;              }              else              {                  if (Count == SmallLimit)                  {                      var extra = 0;                        this.Spine = new T[65536][];                      extra += 8 * 65536;                        Spine[0] = Small;                        this.size += extra;                  }                    if (Count % 65536 == 0)                  {                      //if (Spine[Count / 65536] == null)                      Spine[Count / 65536] = new T[65536];                      this.size += 65536 * elementSize;                  }                  Spine[Count / 65536][Count % 65536] = element;              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,Add,The following statement contains a magic number: if (Count < SmallLimit)              {                  if (Count == Small.Length)                  {                      T[] old = this.Small;                      this.Small = new T[old.Length * 2];                      var extra = old.Length * elementSize;                        old.CopyTo(this.Small' 0);                        this.size += extra;                  }                  Small[Count] = element;              }              else              {                  if (Count == SmallLimit)                  {                      var extra = 0;                        this.Spine = new T[65536][];                      extra += 8 * 65536;                        Spine[0] = Small;                        this.size += extra;                  }                    if (Count % 65536 == 0)                  {                      //if (Spine[Count / 65536] == null)                      Spine[Count / 65536] = new T[65536];                      this.size += 65536 * elementSize;                  }                  Spine[Count / 65536][Count % 65536] = element;              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,Add,The following statement contains a magic number: if (Count < SmallLimit)              {                  if (Count == Small.Length)                  {                      T[] old = this.Small;                      this.Small = new T[old.Length * 2];                      var extra = old.Length * elementSize;                        old.CopyTo(this.Small' 0);                        this.size += extra;                  }                  Small[Count] = element;              }              else              {                  if (Count == SmallLimit)                  {                      var extra = 0;                        this.Spine = new T[65536][];                      extra += 8 * 65536;                        Spine[0] = Small;                        this.size += extra;                  }                    if (Count % 65536 == 0)                  {                      //if (Spine[Count / 65536] == null)                      Spine[Count / 65536] = new T[65536];                      this.size += 65536 * elementSize;                  }                  Spine[Count / 65536][Count % 65536] = element;              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,Add,The following statement contains a magic number: if (Count < SmallLimit)              {                  if (Count == Small.Length)                  {                      T[] old = this.Small;                      this.Small = new T[old.Length * 2];                      var extra = old.Length * elementSize;                        old.CopyTo(this.Small' 0);                        this.size += extra;                  }                  Small[Count] = element;              }              else              {                  if (Count == SmallLimit)                  {                      var extra = 0;                        this.Spine = new T[65536][];                      extra += 8 * 65536;                        Spine[0] = Small;                        this.size += extra;                  }                    if (Count % 65536 == 0)                  {                      //if (Spine[Count / 65536] == null)                      Spine[Count / 65536] = new T[65536];                      this.size += 65536 * elementSize;                  }                  Spine[Count / 65536][Count % 65536] = element;              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,AsEnumerable,The following statement contains a magic number: if (Count <= SmallLimit)              {                  for (int i = 0; i < Count; i++)                  {                      yield return Small[i];                  }              }              else              {                  // empties the spine as it goes.                  for (int i = 0; i < Count; i++)                  {                      yield return Spine[i / 65536][i % 65536];                        if (i > 0 && i % 65536 == 0)                          Spine[(i / 65536) - 1] = null;                  }              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,AsEnumerable,The following statement contains a magic number: if (Count <= SmallLimit)              {                  for (int i = 0; i < Count; i++)                  {                      yield return Small[i];                  }              }              else              {                  // empties the spine as it goes.                  for (int i = 0; i < Count; i++)                  {                      yield return Spine[i / 65536][i % 65536];                        if (i > 0 && i % 65536 == 0)                          Spine[(i / 65536) - 1] = null;                  }              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,AsEnumerable,The following statement contains a magic number: if (Count <= SmallLimit)              {                  for (int i = 0; i < Count; i++)                  {                      yield return Small[i];                  }              }              else              {                  // empties the spine as it goes.                  for (int i = 0; i < Count; i++)                  {                      yield return Spine[i / 65536][i % 65536];                        if (i > 0 && i % 65536 == 0)                          Spine[(i / 65536) - 1] = null;                  }              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,AsEnumerable,The following statement contains a magic number: if (Count <= SmallLimit)              {                  for (int i = 0; i < Count; i++)                  {                      yield return Small[i];                  }              }              else              {                  // empties the spine as it goes.                  for (int i = 0; i < Count; i++)                  {                      yield return Spine[i / 65536][i % 65536];                        if (i > 0 && i % 65536 == 0)                          Spine[(i / 65536) - 1] = null;                  }              }
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,Checkpoint,The following statement contains a magic number: for (int i = 0; i < this.Count; ++i)                  writer.Write(this.Spine[i / 65536][i % 65536]' serializer);
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,Checkpoint,The following statement contains a magic number: for (int i = 0; i < this.Count; ++i)                  writer.Write(this.Spine[i / 65536][i % 65536]' serializer);
Magic Number,Microsoft.Research.Naiad.DataStructures,SpinedList<T>,C:\repos\MicrosoftResearch_Naiad\Naiad\DataStructures\SpinedList.cs,SpinedList,The following statement contains a magic number: this.elementSize = 4;
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalKeyedReduceVertex<A;X;R;S;K;I;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: if (reducers == null)              {                  //reducers = new A[4];                  // Console.Error.WriteLine("Making a SpinedList in reducer");                  reducers = new SpinedList<A>();                  nextReducer = 0;                  index = new Dictionary<K' int>(2000000);                  lastTime = message.time;                  recordsIn = 0;                  NotifyAt(message.time);              }              else if (!message.time.Equals(lastTime))              {                  throw new Exception("One time at a time please!");              }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalKeyedReduceVertex<A;X;R;S;K;I;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: if (reducers == null)              {                  //reducers = new A[4];                  // Console.Error.WriteLine("Making a SpinedList in reducer");                  reducers = new SpinedList<A>();                  nextReducer = 0;                  index = new Dictionary<K' int>(2000000);                  lastTime = message.time;                  recordsIn = 0;                  NotifyAt(message.time);              }              else if (!message.time.Equals(lastTime))              {                  throw new Exception("One time at a time please!");              }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalTimeKeyedReduceVertex<A;X;R;S;K;I;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: if (!reducers.TryGetValue(message.time' out t))              {                  t = new Time(4);                  reducers.Add(message.time' t);                  NotifyAt(message.time);              }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalTimeKeyedReduceVertex<A;X;R;S;K;I;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: for (int ii = 0; ii < message.length; ii++)              {                  //this.OnRecv(message.payload[i].PairWith(message.time));                    var record = message.payload[ii];                    K k = key(record);                  int i;                  if (t.index.TryGetValue(k' out i))                  {                      t.reducers[i].Add(val(record));                  }                  else                  {                      if (t.nextReducer == t.reducers.Length)                      {                          A[] n = new A[t.nextReducer * 2];                          Array.Copy(t.reducers' n' t.nextReducer);                          t.reducers = n;                      }                      t.reducers[t.nextReducer] = factory();                      t.reducers[t.nextReducer].InitialAdd(val(record));                      t.index.Add(k' t.nextReducer);                      ++t.nextReducer;                  }              }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalTimeKeyedReduceVertex<A;X;R;S;K;I;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: if (!reducers.TryGetValue(message.time' out t))              {                  t = new Time(4);                  reducers.Add(message.time' t);                  NotifyAt(message.time);              }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalTimeKeyedReduceVertex<A;X;R;S;K;I;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: for (int ii = 0; ii < message.length; ii++)              {                  //this.OnRecv(message.payload[i].PairWith(message.time));                    var record = message.payload[ii];                    K k = key(record);                  int i;                  if (t.index.TryGetValue(k' out i))                  {                      t.reducers[i].Add(val(record));                  }                  else                  {                      if (t.nextReducer == t.reducers.Length)                      {                          A[] n = new A[t.nextReducer * 2];                          Array.Copy(t.reducers' n' t.nextReducer);                          t.reducers = n;                      }                      t.reducers[t.nextReducer] = factory();                      t.reducers[t.nextReducer].InitialAdd(val(record));                      t.index.Add(k' t.nextReducer);                      ++t.nextReducer;                  }              }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalKeyedCombineVertex<A;X;R;S;K;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: if (reducers == null)              {                  reducers = new A[4];                  nextReducer = 0;                  index = new Dictionary<K' int>();                  lastTime = message.time;                  recordsIn = 0;                  NotifyAt(message.time);              }              else if (!message.time.Equals(lastTime))              {                  throw new Exception("One time at a time please!");              }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalKeyedCombineVertex<A;X;R;S;K;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: for (int ii = 0; ii < message.length; ii++)              {                  //this.OnRecv(message.payload[i].PairWith(message.time));                    var record = message.payload[ii];                    K k = record.First;                  int i;                  if (index.TryGetValue(k' out i))                  {                      reducers[i].Combine(record.Second);                  }                  else                  {                      if (nextReducer == reducers.Length)                      {                          A[] n = new A[nextReducer * 2];                          Array.Copy(reducers' n' nextReducer);                          reducers = n;                      }                      reducers[nextReducer] = factory();                      reducers[nextReducer].InitialCombine(record.Second);                      index.Add(k' nextReducer);                      ++nextReducer;                  }                    ++recordsIn;                }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalKeyedCombineVertex<A;X;R;S;K;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: if (reducers == null)              {                  reducers = new A[4];                  nextReducer = 0;                  index = new Dictionary<K' int>();                  lastTime = message.time;                  recordsIn = 0;                  NotifyAt(message.time);              }              else if (!message.time.Equals(lastTime))              {                  throw new Exception("One time at a time please!");              }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalKeyedCombineVertex<A;X;R;S;K;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: for (int ii = 0; ii < message.length; ii++)              {                  //this.OnRecv(message.payload[i].PairWith(message.time));                    var record = message.payload[ii];                    K k = record.First;                  int i;                  if (index.TryGetValue(k' out i))                  {                      reducers[i].Combine(record.Second);                  }                  else                  {                      if (nextReducer == reducers.Length)                      {                          A[] n = new A[nextReducer * 2];                          Array.Copy(reducers' n' nextReducer);                          reducers = n;                      }                      reducers[nextReducer] = factory();                      reducers[nextReducer].InitialCombine(record.Second);                      index.Add(k' nextReducer);                      ++nextReducer;                  }                    ++recordsIn;                }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalTimeKeyedCombineVertex<A;X;R;S;K;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: if (!reducers.TryGetValue(message.time' out r))              {                  r = new Time(4);                  reducers.Add(message.time' r);                  NotifyAt(message.time);              }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalTimeKeyedCombineVertex<A;X;R;S;K;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: for (int ii = 0; ii < message.length; ii++)              {                  //this.OnRecv(message.payload[i].PairWith(message.time));                  var record = message.payload[ii];                    K k = record.First;                  int i;                  if (r.index.TryGetValue(k' out i))                  {                      r.reducers[i].Combine(record.Second);                  }                  else                  {                      if (r.nextReducer == r.reducers.Length)                      {                          A[] n = new A[r.nextReducer * 2];                          Array.Copy(r.reducers' n' r.nextReducer);                          r.reducers = n;                      }                      r.reducers[r.nextReducer] = factory();                      r.reducers[r.nextReducer].InitialCombine(record.Second);                      r.index.Add(k' r.nextReducer);                      ++r.nextReducer;                  }                }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalTimeKeyedCombineVertex<A;X;R;S;K;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: if (!reducers.TryGetValue(message.time' out r))              {                  r = new Time(4);                  reducers.Add(message.time' r);                  NotifyAt(message.time);              }
Magic Number,Microsoft.Research.Naiad.Frameworks.Reduction,LocalTimeKeyedCombineVertex<A;X;R;S;K;T>,C:\repos\MicrosoftResearch_Naiad\Naiad\Frameworks\Reduce.cs,OnReceive,The following statement contains a magic number: for (int ii = 0; ii < message.length; ii++)              {                  //this.OnRecv(message.payload[i].PairWith(message.time));                  var record = message.payload[ii];                    K k = record.First;                  int i;                  if (r.index.TryGetValue(k' out i))                  {                      r.reducers[i].Combine(record.Second);                  }                  else                  {                      if (r.nextReducer == r.reducers.Length)                      {                          A[] n = new A[r.nextReducer * 2];                          Array.Copy(r.reducers' n' r.nextReducer);                          r.reducers = n;                      }                      r.reducers[r.nextReducer] = factory();                      r.reducers[r.nextReducer].InitialCombine(record.Second);                      r.index.Add(k' r.nextReducer);                      ++r.nextReducer;                  }                }
Magic Number,Microsoft.Research.Naiad.Scheduling,Scheduler,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Scheduling\Scheduler.cs,ConsiderSleeping,The following statement contains a magic number: if (this.Controller.Configuration.UseBroadcastWakeup)              {                  wakeupCount = this.Controller.Workers.BlockScheduler(this.ev' wakeupCount + 1);              }              else              {                  if (!ev.WaitOne(this.deadlockTimeout))                  {                      Complain();                      while (!ev.WaitOne(1000)) ;                  }              }
Magic Number,Microsoft.Research.Naiad.Utilities,Win32,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\Win32.cs,SetKeepaliveOptions,The following statement contains a magic number: byte[] keepalivevals = new byte[12];
Magic Number,Microsoft.Research.Naiad.Utilities,Win32,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\Win32.cs,SetKeepaliveOptions,The following statement contains a magic number: int interval = 10;
Magic Number,Microsoft.Research.Naiad.Utilities,Win32,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\Win32.cs,SetKeepaliveOptions,The following statement contains a magic number: keepalivevals[4] = 10;
Magic Number,Microsoft.Research.Naiad.Utilities,Win32,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\Win32.cs,SetKeepaliveOptions,The following statement contains a magic number: keepalivevals[4] = 10;
Magic Number,Microsoft.Research.Naiad.Utilities,Win32,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\Win32.cs,SetKeepaliveOptions,The following statement contains a magic number: keepalivevals[8] = (byte)(interval & 0xff);
Magic Number,Microsoft.Research.Naiad.Utilities,Win32,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\Win32.cs,SetKeepaliveOptions,The following statement contains a magic number: keepalivevals[9] = (byte)(interval >> 8);
Magic Number,Microsoft.Research.Naiad.Utilities,Win32,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\Win32.cs,SetKeepaliveOptions,The following statement contains a magic number: keepalivevals[9] = (byte)(interval >> 8);
Magic Number,Microsoft.Research.Naiad.Utilities,Win32,C:\repos\MicrosoftResearch_Naiad\Naiad\Util\Win32.cs,SetKeepaliveOptions,The following statement contains a magic number: int ret = WSAIoctl(sockHandle' SIO_KEEPALIVE_VALS'                   keepalivevals' 12'                   IntPtr.Zero' 0'                   out cbRet'                   IntPtr.Zero' IntPtr.Zero);
Duplicate Code,Microsoft.Research.Naiad.Runtime.Networking,TcpNetworkChannel,C:\repos\MicrosoftResearch_Naiad\Naiad\Runtime\Networking\Networking.cs,PerProcessSendThread,The method contains a code clone-set at the following line numbers (starting from the method definition): ((133' 165)' (181' 213))
Missing Default,Microsoft.Research.Naiad.Serialization,RecvBufferSheaf,C:\repos\MicrosoftResearch_Naiad\Naiad\Channels\IOHelper.cs,ConsumeMessages,The following switch statement is missing a default case: switch (result)                      {                          case TryConsumeResult.Success:                              //Console.Error.WriteLine("*** Consumed {0} contiguous bytes"' unsplitBuffer.End - unsplitBuffer.CurrentPos);                              yield return new SerializedMessage(this.ForProcessID' this.currentMessageHeader' unsplitBuffer);                              this.currentMessageHeaderValid = false;                              break;                          case TryConsumeResult.Fail_InsufficientData:                              //Console.Error.WriteLine("*** Not enough data to proceed :(!");                              yield break;                          case TryConsumeResult.Fail_TryWithNextPage:                              //Console.Error.WriteLine("*** Need to split!");                              this.currentSplitMessageBody = new byte[this.currentMessageHeader.Length];                              this.currentSplitMessagePosition = 0;                              break;                      }
Missing Default,Microsoft.Research.Naiad.Dataflow,IntReportingReducer,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,Add,The following switch statement is missing a default case: switch (r.type)                  {                      case Reporting.AggregateType.Sum:                      case Reporting.AggregateType.Average:                          value.payload += r.payload;                          value.count += r.count;                          break;                        case Reporting.AggregateType.Min:                          value.payload = Math.Min(value.payload' r.payload);                          break;                        case Reporting.AggregateType.Max:                          value.payload = Math.Max(value.payload' r.payload);                          break;                  }
Missing Default,Microsoft.Research.Naiad.Dataflow,DoubleReportingReducer,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,Add,The following switch statement is missing a default case: switch (r.type)                  {                      case Reporting.AggregateType.Sum:                      case Reporting.AggregateType.Average:                          value.payload += r.payload;                          value.count += r.count;                          break;                        case Reporting.AggregateType.Min:                          value.payload = Math.Min(value.payload' r.payload);                          break;                        case Reporting.AggregateType.Max:                          value.payload = Math.Max(value.payload' r.payload);                          break;                  }
Missing Default,Microsoft.Research.Naiad.Diagnostics,Logging,C:\repos\MicrosoftResearch_Naiad\Naiad\Logging.cs,Init,The following switch statement is missing a default case: switch (LogStyle)              {                  case LoggingStyle.File:                      res = initFileLogging();                      s = String.Format("file {0}"' LogFileName);                      break;                  case LoggingStyle.Console:                      res = true;                      s = "console";                      break;              }
Missing Default,Microsoft.Research.Naiad.Diagnostics,Logging,C:\repos\MicrosoftResearch_Naiad\Naiad\Logging.cs,Log,The following switch statement is missing a default case: switch (LogStyle)                  {                      case LoggingStyle.File:                          initedNow = initFileLogging();                          break;                      case LoggingStyle.Console:                          initedNow = true;                          break;                  }
Missing Default,Microsoft.Research.Naiad.Diagnostics,Logging,C:\repos\MicrosoftResearch_Naiad\Naiad\Logging.cs,Log,The following switch statement is missing a default case: switch (LogStyle)              {                  case LoggingStyle.File:                      logToFile(thrd' msg);                      break;                  case LoggingStyle.Console:                      logToConsole(msg);                      break;              }
Missing Default,Reporting,IntReportingReducer,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,Add,The following switch statement is missing a default case: switch (r.type)                  {                      case Reporting.AggregateType.Sum:                      case Reporting.AggregateType.Average:                          value.payload += r.payload;                          value.count += r.count;                          break;                        case Reporting.AggregateType.Min:                          value.payload = Math.Min(value.payload' r.payload);                          break;                        case Reporting.AggregateType.Max:                          value.payload = Math.Max(value.payload' r.payload);                          break;                  }
Missing Default,Reporting,DoubleReportingReducer,C:\repos\MicrosoftResearch_Naiad\Naiad\Dataflow\Statistics.cs,Add,The following switch statement is missing a default case: switch (r.type)                  {                      case Reporting.AggregateType.Sum:                      case Reporting.AggregateType.Average:                          value.payload += r.payload;                          value.count += r.count;                          break;                        case Reporting.AggregateType.Min:                          value.payload = Math.Min(value.payload' r.payload);                          break;                        case Reporting.AggregateType.Max:                          value.payload = Math.Max(value.payload' r.payload);                          break;                  }
