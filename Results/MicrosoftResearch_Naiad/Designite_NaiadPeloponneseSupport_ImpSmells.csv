Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Microsoft.Research.Naiad.Util,Flags,C:\repos\MicrosoftResearch_Naiad\ClusterSubmission\NaiadPeloponneseSupport\Flags.cs,Parse,Cyclomatic complexity of the method is 8
Long Parameter List,Microsoft.Research.Naiad.Cluster,ClusterSubmission,C:\repos\MicrosoftResearch_Naiad\ClusterSubmission\NaiadPeloponneseSupport\ClusterSubmission.cs,ClusterSubmission,The method has 7 parameters. Parameters: cluster' stagingRoot' queueName' amMemoryInMB' numberOfProcesses' workerMemoryInMB' args
Long Parameter List,Microsoft.Research.Naiad.Cluster,Helpers,C:\repos\MicrosoftResearch_Naiad\ClusterSubmission\NaiadPeloponneseSupport\PPMSubmission.cs,MakePeloponneseConfig,The method has 7 parameters. Parameters: numberOfProcesses' workerMemoryInMB' type' commandLine' commandLineArgs' addRedirects' resources
Long Statement,Microsoft.Research.Naiad.Cluster,ClusterSubmission,C:\repos\MicrosoftResearch_Naiad\ClusterSubmission\NaiadPeloponneseSupport\ClusterSubmission.cs,MakeJobResourceGroups,The length of the statement  "                IEnumerable<string> dependencies = Microsoft.Research.Peloponnese.Shared.DependencyLister.Lister.ListDependencies(exeName); " is 123.
Long Statement,Microsoft.Research.Naiad.Cluster,ClusterSubmission,C:\repos\MicrosoftResearch_Naiad\ClusterSubmission\NaiadPeloponneseSupport\ClusterSubmission.cs,MakeJobResourceGroups,The length of the statement  "                IEnumerable<string> peloponneseDependencies = dependencies.Where(x => Path.GetFileName(x).StartsWith("Microsoft.Research.Peloponnese")); " is 136.
Long Statement,Microsoft.Research.Naiad.Cluster,ClusterSubmission,C:\repos\MicrosoftResearch_Naiad\ClusterSubmission\NaiadPeloponneseSupport\ClusterSubmission.cs,MakeJobResourceGroups,The length of the statement  "                XElement peloponneseGroup = ConfigHelpers.MakeResourceGroup(this.clusterClient.DfsClient' this.clusterClient.DfsClient.Combine(stagingRoot' "peloponnese")' true' peloponneseDependencies); " is 187.
Long Statement,Microsoft.Research.Naiad.Cluster,ClusterSubmission,C:\repos\MicrosoftResearch_Naiad\ClusterSubmission\NaiadPeloponneseSupport\ClusterSubmission.cs,MakeJobResourceGroups,The length of the statement  "                IEnumerable<string> naiadDependencies = dependencies.Where(x => Path.GetFileName(x).StartsWith("Microsoft.Research.Naiad")); " is 124.
Long Statement,Microsoft.Research.Naiad.Cluster,ClusterSubmission,C:\repos\MicrosoftResearch_Naiad\ClusterSubmission\NaiadPeloponneseSupport\ClusterSubmission.cs,MakeJobResourceGroups,The length of the statement  "                XElement naiadGroup = ConfigHelpers.MakeResourceGroup(this.clusterClient.DfsClient' this.clusterClient.DfsClient.Combine(stagingRoot' "naiad")' true' naiadDependencies); " is 169.
Long Statement,Microsoft.Research.Naiad.Cluster,ClusterSubmission,C:\repos\MicrosoftResearch_Naiad\ClusterSubmission\NaiadPeloponneseSupport\ClusterSubmission.cs,MakeJobResourceGroups,The length of the statement  "                IEnumerable<string> jobDependencies = dependencies.Where(x => !Path.GetFileName(x).StartsWith("Microsoft.Research.Naiad") && !Path.GetFileName(x).StartsWith("Microsoft.Research.Peloponnese")); " is 192.
Magic Number,Microsoft.Research.Naiad.Util,Flags,C:\repos\MicrosoftResearch_Naiad\ClusterSubmission\NaiadPeloponneseSupport\Flags.cs,Parse,The following statement contains a magic number: while (idx < args.Length)              {                  var arg = args[idx];                  //Console.Error.WriteLine("Parsing... {0} {1}"' idx' arg);                    ++idx;                  string name = null;                  if (arg.StartsWith("--"))                  {                      name = arg.Substring(2);                  }                  else if (arg.StartsWith("-"))                  {                      name = arg.Substring(1);                  }                  else                  {                      //Console.Error.WriteLine("Skipping non-flag argument " + arg);                      unparsedArgs.Add(arg);                      continue;                  }                    String value = null;                  if (name.Contains("="))                  {                      var parts = name.Split(new[] { '=' });                      Debug.Assert(parts.Length == 2);                      name = parts[0];                      value = parts[1];                  }                    if (name == "helpflags")                  {                      Console.Error.WriteLine("Application: {0}"' Assembly.GetEntryAssembly().GetName());                      Console.Error.WriteLine("Flags currently defined:");                        foreach (var k in _flagMap.Keys.OrderBy(k => k))                      {                          var f = _flagMap[k];                          Console.Error.WriteLine("  --{0} : {1} ({2})"' k' f.FlagType.Name' f.ToString());                      }                      System.Environment.Exit(0);                  }                    if (!_flagMap.ContainsKey(name))                  {                      //Console.Error.WriteLine("Skipping unknown argument " + name);                      unparsedArgs.Add(arg);                      continue;                  }                    var flag = _flagMap[name];                    if (flag.FlagType == typeof(bool))                  {                      flag.Parse("true");                  }                  else                  {                      if (value == null)                      {                          value = args[idx++];                      }                      //Console.WriteLine(name);                      flag.Parse(value);                  }              }
Magic Number,Microsoft.Research.Naiad.Util,Flags,C:\repos\MicrosoftResearch_Naiad\ClusterSubmission\NaiadPeloponneseSupport\Flags.cs,Parse,The following statement contains a magic number: while (idx < args.Length)              {                  var arg = args[idx];                  //Console.Error.WriteLine("Parsing... {0} {1}"' idx' arg);                    ++idx;                  string name = null;                  if (arg.StartsWith("--"))                  {                      name = arg.Substring(2);                  }                  else if (arg.StartsWith("-"))                  {                      name = arg.Substring(1);                  }                  else                  {                      //Console.Error.WriteLine("Skipping non-flag argument " + arg);                      unparsedArgs.Add(arg);                      continue;                  }                    String value = null;                  if (name.Contains("="))                  {                      var parts = name.Split(new[] { '=' });                      Debug.Assert(parts.Length == 2);                      name = parts[0];                      value = parts[1];                  }                    if (name == "helpflags")                  {                      Console.Error.WriteLine("Application: {0}"' Assembly.GetEntryAssembly().GetName());                      Console.Error.WriteLine("Flags currently defined:");                        foreach (var k in _flagMap.Keys.OrderBy(k => k))                      {                          var f = _flagMap[k];                          Console.Error.WriteLine("  --{0} : {1} ({2})"' k' f.FlagType.Name' f.ToString());                      }                      System.Environment.Exit(0);                  }                    if (!_flagMap.ContainsKey(name))                  {                      //Console.Error.WriteLine("Skipping unknown argument " + name);                      unparsedArgs.Add(arg);                      continue;                  }                    var flag = _flagMap[name];                    if (flag.FlagType == typeof(bool))                  {                      flag.Parse("true");                  }                  else                  {                      if (value == null)                      {                          value = args[idx++];                      }                      //Console.WriteLine(name);                      flag.Parse(value);                  }              }
