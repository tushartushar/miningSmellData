Implementation smell,Namespace,Class,File,Method,Description
Complex Method,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,GetSampleData,Cyclomatic complexity of the method is 8
Long Parameter List,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,LoadData,The method has 6 parameters.
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: ds.AddMapping (CirclePointMarker.FillProperty' dp =>  {  	double alpha = (dp.Data - currentRange.Min) / (currentRange.Max - currentRange.Min);  	Debug.Assert (0 <= alpha && alpha <= 1);  	const double hueWidth = 100;  	double hue = hueWidth * (alpha - 0.5) + hueSlider.Value;  	if (hue > 360)  		hue -= 360;  	else if (hue < 0)  		hue += 360;  	Debug.Assert (0 <= hue && hue <= 360);  	Color mainColor = new HsbColor (hue' 1' 0 + 1 * alpha' 0.3 + 0.7 * alpha).ToArgbColor ();  	const int colorCount = 5;  	GradientStopCollection colors = new GradientStopCollection (colorCount);  	double step = 1.0 / (colorCount - 1);  	for (int i = 0; i < colorCount; i++) {  		Color color = mainColor;  		double x = attSlider.Value * step * i;  		color.A = (byte)(255 * Math.Exp (-x * x));  		colors.Add (new GradientStop (color' step * i));  	}  	return new RadialGradientBrush (colors);  });  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: ds.AddMapping (CirclePointMarker.FillProperty' dp =>  {  	double alpha = (dp.Data - currentRange.Min) / (currentRange.Max - currentRange.Min);  	Debug.Assert (0 <= alpha && alpha <= 1);  	const double hueWidth = 100;  	double hue = hueWidth * (alpha - 0.5) + hueSlider.Value;  	if (hue > 360)  		hue -= 360;  	else if (hue < 0)  		hue += 360;  	Debug.Assert (0 <= hue && hue <= 360);  	Color mainColor = new HsbColor (hue' 1' 0 + 1 * alpha' 0.3 + 0.7 * alpha).ToArgbColor ();  	const int colorCount = 5;  	GradientStopCollection colors = new GradientStopCollection (colorCount);  	double step = 1.0 / (colorCount - 1);  	for (int i = 0; i < colorCount; i++) {  		Color color = mainColor;  		double x = attSlider.Value * step * i;  		color.A = (byte)(255 * Math.Exp (-x * x));  		colors.Add (new GradientStop (color' step * i));  	}  	return new RadialGradientBrush (colors);  });  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: ds.AddMapping (CirclePointMarker.FillProperty' dp =>  {  	double alpha = (dp.Data - currentRange.Min) / (currentRange.Max - currentRange.Min);  	Debug.Assert (0 <= alpha && alpha <= 1);  	const double hueWidth = 100;  	double hue = hueWidth * (alpha - 0.5) + hueSlider.Value;  	if (hue > 360)  		hue -= 360;  	else if (hue < 0)  		hue += 360;  	Debug.Assert (0 <= hue && hue <= 360);  	Color mainColor = new HsbColor (hue' 1' 0 + 1 * alpha' 0.3 + 0.7 * alpha).ToArgbColor ();  	const int colorCount = 5;  	GradientStopCollection colors = new GradientStopCollection (colorCount);  	double step = 1.0 / (colorCount - 1);  	for (int i = 0; i < colorCount; i++) {  		Color color = mainColor;  		double x = attSlider.Value * step * i;  		color.A = (byte)(255 * Math.Exp (-x * x));  		colors.Add (new GradientStop (color' step * i));  	}  	return new RadialGradientBrush (colors);  });  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: ds.AddMapping (CirclePointMarker.FillProperty' dp =>  {  	double alpha = (dp.Data - currentRange.Min) / (currentRange.Max - currentRange.Min);  	Debug.Assert (0 <= alpha && alpha <= 1);  	const double hueWidth = 100;  	double hue = hueWidth * (alpha - 0.5) + hueSlider.Value;  	if (hue > 360)  		hue -= 360;  	else if (hue < 0)  		hue += 360;  	Debug.Assert (0 <= hue && hue <= 360);  	Color mainColor = new HsbColor (hue' 1' 0 + 1 * alpha' 0.3 + 0.7 * alpha).ToArgbColor ();  	const int colorCount = 5;  	GradientStopCollection colors = new GradientStopCollection (colorCount);  	double step = 1.0 / (colorCount - 1);  	for (int i = 0; i < colorCount; i++) {  		Color color = mainColor;  		double x = attSlider.Value * step * i;  		color.A = (byte)(255 * Math.Exp (-x * x));  		colors.Add (new GradientStop (color' step * i));  	}  	return new RadialGradientBrush (colors);  });  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: ds.AddMapping (CirclePointMarker.FillProperty' dp =>  {  	double alpha = (dp.Data - currentRange.Min) / (currentRange.Max - currentRange.Min);  	Debug.Assert (0 <= alpha && alpha <= 1);  	const double hueWidth = 100;  	double hue = hueWidth * (alpha - 0.5) + hueSlider.Value;  	if (hue > 360)  		hue -= 360;  	else if (hue < 0)  		hue += 360;  	Debug.Assert (0 <= hue && hue <= 360);  	Color mainColor = new HsbColor (hue' 1' 0 + 1 * alpha' 0.3 + 0.7 * alpha).ToArgbColor ();  	const int colorCount = 5;  	GradientStopCollection colors = new GradientStopCollection (colorCount);  	double step = 1.0 / (colorCount - 1);  	for (int i = 0; i < colorCount; i++) {  		Color color = mainColor;  		double x = attSlider.Value * step * i;  		color.A = (byte)(255 * Math.Exp (-x * x));  		colors.Add (new GradientStop (color' step * i));  	}  	return new RadialGradientBrush (colors);  });  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: ds.AddMapping (CirclePointMarker.FillProperty' dp =>  {  	double alpha = (dp.Data - currentRange.Min) / (currentRange.Max - currentRange.Min);  	Debug.Assert (0 <= alpha && alpha <= 1);  	const double hueWidth = 100;  	double hue = hueWidth * (alpha - 0.5) + hueSlider.Value;  	if (hue > 360)  		hue -= 360;  	else if (hue < 0)  		hue += 360;  	Debug.Assert (0 <= hue && hue <= 360);  	Color mainColor = new HsbColor (hue' 1' 0 + 1 * alpha' 0.3 + 0.7 * alpha).ToArgbColor ();  	const int colorCount = 5;  	GradientStopCollection colors = new GradientStopCollection (colorCount);  	double step = 1.0 / (colorCount - 1);  	for (int i = 0; i < colorCount; i++) {  		Color color = mainColor;  		double x = attSlider.Value * step * i;  		color.A = (byte)(255 * Math.Exp (-x * x));  		colors.Add (new GradientStop (color' step * i));  	}  	return new RadialGradientBrush (colors);  });  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: ds.AddMapping (CirclePointMarker.FillProperty' dp =>  {  	double alpha = (dp.Data - currentRange.Min) / (currentRange.Max - currentRange.Min);  	Debug.Assert (0 <= alpha && alpha <= 1);  	const double hueWidth = 100;  	double hue = hueWidth * (alpha - 0.5) + hueSlider.Value;  	if (hue > 360)  		hue -= 360;  	else if (hue < 0)  		hue += 360;  	Debug.Assert (0 <= hue && hue <= 360);  	Color mainColor = new HsbColor (hue' 1' 0 + 1 * alpha' 0.3 + 0.7 * alpha).ToArgbColor ();  	const int colorCount = 5;  	GradientStopCollection colors = new GradientStopCollection (colorCount);  	double step = 1.0 / (colorCount - 1);  	for (int i = 0; i < colorCount; i++) {  		Color color = mainColor;  		double x = attSlider.Value * step * i;  		color.A = (byte)(255 * Math.Exp (-x * x));  		colors.Add (new GradientStop (color' step * i));  	}  	return new RadialGradientBrush (colors);  });  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: ds.AddMapping (CirclePointMarker.FillProperty' dp =>  {  	double alpha = (dp.Data - currentRange.Min) / (currentRange.Max - currentRange.Min);  	Debug.Assert (0 <= alpha && alpha <= 1);  	const double hueWidth = 100;  	double hue = hueWidth * (alpha - 0.5) + hueSlider.Value;  	if (hue > 360)  		hue -= 360;  	else if (hue < 0)  		hue += 360;  	Debug.Assert (0 <= hue && hue <= 360);  	Color mainColor = new HsbColor (hue' 1' 0 + 1 * alpha' 0.3 + 0.7 * alpha).ToArgbColor ();  	const int colorCount = 5;  	GradientStopCollection colors = new GradientStopCollection (colorCount);  	double step = 1.0 / (colorCount - 1);  	for (int i = 0; i < colorCount; i++) {  		Color color = mainColor;  		double x = attSlider.Value * step * i;  		color.A = (byte)(255 * Math.Exp (-x * x));  		colors.Add (new GradientStop (color' step * i));  	}  	return new RadialGradientBrush (colors);  });  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: ds.AddMapping (CirclePointMarker.FillProperty' dp =>  {  	double alpha = (dp.Data - currentRange.Min) / (currentRange.Max - currentRange.Min);  	Debug.Assert (0 <= alpha && alpha <= 1);  	const double hueWidth = 100;  	double hue = hueWidth * (alpha - 0.5) + hueSlider.Value;  	if (hue > 360)  		hue -= 360;  	else if (hue < 0)  		hue += 360;  	Debug.Assert (0 <= hue && hue <= 360);  	Color mainColor = new HsbColor (hue' 1' 0 + 1 * alpha' 0.3 + 0.7 * alpha).ToArgbColor ();  	const int colorCount = 5;  	GradientStopCollection colors = new GradientStopCollection (colorCount);  	double step = 1.0 / (colorCount - 1);  	for (int i = 0; i < colorCount; i++) {  		Color color = mainColor;  		double x = attSlider.Value * step * i;  		color.A = (byte)(255 * Math.Exp (-x * x));  		colors.Add (new GradientStop (color' step * i));  	}  	return new RadialGradientBrush (colors);  });  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: ds.AddMapping (CirclePointMarker.FillProperty' dp =>  {  	double alpha = (dp.Data - currentRange.Min) / (currentRange.Max - currentRange.Min);  	Debug.Assert (0 <= alpha && alpha <= 1);  	const double hueWidth = 100;  	double hue = hueWidth * (alpha - 0.5) + hueSlider.Value;  	if (hue > 360)  		hue -= 360;  	else if (hue < 0)  		hue += 360;  	Debug.Assert (0 <= hue && hue <= 360);  	Color mainColor = new HsbColor (hue' 1' 0 + 1 * alpha' 0.3 + 0.7 * alpha).ToArgbColor ();  	const int colorCount = 5;  	GradientStopCollection colors = new GradientStopCollection (colorCount);  	double step = 1.0 / (colorCount - 1);  	for (int i = 0; i < colorCount; i++) {  		Color color = mainColor;  		double x = attSlider.Value * step * i;  		color.A = (byte)(255 * Math.Exp (-x * x));  		colors.Add (new GradientStop (color' step * i));  	}  	return new RadialGradientBrush (colors);  });  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: if (hue > 360)  	hue -= 360;  else if (hue < 0)  	hue += 360;  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: if (hue > 360)  	hue -= 360;  else if (hue < 0)  	hue += 360;  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: if (hue > 360)  	hue -= 360;  else if (hue < 0)  	hue += 360;  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: hue -= 360;  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: if (hue < 0)  	hue += 360;  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: hue += 360;  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: Debug.Assert (0 <= hue && hue <= 360);  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: for (int i = 0; i < colorCount; i++) {  	Color color = mainColor;  	double x = attSlider.Value * step * i;  	color.A = (byte)(255 * Math.Exp (-x * x));  	colors.Add (new GradientStop (color' step * i));  }  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,CreateDataSource,The following statement contains a magic number: color.A = (byte)(255 * Math.Exp (-x * x));  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,ParseDataPoint,The following statement contains a magic number: res.Temp = Double.Parse (pieces [2]' CultureInfo.InvariantCulture);  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,ParseDataPoint,The following statement contains a magic number: res.RainFall = Double.Parse (pieces [3]' CultureInfo.InvariantCulture);  
Magic Number,PointSetOnMap,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\Samples\v0.4\PointsOnMapSampleApp\Window1.xaml.cs,ParseDataPoint,The following statement contains a magic number: res.SoilDepth = Double.Parse (pieces [4]' CultureInfo.InvariantCulture);  
