Implementation smell,Namespace,Class,File,Method,Description
Long Statement,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,Initialize,The length of the statement  "	d3dimage.IsFrontBufferAvailableChanged += new DependencyPropertyChangedEventHandler (d3dimage_IsFrontBufferAvailableChanged); " is 125.
Long Statement,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The length of the statement  "		device.DrawIndexedUserPrimitives<short' VertexPositionColor> (PrimitiveType.LineList' 0' points.Length' points.Length - 1' lineListIndices' Format.Index16' pointList' 20); " is 171.
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,Window_Loaded,The following statement contains a magic number: timer.Interval = TimeSpan.FromMilliseconds (10);  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,timer_Tick,The following statement contains a magic number: phase += 0.01;  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,timer_Tick,The following statement contains a magic number: if (phase > 2 * Math.PI)  	phase -= 2 * Math.PI;  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,timer_Tick,The following statement contains a magic number: if (phase > 2 * Math.PI)  	phase -= 2 * Math.PI;  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,timer_Tick,The following statement contains a magic number: phase -= 2 * Math.PI;  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,timer_Tick,The following statement contains a magic number: for (int i = 0; i < animatedX.Length; i++) {  	animatedX [i] = 2 * Math.PI * i / animatedX.Length;  	if (i % 2 == 0)  		animatedY [i] = Math.Sin (animatedX [i] + phase);  	else  		animatedY [i] = -Math.Sin (animatedX [i] + phase);  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,timer_Tick,The following statement contains a magic number: for (int i = 0; i < animatedX.Length; i++) {  	animatedX [i] = 2 * Math.PI * i / animatedX.Length;  	if (i % 2 == 0)  		animatedY [i] = Math.Sin (animatedX [i] + phase);  	else  		animatedY [i] = -Math.Sin (animatedX [i] + phase);  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,timer_Tick,The following statement contains a magic number: animatedX [i] = 2 * Math.PI * i / animatedX.Length;  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,timer_Tick,The following statement contains a magic number: if (i % 2 == 0)  	animatedY [i] = Math.Sin (animatedX [i] + phase);  else  	animatedY [i] = -Math.Sin (animatedX [i] + phase);  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: if (counter++ % 2 == 0)  	return;  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: if (d3dimage.IsFrontBufferAvailable) {  	result = Device.TestCooperativeLevel ();  	if (result.IsFailure) {  		throw new Direct3D9Exception ();  	}  	d3dimage.Lock ();  	Device.SetRenderState (RenderState.CullMode' Cull.None);  	Device.SetRenderState (RenderState.ZEnable' true);  	Device.Clear (ClearFlags.Target | ClearFlags.ZBuffer' new Color4 (1' 1' 1' 1)' 1.0f' 0);  	Device.BeginScene ();  	var points = animatedDataSource.GetPoints ().ToArray ();  	var pointList = new VertexPositionColor[points.Length];  	//phase += 0.01;  	//if (phase > 2 * Math.PI)  	//    phase -= 2 * Math.PI;  	//for (int i = 0; i < animatedX.Length; i++)  	//{  	//    animatedX[i] = 2 * Math.PI * i / animatedX.Length;  	//    if (i % 2 == 0)  	//        animatedY[i] = Math.Sin(animatedX[i] + phase);  	//    else  	//        animatedY[i] = -Math.Sin(animatedX[i] + phase);  	//}  	for (int i = 0; i < points.Length; i++) {  		pointList [i] = new VertexPositionColor {  			Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  			Color = Color.Orange.ToArgb ()  		};  	}  	var lineListIndices = new short[(points.Length * 2) - 2];  	// Populate the array with references to indices in the vertex buffer  	for (int i = 0; i < points.Length - 1; i++) {  		lineListIndices [i * 2] = (short)(i);  		lineListIndices [(i * 2) + 1] = (short)(i + 1);  	}  	device.SetRenderState (RenderState.AntialiasedLineEnable' true);  	device.VertexFormat = VertexFormat.Diffuse | VertexFormat.PositionRhw;  	device.DrawIndexedUserPrimitives<short' VertexPositionColor> (PrimitiveType.LineList' 0' points.Length' points.Length - 1' lineListIndices' Format.Index16' pointList' 20);  	//pointList'  	//0'  // vertex buffer offset to add to each element of the index buffer  	//8'  // number of vertices in pointList  	//lineListIndices'  // the index buffer  	//0'  // first index element to read  	//7   // number of primitives to draw  	//);  	Device.EndScene ();  	Device.Present ();  	d3dimage.SetBackBuffer (D3DResourceType.IDirect3DSurface9' Device.GetBackBuffer (0' 0).ComPointer);  	d3dimage.AddDirtyRect (new Int32Rect (0' 0' d3dimage.PixelWidth' d3dimage.PixelHeight));  	d3dimage.Unlock ();  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: if (d3dimage.IsFrontBufferAvailable) {  	result = Device.TestCooperativeLevel ();  	if (result.IsFailure) {  		throw new Direct3D9Exception ();  	}  	d3dimage.Lock ();  	Device.SetRenderState (RenderState.CullMode' Cull.None);  	Device.SetRenderState (RenderState.ZEnable' true);  	Device.Clear (ClearFlags.Target | ClearFlags.ZBuffer' new Color4 (1' 1' 1' 1)' 1.0f' 0);  	Device.BeginScene ();  	var points = animatedDataSource.GetPoints ().ToArray ();  	var pointList = new VertexPositionColor[points.Length];  	//phase += 0.01;  	//if (phase > 2 * Math.PI)  	//    phase -= 2 * Math.PI;  	//for (int i = 0; i < animatedX.Length; i++)  	//{  	//    animatedX[i] = 2 * Math.PI * i / animatedX.Length;  	//    if (i % 2 == 0)  	//        animatedY[i] = Math.Sin(animatedX[i] + phase);  	//    else  	//        animatedY[i] = -Math.Sin(animatedX[i] + phase);  	//}  	for (int i = 0; i < points.Length; i++) {  		pointList [i] = new VertexPositionColor {  			Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  			Color = Color.Orange.ToArgb ()  		};  	}  	var lineListIndices = new short[(points.Length * 2) - 2];  	// Populate the array with references to indices in the vertex buffer  	for (int i = 0; i < points.Length - 1; i++) {  		lineListIndices [i * 2] = (short)(i);  		lineListIndices [(i * 2) + 1] = (short)(i + 1);  	}  	device.SetRenderState (RenderState.AntialiasedLineEnable' true);  	device.VertexFormat = VertexFormat.Diffuse | VertexFormat.PositionRhw;  	device.DrawIndexedUserPrimitives<short' VertexPositionColor> (PrimitiveType.LineList' 0' points.Length' points.Length - 1' lineListIndices' Format.Index16' pointList' 20);  	//pointList'  	//0'  // vertex buffer offset to add to each element of the index buffer  	//8'  // number of vertices in pointList  	//lineListIndices'  // the index buffer  	//0'  // first index element to read  	//7   // number of primitives to draw  	//);  	Device.EndScene ();  	Device.Present ();  	d3dimage.SetBackBuffer (D3DResourceType.IDirect3DSurface9' Device.GetBackBuffer (0' 0).ComPointer);  	d3dimage.AddDirtyRect (new Int32Rect (0' 0' d3dimage.PixelWidth' d3dimage.PixelHeight));  	d3dimage.Unlock ();  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: if (d3dimage.IsFrontBufferAvailable) {  	result = Device.TestCooperativeLevel ();  	if (result.IsFailure) {  		throw new Direct3D9Exception ();  	}  	d3dimage.Lock ();  	Device.SetRenderState (RenderState.CullMode' Cull.None);  	Device.SetRenderState (RenderState.ZEnable' true);  	Device.Clear (ClearFlags.Target | ClearFlags.ZBuffer' new Color4 (1' 1' 1' 1)' 1.0f' 0);  	Device.BeginScene ();  	var points = animatedDataSource.GetPoints ().ToArray ();  	var pointList = new VertexPositionColor[points.Length];  	//phase += 0.01;  	//if (phase > 2 * Math.PI)  	//    phase -= 2 * Math.PI;  	//for (int i = 0; i < animatedX.Length; i++)  	//{  	//    animatedX[i] = 2 * Math.PI * i / animatedX.Length;  	//    if (i % 2 == 0)  	//        animatedY[i] = Math.Sin(animatedX[i] + phase);  	//    else  	//        animatedY[i] = -Math.Sin(animatedX[i] + phase);  	//}  	for (int i = 0; i < points.Length; i++) {  		pointList [i] = new VertexPositionColor {  			Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  			Color = Color.Orange.ToArgb ()  		};  	}  	var lineListIndices = new short[(points.Length * 2) - 2];  	// Populate the array with references to indices in the vertex buffer  	for (int i = 0; i < points.Length - 1; i++) {  		lineListIndices [i * 2] = (short)(i);  		lineListIndices [(i * 2) + 1] = (short)(i + 1);  	}  	device.SetRenderState (RenderState.AntialiasedLineEnable' true);  	device.VertexFormat = VertexFormat.Diffuse | VertexFormat.PositionRhw;  	device.DrawIndexedUserPrimitives<short' VertexPositionColor> (PrimitiveType.LineList' 0' points.Length' points.Length - 1' lineListIndices' Format.Index16' pointList' 20);  	//pointList'  	//0'  // vertex buffer offset to add to each element of the index buffer  	//8'  // number of vertices in pointList  	//lineListIndices'  // the index buffer  	//0'  // first index element to read  	//7   // number of primitives to draw  	//);  	Device.EndScene ();  	Device.Present ();  	d3dimage.SetBackBuffer (D3DResourceType.IDirect3DSurface9' Device.GetBackBuffer (0' 0).ComPointer);  	d3dimage.AddDirtyRect (new Int32Rect (0' 0' d3dimage.PixelWidth' d3dimage.PixelHeight));  	d3dimage.Unlock ();  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: if (d3dimage.IsFrontBufferAvailable) {  	result = Device.TestCooperativeLevel ();  	if (result.IsFailure) {  		throw new Direct3D9Exception ();  	}  	d3dimage.Lock ();  	Device.SetRenderState (RenderState.CullMode' Cull.None);  	Device.SetRenderState (RenderState.ZEnable' true);  	Device.Clear (ClearFlags.Target | ClearFlags.ZBuffer' new Color4 (1' 1' 1' 1)' 1.0f' 0);  	Device.BeginScene ();  	var points = animatedDataSource.GetPoints ().ToArray ();  	var pointList = new VertexPositionColor[points.Length];  	//phase += 0.01;  	//if (phase > 2 * Math.PI)  	//    phase -= 2 * Math.PI;  	//for (int i = 0; i < animatedX.Length; i++)  	//{  	//    animatedX[i] = 2 * Math.PI * i / animatedX.Length;  	//    if (i % 2 == 0)  	//        animatedY[i] = Math.Sin(animatedX[i] + phase);  	//    else  	//        animatedY[i] = -Math.Sin(animatedX[i] + phase);  	//}  	for (int i = 0; i < points.Length; i++) {  		pointList [i] = new VertexPositionColor {  			Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  			Color = Color.Orange.ToArgb ()  		};  	}  	var lineListIndices = new short[(points.Length * 2) - 2];  	// Populate the array with references to indices in the vertex buffer  	for (int i = 0; i < points.Length - 1; i++) {  		lineListIndices [i * 2] = (short)(i);  		lineListIndices [(i * 2) + 1] = (short)(i + 1);  	}  	device.SetRenderState (RenderState.AntialiasedLineEnable' true);  	device.VertexFormat = VertexFormat.Diffuse | VertexFormat.PositionRhw;  	device.DrawIndexedUserPrimitives<short' VertexPositionColor> (PrimitiveType.LineList' 0' points.Length' points.Length - 1' lineListIndices' Format.Index16' pointList' 20);  	//pointList'  	//0'  // vertex buffer offset to add to each element of the index buffer  	//8'  // number of vertices in pointList  	//lineListIndices'  // the index buffer  	//0'  // first index element to read  	//7   // number of primitives to draw  	//);  	Device.EndScene ();  	Device.Present ();  	d3dimage.SetBackBuffer (D3DResourceType.IDirect3DSurface9' Device.GetBackBuffer (0' 0).ComPointer);  	d3dimage.AddDirtyRect (new Int32Rect (0' 0' d3dimage.PixelWidth' d3dimage.PixelHeight));  	d3dimage.Unlock ();  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: if (d3dimage.IsFrontBufferAvailable) {  	result = Device.TestCooperativeLevel ();  	if (result.IsFailure) {  		throw new Direct3D9Exception ();  	}  	d3dimage.Lock ();  	Device.SetRenderState (RenderState.CullMode' Cull.None);  	Device.SetRenderState (RenderState.ZEnable' true);  	Device.Clear (ClearFlags.Target | ClearFlags.ZBuffer' new Color4 (1' 1' 1' 1)' 1.0f' 0);  	Device.BeginScene ();  	var points = animatedDataSource.GetPoints ().ToArray ();  	var pointList = new VertexPositionColor[points.Length];  	//phase += 0.01;  	//if (phase > 2 * Math.PI)  	//    phase -= 2 * Math.PI;  	//for (int i = 0; i < animatedX.Length; i++)  	//{  	//    animatedX[i] = 2 * Math.PI * i / animatedX.Length;  	//    if (i % 2 == 0)  	//        animatedY[i] = Math.Sin(animatedX[i] + phase);  	//    else  	//        animatedY[i] = -Math.Sin(animatedX[i] + phase);  	//}  	for (int i = 0; i < points.Length; i++) {  		pointList [i] = new VertexPositionColor {  			Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  			Color = Color.Orange.ToArgb ()  		};  	}  	var lineListIndices = new short[(points.Length * 2) - 2];  	// Populate the array with references to indices in the vertex buffer  	for (int i = 0; i < points.Length - 1; i++) {  		lineListIndices [i * 2] = (short)(i);  		lineListIndices [(i * 2) + 1] = (short)(i + 1);  	}  	device.SetRenderState (RenderState.AntialiasedLineEnable' true);  	device.VertexFormat = VertexFormat.Diffuse | VertexFormat.PositionRhw;  	device.DrawIndexedUserPrimitives<short' VertexPositionColor> (PrimitiveType.LineList' 0' points.Length' points.Length - 1' lineListIndices' Format.Index16' pointList' 20);  	//pointList'  	//0'  // vertex buffer offset to add to each element of the index buffer  	//8'  // number of vertices in pointList  	//lineListIndices'  // the index buffer  	//0'  // first index element to read  	//7   // number of primitives to draw  	//);  	Device.EndScene ();  	Device.Present ();  	d3dimage.SetBackBuffer (D3DResourceType.IDirect3DSurface9' Device.GetBackBuffer (0' 0).ComPointer);  	d3dimage.AddDirtyRect (new Int32Rect (0' 0' d3dimage.PixelWidth' d3dimage.PixelHeight));  	d3dimage.Unlock ();  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: if (d3dimage.IsFrontBufferAvailable) {  	result = Device.TestCooperativeLevel ();  	if (result.IsFailure) {  		throw new Direct3D9Exception ();  	}  	d3dimage.Lock ();  	Device.SetRenderState (RenderState.CullMode' Cull.None);  	Device.SetRenderState (RenderState.ZEnable' true);  	Device.Clear (ClearFlags.Target | ClearFlags.ZBuffer' new Color4 (1' 1' 1' 1)' 1.0f' 0);  	Device.BeginScene ();  	var points = animatedDataSource.GetPoints ().ToArray ();  	var pointList = new VertexPositionColor[points.Length];  	//phase += 0.01;  	//if (phase > 2 * Math.PI)  	//    phase -= 2 * Math.PI;  	//for (int i = 0; i < animatedX.Length; i++)  	//{  	//    animatedX[i] = 2 * Math.PI * i / animatedX.Length;  	//    if (i % 2 == 0)  	//        animatedY[i] = Math.Sin(animatedX[i] + phase);  	//    else  	//        animatedY[i] = -Math.Sin(animatedX[i] + phase);  	//}  	for (int i = 0; i < points.Length; i++) {  		pointList [i] = new VertexPositionColor {  			Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  			Color = Color.Orange.ToArgb ()  		};  	}  	var lineListIndices = new short[(points.Length * 2) - 2];  	// Populate the array with references to indices in the vertex buffer  	for (int i = 0; i < points.Length - 1; i++) {  		lineListIndices [i * 2] = (short)(i);  		lineListIndices [(i * 2) + 1] = (short)(i + 1);  	}  	device.SetRenderState (RenderState.AntialiasedLineEnable' true);  	device.VertexFormat = VertexFormat.Diffuse | VertexFormat.PositionRhw;  	device.DrawIndexedUserPrimitives<short' VertexPositionColor> (PrimitiveType.LineList' 0' points.Length' points.Length - 1' lineListIndices' Format.Index16' pointList' 20);  	//pointList'  	//0'  // vertex buffer offset to add to each element of the index buffer  	//8'  // number of vertices in pointList  	//lineListIndices'  // the index buffer  	//0'  // first index element to read  	//7   // number of primitives to draw  	//);  	Device.EndScene ();  	Device.Present ();  	d3dimage.SetBackBuffer (D3DResourceType.IDirect3DSurface9' Device.GetBackBuffer (0' 0).ComPointer);  	d3dimage.AddDirtyRect (new Int32Rect (0' 0' d3dimage.PixelWidth' d3dimage.PixelHeight));  	d3dimage.Unlock ();  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: if (d3dimage.IsFrontBufferAvailable) {  	result = Device.TestCooperativeLevel ();  	if (result.IsFailure) {  		throw new Direct3D9Exception ();  	}  	d3dimage.Lock ();  	Device.SetRenderState (RenderState.CullMode' Cull.None);  	Device.SetRenderState (RenderState.ZEnable' true);  	Device.Clear (ClearFlags.Target | ClearFlags.ZBuffer' new Color4 (1' 1' 1' 1)' 1.0f' 0);  	Device.BeginScene ();  	var points = animatedDataSource.GetPoints ().ToArray ();  	var pointList = new VertexPositionColor[points.Length];  	//phase += 0.01;  	//if (phase > 2 * Math.PI)  	//    phase -= 2 * Math.PI;  	//for (int i = 0; i < animatedX.Length; i++)  	//{  	//    animatedX[i] = 2 * Math.PI * i / animatedX.Length;  	//    if (i % 2 == 0)  	//        animatedY[i] = Math.Sin(animatedX[i] + phase);  	//    else  	//        animatedY[i] = -Math.Sin(animatedX[i] + phase);  	//}  	for (int i = 0; i < points.Length; i++) {  		pointList [i] = new VertexPositionColor {  			Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  			Color = Color.Orange.ToArgb ()  		};  	}  	var lineListIndices = new short[(points.Length * 2) - 2];  	// Populate the array with references to indices in the vertex buffer  	for (int i = 0; i < points.Length - 1; i++) {  		lineListIndices [i * 2] = (short)(i);  		lineListIndices [(i * 2) + 1] = (short)(i + 1);  	}  	device.SetRenderState (RenderState.AntialiasedLineEnable' true);  	device.VertexFormat = VertexFormat.Diffuse | VertexFormat.PositionRhw;  	device.DrawIndexedUserPrimitives<short' VertexPositionColor> (PrimitiveType.LineList' 0' points.Length' points.Length - 1' lineListIndices' Format.Index16' pointList' 20);  	//pointList'  	//0'  // vertex buffer offset to add to each element of the index buffer  	//8'  // number of vertices in pointList  	//lineListIndices'  // the index buffer  	//0'  // first index element to read  	//7   // number of primitives to draw  	//);  	Device.EndScene ();  	Device.Present ();  	d3dimage.SetBackBuffer (D3DResourceType.IDirect3DSurface9' Device.GetBackBuffer (0' 0).ComPointer);  	d3dimage.AddDirtyRect (new Int32Rect (0' 0' d3dimage.PixelWidth' d3dimage.PixelHeight));  	d3dimage.Unlock ();  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: if (d3dimage.IsFrontBufferAvailable) {  	result = Device.TestCooperativeLevel ();  	if (result.IsFailure) {  		throw new Direct3D9Exception ();  	}  	d3dimage.Lock ();  	Device.SetRenderState (RenderState.CullMode' Cull.None);  	Device.SetRenderState (RenderState.ZEnable' true);  	Device.Clear (ClearFlags.Target | ClearFlags.ZBuffer' new Color4 (1' 1' 1' 1)' 1.0f' 0);  	Device.BeginScene ();  	var points = animatedDataSource.GetPoints ().ToArray ();  	var pointList = new VertexPositionColor[points.Length];  	//phase += 0.01;  	//if (phase > 2 * Math.PI)  	//    phase -= 2 * Math.PI;  	//for (int i = 0; i < animatedX.Length; i++)  	//{  	//    animatedX[i] = 2 * Math.PI * i / animatedX.Length;  	//    if (i % 2 == 0)  	//        animatedY[i] = Math.Sin(animatedX[i] + phase);  	//    else  	//        animatedY[i] = -Math.Sin(animatedX[i] + phase);  	//}  	for (int i = 0; i < points.Length; i++) {  		pointList [i] = new VertexPositionColor {  			Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  			Color = Color.Orange.ToArgb ()  		};  	}  	var lineListIndices = new short[(points.Length * 2) - 2];  	// Populate the array with references to indices in the vertex buffer  	for (int i = 0; i < points.Length - 1; i++) {  		lineListIndices [i * 2] = (short)(i);  		lineListIndices [(i * 2) + 1] = (short)(i + 1);  	}  	device.SetRenderState (RenderState.AntialiasedLineEnable' true);  	device.VertexFormat = VertexFormat.Diffuse | VertexFormat.PositionRhw;  	device.DrawIndexedUserPrimitives<short' VertexPositionColor> (PrimitiveType.LineList' 0' points.Length' points.Length - 1' lineListIndices' Format.Index16' pointList' 20);  	//pointList'  	//0'  // vertex buffer offset to add to each element of the index buffer  	//8'  // number of vertices in pointList  	//lineListIndices'  // the index buffer  	//0'  // first index element to read  	//7   // number of primitives to draw  	//);  	Device.EndScene ();  	Device.Present ();  	d3dimage.SetBackBuffer (D3DResourceType.IDirect3DSurface9' Device.GetBackBuffer (0' 0).ComPointer);  	d3dimage.AddDirtyRect (new Int32Rect (0' 0' d3dimage.PixelWidth' d3dimage.PixelHeight));  	d3dimage.Unlock ();  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: if (d3dimage.IsFrontBufferAvailable) {  	result = Device.TestCooperativeLevel ();  	if (result.IsFailure) {  		throw new Direct3D9Exception ();  	}  	d3dimage.Lock ();  	Device.SetRenderState (RenderState.CullMode' Cull.None);  	Device.SetRenderState (RenderState.ZEnable' true);  	Device.Clear (ClearFlags.Target | ClearFlags.ZBuffer' new Color4 (1' 1' 1' 1)' 1.0f' 0);  	Device.BeginScene ();  	var points = animatedDataSource.GetPoints ().ToArray ();  	var pointList = new VertexPositionColor[points.Length];  	//phase += 0.01;  	//if (phase > 2 * Math.PI)  	//    phase -= 2 * Math.PI;  	//for (int i = 0; i < animatedX.Length; i++)  	//{  	//    animatedX[i] = 2 * Math.PI * i / animatedX.Length;  	//    if (i % 2 == 0)  	//        animatedY[i] = Math.Sin(animatedX[i] + phase);  	//    else  	//        animatedY[i] = -Math.Sin(animatedX[i] + phase);  	//}  	for (int i = 0; i < points.Length; i++) {  		pointList [i] = new VertexPositionColor {  			Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  			Color = Color.Orange.ToArgb ()  		};  	}  	var lineListIndices = new short[(points.Length * 2) - 2];  	// Populate the array with references to indices in the vertex buffer  	for (int i = 0; i < points.Length - 1; i++) {  		lineListIndices [i * 2] = (short)(i);  		lineListIndices [(i * 2) + 1] = (short)(i + 1);  	}  	device.SetRenderState (RenderState.AntialiasedLineEnable' true);  	device.VertexFormat = VertexFormat.Diffuse | VertexFormat.PositionRhw;  	device.DrawIndexedUserPrimitives<short' VertexPositionColor> (PrimitiveType.LineList' 0' points.Length' points.Length - 1' lineListIndices' Format.Index16' pointList' 20);  	//pointList'  	//0'  // vertex buffer offset to add to each element of the index buffer  	//8'  // number of vertices in pointList  	//lineListIndices'  // the index buffer  	//0'  // first index element to read  	//7   // number of primitives to draw  	//);  	Device.EndScene ();  	Device.Present ();  	d3dimage.SetBackBuffer (D3DResourceType.IDirect3DSurface9' Device.GetBackBuffer (0' 0).ComPointer);  	d3dimage.AddDirtyRect (new Int32Rect (0' 0' d3dimage.PixelWidth' d3dimage.PixelHeight));  	d3dimage.Unlock ();  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: for (int i = 0; i < points.Length; i++) {  	pointList [i] = new VertexPositionColor {  		Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  		Color = Color.Orange.ToArgb ()  	};  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: for (int i = 0; i < points.Length; i++) {  	pointList [i] = new VertexPositionColor {  		Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  		Color = Color.Orange.ToArgb ()  	};  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: for (int i = 0; i < points.Length; i++) {  	pointList [i] = new VertexPositionColor {  		Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  		Color = Color.Orange.ToArgb ()  	};  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: for (int i = 0; i < points.Length; i++) {  	pointList [i] = new VertexPositionColor {  		Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  		Color = Color.Orange.ToArgb ()  	};  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: pointList [i] = new VertexPositionColor {  	Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  	Color = Color.Orange.ToArgb ()  };  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: pointList [i] = new VertexPositionColor {  	Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  	Color = Color.Orange.ToArgb ()  };  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: pointList [i] = new VertexPositionColor {  	Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  	Color = Color.Orange.ToArgb ()  };  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: pointList [i] = new VertexPositionColor {  	Position = new Vector4 (100 + 500 * (float)points [i].X' 500 + 500 * (float)points [i].Y' 0.5f' 1)'  	Color = Color.Orange.ToArgb ()  };  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: for (int i = 0; i < points.Length - 1; i++) {  	lineListIndices [i * 2] = (short)(i);  	lineListIndices [(i * 2) + 1] = (short)(i + 1);  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: for (int i = 0; i < points.Length - 1; i++) {  	lineListIndices [i * 2] = (short)(i);  	lineListIndices [(i * 2) + 1] = (short)(i + 1);  }  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: lineListIndices [i * 2] = (short)(i);  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: lineListIndices [(i * 2) + 1] = (short)(i + 1);  
Magic Number,LineSample,Window1,C:\repos\dotnetprojects_DynamicDataDisplay\src\D3-Line-in-3D\LineSample\Window1.xaml.cs,CompositionTarget_Rendering,The following statement contains a magic number: device.DrawIndexedUserPrimitives<short' VertexPositionColor> (PrimitiveType.LineList' 0' points.Length' points.Length - 1' lineListIndices' Format.Index16' pointList' 20);  
