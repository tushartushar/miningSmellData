Implementation smell,Namespace,Class,File,Method,Description
Long Method,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The method has 126 lines of code.
Long Method,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The method has 212 lines of code.
Long Method,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The method has 194 lines of code.
Complex Method,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,Cyclomatic complexity of the method is 13
Complex Method,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,Cyclomatic complexity of the method is 9
Complex Method,Spine,FFDTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,Cyclomatic complexity of the method is 9
Complex Method,Spine,AnimationState,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\AnimationState.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,Spine,AnimationState,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\AnimationState.cs,Apply,Cyclomatic complexity of the method is 8
Complex Method,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadSkeletonData,Cyclomatic complexity of the method is 22
Complex Method,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,Cyclomatic complexity of the method is 34
Long Parameter List,Spine,Animation,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' loop' events
Long Parameter List,Spine,Animation,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Mix,The method has 6 parameters. Parameters: skeleton' lastTime' time' loop' events' alpha
Long Parameter List,Spine,Timeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The method has 5 parameters. Parameters: frameIndex' cx1' cy1' cx2' cy2
Long Parameter List,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,TranslateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,ScaleTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,setFrame,The method has 6 parameters. Parameters: frameIndex' time' r' g' b' a
Long Parameter List,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,AttachmentTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,EventTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,DrawOrderTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,FFDTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,SkeletonBounds,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,IntersectsSegment,The method has 5 parameters. Parameters: polygon' x1' y1' x2' y2
Long Parameter List,Spine,RegionAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\RegionAttachment.cs,SetUVs,The method has 5 parameters. Parameters: u' v' u2' v2' rotate
Long Statement,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The length of the statement  "			skeletonMoveAction = new CCSequence(new CCMoveTo(5' new CCPoint(windowSize.Width' 10))' new CCMoveTo(5' new CCPoint(10' 10))); " is 126.
Long Statement,Spine,ScaleTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The length of the statement  "			bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + FRAME_X] - lastFrameX) * percent - bone.scaleX) * alpha; " is 129.
Long Statement,Spine,ScaleTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The length of the statement  "			bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + FRAME_Y] - lastFrameY) * percent - bone.scaleY) * alpha; " is 129.
Long Statement,Spine,SkeletonBounds,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,AabbIntersectsSegment,The length of the statement  "			if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)) " is 121.
Long Statement,Spine,AtlasAttachmentLoader,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\AtlasAttachmentLoader.cs,NewSkinnedMeshAttachment,The length of the statement  "			if (region == null) throw new Exception("Region not found in atlas: " + path + " (skinned mesh attachment: " + name + ")"); " is 123.
Complex Conditional,Spine,Serializer,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,SerializeOther,The conditional expression  "value is float                      || value is int                      || value is uint                      || value is long  						  || value is float                      || value is sbyte                      || value is byte                      || value is short                      || value is ushort                      || value is ulong                      || value is decimal"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,AabbIntersectsSegment,The conditional expression  "(x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,ContainsPoint,The conditional expression  "(vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,IntersectsSegment,The conditional expression  "((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,IntersectsSegment,The conditional expression  "((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))"  is complex.
Magic Number,spine_cocossharp,AppDelegate,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\AppDelegate.cs,ApplicationDidFinishLaunching,The following statement contains a magic number: preferredWidth = 1024;
Magic Number,spine_cocossharp,AppDelegate,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\AppDelegate.cs,ApplicationDidFinishLaunching,The following statement contains a magic number: preferredHeight = 768;
Magic Number,spine_cocossharp,AppDelegate,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\AppDelegate.cs,ApplicationDidFinishLaunching,The following statement contains a magic number: CCSize designSize = new CCSize(480' 320);
Magic Number,spine_cocossharp,AppDelegate,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\AppDelegate.cs,ApplicationDidFinishLaunching,The following statement contains a magic number: CCSize designSize = new CCSize(480' 320);
Magic Number,spine_cocossharp,AppDelegate,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\AppDelegate.cs,ApplicationDidFinishLaunching,The following statement contains a magic number: mainWindow.StatsScale = 2;
Magic Number,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The following statement contains a magic number: CCMenuItemFont.FontSize = 12;
Magic Number,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The following statement contains a magic number: skeletonNode.AddAnimation(0' "walk"' true' 4);
Magic Number,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: menu.Position = new CCPoint(15' windowSize.Height - 85);
Magic Number,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: menu.Position = new CCPoint(15' windowSize.Height - 85);
Magic Number,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: skeletonNode.Position = new CCPoint(windowSize.Center.X' skeletonNode.ContentSize.Height / 2);
Magic Number,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: skeletonMoveAction = new CCSequence(new CCMoveTo(5' new CCPoint(windowSize.Width' 10))' new CCMoveTo(5' new CCPoint(10' 10)));
Magic Number,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: skeletonMoveAction = new CCSequence(new CCMoveTo(5' new CCPoint(windowSize.Width' 10))' new CCMoveTo(5' new CCPoint(10' 10)));
Magic Number,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: skeletonMoveAction = new CCSequence(new CCMoveTo(5' new CCPoint(windowSize.Width' 10))' new CCMoveTo(5' new CCPoint(10' 10)));
Magic Number,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: skeletonMoveAction = new CCSequence(new CCMoveTo(5' new CCPoint(windowSize.Width' 10))' new CCMoveTo(5' new CCPoint(10' 10)));
Magic Number,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: skeletonMoveAction = new CCSequence(new CCMoveTo(5' new CCPoint(windowSize.Width' 10))' new CCMoveTo(5' new CCPoint(10' 10)));
Magic Number,spine_cocossharp,SpineBoyLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following statement contains a magic number: CCMenuItemFont.FontSize = 12;
Magic Number,spine_cocossharp,SpineBoyLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following statement contains a magic number: TrackEntry jumpEntry = skeletonNode.AddAnimation(0' "jump"' false' 3);
Magic Number,spine_cocossharp,SpineBoyLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,AddedToScene,The following statement contains a magic number: menu.Position = new CCPoint(15' windowSize.Height - 70);
Magic Number,spine_cocossharp,SpineBoyLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,AddedToScene,The following statement contains a magic number: menu.Position = new CCPoint(15' windowSize.Height - 70);
Magic Number,spine_cocossharp,SpineBoyLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,AddedToScene,The following statement contains a magic number: skeletonNode.Position = new CCPoint(windowSize.Center.X' 10);
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: for (int i = 0' n = drawOrder.Count; i < n; i++)              {                  Slot slot = drawOrder[i];                  Attachment attachment = slot.Attachment;                  if (attachment is RegionAttachment)                  {                      RegionAttachment regionAttachment = (RegionAttachment)attachment;                      //BlendState blend = slot.Data.AdditiveBlending ? BlendState.Additive : defaultBlendState;                        var item = skeletonGeometry.CreateGeometryInstance(4' 6);                        //item.InstanceAttributes.BlendState = blend;                      //item.InstanceAttributes.AdditionalTransform = AffineWorldTransform;                      item.GeometryPacket.Indicies = quadTriangles;                        var itemVertices = item.GeometryPacket.Vertices;                        AtlasRegion region = (AtlasRegion)regionAttachment.RendererObject;                      item.GeometryPacket.Texture = (CCTexture2D)region.page.rendererObject;                        CCColor4B color;                      float a = skeletonA * slot.A * regionAttachment.A;                      if (PremultipliedAlpha)                      {                          color = new CCColor4B(                                  skeletonR * slot.R * regionAttachment.R * a'                                  skeletonG * slot.G * regionAttachment.G * a'                                  skeletonB * slot.B * regionAttachment.B * a' a);                      }                      else                      {                          color = new CCColor4B(                                  skeletonR * slot.R * regionAttachment.R'                                  skeletonG * slot.G * regionAttachment.G'                                  skeletonB * slot.B * regionAttachment.B' a);                      }                      itemVertices[TL].Colors = color;                      itemVertices[BL].Colors = color;                      itemVertices[BR].Colors = color;                      itemVertices[TR].Colors = color;                        regionAttachment.ComputeWorldVertices(x' y' slot.Bone' vertices);                      itemVertices[TL].Vertices.X = vertices[RegionAttachment.X1];                      itemVertices[TL].Vertices.Y = vertices[RegionAttachment.Y1];                      itemVertices[TL].Vertices.Z = 0;                      itemVertices[BL].Vertices.X = vertices[RegionAttachment.X2];                      itemVertices[BL].Vertices.Y = vertices[RegionAttachment.Y2];                      itemVertices[BL].Vertices.Z = 0;                      itemVertices[BR].Vertices.X = vertices[RegionAttachment.X3];                      itemVertices[BR].Vertices.Y = vertices[RegionAttachment.Y3];                      itemVertices[BR].Vertices.Z = 0;                      itemVertices[TR].Vertices.X = vertices[RegionAttachment.X4];                      itemVertices[TR].Vertices.Y = vertices[RegionAttachment.Y4];                      itemVertices[TR].Vertices.Z = 0;                        float[] uvs = regionAttachment.UVs;                      itemVertices[TL].TexCoords.U = uvs[RegionAttachment.X1];                      itemVertices[TL].TexCoords.V = uvs[RegionAttachment.Y1];                      itemVertices[BL].TexCoords.U = uvs[RegionAttachment.X2];                      itemVertices[BL].TexCoords.V = uvs[RegionAttachment.Y2];                      itemVertices[BR].TexCoords.U = uvs[RegionAttachment.X3];                      itemVertices[BR].TexCoords.V = uvs[RegionAttachment.Y3];                      itemVertices[TR].TexCoords.U = uvs[RegionAttachment.X4];                      itemVertices[TR].TexCoords.V = uvs[RegionAttachment.Y4];                  }                  else if (attachment is MeshAttachment)                  {                      MeshAttachment mesh = (MeshAttachment)attachment;                      int vertexCount = mesh.Vertices.Length;                      if (vertices.Length < vertexCount) vertices = new float[vertexCount];                      mesh.ComputeWorldVertices(x' y' slot' vertices);                        int[] triangles = mesh.Triangles;                      var item = skeletonGeometry.CreateGeometryInstance(vertexCount' triangles.Length);                      //item.InstanceAttributes.AdditionalTransform = AffineWorldTransform;                      item.GeometryPacket.Indicies = triangles;                        AtlasRegion region = (AtlasRegion)mesh.RendererObject;                      item.GeometryPacket.Texture = (CCTexture2D)region.page.rendererObject;                        CCColor4B color;                      float a = skeletonA * slot.A * mesh.A;                      if (PremultipliedAlpha)                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R * a'                                  skeletonG * slot.G * mesh.G * a'                                  skeletonB * slot.B * mesh.B * a' a);                      }                      else                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R'                                  skeletonG * slot.G * mesh.G'                                  skeletonB * slot.B * mesh.B' a);                      }                        float[] uvs = mesh.UVs;                      var itemVertices = item.GeometryPacket.Vertices;                      for (int ii = 0' v = 0; v < vertexCount; ii++' v += 2)                      {                          itemVertices[ii].Colors = color;                          itemVertices[ii].Vertices.X = vertices[v];                          itemVertices[ii].Vertices.Y = vertices[v + 1];                          itemVertices[ii].Vertices.Z = 0;                          itemVertices[ii].TexCoords.U = uvs[v];                          itemVertices[ii].TexCoords.V = uvs[v + 1];                      }                  }                  else if (attachment is SkinnedMeshAttachment)                  {                      SkinnedMeshAttachment mesh = (SkinnedMeshAttachment)attachment;                      int vertexCount = mesh.UVs.Length;                      if (vertices.Length < vertexCount) vertices = new float[vertexCount];                      mesh.ComputeWorldVertices(x' y' slot' vertices);                        int[] triangles = mesh.Triangles;                      var item = skeletonGeometry.CreateGeometryInstance(vertexCount' triangles.Length);                      item.GeometryPacket.Indicies = triangles;                      //item.InstanceAttributes.AdditionalTransform = AffineWorldTransform;                        AtlasRegion region = (AtlasRegion)mesh.RendererObject;                      item.GeometryPacket.Texture = (CCTexture2D)region.page.rendererObject;                        CCColor4B color;                      float a = skeletonA * slot.A * mesh.A;                      if (PremultipliedAlpha)                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R * a'                                  skeletonG * slot.G * mesh.G * a'                                  skeletonB * slot.B * mesh.B * a' a);                      }                      else                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R'                                  skeletonG * slot.G * mesh.G'                                  skeletonB * slot.B * mesh.B' a);                      }                        float[] uvs = mesh.UVs;                      var itemVertices = item.GeometryPacket.Vertices;                      for (int ii = 0' v = 0; v < vertexCount; ii++' v += 2)                      {                          itemVertices[ii].Colors = color;                          itemVertices[ii].Vertices.X = vertices[v];                          itemVertices[ii].Vertices.Y = vertices[v + 1];                          itemVertices[ii].Vertices.Z = 0;                          itemVertices[ii].TexCoords.U = uvs[v];                          itemVertices[ii].TexCoords.V = uvs[v + 1];                      }                  }              }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: for (int i = 0' n = drawOrder.Count; i < n; i++)              {                  Slot slot = drawOrder[i];                  Attachment attachment = slot.Attachment;                  if (attachment is RegionAttachment)                  {                      RegionAttachment regionAttachment = (RegionAttachment)attachment;                      //BlendState blend = slot.Data.AdditiveBlending ? BlendState.Additive : defaultBlendState;                        var item = skeletonGeometry.CreateGeometryInstance(4' 6);                        //item.InstanceAttributes.BlendState = blend;                      //item.InstanceAttributes.AdditionalTransform = AffineWorldTransform;                      item.GeometryPacket.Indicies = quadTriangles;                        var itemVertices = item.GeometryPacket.Vertices;                        AtlasRegion region = (AtlasRegion)regionAttachment.RendererObject;                      item.GeometryPacket.Texture = (CCTexture2D)region.page.rendererObject;                        CCColor4B color;                      float a = skeletonA * slot.A * regionAttachment.A;                      if (PremultipliedAlpha)                      {                          color = new CCColor4B(                                  skeletonR * slot.R * regionAttachment.R * a'                                  skeletonG * slot.G * regionAttachment.G * a'                                  skeletonB * slot.B * regionAttachment.B * a' a);                      }                      else                      {                          color = new CCColor4B(                                  skeletonR * slot.R * regionAttachment.R'                                  skeletonG * slot.G * regionAttachment.G'                                  skeletonB * slot.B * regionAttachment.B' a);                      }                      itemVertices[TL].Colors = color;                      itemVertices[BL].Colors = color;                      itemVertices[BR].Colors = color;                      itemVertices[TR].Colors = color;                        regionAttachment.ComputeWorldVertices(x' y' slot.Bone' vertices);                      itemVertices[TL].Vertices.X = vertices[RegionAttachment.X1];                      itemVertices[TL].Vertices.Y = vertices[RegionAttachment.Y1];                      itemVertices[TL].Vertices.Z = 0;                      itemVertices[BL].Vertices.X = vertices[RegionAttachment.X2];                      itemVertices[BL].Vertices.Y = vertices[RegionAttachment.Y2];                      itemVertices[BL].Vertices.Z = 0;                      itemVertices[BR].Vertices.X = vertices[RegionAttachment.X3];                      itemVertices[BR].Vertices.Y = vertices[RegionAttachment.Y3];                      itemVertices[BR].Vertices.Z = 0;                      itemVertices[TR].Vertices.X = vertices[RegionAttachment.X4];                      itemVertices[TR].Vertices.Y = vertices[RegionAttachment.Y4];                      itemVertices[TR].Vertices.Z = 0;                        float[] uvs = regionAttachment.UVs;                      itemVertices[TL].TexCoords.U = uvs[RegionAttachment.X1];                      itemVertices[TL].TexCoords.V = uvs[RegionAttachment.Y1];                      itemVertices[BL].TexCoords.U = uvs[RegionAttachment.X2];                      itemVertices[BL].TexCoords.V = uvs[RegionAttachment.Y2];                      itemVertices[BR].TexCoords.U = uvs[RegionAttachment.X3];                      itemVertices[BR].TexCoords.V = uvs[RegionAttachment.Y3];                      itemVertices[TR].TexCoords.U = uvs[RegionAttachment.X4];                      itemVertices[TR].TexCoords.V = uvs[RegionAttachment.Y4];                  }                  else if (attachment is MeshAttachment)                  {                      MeshAttachment mesh = (MeshAttachment)attachment;                      int vertexCount = mesh.Vertices.Length;                      if (vertices.Length < vertexCount) vertices = new float[vertexCount];                      mesh.ComputeWorldVertices(x' y' slot' vertices);                        int[] triangles = mesh.Triangles;                      var item = skeletonGeometry.CreateGeometryInstance(vertexCount' triangles.Length);                      //item.InstanceAttributes.AdditionalTransform = AffineWorldTransform;                      item.GeometryPacket.Indicies = triangles;                        AtlasRegion region = (AtlasRegion)mesh.RendererObject;                      item.GeometryPacket.Texture = (CCTexture2D)region.page.rendererObject;                        CCColor4B color;                      float a = skeletonA * slot.A * mesh.A;                      if (PremultipliedAlpha)                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R * a'                                  skeletonG * slot.G * mesh.G * a'                                  skeletonB * slot.B * mesh.B * a' a);                      }                      else                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R'                                  skeletonG * slot.G * mesh.G'                                  skeletonB * slot.B * mesh.B' a);                      }                        float[] uvs = mesh.UVs;                      var itemVertices = item.GeometryPacket.Vertices;                      for (int ii = 0' v = 0; v < vertexCount; ii++' v += 2)                      {                          itemVertices[ii].Colors = color;                          itemVertices[ii].Vertices.X = vertices[v];                          itemVertices[ii].Vertices.Y = vertices[v + 1];                          itemVertices[ii].Vertices.Z = 0;                          itemVertices[ii].TexCoords.U = uvs[v];                          itemVertices[ii].TexCoords.V = uvs[v + 1];                      }                  }                  else if (attachment is SkinnedMeshAttachment)                  {                      SkinnedMeshAttachment mesh = (SkinnedMeshAttachment)attachment;                      int vertexCount = mesh.UVs.Length;                      if (vertices.Length < vertexCount) vertices = new float[vertexCount];                      mesh.ComputeWorldVertices(x' y' slot' vertices);                        int[] triangles = mesh.Triangles;                      var item = skeletonGeometry.CreateGeometryInstance(vertexCount' triangles.Length);                      item.GeometryPacket.Indicies = triangles;                      //item.InstanceAttributes.AdditionalTransform = AffineWorldTransform;                        AtlasRegion region = (AtlasRegion)mesh.RendererObject;                      item.GeometryPacket.Texture = (CCTexture2D)region.page.rendererObject;                        CCColor4B color;                      float a = skeletonA * slot.A * mesh.A;                      if (PremultipliedAlpha)                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R * a'                                  skeletonG * slot.G * mesh.G * a'                                  skeletonB * slot.B * mesh.B * a' a);                      }                      else                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R'                                  skeletonG * slot.G * mesh.G'                                  skeletonB * slot.B * mesh.B' a);                      }                        float[] uvs = mesh.UVs;                      var itemVertices = item.GeometryPacket.Vertices;                      for (int ii = 0' v = 0; v < vertexCount; ii++' v += 2)                      {                          itemVertices[ii].Colors = color;                          itemVertices[ii].Vertices.X = vertices[v];                          itemVertices[ii].Vertices.Y = vertices[v + 1];                          itemVertices[ii].Vertices.Z = 0;                          itemVertices[ii].TexCoords.U = uvs[v];                          itemVertices[ii].TexCoords.V = uvs[v + 1];                      }                  }              }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: for (int i = 0' n = drawOrder.Count; i < n; i++)              {                  Slot slot = drawOrder[i];                  Attachment attachment = slot.Attachment;                  if (attachment is RegionAttachment)                  {                      RegionAttachment regionAttachment = (RegionAttachment)attachment;                      //BlendState blend = slot.Data.AdditiveBlending ? BlendState.Additive : defaultBlendState;                        var item = skeletonGeometry.CreateGeometryInstance(4' 6);                        //item.InstanceAttributes.BlendState = blend;                      //item.InstanceAttributes.AdditionalTransform = AffineWorldTransform;                      item.GeometryPacket.Indicies = quadTriangles;                        var itemVertices = item.GeometryPacket.Vertices;                        AtlasRegion region = (AtlasRegion)regionAttachment.RendererObject;                      item.GeometryPacket.Texture = (CCTexture2D)region.page.rendererObject;                        CCColor4B color;                      float a = skeletonA * slot.A * regionAttachment.A;                      if (PremultipliedAlpha)                      {                          color = new CCColor4B(                                  skeletonR * slot.R * regionAttachment.R * a'                                  skeletonG * slot.G * regionAttachment.G * a'                                  skeletonB * slot.B * regionAttachment.B * a' a);                      }                      else                      {                          color = new CCColor4B(                                  skeletonR * slot.R * regionAttachment.R'                                  skeletonG * slot.G * regionAttachment.G'                                  skeletonB * slot.B * regionAttachment.B' a);                      }                      itemVertices[TL].Colors = color;                      itemVertices[BL].Colors = color;                      itemVertices[BR].Colors = color;                      itemVertices[TR].Colors = color;                        regionAttachment.ComputeWorldVertices(x' y' slot.Bone' vertices);                      itemVertices[TL].Vertices.X = vertices[RegionAttachment.X1];                      itemVertices[TL].Vertices.Y = vertices[RegionAttachment.Y1];                      itemVertices[TL].Vertices.Z = 0;                      itemVertices[BL].Vertices.X = vertices[RegionAttachment.X2];                      itemVertices[BL].Vertices.Y = vertices[RegionAttachment.Y2];                      itemVertices[BL].Vertices.Z = 0;                      itemVertices[BR].Vertices.X = vertices[RegionAttachment.X3];                      itemVertices[BR].Vertices.Y = vertices[RegionAttachment.Y3];                      itemVertices[BR].Vertices.Z = 0;                      itemVertices[TR].Vertices.X = vertices[RegionAttachment.X4];                      itemVertices[TR].Vertices.Y = vertices[RegionAttachment.Y4];                      itemVertices[TR].Vertices.Z = 0;                        float[] uvs = regionAttachment.UVs;                      itemVertices[TL].TexCoords.U = uvs[RegionAttachment.X1];                      itemVertices[TL].TexCoords.V = uvs[RegionAttachment.Y1];                      itemVertices[BL].TexCoords.U = uvs[RegionAttachment.X2];                      itemVertices[BL].TexCoords.V = uvs[RegionAttachment.Y2];                      itemVertices[BR].TexCoords.U = uvs[RegionAttachment.X3];                      itemVertices[BR].TexCoords.V = uvs[RegionAttachment.Y3];                      itemVertices[TR].TexCoords.U = uvs[RegionAttachment.X4];                      itemVertices[TR].TexCoords.V = uvs[RegionAttachment.Y4];                  }                  else if (attachment is MeshAttachment)                  {                      MeshAttachment mesh = (MeshAttachment)attachment;                      int vertexCount = mesh.Vertices.Length;                      if (vertices.Length < vertexCount) vertices = new float[vertexCount];                      mesh.ComputeWorldVertices(x' y' slot' vertices);                        int[] triangles = mesh.Triangles;                      var item = skeletonGeometry.CreateGeometryInstance(vertexCount' triangles.Length);                      //item.InstanceAttributes.AdditionalTransform = AffineWorldTransform;                      item.GeometryPacket.Indicies = triangles;                        AtlasRegion region = (AtlasRegion)mesh.RendererObject;                      item.GeometryPacket.Texture = (CCTexture2D)region.page.rendererObject;                        CCColor4B color;                      float a = skeletonA * slot.A * mesh.A;                      if (PremultipliedAlpha)                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R * a'                                  skeletonG * slot.G * mesh.G * a'                                  skeletonB * slot.B * mesh.B * a' a);                      }                      else                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R'                                  skeletonG * slot.G * mesh.G'                                  skeletonB * slot.B * mesh.B' a);                      }                        float[] uvs = mesh.UVs;                      var itemVertices = item.GeometryPacket.Vertices;                      for (int ii = 0' v = 0; v < vertexCount; ii++' v += 2)                      {                          itemVertices[ii].Colors = color;                          itemVertices[ii].Vertices.X = vertices[v];                          itemVertices[ii].Vertices.Y = vertices[v + 1];                          itemVertices[ii].Vertices.Z = 0;                          itemVertices[ii].TexCoords.U = uvs[v];                          itemVertices[ii].TexCoords.V = uvs[v + 1];                      }                  }                  else if (attachment is SkinnedMeshAttachment)                  {                      SkinnedMeshAttachment mesh = (SkinnedMeshAttachment)attachment;                      int vertexCount = mesh.UVs.Length;                      if (vertices.Length < vertexCount) vertices = new float[vertexCount];                      mesh.ComputeWorldVertices(x' y' slot' vertices);                        int[] triangles = mesh.Triangles;                      var item = skeletonGeometry.CreateGeometryInstance(vertexCount' triangles.Length);                      item.GeometryPacket.Indicies = triangles;                      //item.InstanceAttributes.AdditionalTransform = AffineWorldTransform;                        AtlasRegion region = (AtlasRegion)mesh.RendererObject;                      item.GeometryPacket.Texture = (CCTexture2D)region.page.rendererObject;                        CCColor4B color;                      float a = skeletonA * slot.A * mesh.A;                      if (PremultipliedAlpha)                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R * a'                                  skeletonG * slot.G * mesh.G * a'                                  skeletonB * slot.B * mesh.B * a' a);                      }                      else                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R'                                  skeletonG * slot.G * mesh.G'                                  skeletonB * slot.B * mesh.B' a);                      }                        float[] uvs = mesh.UVs;                      var itemVertices = item.GeometryPacket.Vertices;                      for (int ii = 0' v = 0; v < vertexCount; ii++' v += 2)                      {                          itemVertices[ii].Colors = color;                          itemVertices[ii].Vertices.X = vertices[v];                          itemVertices[ii].Vertices.Y = vertices[v + 1];                          itemVertices[ii].Vertices.Z = 0;                          itemVertices[ii].TexCoords.U = uvs[v];                          itemVertices[ii].TexCoords.V = uvs[v + 1];                      }                  }              }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: for (int i = 0' n = drawOrder.Count; i < n; i++)              {                  Slot slot = drawOrder[i];                  Attachment attachment = slot.Attachment;                  if (attachment is RegionAttachment)                  {                      RegionAttachment regionAttachment = (RegionAttachment)attachment;                      //BlendState blend = slot.Data.AdditiveBlending ? BlendState.Additive : defaultBlendState;                        var item = skeletonGeometry.CreateGeometryInstance(4' 6);                        //item.InstanceAttributes.BlendState = blend;                      //item.InstanceAttributes.AdditionalTransform = AffineWorldTransform;                      item.GeometryPacket.Indicies = quadTriangles;                        var itemVertices = item.GeometryPacket.Vertices;                        AtlasRegion region = (AtlasRegion)regionAttachment.RendererObject;                      item.GeometryPacket.Texture = (CCTexture2D)region.page.rendererObject;                        CCColor4B color;                      float a = skeletonA * slot.A * regionAttachment.A;                      if (PremultipliedAlpha)                      {                          color = new CCColor4B(                                  skeletonR * slot.R * regionAttachment.R * a'                                  skeletonG * slot.G * regionAttachment.G * a'                                  skeletonB * slot.B * regionAttachment.B * a' a);                      }                      else                      {                          color = new CCColor4B(                                  skeletonR * slot.R * regionAttachment.R'                                  skeletonG * slot.G * regionAttachment.G'                                  skeletonB * slot.B * regionAttachment.B' a);                      }                      itemVertices[TL].Colors = color;                      itemVertices[BL].Colors = color;                      itemVertices[BR].Colors = color;                      itemVertices[TR].Colors = color;                        regionAttachment.ComputeWorldVertices(x' y' slot.Bone' vertices);                      itemVertices[TL].Vertices.X = vertices[RegionAttachment.X1];                      itemVertices[TL].Vertices.Y = vertices[RegionAttachment.Y1];                      itemVertices[TL].Vertices.Z = 0;                      itemVertices[BL].Vertices.X = vertices[RegionAttachment.X2];                      itemVertices[BL].Vertices.Y = vertices[RegionAttachment.Y2];                      itemVertices[BL].Vertices.Z = 0;                      itemVertices[BR].Vertices.X = vertices[RegionAttachment.X3];                      itemVertices[BR].Vertices.Y = vertices[RegionAttachment.Y3];                      itemVertices[BR].Vertices.Z = 0;                      itemVertices[TR].Vertices.X = vertices[RegionAttachment.X4];                      itemVertices[TR].Vertices.Y = vertices[RegionAttachment.Y4];                      itemVertices[TR].Vertices.Z = 0;                        float[] uvs = regionAttachment.UVs;                      itemVertices[TL].TexCoords.U = uvs[RegionAttachment.X1];                      itemVertices[TL].TexCoords.V = uvs[RegionAttachment.Y1];                      itemVertices[BL].TexCoords.U = uvs[RegionAttachment.X2];                      itemVertices[BL].TexCoords.V = uvs[RegionAttachment.Y2];                      itemVertices[BR].TexCoords.U = uvs[RegionAttachment.X3];                      itemVertices[BR].TexCoords.V = uvs[RegionAttachment.Y3];                      itemVertices[TR].TexCoords.U = uvs[RegionAttachment.X4];                      itemVertices[TR].TexCoords.V = uvs[RegionAttachment.Y4];                  }                  else if (attachment is MeshAttachment)                  {                      MeshAttachment mesh = (MeshAttachment)attachment;                      int vertexCount = mesh.Vertices.Length;                      if (vertices.Length < vertexCount) vertices = new float[vertexCount];                      mesh.ComputeWorldVertices(x' y' slot' vertices);                        int[] triangles = mesh.Triangles;                      var item = skeletonGeometry.CreateGeometryInstance(vertexCount' triangles.Length);                      //item.InstanceAttributes.AdditionalTransform = AffineWorldTransform;                      item.GeometryPacket.Indicies = triangles;                        AtlasRegion region = (AtlasRegion)mesh.RendererObject;                      item.GeometryPacket.Texture = (CCTexture2D)region.page.rendererObject;                        CCColor4B color;                      float a = skeletonA * slot.A * mesh.A;                      if (PremultipliedAlpha)                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R * a'                                  skeletonG * slot.G * mesh.G * a'                                  skeletonB * slot.B * mesh.B * a' a);                      }                      else                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R'                                  skeletonG * slot.G * mesh.G'                                  skeletonB * slot.B * mesh.B' a);                      }                        float[] uvs = mesh.UVs;                      var itemVertices = item.GeometryPacket.Vertices;                      for (int ii = 0' v = 0; v < vertexCount; ii++' v += 2)                      {                          itemVertices[ii].Colors = color;                          itemVertices[ii].Vertices.X = vertices[v];                          itemVertices[ii].Vertices.Y = vertices[v + 1];                          itemVertices[ii].Vertices.Z = 0;                          itemVertices[ii].TexCoords.U = uvs[v];                          itemVertices[ii].TexCoords.V = uvs[v + 1];                      }                  }                  else if (attachment is SkinnedMeshAttachment)                  {                      SkinnedMeshAttachment mesh = (SkinnedMeshAttachment)attachment;                      int vertexCount = mesh.UVs.Length;                      if (vertices.Length < vertexCount) vertices = new float[vertexCount];                      mesh.ComputeWorldVertices(x' y' slot' vertices);                        int[] triangles = mesh.Triangles;                      var item = skeletonGeometry.CreateGeometryInstance(vertexCount' triangles.Length);                      item.GeometryPacket.Indicies = triangles;                      //item.InstanceAttributes.AdditionalTransform = AffineWorldTransform;                        AtlasRegion region = (AtlasRegion)mesh.RendererObject;                      item.GeometryPacket.Texture = (CCTexture2D)region.page.rendererObject;                        CCColor4B color;                      float a = skeletonA * slot.A * mesh.A;                      if (PremultipliedAlpha)                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R * a'                                  skeletonG * slot.G * mesh.G * a'                                  skeletonB * slot.B * mesh.B * a' a);                      }                      else                      {                          color = new CCColor4B(                                  skeletonR * slot.R * mesh.R'                                  skeletonG * slot.G * mesh.G'                                  skeletonB * slot.B * mesh.B' a);                      }                        float[] uvs = mesh.UVs;                      var itemVertices = item.GeometryPacket.Vertices;                      for (int ii = 0' v = 0; v < vertexCount; ii++' v += 2)                      {                          itemVertices[ii].Colors = color;                          itemVertices[ii].Vertices.X = vertices[v];                          itemVertices[ii].Vertices.Y = vertices[v + 1];                          itemVertices[ii].Vertices.Z = 0;                          itemVertices[ii].TexCoords.U = uvs[v];                          itemVertices[ii].TexCoords.V = uvs[v + 1];                      }                  }              }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: if (DebugBones || DebugSlots)              {                      if (DebugSlots)                  {                        for (int i = 0; i < Skeleton.Slots.Count; ++i)                      {                            var slot = Skeleton.Slots[i];                            if (slot.Attachment == null) continue;                            var verticesCount = 0;                          var worldVertices = new float[1000]; // Max number of vertices per mesh.                          if (slot.Attachment is RegionAttachment)                          {                              var attachment = (RegionAttachment)slot.Attachment;                              attachment.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot.bone' worldVertices);                              verticesCount = 8;                          }                          else if (slot.Attachment is MeshAttachment)                          {                              var mesh = (MeshAttachment)slot.Attachment;                              mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                              verticesCount = mesh.Vertices.Length;                          }                          else if (slot.Attachment is SkinnedMeshAttachment)                          {                              var mesh = (SkinnedMeshAttachment)slot.Attachment;                              mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                              verticesCount = mesh.UVs.Length;                          }                          else                              continue;                            CCPoint[] slotVertices = new CCPoint[verticesCount/2];                            for (int ii = 0' si = 0; ii < verticesCount; ii += 2' si++)                          {                              slotVertices[si].X = worldVertices[ii] * ScaleX;                              slotVertices[si].Y = worldVertices[ii + 1] * ScaleY;                          }                            debugger.DrawPolygon(slotVertices' verticesCount / 2' CCColor4B.Transparent' 1' DebugSlotColor);                        }                      }                    if (DebugBones)                  {                      // Bone lengths.                      for (int i = 0; i < Skeleton.Bones.Count; i++)                      {                          Bone bone = Skeleton.Bones[i];                          x = bone.Data.Length * bone.M00 + bone.WorldX;                          y = bone.Data.Length * bone.M10 + bone.WorldY;                            debugger.DrawLine(new CCPoint(bone.WorldX' bone.WorldY)' new CCPoint(x' y)' 1' DebugJointColor);                      }                        // Bone origins.                      for (int i = 0; i < Skeleton.Bones.Count; i++)                      {                          Bone bone = Skeleton.Bones[i];                          debugger.DrawDot(new CCPoint(bone.WorldX' bone.WorldY)' 3' DebugBoneColor);                        }                  }              }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: if (DebugBones || DebugSlots)              {                      if (DebugSlots)                  {                        for (int i = 0; i < Skeleton.Slots.Count; ++i)                      {                            var slot = Skeleton.Slots[i];                            if (slot.Attachment == null) continue;                            var verticesCount = 0;                          var worldVertices = new float[1000]; // Max number of vertices per mesh.                          if (slot.Attachment is RegionAttachment)                          {                              var attachment = (RegionAttachment)slot.Attachment;                              attachment.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot.bone' worldVertices);                              verticesCount = 8;                          }                          else if (slot.Attachment is MeshAttachment)                          {                              var mesh = (MeshAttachment)slot.Attachment;                              mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                              verticesCount = mesh.Vertices.Length;                          }                          else if (slot.Attachment is SkinnedMeshAttachment)                          {                              var mesh = (SkinnedMeshAttachment)slot.Attachment;                              mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                              verticesCount = mesh.UVs.Length;                          }                          else                              continue;                            CCPoint[] slotVertices = new CCPoint[verticesCount/2];                            for (int ii = 0' si = 0; ii < verticesCount; ii += 2' si++)                          {                              slotVertices[si].X = worldVertices[ii] * ScaleX;                              slotVertices[si].Y = worldVertices[ii + 1] * ScaleY;                          }                            debugger.DrawPolygon(slotVertices' verticesCount / 2' CCColor4B.Transparent' 1' DebugSlotColor);                        }                      }                    if (DebugBones)                  {                      // Bone lengths.                      for (int i = 0; i < Skeleton.Bones.Count; i++)                      {                          Bone bone = Skeleton.Bones[i];                          x = bone.Data.Length * bone.M00 + bone.WorldX;                          y = bone.Data.Length * bone.M10 + bone.WorldY;                            debugger.DrawLine(new CCPoint(bone.WorldX' bone.WorldY)' new CCPoint(x' y)' 1' DebugJointColor);                      }                        // Bone origins.                      for (int i = 0; i < Skeleton.Bones.Count; i++)                      {                          Bone bone = Skeleton.Bones[i];                          debugger.DrawDot(new CCPoint(bone.WorldX' bone.WorldY)' 3' DebugBoneColor);                        }                  }              }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: if (DebugBones || DebugSlots)              {                      if (DebugSlots)                  {                        for (int i = 0; i < Skeleton.Slots.Count; ++i)                      {                            var slot = Skeleton.Slots[i];                            if (slot.Attachment == null) continue;                            var verticesCount = 0;                          var worldVertices = new float[1000]; // Max number of vertices per mesh.                          if (slot.Attachment is RegionAttachment)                          {                              var attachment = (RegionAttachment)slot.Attachment;                              attachment.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot.bone' worldVertices);                              verticesCount = 8;                          }                          else if (slot.Attachment is MeshAttachment)                          {                              var mesh = (MeshAttachment)slot.Attachment;                              mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                              verticesCount = mesh.Vertices.Length;                          }                          else if (slot.Attachment is SkinnedMeshAttachment)                          {                              var mesh = (SkinnedMeshAttachment)slot.Attachment;                              mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                              verticesCount = mesh.UVs.Length;                          }                          else                              continue;                            CCPoint[] slotVertices = new CCPoint[verticesCount/2];                            for (int ii = 0' si = 0; ii < verticesCount; ii += 2' si++)                          {                              slotVertices[si].X = worldVertices[ii] * ScaleX;                              slotVertices[si].Y = worldVertices[ii + 1] * ScaleY;                          }                            debugger.DrawPolygon(slotVertices' verticesCount / 2' CCColor4B.Transparent' 1' DebugSlotColor);                        }                      }                    if (DebugBones)                  {                      // Bone lengths.                      for (int i = 0; i < Skeleton.Bones.Count; i++)                      {                          Bone bone = Skeleton.Bones[i];                          x = bone.Data.Length * bone.M00 + bone.WorldX;                          y = bone.Data.Length * bone.M10 + bone.WorldY;                            debugger.DrawLine(new CCPoint(bone.WorldX' bone.WorldY)' new CCPoint(x' y)' 1' DebugJointColor);                      }                        // Bone origins.                      for (int i = 0; i < Skeleton.Bones.Count; i++)                      {                          Bone bone = Skeleton.Bones[i];                          debugger.DrawDot(new CCPoint(bone.WorldX' bone.WorldY)' 3' DebugBoneColor);                        }                  }              }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: if (DebugBones || DebugSlots)              {                      if (DebugSlots)                  {                        for (int i = 0; i < Skeleton.Slots.Count; ++i)                      {                            var slot = Skeleton.Slots[i];                            if (slot.Attachment == null) continue;                            var verticesCount = 0;                          var worldVertices = new float[1000]; // Max number of vertices per mesh.                          if (slot.Attachment is RegionAttachment)                          {                              var attachment = (RegionAttachment)slot.Attachment;                              attachment.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot.bone' worldVertices);                              verticesCount = 8;                          }                          else if (slot.Attachment is MeshAttachment)                          {                              var mesh = (MeshAttachment)slot.Attachment;                              mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                              verticesCount = mesh.Vertices.Length;                          }                          else if (slot.Attachment is SkinnedMeshAttachment)                          {                              var mesh = (SkinnedMeshAttachment)slot.Attachment;                              mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                              verticesCount = mesh.UVs.Length;                          }                          else                              continue;                            CCPoint[] slotVertices = new CCPoint[verticesCount/2];                            for (int ii = 0' si = 0; ii < verticesCount; ii += 2' si++)                          {                              slotVertices[si].X = worldVertices[ii] * ScaleX;                              slotVertices[si].Y = worldVertices[ii + 1] * ScaleY;                          }                            debugger.DrawPolygon(slotVertices' verticesCount / 2' CCColor4B.Transparent' 1' DebugSlotColor);                        }                      }                    if (DebugBones)                  {                      // Bone lengths.                      for (int i = 0; i < Skeleton.Bones.Count; i++)                      {                          Bone bone = Skeleton.Bones[i];                          x = bone.Data.Length * bone.M00 + bone.WorldX;                          y = bone.Data.Length * bone.M10 + bone.WorldY;                            debugger.DrawLine(new CCPoint(bone.WorldX' bone.WorldY)' new CCPoint(x' y)' 1' DebugJointColor);                      }                        // Bone origins.                      for (int i = 0; i < Skeleton.Bones.Count; i++)                      {                          Bone bone = Skeleton.Bones[i];                          debugger.DrawDot(new CCPoint(bone.WorldX' bone.WorldY)' 3' DebugBoneColor);                        }                  }              }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: if (DebugBones || DebugSlots)              {                      if (DebugSlots)                  {                        for (int i = 0; i < Skeleton.Slots.Count; ++i)                      {                            var slot = Skeleton.Slots[i];                            if (slot.Attachment == null) continue;                            var verticesCount = 0;                          var worldVertices = new float[1000]; // Max number of vertices per mesh.                          if (slot.Attachment is RegionAttachment)                          {                              var attachment = (RegionAttachment)slot.Attachment;                              attachment.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot.bone' worldVertices);                              verticesCount = 8;                          }                          else if (slot.Attachment is MeshAttachment)                          {                              var mesh = (MeshAttachment)slot.Attachment;                              mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                              verticesCount = mesh.Vertices.Length;                          }                          else if (slot.Attachment is SkinnedMeshAttachment)                          {                              var mesh = (SkinnedMeshAttachment)slot.Attachment;                              mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                              verticesCount = mesh.UVs.Length;                          }                          else                              continue;                            CCPoint[] slotVertices = new CCPoint[verticesCount/2];                            for (int ii = 0' si = 0; ii < verticesCount; ii += 2' si++)                          {                              slotVertices[si].X = worldVertices[ii] * ScaleX;                              slotVertices[si].Y = worldVertices[ii + 1] * ScaleY;                          }                            debugger.DrawPolygon(slotVertices' verticesCount / 2' CCColor4B.Transparent' 1' DebugSlotColor);                        }                      }                    if (DebugBones)                  {                      // Bone lengths.                      for (int i = 0; i < Skeleton.Bones.Count; i++)                      {                          Bone bone = Skeleton.Bones[i];                          x = bone.Data.Length * bone.M00 + bone.WorldX;                          y = bone.Data.Length * bone.M10 + bone.WorldY;                            debugger.DrawLine(new CCPoint(bone.WorldX' bone.WorldY)' new CCPoint(x' y)' 1' DebugJointColor);                      }                        // Bone origins.                      for (int i = 0; i < Skeleton.Bones.Count; i++)                      {                          Bone bone = Skeleton.Bones[i];                          debugger.DrawDot(new CCPoint(bone.WorldX' bone.WorldY)' 3' DebugBoneColor);                        }                  }              }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: if (DebugBones || DebugSlots)              {                      if (DebugSlots)                  {                        for (int i = 0; i < Skeleton.Slots.Count; ++i)                      {                            var slot = Skeleton.Slots[i];                            if (slot.Attachment == null) continue;                            var verticesCount = 0;                          var worldVertices = new float[1000]; // Max number of vertices per mesh.                          if (slot.Attachment is RegionAttachment)                          {                              var attachment = (RegionAttachment)slot.Attachment;                              attachment.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot.bone' worldVertices);                              verticesCount = 8;                          }                          else if (slot.Attachment is MeshAttachment)                          {                              var mesh = (MeshAttachment)slot.Attachment;                              mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                              verticesCount = mesh.Vertices.Length;                          }                          else if (slot.Attachment is SkinnedMeshAttachment)                          {                              var mesh = (SkinnedMeshAttachment)slot.Attachment;                              mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                              verticesCount = mesh.UVs.Length;                          }                          else                              continue;                            CCPoint[] slotVertices = new CCPoint[verticesCount/2];                            for (int ii = 0' si = 0; ii < verticesCount; ii += 2' si++)                          {                              slotVertices[si].X = worldVertices[ii] * ScaleX;                              slotVertices[si].Y = worldVertices[ii + 1] * ScaleY;                          }                            debugger.DrawPolygon(slotVertices' verticesCount / 2' CCColor4B.Transparent' 1' DebugSlotColor);                        }                      }                    if (DebugBones)                  {                      // Bone lengths.                      for (int i = 0; i < Skeleton.Bones.Count; i++)                      {                          Bone bone = Skeleton.Bones[i];                          x = bone.Data.Length * bone.M00 + bone.WorldX;                          y = bone.Data.Length * bone.M10 + bone.WorldY;                            debugger.DrawLine(new CCPoint(bone.WorldX' bone.WorldY)' new CCPoint(x' y)' 1' DebugJointColor);                      }                        // Bone origins.                      for (int i = 0; i < Skeleton.Bones.Count; i++)                      {                          Bone bone = Skeleton.Bones[i];                          debugger.DrawDot(new CCPoint(bone.WorldX' bone.WorldY)' 3' DebugBoneColor);                        }                  }              }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,boundingBox,The following statement contains a magic number: for (int i = 0; i < Skeleton.Slots.Count; ++i)              {                    var slot = Skeleton.Slots[i];                    if (slot.Attachment == null) continue;                    var verticesCount = 0;                  var worldVertices = new float[1000]; // Max number of vertices per mesh.                  if (slot.Attachment is RegionAttachment)                  {                      var attachment = (RegionAttachment)slot.Attachment;                      attachment.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot.bone' worldVertices);                      verticesCount = 8;                  }                  else if (slot.Attachment is MeshAttachment)                  {                      var mesh = (MeshAttachment)slot.Attachment;                      mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                      verticesCount = mesh.Vertices.Length;                  }                  else if (slot.Attachment is SkinnedMeshAttachment)                  {                      var mesh = (SkinnedMeshAttachment)slot.Attachment;                      mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                      verticesCount = mesh.UVs.Length;                  }                  else                      continue;                  for (int ii = 0; ii < verticesCount; ii += 2)                  {                      float x = worldVertices[ii] * ScaleX' y = worldVertices[ii + 1] * ScaleY;                      minX = Math.Min(minX' x);                      minY = Math.Min(minY' y);                      maxX = Math.Max(maxX' x);                      maxY = Math.Max(maxY' y);                  }                }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,boundingBox,The following statement contains a magic number: for (int i = 0; i < Skeleton.Slots.Count; ++i)              {                    var slot = Skeleton.Slots[i];                    if (slot.Attachment == null) continue;                    var verticesCount = 0;                  var worldVertices = new float[1000]; // Max number of vertices per mesh.                  if (slot.Attachment is RegionAttachment)                  {                      var attachment = (RegionAttachment)slot.Attachment;                      attachment.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot.bone' worldVertices);                      verticesCount = 8;                  }                  else if (slot.Attachment is MeshAttachment)                  {                      var mesh = (MeshAttachment)slot.Attachment;                      mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                      verticesCount = mesh.Vertices.Length;                  }                  else if (slot.Attachment is SkinnedMeshAttachment)                  {                      var mesh = (SkinnedMeshAttachment)slot.Attachment;                      mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                      verticesCount = mesh.UVs.Length;                  }                  else                      continue;                  for (int ii = 0; ii < verticesCount; ii += 2)                  {                      float x = worldVertices[ii] * ScaleX' y = worldVertices[ii + 1] * ScaleY;                      minX = Math.Min(minX' x);                      minY = Math.Min(minY' y);                      maxX = Math.Max(maxX' x);                      maxY = Math.Max(maxY' y);                  }                }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,boundingBox,The following statement contains a magic number: for (int i = 0; i < Skeleton.Slots.Count; ++i)              {                    var slot = Skeleton.Slots[i];                    if (slot.Attachment == null) continue;                    var verticesCount = 0;                  var worldVertices = new float[1000]; // Max number of vertices per mesh.                  if (slot.Attachment is RegionAttachment)                  {                      var attachment = (RegionAttachment)slot.Attachment;                      attachment.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot.bone' worldVertices);                      verticesCount = 8;                  }                  else if (slot.Attachment is MeshAttachment)                  {                      var mesh = (MeshAttachment)slot.Attachment;                      mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                      verticesCount = mesh.Vertices.Length;                  }                  else if (slot.Attachment is SkinnedMeshAttachment)                  {                      var mesh = (SkinnedMeshAttachment)slot.Attachment;                      mesh.ComputeWorldVertices(Skeleton.X' Skeleton.Y' slot' worldVertices);                      verticesCount = mesh.UVs.Length;                  }                  else                      continue;                  for (int ii = 0; ii < verticesCount; ii += 2)                  {                      float x = worldVertices[ii] * ScaleX' y = worldVertices[ii + 1] * ScaleY;                      minX = Math.Min(minX' x);                      minY = Math.Min(minY' y);                      maxX = Math.Max(maxX' x);                      maxY = Math.Max(maxY' y);                  }                }
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateRegionAttachmentQuad,The following statement contains a magic number: float[] vertices = new float[8];
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateRegionAttachmentQuad,The following statement contains a magic number: float r = slot.Skeleton.R * slot.R * 255;
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateRegionAttachmentQuad,The following statement contains a magic number: float g = slot.Skeleton.G * slot.G * 255;
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateRegionAttachmentQuad,The following statement contains a magic number: float b = slot.Skeleton.B * slot.B * 255;
Magic Number,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateRegionAttachmentQuad,The following statement contains a magic number: float a = normalizedAlpha * 255;
Magic Number,Spine,Animation,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,binarySearch,The following statement contains a magic number: int high = values.Length / step - 2;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,CurveTimeline,The following statement contains a magic number: curves = new float[(frameCount - 1) * 6];
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetLinear,The following statement contains a magic number: curves[frameIndex * 6] = LINEAR;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetStepped,The following statement contains a magic number: curves[frameIndex * 6] = STEPPED;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float pre1 = 3 * subdiv_step;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float pre2 = 3 * subdiv_step2;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float pre4 = 6 * subdiv_step2;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float pre5 = 6 * subdiv_step3;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float tmp1x = -cx1 * 2 + cx2;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float tmp1y = -cy1 * 2 + cy2;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float tmp2x = (cx1 - cx2) * 3 + 1;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float tmp2y = (cy1 - cy2) * 3 + 1;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: int i = frameIndex * 6;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: curves[i + 2] = tmp1x * pre4 + tmp2x * pre5;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: curves[i + 3] = tmp1y * pre4 + tmp2y * pre5;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: curves[i + 4] = tmp2x * pre5;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: curves[i + 5] = tmp2y * pre5;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,GetCurvePercent,The following statement contains a magic number: int curveIndex = frameIndex * 6;
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,GetCurvePercent,The following statement contains a magic number: float ddfx = curves[curveIndex + 2];
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,GetCurvePercent,The following statement contains a magic number: float ddfy = curves[curveIndex + 3];
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,GetCurvePercent,The following statement contains a magic number: float dddfx = curves[curveIndex + 4];
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,GetCurvePercent,The following statement contains a magic number: float dddfy = curves[curveIndex + 5];
Magic Number,Spine,CurveTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,GetCurvePercent,The following statement contains a magic number: int i = BEZIER_SEGMENTS - 2;
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,RotateTimeline,The following statement contains a magic number: frames = new float[frameCount * 2];
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetFrame,The following statement contains a magic number: frameIndex *= 2;
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 2]) { // Time is after last frame.  				amount = bone.data.rotation + frames[frames.Length - 1] - bone.rotation;  				while (amount > 180)  					amount -= 360;  				while (amount < -180)  					amount += 360;  				bone.rotation += amount * alpha;  				return;  			}
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 2]) { // Time is after last frame.  				amount = bone.data.rotation + frames[frames.Length - 1] - bone.rotation;  				while (amount > 180)  					amount -= 360;  				while (amount < -180)  					amount += 360;  				bone.rotation += amount * alpha;  				return;  			}
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 2]) { // Time is after last frame.  				amount = bone.data.rotation + frames[frames.Length - 1] - bone.rotation;  				while (amount > 180)  					amount -= 360;  				while (amount < -180)  					amount += 360;  				bone.rotation += amount * alpha;  				return;  			}
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 2]) { // Time is after last frame.  				amount = bone.data.rotation + frames[frames.Length - 1] - bone.rotation;  				while (amount > 180)  					amount -= 360;  				while (amount < -180)  					amount += 360;  				bone.rotation += amount * alpha;  				return;  			}
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 2]) { // Time is after last frame.  				amount = bone.data.rotation + frames[frames.Length - 1] - bone.rotation;  				while (amount > 180)  					amount -= 360;  				while (amount < -180)  					amount += 360;  				bone.rotation += amount * alpha;  				return;  			}
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: int frameIndex = Animation.binarySearch(frames' time' 2);
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent(frameIndex / 2 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  				amount -= 360;
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  				amount -= 360;
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  				amount += 360;
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  				amount += 360;
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  				amount -= 360;
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: while (amount > 180)  				amount -= 360;
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  				amount += 360;
Magic Number,Spine,RotateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: while (amount < -180)  				amount += 360;
Magic Number,Spine,TranslateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,TranslateTimeline,The following statement contains a magic number: frames = new float[frameCount * 3];
Magic Number,Spine,TranslateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetFrame,The following statement contains a magic number: frameIndex *= 3;
Magic Number,Spine,TranslateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetFrame,The following statement contains a magic number: frames[frameIndex + 2] = y;
Magic Number,Spine,TranslateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 3]) { // Time is after last frame.  				bone.x += (bone.data.x + frames[frames.Length - 2] - bone.x) * alpha;  				bone.y += (bone.data.y + frames[frames.Length - 1] - bone.y) * alpha;  				return;  			}
Magic Number,Spine,TranslateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 3]) { // Time is after last frame.  				bone.x += (bone.data.x + frames[frames.Length - 2] - bone.x) * alpha;  				bone.y += (bone.data.y + frames[frames.Length - 1] - bone.y) * alpha;  				return;  			}
Magic Number,Spine,TranslateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: int frameIndex = Animation.binarySearch(frames' time' 3);
Magic Number,Spine,TranslateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: float lastFrameX = frames[frameIndex - 2];
Magic Number,Spine,TranslateTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent(frameIndex / 3 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));
Magic Number,Spine,ScaleTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 3]) { // Time is after last frame.  				bone.scaleX += (bone.data.scaleX - 1 + frames[frames.Length - 2] - bone.scaleX) * alpha;  				bone.scaleY += (bone.data.scaleY - 1 + frames[frames.Length - 1] - bone.scaleY) * alpha;  				return;  			}
Magic Number,Spine,ScaleTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 3]) { // Time is after last frame.  				bone.scaleX += (bone.data.scaleX - 1 + frames[frames.Length - 2] - bone.scaleX) * alpha;  				bone.scaleY += (bone.data.scaleY - 1 + frames[frames.Length - 1] - bone.scaleY) * alpha;  				return;  			}
Magic Number,Spine,ScaleTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: int frameIndex = Animation.binarySearch(frames' time' 3);
Magic Number,Spine,ScaleTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: float lastFrameX = frames[frameIndex - 2];
Magic Number,Spine,ScaleTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent(frameIndex / 3 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,ColorTimeline,The following statement contains a magic number: frames = new float[frameCount * 5];
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,setFrame,The following statement contains a magic number: frameIndex *= 5;
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,setFrame,The following statement contains a magic number: frames[frameIndex + 2] = g;
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,setFrame,The following statement contains a magic number: frames[frameIndex + 3] = b;
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,setFrame,The following statement contains a magic number: frames[frameIndex + 4] = a;
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 5]) {  				// Time is after last frame.  				int i = frames.Length - 1;  				r = frames[i - 3];  				g = frames[i - 2];  				b = frames[i - 1];  				a = frames[i];  			} else {  				// Interpolate between the last frame and the current frame.  				int frameIndex = Animation.binarySearch(frames' time' 5);  				float lastFrameR = frames[frameIndex - 4];  				float lastFrameG = frames[frameIndex - 3];  				float lastFrameB = frames[frameIndex - 2];  				float lastFrameA = frames[frameIndex - 1];  				float frameTime = frames[frameIndex];  				float percent = 1 - (time - frameTime) / (frames[frameIndex + LAST_FRAME_TIME] - frameTime);  				percent = GetCurvePercent(frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));    				r = lastFrameR + (frames[frameIndex + FRAME_R] - lastFrameR) * percent;  				g = lastFrameG + (frames[frameIndex + FRAME_G] - lastFrameG) * percent;  				b = lastFrameB + (frames[frameIndex + FRAME_B] - lastFrameB) * percent;  				a = lastFrameA + (frames[frameIndex + FRAME_A] - lastFrameA) * percent;  			}
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 5]) {  				// Time is after last frame.  				int i = frames.Length - 1;  				r = frames[i - 3];  				g = frames[i - 2];  				b = frames[i - 1];  				a = frames[i];  			} else {  				// Interpolate between the last frame and the current frame.  				int frameIndex = Animation.binarySearch(frames' time' 5);  				float lastFrameR = frames[frameIndex - 4];  				float lastFrameG = frames[frameIndex - 3];  				float lastFrameB = frames[frameIndex - 2];  				float lastFrameA = frames[frameIndex - 1];  				float frameTime = frames[frameIndex];  				float percent = 1 - (time - frameTime) / (frames[frameIndex + LAST_FRAME_TIME] - frameTime);  				percent = GetCurvePercent(frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));    				r = lastFrameR + (frames[frameIndex + FRAME_R] - lastFrameR) * percent;  				g = lastFrameG + (frames[frameIndex + FRAME_G] - lastFrameG) * percent;  				b = lastFrameB + (frames[frameIndex + FRAME_B] - lastFrameB) * percent;  				a = lastFrameA + (frames[frameIndex + FRAME_A] - lastFrameA) * percent;  			}
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 5]) {  				// Time is after last frame.  				int i = frames.Length - 1;  				r = frames[i - 3];  				g = frames[i - 2];  				b = frames[i - 1];  				a = frames[i];  			} else {  				// Interpolate between the last frame and the current frame.  				int frameIndex = Animation.binarySearch(frames' time' 5);  				float lastFrameR = frames[frameIndex - 4];  				float lastFrameG = frames[frameIndex - 3];  				float lastFrameB = frames[frameIndex - 2];  				float lastFrameA = frames[frameIndex - 1];  				float frameTime = frames[frameIndex];  				float percent = 1 - (time - frameTime) / (frames[frameIndex + LAST_FRAME_TIME] - frameTime);  				percent = GetCurvePercent(frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));    				r = lastFrameR + (frames[frameIndex + FRAME_R] - lastFrameR) * percent;  				g = lastFrameG + (frames[frameIndex + FRAME_G] - lastFrameG) * percent;  				b = lastFrameB + (frames[frameIndex + FRAME_B] - lastFrameB) * percent;  				a = lastFrameA + (frames[frameIndex + FRAME_A] - lastFrameA) * percent;  			}
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 5]) {  				// Time is after last frame.  				int i = frames.Length - 1;  				r = frames[i - 3];  				g = frames[i - 2];  				b = frames[i - 1];  				a = frames[i];  			} else {  				// Interpolate between the last frame and the current frame.  				int frameIndex = Animation.binarySearch(frames' time' 5);  				float lastFrameR = frames[frameIndex - 4];  				float lastFrameG = frames[frameIndex - 3];  				float lastFrameB = frames[frameIndex - 2];  				float lastFrameA = frames[frameIndex - 1];  				float frameTime = frames[frameIndex];  				float percent = 1 - (time - frameTime) / (frames[frameIndex + LAST_FRAME_TIME] - frameTime);  				percent = GetCurvePercent(frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));    				r = lastFrameR + (frames[frameIndex + FRAME_R] - lastFrameR) * percent;  				g = lastFrameG + (frames[frameIndex + FRAME_G] - lastFrameG) * percent;  				b = lastFrameB + (frames[frameIndex + FRAME_B] - lastFrameB) * percent;  				a = lastFrameA + (frames[frameIndex + FRAME_A] - lastFrameA) * percent;  			}
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 5]) {  				// Time is after last frame.  				int i = frames.Length - 1;  				r = frames[i - 3];  				g = frames[i - 2];  				b = frames[i - 1];  				a = frames[i];  			} else {  				// Interpolate between the last frame and the current frame.  				int frameIndex = Animation.binarySearch(frames' time' 5);  				float lastFrameR = frames[frameIndex - 4];  				float lastFrameG = frames[frameIndex - 3];  				float lastFrameB = frames[frameIndex - 2];  				float lastFrameA = frames[frameIndex - 1];  				float frameTime = frames[frameIndex];  				float percent = 1 - (time - frameTime) / (frames[frameIndex + LAST_FRAME_TIME] - frameTime);  				percent = GetCurvePercent(frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));    				r = lastFrameR + (frames[frameIndex + FRAME_R] - lastFrameR) * percent;  				g = lastFrameG + (frames[frameIndex + FRAME_G] - lastFrameG) * percent;  				b = lastFrameB + (frames[frameIndex + FRAME_B] - lastFrameB) * percent;  				a = lastFrameA + (frames[frameIndex + FRAME_A] - lastFrameA) * percent;  			}
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 5]) {  				// Time is after last frame.  				int i = frames.Length - 1;  				r = frames[i - 3];  				g = frames[i - 2];  				b = frames[i - 1];  				a = frames[i];  			} else {  				// Interpolate between the last frame and the current frame.  				int frameIndex = Animation.binarySearch(frames' time' 5);  				float lastFrameR = frames[frameIndex - 4];  				float lastFrameG = frames[frameIndex - 3];  				float lastFrameB = frames[frameIndex - 2];  				float lastFrameA = frames[frameIndex - 1];  				float frameTime = frames[frameIndex];  				float percent = 1 - (time - frameTime) / (frames[frameIndex + LAST_FRAME_TIME] - frameTime);  				percent = GetCurvePercent(frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));    				r = lastFrameR + (frames[frameIndex + FRAME_R] - lastFrameR) * percent;  				g = lastFrameG + (frames[frameIndex + FRAME_G] - lastFrameG) * percent;  				b = lastFrameB + (frames[frameIndex + FRAME_B] - lastFrameB) * percent;  				a = lastFrameA + (frames[frameIndex + FRAME_A] - lastFrameA) * percent;  			}
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 5]) {  				// Time is after last frame.  				int i = frames.Length - 1;  				r = frames[i - 3];  				g = frames[i - 2];  				b = frames[i - 1];  				a = frames[i];  			} else {  				// Interpolate between the last frame and the current frame.  				int frameIndex = Animation.binarySearch(frames' time' 5);  				float lastFrameR = frames[frameIndex - 4];  				float lastFrameG = frames[frameIndex - 3];  				float lastFrameB = frames[frameIndex - 2];  				float lastFrameA = frames[frameIndex - 1];  				float frameTime = frames[frameIndex];  				float percent = 1 - (time - frameTime) / (frames[frameIndex + LAST_FRAME_TIME] - frameTime);  				percent = GetCurvePercent(frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));    				r = lastFrameR + (frames[frameIndex + FRAME_R] - lastFrameR) * percent;  				g = lastFrameG + (frames[frameIndex + FRAME_G] - lastFrameG) * percent;  				b = lastFrameB + (frames[frameIndex + FRAME_B] - lastFrameB) * percent;  				a = lastFrameA + (frames[frameIndex + FRAME_A] - lastFrameA) * percent;  			}
Magic Number,Spine,ColorTimeline,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: if (time >= frames[frames.Length - 5]) {  				// Time is after last frame.  				int i = frames.Length - 1;  				r = frames[i - 3];  				g = frames[i - 2];  				b = frames[i - 1];  				a = frames[i];  			} else {  				// Interpolate between the last frame and the current frame.  				int frameIndex = Animation.binarySearch(frames' time' 5);  				float lastFrameR = frames[frameIndex - 4];  				float lastFrameG = frames[frameIndex - 3];  				float lastFrameB = frames[frameIndex - 2];  				float lastFrameA = frames[frameIndex - 1];  				float frameTime = frames[frameIndex];  				float percent = 1 - (time - frameTime) / (frames[frameIndex + LAST_FRAME_TIME] - frameTime);  				percent = GetCurvePercent(frameIndex / 5 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));    				r = lastFrameR + (frames[frameIndex + FRAME_R] - lastFrameR) * percent;  				g = lastFrameG + (frames[frameIndex + FRAME_G] - lastFrameG) * percent;  				b = lastFrameB + (frames[frameIndex + FRAME_B] - lastFrameB) * percent;  				a = lastFrameA + (frames[frameIndex + FRAME_A] - lastFrameA) * percent;  			}
Magic Number,Spine,Atlas,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Atlas.cs,Load,The following statement contains a magic number: String[] tuple = new String[4];
Magic Number,Spine,Atlas,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Atlas.cs,Load,The following statement contains a magic number: while (true) {  				String line = reader.ReadLine();  				if (line == null) break;  				if (line.Trim().Length == 0)  					page = null;  				else if (page == null) {  					page = new AtlasPage();  					page.name = line;    					if (readTuple(reader' tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.  						page.width = int.Parse(tuple[0]);  						page.height = int.Parse(tuple[1]);  						readTuple(reader' tuple);  					}  					page.format = (Format)Enum.Parse(typeof(Format)' tuple[0]' false);    					readTuple(reader' tuple);  					page.minFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[0]' false);  					page.magFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[1]' false);    					String direction = readValue(reader);  					page.uWrap = TextureWrap.ClampToEdge;  					page.vWrap = TextureWrap.ClampToEdge;  					if (direction == "x")  						page.uWrap = TextureWrap.Repeat;  					else if (direction == "y")  						page.vWrap = TextureWrap.Repeat;  					else if (direction == "xy")  						page.uWrap = page.vWrap = TextureWrap.Repeat;                        //textureLoader.Load(page' Path.Combine(imagesDir' line));                      // PCL does not have access to Path now                      // TODO: create some platform specific routines if CCFileUtils                      textureLoader.Load(page' line);    					pages.Add(page);    				} else {  					AtlasRegion region = new AtlasRegion();  					region.name = line;  					region.page = page;    					region.rotate = Boolean.Parse(readValue(reader));    					readTuple(reader' tuple);  					int x = int.Parse(tuple[0]);  					int y = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					int width = int.Parse(tuple[0]);  					int height = int.Parse(tuple[1]);    					region.u = x / (float)page.width;  					region.v = y / (float)page.height;  					if (region.rotate) {  						region.u2 = (x + height) / (float)page.width;  						region.v2 = (y + width) / (float)page.height;  					} else {  						region.u2 = (x + width) / (float)page.width;  						region.v2 = (y + height) / (float)page.height;  					}  					region.x = x;  					region.y = y;  					region.width = Math.Abs(width);  					region.height = Math.Abs(height);    					if (readTuple(reader' tuple) == 4) { // split is optional  						region.splits = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  								int.Parse(tuple[2])' int.Parse(tuple[3])};    						if (readTuple(reader' tuple) == 4) { // pad is optional' but only present with splits  							region.pads = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  									int.Parse(tuple[2])' int.Parse(tuple[3])};    							readTuple(reader' tuple);  						}  					}    					region.originalWidth = int.Parse(tuple[0]);  					region.originalHeight = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					region.offsetX = int.Parse(tuple[0]);  					region.offsetY = int.Parse(tuple[1]);    					region.index = int.Parse(readValue(reader));    					regions.Add(region);  				}  			}
Magic Number,Spine,Atlas,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Atlas.cs,Load,The following statement contains a magic number: while (true) {  				String line = reader.ReadLine();  				if (line == null) break;  				if (line.Trim().Length == 0)  					page = null;  				else if (page == null) {  					page = new AtlasPage();  					page.name = line;    					if (readTuple(reader' tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.  						page.width = int.Parse(tuple[0]);  						page.height = int.Parse(tuple[1]);  						readTuple(reader' tuple);  					}  					page.format = (Format)Enum.Parse(typeof(Format)' tuple[0]' false);    					readTuple(reader' tuple);  					page.minFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[0]' false);  					page.magFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[1]' false);    					String direction = readValue(reader);  					page.uWrap = TextureWrap.ClampToEdge;  					page.vWrap = TextureWrap.ClampToEdge;  					if (direction == "x")  						page.uWrap = TextureWrap.Repeat;  					else if (direction == "y")  						page.vWrap = TextureWrap.Repeat;  					else if (direction == "xy")  						page.uWrap = page.vWrap = TextureWrap.Repeat;                        //textureLoader.Load(page' Path.Combine(imagesDir' line));                      // PCL does not have access to Path now                      // TODO: create some platform specific routines if CCFileUtils                      textureLoader.Load(page' line);    					pages.Add(page);    				} else {  					AtlasRegion region = new AtlasRegion();  					region.name = line;  					region.page = page;    					region.rotate = Boolean.Parse(readValue(reader));    					readTuple(reader' tuple);  					int x = int.Parse(tuple[0]);  					int y = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					int width = int.Parse(tuple[0]);  					int height = int.Parse(tuple[1]);    					region.u = x / (float)page.width;  					region.v = y / (float)page.height;  					if (region.rotate) {  						region.u2 = (x + height) / (float)page.width;  						region.v2 = (y + width) / (float)page.height;  					} else {  						region.u2 = (x + width) / (float)page.width;  						region.v2 = (y + height) / (float)page.height;  					}  					region.x = x;  					region.y = y;  					region.width = Math.Abs(width);  					region.height = Math.Abs(height);    					if (readTuple(reader' tuple) == 4) { // split is optional  						region.splits = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  								int.Parse(tuple[2])' int.Parse(tuple[3])};    						if (readTuple(reader' tuple) == 4) { // pad is optional' but only present with splits  							region.pads = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  									int.Parse(tuple[2])' int.Parse(tuple[3])};    							readTuple(reader' tuple);  						}  					}    					region.originalWidth = int.Parse(tuple[0]);  					region.originalHeight = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					region.offsetX = int.Parse(tuple[0]);  					region.offsetY = int.Parse(tuple[1]);    					region.index = int.Parse(readValue(reader));    					regions.Add(region);  				}  			}
Magic Number,Spine,Atlas,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Atlas.cs,Load,The following statement contains a magic number: while (true) {  				String line = reader.ReadLine();  				if (line == null) break;  				if (line.Trim().Length == 0)  					page = null;  				else if (page == null) {  					page = new AtlasPage();  					page.name = line;    					if (readTuple(reader' tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.  						page.width = int.Parse(tuple[0]);  						page.height = int.Parse(tuple[1]);  						readTuple(reader' tuple);  					}  					page.format = (Format)Enum.Parse(typeof(Format)' tuple[0]' false);    					readTuple(reader' tuple);  					page.minFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[0]' false);  					page.magFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[1]' false);    					String direction = readValue(reader);  					page.uWrap = TextureWrap.ClampToEdge;  					page.vWrap = TextureWrap.ClampToEdge;  					if (direction == "x")  						page.uWrap = TextureWrap.Repeat;  					else if (direction == "y")  						page.vWrap = TextureWrap.Repeat;  					else if (direction == "xy")  						page.uWrap = page.vWrap = TextureWrap.Repeat;                        //textureLoader.Load(page' Path.Combine(imagesDir' line));                      // PCL does not have access to Path now                      // TODO: create some platform specific routines if CCFileUtils                      textureLoader.Load(page' line);    					pages.Add(page);    				} else {  					AtlasRegion region = new AtlasRegion();  					region.name = line;  					region.page = page;    					region.rotate = Boolean.Parse(readValue(reader));    					readTuple(reader' tuple);  					int x = int.Parse(tuple[0]);  					int y = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					int width = int.Parse(tuple[0]);  					int height = int.Parse(tuple[1]);    					region.u = x / (float)page.width;  					region.v = y / (float)page.height;  					if (region.rotate) {  						region.u2 = (x + height) / (float)page.width;  						region.v2 = (y + width) / (float)page.height;  					} else {  						region.u2 = (x + width) / (float)page.width;  						region.v2 = (y + height) / (float)page.height;  					}  					region.x = x;  					region.y = y;  					region.width = Math.Abs(width);  					region.height = Math.Abs(height);    					if (readTuple(reader' tuple) == 4) { // split is optional  						region.splits = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  								int.Parse(tuple[2])' int.Parse(tuple[3])};    						if (readTuple(reader' tuple) == 4) { // pad is optional' but only present with splits  							region.pads = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  									int.Parse(tuple[2])' int.Parse(tuple[3])};    							readTuple(reader' tuple);  						}  					}    					region.originalWidth = int.Parse(tuple[0]);  					region.originalHeight = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					region.offsetX = int.Parse(tuple[0]);  					region.offsetY = int.Parse(tuple[1]);    					region.index = int.Parse(readValue(reader));    					regions.Add(region);  				}  			}
Magic Number,Spine,Atlas,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Atlas.cs,Load,The following statement contains a magic number: while (true) {  				String line = reader.ReadLine();  				if (line == null) break;  				if (line.Trim().Length == 0)  					page = null;  				else if (page == null) {  					page = new AtlasPage();  					page.name = line;    					if (readTuple(reader' tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.  						page.width = int.Parse(tuple[0]);  						page.height = int.Parse(tuple[1]);  						readTuple(reader' tuple);  					}  					page.format = (Format)Enum.Parse(typeof(Format)' tuple[0]' false);    					readTuple(reader' tuple);  					page.minFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[0]' false);  					page.magFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[1]' false);    					String direction = readValue(reader);  					page.uWrap = TextureWrap.ClampToEdge;  					page.vWrap = TextureWrap.ClampToEdge;  					if (direction == "x")  						page.uWrap = TextureWrap.Repeat;  					else if (direction == "y")  						page.vWrap = TextureWrap.Repeat;  					else if (direction == "xy")  						page.uWrap = page.vWrap = TextureWrap.Repeat;                        //textureLoader.Load(page' Path.Combine(imagesDir' line));                      // PCL does not have access to Path now                      // TODO: create some platform specific routines if CCFileUtils                      textureLoader.Load(page' line);    					pages.Add(page);    				} else {  					AtlasRegion region = new AtlasRegion();  					region.name = line;  					region.page = page;    					region.rotate = Boolean.Parse(readValue(reader));    					readTuple(reader' tuple);  					int x = int.Parse(tuple[0]);  					int y = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					int width = int.Parse(tuple[0]);  					int height = int.Parse(tuple[1]);    					region.u = x / (float)page.width;  					region.v = y / (float)page.height;  					if (region.rotate) {  						region.u2 = (x + height) / (float)page.width;  						region.v2 = (y + width) / (float)page.height;  					} else {  						region.u2 = (x + width) / (float)page.width;  						region.v2 = (y + height) / (float)page.height;  					}  					region.x = x;  					region.y = y;  					region.width = Math.Abs(width);  					region.height = Math.Abs(height);    					if (readTuple(reader' tuple) == 4) { // split is optional  						region.splits = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  								int.Parse(tuple[2])' int.Parse(tuple[3])};    						if (readTuple(reader' tuple) == 4) { // pad is optional' but only present with splits  							region.pads = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  									int.Parse(tuple[2])' int.Parse(tuple[3])};    							readTuple(reader' tuple);  						}  					}    					region.originalWidth = int.Parse(tuple[0]);  					region.originalHeight = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					region.offsetX = int.Parse(tuple[0]);  					region.offsetY = int.Parse(tuple[1]);    					region.index = int.Parse(readValue(reader));    					regions.Add(region);  				}  			}
Magic Number,Spine,Atlas,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Atlas.cs,Load,The following statement contains a magic number: while (true) {  				String line = reader.ReadLine();  				if (line == null) break;  				if (line.Trim().Length == 0)  					page = null;  				else if (page == null) {  					page = new AtlasPage();  					page.name = line;    					if (readTuple(reader' tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.  						page.width = int.Parse(tuple[0]);  						page.height = int.Parse(tuple[1]);  						readTuple(reader' tuple);  					}  					page.format = (Format)Enum.Parse(typeof(Format)' tuple[0]' false);    					readTuple(reader' tuple);  					page.minFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[0]' false);  					page.magFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[1]' false);    					String direction = readValue(reader);  					page.uWrap = TextureWrap.ClampToEdge;  					page.vWrap = TextureWrap.ClampToEdge;  					if (direction == "x")  						page.uWrap = TextureWrap.Repeat;  					else if (direction == "y")  						page.vWrap = TextureWrap.Repeat;  					else if (direction == "xy")  						page.uWrap = page.vWrap = TextureWrap.Repeat;                        //textureLoader.Load(page' Path.Combine(imagesDir' line));                      // PCL does not have access to Path now                      // TODO: create some platform specific routines if CCFileUtils                      textureLoader.Load(page' line);    					pages.Add(page);    				} else {  					AtlasRegion region = new AtlasRegion();  					region.name = line;  					region.page = page;    					region.rotate = Boolean.Parse(readValue(reader));    					readTuple(reader' tuple);  					int x = int.Parse(tuple[0]);  					int y = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					int width = int.Parse(tuple[0]);  					int height = int.Parse(tuple[1]);    					region.u = x / (float)page.width;  					region.v = y / (float)page.height;  					if (region.rotate) {  						region.u2 = (x + height) / (float)page.width;  						region.v2 = (y + width) / (float)page.height;  					} else {  						region.u2 = (x + width) / (float)page.width;  						region.v2 = (y + height) / (float)page.height;  					}  					region.x = x;  					region.y = y;  					region.width = Math.Abs(width);  					region.height = Math.Abs(height);    					if (readTuple(reader' tuple) == 4) { // split is optional  						region.splits = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  								int.Parse(tuple[2])' int.Parse(tuple[3])};    						if (readTuple(reader' tuple) == 4) { // pad is optional' but only present with splits  							region.pads = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  									int.Parse(tuple[2])' int.Parse(tuple[3])};    							readTuple(reader' tuple);  						}  					}    					region.originalWidth = int.Parse(tuple[0]);  					region.originalHeight = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					region.offsetX = int.Parse(tuple[0]);  					region.offsetY = int.Parse(tuple[1]);    					region.index = int.Parse(readValue(reader));    					regions.Add(region);  				}  			}
Magic Number,Spine,Atlas,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Atlas.cs,Load,The following statement contains a magic number: while (true) {  				String line = reader.ReadLine();  				if (line == null) break;  				if (line.Trim().Length == 0)  					page = null;  				else if (page == null) {  					page = new AtlasPage();  					page.name = line;    					if (readTuple(reader' tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.  						page.width = int.Parse(tuple[0]);  						page.height = int.Parse(tuple[1]);  						readTuple(reader' tuple);  					}  					page.format = (Format)Enum.Parse(typeof(Format)' tuple[0]' false);    					readTuple(reader' tuple);  					page.minFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[0]' false);  					page.magFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[1]' false);    					String direction = readValue(reader);  					page.uWrap = TextureWrap.ClampToEdge;  					page.vWrap = TextureWrap.ClampToEdge;  					if (direction == "x")  						page.uWrap = TextureWrap.Repeat;  					else if (direction == "y")  						page.vWrap = TextureWrap.Repeat;  					else if (direction == "xy")  						page.uWrap = page.vWrap = TextureWrap.Repeat;                        //textureLoader.Load(page' Path.Combine(imagesDir' line));                      // PCL does not have access to Path now                      // TODO: create some platform specific routines if CCFileUtils                      textureLoader.Load(page' line);    					pages.Add(page);    				} else {  					AtlasRegion region = new AtlasRegion();  					region.name = line;  					region.page = page;    					region.rotate = Boolean.Parse(readValue(reader));    					readTuple(reader' tuple);  					int x = int.Parse(tuple[0]);  					int y = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					int width = int.Parse(tuple[0]);  					int height = int.Parse(tuple[1]);    					region.u = x / (float)page.width;  					region.v = y / (float)page.height;  					if (region.rotate) {  						region.u2 = (x + height) / (float)page.width;  						region.v2 = (y + width) / (float)page.height;  					} else {  						region.u2 = (x + width) / (float)page.width;  						region.v2 = (y + height) / (float)page.height;  					}  					region.x = x;  					region.y = y;  					region.width = Math.Abs(width);  					region.height = Math.Abs(height);    					if (readTuple(reader' tuple) == 4) { // split is optional  						region.splits = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  								int.Parse(tuple[2])' int.Parse(tuple[3])};    						if (readTuple(reader' tuple) == 4) { // pad is optional' but only present with splits  							region.pads = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  									int.Parse(tuple[2])' int.Parse(tuple[3])};    							readTuple(reader' tuple);  						}  					}    					region.originalWidth = int.Parse(tuple[0]);  					region.originalHeight = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					region.offsetX = int.Parse(tuple[0]);  					region.offsetY = int.Parse(tuple[1]);    					region.index = int.Parse(readValue(reader));    					regions.Add(region);  				}  			}
Magic Number,Spine,Atlas,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Atlas.cs,Load,The following statement contains a magic number: while (true) {  				String line = reader.ReadLine();  				if (line == null) break;  				if (line.Trim().Length == 0)  					page = null;  				else if (page == null) {  					page = new AtlasPage();  					page.name = line;    					if (readTuple(reader' tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.  						page.width = int.Parse(tuple[0]);  						page.height = int.Parse(tuple[1]);  						readTuple(reader' tuple);  					}  					page.format = (Format)Enum.Parse(typeof(Format)' tuple[0]' false);    					readTuple(reader' tuple);  					page.minFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[0]' false);  					page.magFilter = (TextureFilter)Enum.Parse(typeof(TextureFilter)' tuple[1]' false);    					String direction = readValue(reader);  					page.uWrap = TextureWrap.ClampToEdge;  					page.vWrap = TextureWrap.ClampToEdge;  					if (direction == "x")  						page.uWrap = TextureWrap.Repeat;  					else if (direction == "y")  						page.vWrap = TextureWrap.Repeat;  					else if (direction == "xy")  						page.uWrap = page.vWrap = TextureWrap.Repeat;                        //textureLoader.Load(page' Path.Combine(imagesDir' line));                      // PCL does not have access to Path now                      // TODO: create some platform specific routines if CCFileUtils                      textureLoader.Load(page' line);    					pages.Add(page);    				} else {  					AtlasRegion region = new AtlasRegion();  					region.name = line;  					region.page = page;    					region.rotate = Boolean.Parse(readValue(reader));    					readTuple(reader' tuple);  					int x = int.Parse(tuple[0]);  					int y = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					int width = int.Parse(tuple[0]);  					int height = int.Parse(tuple[1]);    					region.u = x / (float)page.width;  					region.v = y / (float)page.height;  					if (region.rotate) {  						region.u2 = (x + height) / (float)page.width;  						region.v2 = (y + width) / (float)page.height;  					} else {  						region.u2 = (x + width) / (float)page.width;  						region.v2 = (y + height) / (float)page.height;  					}  					region.x = x;  					region.y = y;  					region.width = Math.Abs(width);  					region.height = Math.Abs(height);    					if (readTuple(reader' tuple) == 4) { // split is optional  						region.splits = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  								int.Parse(tuple[2])' int.Parse(tuple[3])};    						if (readTuple(reader' tuple) == 4) { // pad is optional' but only present with splits  							region.pads = new int[] {int.Parse(tuple[0])' int.Parse(tuple[1])'  									int.Parse(tuple[2])' int.Parse(tuple[3])};    							readTuple(reader' tuple);  						}  					}    					region.originalWidth = int.Parse(tuple[0]);  					region.originalHeight = int.Parse(tuple[1]);    					readTuple(reader' tuple);  					region.offsetX = int.Parse(tuple[0]);  					region.offsetY = int.Parse(tuple[1]);    					region.index = int.Parse(readValue(reader));    					regions.Add(region);  				}  			}
Magic Number,Spine,Atlas,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Atlas.cs,readTuple,The following statement contains a magic number: for (; i < 3; i++) {  				int comma = line.IndexOf('''' lastMatch);  				if (comma == -1) break;  				tuple[i] = line.Substring(lastMatch' comma - lastMatch).Trim();  				lastMatch = comma + 1;  			}
Magic Number,Spine,Bone,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Bone.cs,UpdateWorldTransform,The following statement contains a magic number: float radians = worldRotation * (float)Math.PI / 180;
Magic Number,Spine,Parser,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,ParseString,The following statement contains a magic number: while (parsing) {                         if (json.Peek() == -1) {                          parsing = false;                          break;                      }                         c = NextChar;                      switch (c) {                      case '"':                          parsing = false;                          break;                      case '\\':                          if (json.Peek() == -1) {                              parsing = false;                              break;                          }                             c = NextChar;                          switch (c) {                          case '"':                          case '\\':                          case '/':                              s.Append(c);                              break;                          case 'b':                              s.Append('\b');                              break;                          case 'f':                              s.Append('\f');                              break;                          case 'n':                              s.Append('\n');                              break;                          case 'r':                              s.Append('\r');                              break;                          case 't':                              s.Append('\t');                              break;                          case 'u':                              var hex = new StringBuilder();                                 for (int i=0; i< 4; i++) {                                  hex.Append(NextChar);                              }                                 s.Append((char) Convert.ToInt32(hex.ToString()' 16));                              break;                          }                          break;                      default:                          s.Append(c);                          break;                      }                  }
Magic Number,Spine,Parser,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,ParseString,The following statement contains a magic number: while (parsing) {                         if (json.Peek() == -1) {                          parsing = false;                          break;                      }                         c = NextChar;                      switch (c) {                      case '"':                          parsing = false;                          break;                      case '\\':                          if (json.Peek() == -1) {                              parsing = false;                              break;                          }                             c = NextChar;                          switch (c) {                          case '"':                          case '\\':                          case '/':                              s.Append(c);                              break;                          case 'b':                              s.Append('\b');                              break;                          case 'f':                              s.Append('\f');                              break;                          case 'n':                              s.Append('\n');                              break;                          case 'r':                              s.Append('\r');                              break;                          case 't':                              s.Append('\t');                              break;                          case 'u':                              var hex = new StringBuilder();                                 for (int i=0; i< 4; i++) {                                  hex.Append(NextChar);                              }                                 s.Append((char) Convert.ToInt32(hex.ToString()' 16));                              break;                          }                          break;                      default:                          s.Append(c);                          break;                      }                  }
Magic Number,Spine,Serializer,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,SerializeString,The following statement contains a magic number: foreach (var c in charArray) {                      switch (c) {                      case '"':                          builder.Append("\\\"");                          break;                      case '\\':                          builder.Append("\\\\");                          break;                      case '\b':                          builder.Append("\\b");                          break;                      case '\f':                          builder.Append("\\f");                          break;                      case '\n':                          builder.Append("\\n");                          break;                      case '\r':                          builder.Append("\\r");                          break;                      case '\t':                          builder.Append("\\t");                          break;                      default:                          int codepoint = Convert.ToInt32(c);                          if ((codepoint >= 32) && (codepoint <= 126)) {                              builder.Append(c);                          }                          else {                              builder.Append("\\u" + Convert.ToString(codepoint' 16).PadLeft(4' '0'));                          }                          break;                      }                  }
Magic Number,Spine,Serializer,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,SerializeString,The following statement contains a magic number: foreach (var c in charArray) {                      switch (c) {                      case '"':                          builder.Append("\\\"");                          break;                      case '\\':                          builder.Append("\\\\");                          break;                      case '\b':                          builder.Append("\\b");                          break;                      case '\f':                          builder.Append("\\f");                          break;                      case '\n':                          builder.Append("\\n");                          break;                      case '\r':                          builder.Append("\\r");                          break;                      case '\t':                          builder.Append("\\t");                          break;                      default:                          int codepoint = Convert.ToInt32(c);                          if ((codepoint >= 32) && (codepoint <= 126)) {                              builder.Append(c);                          }                          else {                              builder.Append("\\u" + Convert.ToString(codepoint' 16).PadLeft(4' '0'));                          }                          break;                      }                  }
Magic Number,Spine,Serializer,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,SerializeString,The following statement contains a magic number: foreach (var c in charArray) {                      switch (c) {                      case '"':                          builder.Append("\\\"");                          break;                      case '\\':                          builder.Append("\\\\");                          break;                      case '\b':                          builder.Append("\\b");                          break;                      case '\f':                          builder.Append("\\f");                          break;                      case '\n':                          builder.Append("\\n");                          break;                      case '\r':                          builder.Append("\\r");                          break;                      case '\t':                          builder.Append("\\t");                          break;                      default:                          int codepoint = Convert.ToInt32(c);                          if ((codepoint >= 32) && (codepoint <= 126)) {                              builder.Append(c);                          }                          else {                              builder.Append("\\u" + Convert.ToString(codepoint' 16).PadLeft(4' '0'));                          }                          break;                      }                  }
Magic Number,Spine,Serializer,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,SerializeString,The following statement contains a magic number: foreach (var c in charArray) {                      switch (c) {                      case '"':                          builder.Append("\\\"");                          break;                      case '\\':                          builder.Append("\\\\");                          break;                      case '\b':                          builder.Append("\\b");                          break;                      case '\f':                          builder.Append("\\f");                          break;                      case '\n':                          builder.Append("\\n");                          break;                      case '\r':                          builder.Append("\\r");                          break;                      case '\t':                          builder.Append("\\t");                          break;                      default:                          int codepoint = Convert.ToInt32(c);                          if ((codepoint >= 32) && (codepoint <= 126)) {                              builder.Append(c);                          }                          else {                              builder.Append("\\u" + Convert.ToString(codepoint' 16).PadLeft(4' '0'));                          }                          break;                      }                  }
Magic Number,Spine,SkeletonBounds,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,aabbCompute,The following statement contains a magic number: for (int i = 0' n = polygons.Count; i < n; i++) {  				Polygon polygon = polygons[i];  				float[] vertices = polygon.Vertices;  				for (int ii = 0' nn = polygon.Count; ii < nn; ii += 2) {  					float x = vertices[ii];  					float y = vertices[ii + 1];  					minX = Math.Min(minX' x);  					minY = Math.Min(minY' y);  					maxX = Math.Max(maxX' x);  					maxY = Math.Max(maxY' y);  				}  			}
Magic Number,Spine,SkeletonBounds,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,ContainsPoint,The following statement contains a magic number: int prevIndex = nn - 2;
Magic Number,Spine,SkeletonBounds,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,ContainsPoint,The following statement contains a magic number: for (int ii = 0; ii < nn; ii += 2) {  				float vertexY = vertices[ii + 1];  				float prevY = vertices[prevIndex + 1];  				if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {  					float vertexX = vertices[ii];  					if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;  				}  				prevIndex = ii;  			}
Magic Number,Spine,SkeletonBounds,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,IntersectsSegment,The following statement contains a magic number: float x3 = vertices[nn - 2]' y3 = vertices[nn - 1];
Magic Number,Spine,SkeletonBounds,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,IntersectsSegment,The following statement contains a magic number: for (int ii = 0; ii < nn; ii += 2) {  				float x4 = vertices[ii]' y4 = vertices[ii + 1];  				float det2 = x3 * y4 - y3 * x4;  				float width34 = x3 - x4' height34 = y3 - y4;  				float det3 = width12 * height34 - height12 * width34;  				float x = (det1 * width34 - width12 * det2) / det3;  				if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {  					float y = (det1 * height34 - height12 * det2) / det3;  					if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;  				}  				x3 = x4;  				y3 = y4;  			}
Magic Number,Spine,Polygon,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,Polygon,The following statement contains a magic number: Vertices = new float[16];
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: if (root.ContainsKey("slots")) {  				foreach (Dictionary<String' Object> slotMap in (List<Object>)root["slots"]) {  					var slotName = (String)slotMap["name"];  					var boneName = (String)slotMap["bone"];  					BoneData boneData = skeletonData.FindBone(boneName);  					if (boneData == null)  						throw new Exception("Slot bone not found: " + boneName);  					var slotData = new SlotData(slotName' boneData);    					if (slotMap.ContainsKey("color")) {  						var color = (String)slotMap["color"];  						slotData.r = ToColor(color' 0);  						slotData.g = ToColor(color' 1);  						slotData.b = ToColor(color' 2);  						slotData.a = ToColor(color' 3);  					}    					if (slotMap.ContainsKey("attachment"))  						slotData.attachmentName = (String)slotMap["attachment"];    					if (slotMap.ContainsKey("additive"))  						slotData.additiveBlending = (bool)slotMap["additive"];    					skeletonData.AddSlot(slotData);  				}  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: if (root.ContainsKey("slots")) {  				foreach (Dictionary<String' Object> slotMap in (List<Object>)root["slots"]) {  					var slotName = (String)slotMap["name"];  					var boneName = (String)slotMap["bone"];  					BoneData boneData = skeletonData.FindBone(boneName);  					if (boneData == null)  						throw new Exception("Slot bone not found: " + boneName);  					var slotData = new SlotData(slotName' boneData);    					if (slotMap.ContainsKey("color")) {  						var color = (String)slotMap["color"];  						slotData.r = ToColor(color' 0);  						slotData.g = ToColor(color' 1);  						slotData.b = ToColor(color' 2);  						slotData.a = ToColor(color' 3);  					}    					if (slotMap.ContainsKey("attachment"))  						slotData.attachmentName = (String)slotMap["attachment"];    					if (slotMap.ContainsKey("additive"))  						slotData.additiveBlending = (bool)slotMap["additive"];    					skeletonData.AddSlot(slotData);  				}  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ToColor,The following statement contains a magic number: if (hexString.Length != 8)  				throw new ArgumentException("Color hexidecimal length must be 8' recieved: " + hexString);
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32(hexString.Substring(colorIndex * 2' 2)' 16) / (float)255;
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32(hexString.Substring(colorIndex * 2' 2)' 16) / (float)255;
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32(hexString.Substring(colorIndex * 2' 2)' 16) / (float)255;
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32(hexString.Substring(colorIndex * 2' 2)' 16) / (float)255;
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey("slots")) {  				foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map["slots"]) {  					String slotName = entry.Key;  					int slotIndex = skeletonData.FindSlotIndex(slotName);  					var timelineMap = (Dictionary<String' Object>)entry.Value;    					foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  						var values = (List<Object>)timelineEntry.Value;  						var timelineName = (String)timelineEntry.Key;  						if (timelineName.Equals("color")) {  							var timeline = new ColorTimeline(values.Count);  							timeline.slotIndex = slotIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								String c = (String)valueMap["color"];  								timeline.setFrame(frameIndex' time' ToColor(c' 0)' ToColor(c' 1)' ToColor(c' 2)' ToColor(c' 3));  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 5 - 5]);    						} else if (timelineName.Equals("attachment")) {  							var timeline = new AttachmentTimeline(values.Count);  							timeline.slotIndex = slotIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								timeline.setFrame(frameIndex++' time' (String)valueMap["name"]);  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount - 1]);    						} else  							throw new Exception("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  					}  				}  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey("slots")) {  				foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map["slots"]) {  					String slotName = entry.Key;  					int slotIndex = skeletonData.FindSlotIndex(slotName);  					var timelineMap = (Dictionary<String' Object>)entry.Value;    					foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  						var values = (List<Object>)timelineEntry.Value;  						var timelineName = (String)timelineEntry.Key;  						if (timelineName.Equals("color")) {  							var timeline = new ColorTimeline(values.Count);  							timeline.slotIndex = slotIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								String c = (String)valueMap["color"];  								timeline.setFrame(frameIndex' time' ToColor(c' 0)' ToColor(c' 1)' ToColor(c' 2)' ToColor(c' 3));  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 5 - 5]);    						} else if (timelineName.Equals("attachment")) {  							var timeline = new AttachmentTimeline(values.Count);  							timeline.slotIndex = slotIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								timeline.setFrame(frameIndex++' time' (String)valueMap["name"]);  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount - 1]);    						} else  							throw new Exception("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  					}  				}  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey("slots")) {  				foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map["slots"]) {  					String slotName = entry.Key;  					int slotIndex = skeletonData.FindSlotIndex(slotName);  					var timelineMap = (Dictionary<String' Object>)entry.Value;    					foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  						var values = (List<Object>)timelineEntry.Value;  						var timelineName = (String)timelineEntry.Key;  						if (timelineName.Equals("color")) {  							var timeline = new ColorTimeline(values.Count);  							timeline.slotIndex = slotIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								String c = (String)valueMap["color"];  								timeline.setFrame(frameIndex' time' ToColor(c' 0)' ToColor(c' 1)' ToColor(c' 2)' ToColor(c' 3));  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 5 - 5]);    						} else if (timelineName.Equals("attachment")) {  							var timeline = new AttachmentTimeline(values.Count);  							timeline.slotIndex = slotIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								timeline.setFrame(frameIndex++' time' (String)valueMap["name"]);  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount - 1]);    						} else  							throw new Exception("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  					}  				}  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey("slots")) {  				foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map["slots"]) {  					String slotName = entry.Key;  					int slotIndex = skeletonData.FindSlotIndex(slotName);  					var timelineMap = (Dictionary<String' Object>)entry.Value;    					foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  						var values = (List<Object>)timelineEntry.Value;  						var timelineName = (String)timelineEntry.Key;  						if (timelineName.Equals("color")) {  							var timeline = new ColorTimeline(values.Count);  							timeline.slotIndex = slotIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								String c = (String)valueMap["color"];  								timeline.setFrame(frameIndex' time' ToColor(c' 0)' ToColor(c' 1)' ToColor(c' 2)' ToColor(c' 3));  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 5 - 5]);    						} else if (timelineName.Equals("attachment")) {  							var timeline = new AttachmentTimeline(values.Count);  							timeline.slotIndex = slotIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								timeline.setFrame(frameIndex++' time' (String)valueMap["name"]);  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount - 1]);    						} else  							throw new Exception("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");  					}  				}  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey("bones")) {  				foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map["bones"]) {  					String boneName = entry.Key;  					int boneIndex = skeletonData.FindBoneIndex(boneName);  					if (boneIndex == -1)  						throw new Exception("Bone not found: " + boneName);    					var timelineMap = (Dictionary<String' Object>)entry.Value;  					foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  						var values = (List<Object>)timelineEntry.Value;  						var timelineName = (String)timelineEntry.Key;  						if (timelineName.Equals("rotate")) {  							var timeline = new RotateTimeline(values.Count);  							timeline.boneIndex = boneIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								timeline.SetFrame(frameIndex' time' (float)valueMap["angle"]);  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 2 - 2]);    						} else if (timelineName.Equals("translate") || timelineName.Equals("scale")) {  							TranslateTimeline timeline;  							float timelineScale = 1;  							if (timelineName.Equals("scale"))  								timeline = new ScaleTimeline(values.Count);  							else {  								timeline = new TranslateTimeline(values.Count);  								timelineScale = scale;  							}  							timeline.boneIndex = boneIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								float x = valueMap.ContainsKey("x") ? (float)valueMap["x"] : 0;  								float y = valueMap.ContainsKey("y") ? (float)valueMap["y"] : 0;  								timeline.SetFrame(frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 3 - 3]);    						} else  							throw new Exception("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  					}  				}  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey("bones")) {  				foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map["bones"]) {  					String boneName = entry.Key;  					int boneIndex = skeletonData.FindBoneIndex(boneName);  					if (boneIndex == -1)  						throw new Exception("Bone not found: " + boneName);    					var timelineMap = (Dictionary<String' Object>)entry.Value;  					foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  						var values = (List<Object>)timelineEntry.Value;  						var timelineName = (String)timelineEntry.Key;  						if (timelineName.Equals("rotate")) {  							var timeline = new RotateTimeline(values.Count);  							timeline.boneIndex = boneIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								timeline.SetFrame(frameIndex' time' (float)valueMap["angle"]);  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 2 - 2]);    						} else if (timelineName.Equals("translate") || timelineName.Equals("scale")) {  							TranslateTimeline timeline;  							float timelineScale = 1;  							if (timelineName.Equals("scale"))  								timeline = new ScaleTimeline(values.Count);  							else {  								timeline = new TranslateTimeline(values.Count);  								timelineScale = scale;  							}  							timeline.boneIndex = boneIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								float x = valueMap.ContainsKey("x") ? (float)valueMap["x"] : 0;  								float y = valueMap.ContainsKey("y") ? (float)valueMap["y"] : 0;  								timeline.SetFrame(frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 3 - 3]);    						} else  							throw new Exception("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  					}  				}  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey("bones")) {  				foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map["bones"]) {  					String boneName = entry.Key;  					int boneIndex = skeletonData.FindBoneIndex(boneName);  					if (boneIndex == -1)  						throw new Exception("Bone not found: " + boneName);    					var timelineMap = (Dictionary<String' Object>)entry.Value;  					foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  						var values = (List<Object>)timelineEntry.Value;  						var timelineName = (String)timelineEntry.Key;  						if (timelineName.Equals("rotate")) {  							var timeline = new RotateTimeline(values.Count);  							timeline.boneIndex = boneIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								timeline.SetFrame(frameIndex' time' (float)valueMap["angle"]);  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 2 - 2]);    						} else if (timelineName.Equals("translate") || timelineName.Equals("scale")) {  							TranslateTimeline timeline;  							float timelineScale = 1;  							if (timelineName.Equals("scale"))  								timeline = new ScaleTimeline(values.Count);  							else {  								timeline = new TranslateTimeline(values.Count);  								timelineScale = scale;  							}  							timeline.boneIndex = boneIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								float x = valueMap.ContainsKey("x") ? (float)valueMap["x"] : 0;  								float y = valueMap.ContainsKey("y") ? (float)valueMap["y"] : 0;  								timeline.SetFrame(frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 3 - 3]);    						} else  							throw new Exception("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  					}  				}  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey("bones")) {  				foreach (KeyValuePair<String' Object> entry in (Dictionary<String' Object>)map["bones"]) {  					String boneName = entry.Key;  					int boneIndex = skeletonData.FindBoneIndex(boneName);  					if (boneIndex == -1)  						throw new Exception("Bone not found: " + boneName);    					var timelineMap = (Dictionary<String' Object>)entry.Value;  					foreach (KeyValuePair<String' Object> timelineEntry in timelineMap) {  						var values = (List<Object>)timelineEntry.Value;  						var timelineName = (String)timelineEntry.Key;  						if (timelineName.Equals("rotate")) {  							var timeline = new RotateTimeline(values.Count);  							timeline.boneIndex = boneIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								timeline.SetFrame(frameIndex' time' (float)valueMap["angle"]);  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 2 - 2]);    						} else if (timelineName.Equals("translate") || timelineName.Equals("scale")) {  							TranslateTimeline timeline;  							float timelineScale = 1;  							if (timelineName.Equals("scale"))  								timeline = new ScaleTimeline(values.Count);  							else {  								timeline = new TranslateTimeline(values.Count);  								timelineScale = scale;  							}  							timeline.boneIndex = boneIndex;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float time = (float)valueMap["time"];  								float x = valueMap.ContainsKey("x") ? (float)valueMap["x"] : 0;  								float y = valueMap.ContainsKey("y") ? (float)valueMap["y"] : 0;  								timeline.SetFrame(frameIndex' time' (float)x * timelineScale' (float)y * timelineScale);  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 3 - 3]);    						} else  							throw new Exception("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");  					}  				}  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey("ffd")) {  				foreach (KeyValuePair<String' Object> ffdMap in (Dictionary<String' Object>)map["ffd"]) {  					Skin skin = skeletonData.FindSkin(ffdMap.Key);  					foreach (KeyValuePair<String' Object> slotMap in (Dictionary<String' Object>)ffdMap.Value) {  						int slotIndex = skeletonData.FindSlotIndex(slotMap.Key);  						foreach (KeyValuePair<String' Object> meshMap in (Dictionary<String' Object>)slotMap.Value) {  							var values = (List<Object>)meshMap.Value;  							var timeline = new FFDTimeline(values.Count);  							Attachment attachment = skin.GetAttachment(slotIndex' meshMap.Key);  							if (attachment == null) throw new Exception("FFD attachment not found: " + meshMap.Key);  							timeline.slotIndex = slotIndex;  							timeline.attachment = attachment;    							int vertexCount;  							if (attachment is MeshAttachment)  								vertexCount = ((MeshAttachment)attachment).vertices.Length;  							else  								vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float[] vertices;  								if (!valueMap.ContainsKey("vertices")) {  									if (attachment is MeshAttachment)  										vertices = ((MeshAttachment)attachment).vertices;  									else  										vertices = new float[vertexCount];  								} else {  									var verticesValue = (List<Object>)valueMap["vertices"];  									vertices = new float[vertexCount];  									int start = GetInt(valueMap' "offset"' 0);  									if (scale == 1) {  										for (int i = 0' n = verticesValue.Count; i < n; i++)  											vertices[i + start] = (float)verticesValue[i];  									} else {  										for (int i = 0' n = verticesValue.Count; i < n; i++)  											vertices[i + start] = (float)verticesValue[i] * scale;  									}  									if (attachment is MeshAttachment) {  										float[] meshVertices = ((MeshAttachment)attachment).vertices;  										for (int i = 0' n = vertices.Length; i < n; i++)  											vertices[i] += meshVertices[i];  									}  								}    								timeline.setFrame(frameIndex' (float)valueMap["time"]' vertices);  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount - 1]);  						}  					}  				}  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: if (map.ContainsKey("ffd")) {  				foreach (KeyValuePair<String' Object> ffdMap in (Dictionary<String' Object>)map["ffd"]) {  					Skin skin = skeletonData.FindSkin(ffdMap.Key);  					foreach (KeyValuePair<String' Object> slotMap in (Dictionary<String' Object>)ffdMap.Value) {  						int slotIndex = skeletonData.FindSlotIndex(slotMap.Key);  						foreach (KeyValuePair<String' Object> meshMap in (Dictionary<String' Object>)slotMap.Value) {  							var values = (List<Object>)meshMap.Value;  							var timeline = new FFDTimeline(values.Count);  							Attachment attachment = skin.GetAttachment(slotIndex' meshMap.Key);  							if (attachment == null) throw new Exception("FFD attachment not found: " + meshMap.Key);  							timeline.slotIndex = slotIndex;  							timeline.attachment = attachment;    							int vertexCount;  							if (attachment is MeshAttachment)  								vertexCount = ((MeshAttachment)attachment).vertices.Length;  							else  								vertexCount = ((SkinnedMeshAttachment)attachment).Weights.Length / 3 * 2;    							int frameIndex = 0;  							foreach (Dictionary<String' Object> valueMap in values) {  								float[] vertices;  								if (!valueMap.ContainsKey("vertices")) {  									if (attachment is MeshAttachment)  										vertices = ((MeshAttachment)attachment).vertices;  									else  										vertices = new float[vertexCount];  								} else {  									var verticesValue = (List<Object>)valueMap["vertices"];  									vertices = new float[vertexCount];  									int start = GetInt(valueMap' "offset"' 0);  									if (scale == 1) {  										for (int i = 0' n = verticesValue.Count; i < n; i++)  											vertices[i + start] = (float)verticesValue[i];  									} else {  										for (int i = 0' n = verticesValue.Count; i < n; i++)  											vertices[i + start] = (float)verticesValue[i] * scale;  									}  									if (attachment is MeshAttachment) {  										float[] meshVertices = ((MeshAttachment)attachment).vertices;  										for (int i = 0' n = vertices.Length; i < n; i++)  											vertices[i] += meshVertices[i];  									}  								}    								timeline.setFrame(frameIndex' (float)valueMap["time"]' vertices);  								ReadCurve(timeline' frameIndex' valueMap);  								frameIndex++;  							}  							timelines.Add(timeline);  							duration = Math.Max(duration' timeline.frames[timeline.FrameCount - 1]);  						}  					}  				}  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: if (curveObject.Equals("stepped"))  				timeline.SetStepped(frameIndex);  			else if (curveObject is List<Object>) {  				var curve = (List<Object>)curveObject;  				timeline.SetCurve(frameIndex' (float)curve[0]' (float)curve[1]' (float)curve[2]' (float)curve[3]);  			}
Magic Number,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadCurve,The following statement contains a magic number: if (curveObject.Equals("stepped"))  				timeline.SetStepped(frameIndex);  			else if (curveObject is List<Object>) {  				var curve = (List<Object>)curveObject;  				timeline.SetCurve(frameIndex' (float)curve[0]' (float)curve[1]' (float)curve[2]' (float)curve[3]);  			}
Magic Number,Spine,BoundingBoxAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\BoundingBoxAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (int i = 0' n = vertices.Length; i < n; i += 2) {  				float px = vertices[i];  				float py = vertices[i + 1];  				worldVertices[i] = px * m00 + py * m01 + x;  				worldVertices[i + 1] = px * m10 + py * m11 + y;  			}
Magic Number,Spine,MeshAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\MeshAttachment.cs,UpdateUVs,The following statement contains a magic number: if (RegionRotate) {  				for (int i = 0' n = uvs.Length; i < n; i += 2) {  					uvs[i] = u + regionUVs[i + 1] * width;  					uvs[i + 1] = v + height - regionUVs[i] * height;  				}  			} else {  				for (int i = 0' n = uvs.Length; i < n; i += 2) {  					uvs[i] = u + regionUVs[i] * width;  					uvs[i + 1] = v + regionUVs[i + 1] * height;  				}  			}
Magic Number,Spine,MeshAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\MeshAttachment.cs,UpdateUVs,The following statement contains a magic number: if (RegionRotate) {  				for (int i = 0' n = uvs.Length; i < n; i += 2) {  					uvs[i] = u + regionUVs[i + 1] * width;  					uvs[i + 1] = v + height - regionUVs[i] * height;  				}  			} else {  				for (int i = 0' n = uvs.Length; i < n; i += 2) {  					uvs[i] = u + regionUVs[i] * width;  					uvs[i + 1] = v + regionUVs[i + 1] * height;  				}  			}
Magic Number,Spine,MeshAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\MeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: for (int i = 0; i < verticesCount; i += 2) {  				float vx = vertices[i];  				float vy = vertices[i + 1];  				worldVertices[i] = vx * m00 + vy * m01 + x;  				worldVertices[i + 1] = vx * m10 + vy * m11 + y;  			}
Magic Number,Spine,RegionAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\RegionAttachment.cs,UpdateOffset,The following statement contains a magic number: float localX = -width / 2 * scaleX + regionOffsetX * regionScaleX;
Magic Number,Spine,RegionAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\RegionAttachment.cs,UpdateOffset,The following statement contains a magic number: float localY = -height / 2 * scaleY + regionOffsetY * regionScaleY;
Magic Number,Spine,RegionAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\RegionAttachment.cs,UpdateOffset,The following statement contains a magic number: float radians = rotation * (float)Math.PI / 180;
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\SkinnedMeshAttachment.cs,UpdateUVs,The following statement contains a magic number: if (RegionRotate) {  				for (int i = 0' n = uvs.Length; i < n; i += 2) {  					uvs[i] = u + regionUVs[i + 1] * width;  					uvs[i + 1] = v + height - regionUVs[i] * height;  				}  			} else {  				for (int i = 0' n = uvs.Length; i < n; i += 2) {  					uvs[i] = u + regionUVs[i] * width;  					uvs[i + 1] = v + regionUVs[i + 1] * height;  				}  			}
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\SkinnedMeshAttachment.cs,UpdateUVs,The following statement contains a magic number: if (RegionRotate) {  				for (int i = 0' n = uvs.Length; i < n; i += 2) {  					uvs[i] = u + regionUVs[i + 1] * width;  					uvs[i + 1] = v + height - regionUVs[i] * height;  				}  			} else {  				for (int i = 0' n = uvs.Length; i < n; i += 2) {  					uvs[i] = u + regionUVs[i] * width;  					uvs[i + 1] = v + regionUVs[i + 1] * height;  				}  			}
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  				for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b]' vy = weights[b + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			} else {  				float[] ffd = slot.AttachmentVertices;  				for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3' f += 2) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b] + ffd[f]' vy = weights[b + 1] + ffd[f + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			}
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  				for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b]' vy = weights[b + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			} else {  				float[] ffd = slot.AttachmentVertices;  				for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3' f += 2) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b] + ffd[f]' vy = weights[b + 1] + ffd[f + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			}
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  				for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b]' vy = weights[b + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			} else {  				float[] ffd = slot.AttachmentVertices;  				for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3' f += 2) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b] + ffd[f]' vy = weights[b + 1] + ffd[f + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			}
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  				for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b]' vy = weights[b + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			} else {  				float[] ffd = slot.AttachmentVertices;  				for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3' f += 2) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b] + ffd[f]' vy = weights[b + 1] + ffd[f + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			}
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  				for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b]' vy = weights[b + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			} else {  				float[] ffd = slot.AttachmentVertices;  				for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3' f += 2) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b] + ffd[f]' vy = weights[b + 1] + ffd[f + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			}
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  				for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b]' vy = weights[b + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			} else {  				float[] ffd = slot.AttachmentVertices;  				for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3' f += 2) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b] + ffd[f]' vy = weights[b + 1] + ffd[f + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			}
Magic Number,Spine,SkinnedMeshAttachment,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: if (slot.attachmentVerticesCount == 0) {  				for (int w = 0' v = 0' b = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b]' vy = weights[b + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			} else {  				float[] ffd = slot.AttachmentVertices;  				for (int w = 0' v = 0' b = 0' f = 0' n = bones.Length; v < n; w += 2) {  					float wx = 0' wy = 0;  					int nn = bones[v++] + v;  					for (; v < nn; v++' b += 3' f += 2) {  						Bone bone = (Bone)skeletonBones[bones[v]];  						float vx = weights[b] + ffd[f]' vy = weights[b + 1] + ffd[f + 1]' weight = weights[b + 2];  						wx += (vx * bone.M00 + vy * bone.M01 + bone.worldX) * weight;  						wy += (vx * bone.M10 + vy * bone.M11 + bone.worldY) * weight;  					}  					worldVertices[w] = wx + x;  					worldVertices[w + 1] = wy + y;  				}  			}
Duplicate Code,CocosSharp.Spine,CCSkeleton,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The method contains a code clone-set at the following line numbers (starting from the method definition): ((93' 125)' (137' 169))
Missing Default,spine_cocossharp,GoblinLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The following switch statement is missing a default case: switch (keyEvent.Keys)                      {                          case CCKeys.B:                              skeletonNode.DebugBones = !skeletonNode.DebugBones;                              break;                          case CCKeys.M:                              skeletonNode.DebugSlots = !skeletonNode.DebugSlots;                              break;                          case CCKeys.S:                              if (skeletonNode.Skeleton.Skin.Name == "goblin")                                  skeletonNode.SetSkin("goblingirl");                              else                                  skeletonNode.SetSkin("goblin");                              break;                          case CCKeys.Up:                              skeletonNode.TimeScale += 0.1f;                              break;                          case CCKeys.Down:                              skeletonNode.TimeScale -= 0.1f;                              break;                          case CCKeys.A:                              if (isMoving)                              {  								StopAction(skeletonActionState);                                  isMoving = false;                              }                              else                              {                                  skeletonActionState = skeletonNode.RepeatForever(skeletonMoveAction);                                  isMoving = true;                              }                              break;                          case CCKeys.P:  							Director.ReplaceScene(SpineBoyLayer.Scene(Window));                              break;                      }
Missing Default,spine_cocossharp,SpineBoyLayer,C:\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following switch statement is missing a default case: switch (keyEvent.Keys)                      {                          case CCKeys.B:                              skeletonNode.DebugBones = !skeletonNode.DebugBones;                              break;                          case CCKeys.M:                              skeletonNode.DebugSlots = !skeletonNode.DebugSlots;                              break;                          case CCKeys.Up:                              skeletonNode.TimeScale += 0.1f;                              break;                          case CCKeys.Down:                              skeletonNode.TimeScale -= 0.1f;                              break;                          case CCKeys.G:                              Director.ReplaceScene(GoblinLayer.Scene(Window));                              break;  						case CCKeys.J:  							// I truthfully do not know if this is how it is done or not  							skeletonNode.SetAnimation(0' "jump"' false);  							skeletonNode.AddAnimation(0' "run"' true);  							break;                      }
Missing Default,Spine,Parser,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,ParseString,The following switch statement is missing a default case: switch (c) {                          case '"':                          case '\\':                          case '/':                              s.Append(c);                              break;                          case 'b':                              s.Append('\b');                              break;                          case 'f':                              s.Append('\f');                              break;                          case 'n':                              s.Append('\n');                              break;                          case 'r':                              s.Append('\r');                              break;                          case 't':                              s.Append('\t');                              break;                          case 'u':                              var hex = new StringBuilder();                                 for (int i=0; i< 4; i++) {                                  hex.Append(NextChar);                              }                                 s.Append((char) Convert.ToInt32(hex.ToString()' 16));                              break;                          }
Missing Default,Spine,SkeletonJson,C:\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following switch statement is missing a default case: switch (type) {  			case AttachmentType.region:  				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path);  				if (region == null) return null;  				region.Path = path;  				region.x = GetFloat(map' "x"' 0) * Scale;  				region.y = GetFloat(map' "y"' 0) * Scale;  				region.scaleX = GetFloat(map' "scaleX"' 1);  				region.scaleY = GetFloat(map' "scaleY"' 1);  				region.rotation = GetFloat(map' "rotation"' 0);  				region.width = GetFloat(map' "width"' 32) * Scale;  				region.height = GetFloat(map' "height"' 32) * Scale;  				region.UpdateOffset();    				if (map.ContainsKey("color")) {  					var color = (String)map["color"];  					region.r = ToColor(color' 0);  					region.g = ToColor(color' 1);  					region.b = ToColor(color' 2);  					region.a = ToColor(color' 3);  				}    				return region;  			case AttachmentType.mesh: {  					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;   					mesh.vertices = GetFloatArray(map' "vertices"' Scale);  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = GetFloatArray(map' "uvs"' 1);  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.skinnedmesh: {  					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path);  					if (mesh == null) return null;    					mesh.Path = path;  					float[] uvs = GetFloatArray(map' "uvs"' 1);  					float[] vertices = GetFloatArray(map' "vertices"' 1);  					var weights = new List<float>(uvs.Length * 3 * 3);  					var bones = new List<int>(uvs.Length * 3);  					float scale = Scale;  					for (int i = 0' n = vertices.Length; i < n; ) {  						int boneCount = (int)vertices[i++];  						bones.Add(boneCount);  						for (int nn = i + boneCount * 4; i < nn; ) {  							bones.Add((int)vertices[i]);  							weights.Add(vertices[i + 1] * scale);  							weights.Add(vertices[i + 2] * scale);  							weights.Add(vertices[i + 3]);  							i += 4;  						}  					}  					mesh.bones = bones.ToArray();  					mesh.weights = weights.ToArray();  					mesh.triangles = GetIntArray(map' "triangles");  					mesh.regionUVs = uvs;  					mesh.UpdateUVs();    					if (map.ContainsKey("color")) {  						var color = (String)map["color"];  						mesh.r = ToColor(color' 0);  						mesh.g = ToColor(color' 1);  						mesh.b = ToColor(color' 2);  						mesh.a = ToColor(color' 3);  					}    					mesh.HullLength = GetInt(map' "hull"' 0) * 2;  					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges");  					mesh.Width = GetInt(map' "width"' 0) * Scale;  					mesh.Height = GetInt(map' "height"' 0) * Scale;    					return mesh;  				}  			case AttachmentType.boundingbox:  				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name);  				if (box == null) return null;  				box.vertices = GetFloatArray(map' "vertices"' Scale);  				return box;  			}
