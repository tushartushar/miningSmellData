Implementation smell,Namespace,Class,File,Method,Description
Complex Method,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,Cyclomatic complexity of the method is 9
Complex Method,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,Cyclomatic complexity of the method is 8
Complex Method,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitivePath,Cyclomatic complexity of the method is 8
Complex Method,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildArcGeometryBuffer,Cyclomatic complexity of the method is 8
Complex Method,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillArc,Cyclomatic complexity of the method is 8
Complex Method,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,Cyclomatic complexity of the method is 10
Complex Method,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileOpenPath,Cyclomatic complexity of the method is 9
Complex Method,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileClosedPath,Cyclomatic complexity of the method is 8
Complex Method,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,AddStartOrEndPoint,Cyclomatic complexity of the method is 10
Complex Method,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,AddJoint,Cyclomatic complexity of the method is 9
Complex Method,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,Cyclomatic complexity of the method is 9
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawRectangle,The method has 5 parameters. Parameters: pen' location' width' height' angle
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveRectangle,The method has 5 parameters. Parameters: pen' location' width' height' angle
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitivePath,The method has 5 parameters. Parameters: pen' points' offset' count' pathType
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawEllipse,The method has 5 parameters. Parameters: pen' center' xRadius' yRadius' angle
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawEllipse,The method has 6 parameters. Parameters: pen' center' xRadius' yRadius' angle' subdivisions
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveEllipse,The method has 5 parameters. Parameters: pen' center' xRadius' yRadius' angle
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveEllipse,The method has 6 parameters. Parameters: pen' center' xRadius' yRadius' angle' subdivisions
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildEllipseGeometryBuffer,The method has 5 parameters. Parameters: center' xRadius' yRadius' angle' subdivisions
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawArc,The method has 5 parameters. Parameters: pen' center' radius' startAngle' arcAngle
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawArc,The method has 6 parameters. Parameters: pen' center' radius' startAngle' arcAngle' subdivisions
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawArc,The method has 5 parameters. Parameters: pen' p0' p1' height' subdivisions
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveArc,The method has 5 parameters. Parameters: pen' center' radius' startAngle' arcAngle
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveArc,The method has 6 parameters. Parameters: pen' center' radius' startAngle' arcAngle' subdivisions
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveArc,The method has 5 parameters. Parameters: pen' p0' p1' height' subdivisions
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveClosedArc,The method has 6 parameters. Parameters: pen' center' radius' startAngle' arcAngle' arcType
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveClosedArc,The method has 7 parameters. Parameters: pen' center' radius' startAngle' arcAngle' arcType' subdivisions
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawClosedArc,The method has 6 parameters. Parameters: pen' center' radius' startAngle' arcAngle' arcType
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawClosedArc,The method has 7 parameters. Parameters: pen' center' radius' startAngle' arcAngle' arcType' subdivisions
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBezier,The method has 5 parameters. Parameters: pen' p0' p1' p2' p3
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The method has 5 parameters. Parameters: pen' points' offset' count' bezierType
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The method has 6 parameters. Parameters: pen' points' offset' count' bezierType' pathType
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBezier,The method has 5 parameters. Parameters: pen' p0' p1' p2' p3
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The method has 5 parameters. Parameters: pen' points' offset' count' bezierType
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The method has 6 parameters. Parameters: pen' points' offset' count' bezierType' pathType
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildArcGeometryBuffer,The method has 5 parameters. Parameters: center' radius' subdivisions' startAngle' arcAngle
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillEllipse,The method has 5 parameters. Parameters: brush' center' xRadius' yRadius' angle
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillEllipse,The method has 6 parameters. Parameters: brush' center' xRadius' yRadius' angle' subdivisions
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillArc,The method has 6 parameters. Parameters: brush' center' radius' startAngle' arcAngle' arcType
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillArc,The method has 7 parameters. Parameters: brush' center' radius' startAngle' arcAngle' arcType' subdivisions
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillRectangle,The method has 5 parameters. Parameters: brush' location' width' height' angle
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddClosedPath,The method has 5 parameters. Parameters: points' offset' count' pen' ws
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddPath,The method has 5 parameters. Parameters: points' offset' count' pen' ws
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,RenderBatch,The method has 6 parameters. Parameters: primitiveType' indexOffset' indexCount' vertexOffset' vertexCount' texture
Long Parameter List,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,RenderBatch,The method has 8 parameters. Parameters: primitiveType' indexOffset' indexCount' _indexBuffer' vertexOffset' vertexCount' _vertexBuffer' texture
Long Parameter List,LilyPath,DrawCacheUnit,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawCache.cs,DrawCacheUnit,The method has 7 parameters. Parameters: vertexBuffer' vertexOffset' vertexCount' indexBuffer' indexOffset' indexCount' texture
Long Parameter List,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,GraphicsPath,The method has 5 parameters. Parameters: pen' points' pathType' offset' count
Long Parameter List,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,GraphicsPath,The method has 6 parameters. Parameters: pen' points' lengths' pathType' offset' count
Long Parameter List,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,GraphicsPath,The method has 5 parameters. Parameters: pen' outlinePen' points' pathType' strokeType
Long Parameter List,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,GraphicsPath,The method has 6 parameters. Parameters: pen' outlinePen' points' pathType' offset' count
Long Parameter List,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,GraphicsPath,The method has 7 parameters. Parameters: pen' outlinePen' points' pathType' offset' count' strokeType
Long Parameter List,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileOpenPath,The method has 5 parameters. Parameters: points' accumLengths' offset' count' outlinePen
Long Parameter List,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileClosedPath,The method has 5 parameters. Parameters: points' accumLengths' offset' count' outlinePen
Long Parameter List,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,AddStartPoint,The method has 5 parameters. Parameters: pointIndex' a' b' ws' positionBuffer
Long Parameter List,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,AddEndPoint,The method has 5 parameters. Parameters: pointIndex' a' b' ws' positionBuffer
Long Parameter List,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,AddJoint,The method has 5 parameters. Parameters: pointIndex' joinSample' ws' insetBuffer' outsetBuffer
Long Parameter List,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,AddSegment,The method has 6 parameters. Parameters: vIndexStart' vStartCount' vStartCCW' vIndexEnd' vEndCount' vEndCCW
Long Parameter List,LilyPath,LineCapInfo,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\LineCapInfo.cs,LineCapInfo,The method has 5 parameters. Parameters: width' xyBuffer' uvBuffer' indexBuffer' outlineBuffer
Long Parameter List,LilyPath,LineCapInfo,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\LineCapInfo.cs,Calculate,The method has 5 parameters. Parameters: p' edgeAB' ws' alignment' start
Long Parameter List,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddArc,The method has 5 parameters. Parameters: center' radius' startAngle' arcAngle' subdivisions
Long Parameter List,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddBezier,The method has 5 parameters. Parameters: p0' p1' p2' p3' subdivisions
Long Parameter List,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The method has 5 parameters. Parameters: center' radius' subdivisions' startAngle' arcAngle
Long Parameter List,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildCubicBezierGeometryBuffer,The method has 5 parameters. Parameters: v0' v1' v2' v3' subdivisions
Long Parameter List,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The method has 5 parameters. Parameters: pen' left' top' width' height
Long Parameter List,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddVertex,The method has 5 parameters. Parameters: buffer' index' x' y' c
Long Parameter List,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddQuad,The method has 6 parameters. Parameters: buffer' index' tl' tr' bl' br
Long Parameter List,LilyPath.Utility,JoinSample,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Utility\PenWorkspace.cs,JoinSample,The method has 6 parameters. Parameters: pointA' pointB' pointC' lengthA' lengthB' lengthC
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The length of the statement  "            _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(points[offset + 0].X' points[offset + 0].Y' 0)' pen.Color' new Vector2(points[offset + 0].X'points[offset + 0].Y) ); " is 197.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The length of the statement  "            _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(points[offset + 1].X' points[offset + 1].Y' 0)' pen.Color' new Vector2(points[offset + 1].X' points[offset + 1].Y)); " is 197.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The length of the statement  "            _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(points[offset + 2].X' points[offset + 2].Y' 0)' pen.Color' new Vector2(points[offset + 2].X' points[offset + 2].Y)); " is 197.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The length of the statement  "            _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(points[offset + 3].X' points[offset + 3].Y' 0)' pen.Color' new Vector2(points[offset + 3].X' points[offset + 3].Y)); " is 197.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveLine,The length of the statement  "            _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(p0.X' p0.Y' 0)' pen.Color' new Vector2(p0.X' p0.Y)); " is 133.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveLine,The length of the statement  "            _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(p1.X' p1.Y' 0)' pen.Color' new Vector2(p1.X' p1.Y)); " is 133.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitivePath,The length of the statement  "                _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(pos.X' pos.Y' 0)' pen.Color' Vector2.Zero); " is 124.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawEllipse,The length of the statement  "            DrawEllipse(pen' new CCVector2(bound.Center.X' bound.Center.Y)' bound.Size.Width / 2f' bound.Size.Height / 2f' angle' subdivisions); " is 132.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildCircleGeometryBuffer,The length of the statement  "                _geometryBuffer[subdivisions] = new CCVector2(center.X + radius * unitCircle[0].X' center.Y + radius * unitCircle[0].Y); " is 120.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveEllipse,The length of the statement  "            DrawPrimitiveEllipse(pen' new CCVector2(bound.Center.X' bound.Center.Y)' bound.Size.Width / 2f' bound.Size.Height / 2f' 0); " is 123.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveEllipse,The length of the statement  "            DrawPrimitiveEllipse(pen' new CCVector2(bound.Center.X' bound.Center.Y)' bound.Size.Width / 2f' bound.Size.Height / 2f' angle); " is 127.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveEllipse,The length of the statement  "            DrawPrimitiveEllipse(pen' new CCVector2(bound.Center.X' bound.Center.Y)' bound.Size.Width / 2f' bound.Size.Height / 2f' angle' subdivisions); " is 141.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The length of the statement  "                        _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]); " is 123.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The length of the statement  "                        _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]); " is 123.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildArcGeometryBuffer,The length of the statement  "                    _geometryBuffer[bufIndex++] = new CCVector2(center.X + radius * (float)Math.Cos(-startAngle)' center.Y - radius * (float)Math.Sin(-startAngle)); " is 144.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildArcGeometryBuffer,The length of the statement  "                    _geometryBuffer[bufIndex++] = new CCVector2(center.X + radius * (float)Math.Cos(-stopAngle)' center.Y - radius * (float)Math.Sin(-stopAngle)); " is 142.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildArcGeometryBuffer,The length of the statement  "                    _geometryBuffer[bufIndex++] = new CCVector2(center.X + radius * (float)Math.Cos(-startAngle)' center.Y - radius * (float)Math.Sin(-startAngle)); " is 144.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildArcGeometryBuffer,The length of the statement  "                    _geometryBuffer[bufIndex++] = new CCVector2(center.X + radius * (float)Math.Cos(-stopAngle)' center.Y - radius * (float)Math.Sin(-stopAngle)); " is 142.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillEllipse,The length of the statement  "            FillEllipse(brush' new CCVector2(bound.Center.X' bound.Center.Y)' bound.Size.Width / 2f' bound.Size.Height / 2f' angle); " is 120.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillEllipse,The length of the statement  "            FillEllipse(brush' new CCVector2(bound.Center.X' bound.Center.Y)' bound.Size.Width / 2f' bound.Size.Height / 2f' angle' subdivisions); " is 134.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,RenderBatch,The length of the statement  "                    //_device.DrawUserIndexedPrimitives(primitiveType' _vertexBuffer' vertexOffset' vertexCount' _indexBuffer' indexOffset' indexCount / 2); " is 136.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,RenderBatch,The length of the statement  "                    //_device.DrawUserIndexedPrimitives(primitiveType' _vertexBuffer' vertexOffset' vertexCount' _indexBuffer' indexOffset' indexCount / 3); " is 136.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,RenderBatch,The length of the statement  "                    //_device.DrawUserIndexedPrimitives(primitiveType' _vertexBuffer' vertexOffset' vertexCount' _indexBuffer' indexOffset' indexCount / 2); " is 136.
Long Statement,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,RenderBatch,The length of the statement  "                    //_device.DrawUserIndexedPrimitives(primitiveType' _vertexBuffer' vertexOffset' vertexCount' _indexBuffer' indexOffset' indexCount / 3); " is 136.
Long Statement,LilyPath,DrawCacheUnit,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawCache.cs,Render,The length of the statement  "            //device.DrawUserIndexedPrimitives(PrimitiveType.TriangleList' _vertexBuffer' 0' _vertexBuffer.Length' _indexBuffer' 0' _indexBuffer.Length / 3); " is 145.
Long Statement,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileOpenPath,The length of the statement  "            JoinSample joinSample = new JoinSample(CCVector2.Zero' points[offset + 0]' points[offset + 1]' 0' lengths[offset + 0]' lengths[offset + 1]); " is 140.
Long Statement,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileOpenPath,The length of the statement  "                    AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[i]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[i + 1]); " is 146.
Long Statement,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileOpenPath,The length of the statement  "                vNextCount = AddJoint(i + 1' points[i0]' points[i1]' points[i2]' lengths[i0]' lengths[i1]' lengths[i2]' ws' insetBuffer' outsetBuffer); " is 135.
Long Statement,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileOpenPath,The length of the statement  "                    AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[i]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[i + 1]); " is 146.
Long Statement,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileOpenPath,The length of the statement  "                AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[count - 2]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[count - 1]); " is 158.
Long Statement,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileClosedPath,The length of the statement  "            JoinSample joinSample = new JoinSample(points[offset + count - 1]' points[offset + 0]' points[offset + 1]' 0' lengths[offset + 0]' lengths[offset + 1]); " is 152.
Long Statement,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileClosedPath,The length of the statement  "                    AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[i]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[i + 1]); " is 146.
Long Statement,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileClosedPath,The length of the statement  "                AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[count - 2]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[count - 1]); " is 158.
Long Statement,LilyPath,LineCapInfo,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\LineCapInfo.cs,Calculate,The length of the statement  "                ws.XYBuffer[i] = new CCVector2(_xyBuffer[i].X * tC - _xyBuffer[i].Y * tS + tX' _xyBuffer[i].X * tS + _xyBuffer[i].Y * tC + tY); " is 127.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddPoint,The length of the statement  "                    _lengthBuffer[_geometryIndex] = (_geometryIndex == 0) ? 0 : _lengthBuffer[_geometryIndex - 1] + CCVector2.Distance(_geometryBuffer[_geometryIndex - 1]' point); " is 159.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddPath,The length of the statement  "                    _lengthBuffer[_geometryIndex] = (_geometryIndex == 0) ? 0 : _lengthBuffer[_geometryIndex - 1] + CCVector2.Distance(_geometryBuffer[_geometryIndex - 1]' points[0]); " is 163.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddArc,The length of the statement  "            var startPoint = new CCVector2(center.X + radius * (float)Math.Cos(startAngle)' center.Y + radius * (float)Math.Sin(startAngle)); " is 129.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The length of the statement  "                    _geometryBuffer[_geometryIndex++] = new CCVector2(center.X + radius * (float)Math.Cos(-startAngle)' center.Y - radius * (float)Math.Sin(-startAngle)); " is 150.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The length of the statement  "                        _geometryBuffer[_geometryIndex++] = new CCVector2(center.X + radius * unitCircle[i].X' center.Y - radius * unitCircle[i].Y); " is 124.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The length of the statement  "                        _geometryBuffer[_geometryIndex++] = new CCVector2(center.X + radius * unitCircle[i].X' center.Y - radius * unitCircle[i].Y); " is 124.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The length of the statement  "                        _geometryBuffer[_geometryIndex++] = new CCVector2(center.X + radius * unitCircle[i].X' center.Y - radius * unitCircle[i].Y); " is 124.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The length of the statement  "                    _geometryBuffer[_geometryIndex++] = new CCVector2(center.X + radius * (float)Math.Cos(-stopAngle)' center.Y - radius * (float)Math.Sin(-stopAngle)); " is 148.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The length of the statement  "                    _geometryBuffer[_geometryIndex++] = new CCVector2(center.X + radius * (float)Math.Cos(-startAngle)' center.Y - radius * (float)Math.Sin(-startAngle)); " is 150.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The length of the statement  "                        _geometryBuffer[_geometryIndex++] = new CCVector2(center.X + radius * unitCircle[i].X' center.Y - radius * unitCircle[i].Y); " is 124.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The length of the statement  "                        _geometryBuffer[_geometryIndex++] = new CCVector2(center.X + radius * unitCircle[i].X' center.Y - radius * unitCircle[i].Y); " is 124.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The length of the statement  "                        _geometryBuffer[_geometryIndex++] = new CCVector2(center.X + radius * unitCircle[i].X' center.Y - radius * unitCircle[i].Y); " is 124.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The length of the statement  "                    _geometryBuffer[_geometryIndex++] = new CCVector2(center.X + radius * (float)Math.Cos(-stopAngle)' center.Y - radius * (float)Math.Sin(-stopAngle)); " is 148.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildCircleGeometryBuffer,The length of the statement  "                _geometryBuffer[_geometryIndex++] = new CCVector2(center.X + radius * unitCircle[i].X' center.Y + radius * unitCircle[i].Y); " is 124.
Long Statement,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildCircleGeometryBuffer,The length of the statement  "                _geometryBuffer[_geometryIndex++] = new CCVector2(center.X + radius * unitCircle[0].X' center.Y + radius * unitCircle[0].Y); " is 124.
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBatch,The following statement contains a magic number: _infoBuffer = new DrawingInfo[2048];
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBatch,The following statement contains a magic number: _indexBuffer = new short[32768];
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBatch,The following statement contains a magic number: _vertexBuffer = new VertexPositionColorTexture[8192];
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBatch,The following statement contains a magic number: _computeBuffer = new CCVector2[64];
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBatch,The following statement contains a magic number: _colorBuffer = new Color[64];
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBatch,The following statement contains a magic number: _geometryBuffer = new CCVector2[256];
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawRectangle,The following statement contains a magic number: _geometryBuffer[2] = new CCVector2(rect.MaxX' rect.MinY);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawRectangle,The following statement contains a magic number: _geometryBuffer[3] = new CCVector2(rect.MinX' rect.MinY);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawRectangle,The following statement contains a magic number: _geometryBuffer[2] = new CCVector2(location.X + width' location.Y + height);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawRectangle,The following statement contains a magic number: _geometryBuffer[3] = new CCVector2(location.X' location.Y + height);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: if (points.Length < offset + 4)                  throw new ArgumentException("Points array is too small for the given offset.");
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: RequestBufferSpace(8' 24);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: RequestBufferSpace(8' 24);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' 8' 24' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' 8' 24' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: if (points != _geometryBuffer)                  Array.Copy(points' _geometryBuffer' 4);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' centerY' 0);                    var refTransform = transform.toCCAffineTransform();                                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' refTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' centerY' 0);                    var refTransform = transform.toCCAffineTransform();                                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' refTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' centerY' 0);                    var refTransform = transform.toCCAffineTransform();                                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' refTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' centerY' 0);                    var refTransform = transform.toCCAffineTransform();                                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' refTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' centerY' 0);                    var refTransform = transform.toCCAffineTransform();                                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' refTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' centerY' 0);                    var refTransform = transform.toCCAffineTransform();                                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' refTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' centerY' 0);                    var refTransform = transform.toCCAffineTransform();                                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' refTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: JoinSample js = new JoinSample(_geometryBuffer[0]' _geometryBuffer[1]' _geometryBuffer[2]);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: js.Advance(_geometryBuffer[3]);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: AddSegment(baseVertexIndex + 0' baseVertexIndex + 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: AddSegment(baseVertexIndex + 2' baseVertexIndex + 4);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: AddSegment(baseVertexIndex + 2' baseVertexIndex + 4);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: AddSegment(baseVertexIndex + 4' baseVertexIndex + 6);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: AddSegment(baseVertexIndex + 4' baseVertexIndex + 6);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawQuad,The following statement contains a magic number: AddSegment(baseVertexIndex + 6' baseVertexIndex + 0);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveRectangle,The following statement contains a magic number: _geometryBuffer[2] = new CCVector2(rect.MaxX' rect.MinY);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveRectangle,The following statement contains a magic number: _geometryBuffer[3] = new CCVector2(rect.MinX' rect.MinY);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveRectangle,The following statement contains a magic number: _geometryBuffer[2] = new CCVector2(location.X + width' location.Y + height);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveRectangle,The following statement contains a magic number: _geometryBuffer[3] = new CCVector2(location.X' location.Y + height);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: if (points.Length < offset + 4)                  throw new ArgumentException("Points array is too small for the given offset.");
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: RequestBufferSpace(4' 8);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: RequestBufferSpace(4' 8);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: AddInfo(PrimitiveType.LineList' 4' 8' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: AddInfo(PrimitiveType.LineList' 4' 8' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(points[offset + 2].X' points[offset + 2].Y' 0)' pen.Color' new Vector2(points[offset + 2].X' points[offset + 2].Y));
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(points[offset + 2].X' points[offset + 2].Y' 0)' pen.Color' new Vector2(points[offset + 2].X' points[offset + 2].Y));
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(points[offset + 2].X' points[offset + 2].Y' 0)' pen.Color' new Vector2(points[offset + 2].X' points[offset + 2].Y));
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(points[offset + 2].X' points[offset + 2].Y' 0)' pen.Color' new Vector2(points[offset + 2].X' points[offset + 2].Y));
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(points[offset + 3].X' points[offset + 3].Y' 0)' pen.Color' new Vector2(points[offset + 3].X' points[offset + 3].Y));
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(points[offset + 3].X' points[offset + 3].Y' 0)' pen.Color' new Vector2(points[offset + 3].X' points[offset + 3].Y));
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(points[offset + 3].X' points[offset + 3].Y' 0)' pen.Color' new Vector2(points[offset + 3].X' points[offset + 3].Y));
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: _vertexBuffer[_vertexBufferIndex++] = new VertexPositionColorTexture(new Vector3(points[offset + 3].X' points[offset + 3].Y' 0)' pen.Color' new Vector2(points[offset + 3].X' points[offset + 3].Y));
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (points[offset + 0].X + points[offset + 1].X + points[offset + 2].X + points[offset + 3].X) / 4;                  float centerY = (points[offset + 0].Y + points[offset + 1].Y + points[offset + 2].Y + points[offset + 3].Y) / 4;                  Vector3 center = new Vector3(centerX' centerY' 0);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = center;                    for (int i = _vertexBufferIndex - 4; i < _vertexBufferIndex; i++)                      _vertexBuffer[i].Position = Vector3.Transform(_vertexBuffer[i].Position - center' transform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (points[offset + 0].X + points[offset + 1].X + points[offset + 2].X + points[offset + 3].X) / 4;                  float centerY = (points[offset + 0].Y + points[offset + 1].Y + points[offset + 2].Y + points[offset + 3].Y) / 4;                  Vector3 center = new Vector3(centerX' centerY' 0);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = center;                    for (int i = _vertexBufferIndex - 4; i < _vertexBufferIndex; i++)                      _vertexBuffer[i].Position = Vector3.Transform(_vertexBuffer[i].Position - center' transform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (points[offset + 0].X + points[offset + 1].X + points[offset + 2].X + points[offset + 3].X) / 4;                  float centerY = (points[offset + 0].Y + points[offset + 1].Y + points[offset + 2].Y + points[offset + 3].Y) / 4;                  Vector3 center = new Vector3(centerX' centerY' 0);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = center;                    for (int i = _vertexBufferIndex - 4; i < _vertexBufferIndex; i++)                      _vertexBuffer[i].Position = Vector3.Transform(_vertexBuffer[i].Position - center' transform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (points[offset + 0].X + points[offset + 1].X + points[offset + 2].X + points[offset + 3].X) / 4;                  float centerY = (points[offset + 0].Y + points[offset + 1].Y + points[offset + 2].Y + points[offset + 3].Y) / 4;                  Vector3 center = new Vector3(centerX' centerY' 0);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = center;                    for (int i = _vertexBufferIndex - 4; i < _vertexBufferIndex; i++)                      _vertexBuffer[i].Position = Vector3.Transform(_vertexBuffer[i].Position - center' transform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (points[offset + 0].X + points[offset + 1].X + points[offset + 2].X + points[offset + 3].X) / 4;                  float centerY = (points[offset + 0].Y + points[offset + 1].Y + points[offset + 2].Y + points[offset + 3].Y) / 4;                  Vector3 center = new Vector3(centerX' centerY' 0);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = center;                    for (int i = _vertexBufferIndex - 4; i < _vertexBufferIndex; i++)                      _vertexBuffer[i].Position = Vector3.Transform(_vertexBuffer[i].Position - center' transform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (points[offset + 0].X + points[offset + 1].X + points[offset + 2].X + points[offset + 3].X) / 4;                  float centerY = (points[offset + 0].Y + points[offset + 1].Y + points[offset + 2].Y + points[offset + 3].Y) / 4;                  Vector3 center = new Vector3(centerX' centerY' 0);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = center;                    for (int i = _vertexBufferIndex - 4; i < _vertexBufferIndex; i++)                      _vertexBuffer[i].Position = Vector3.Transform(_vertexBuffer[i].Position - center' transform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: if (angle != 0) {                  float centerX = (points[offset + 0].X + points[offset + 1].X + points[offset + 2].X + points[offset + 3].X) / 4;                  float centerY = (points[offset + 0].Y + points[offset + 1].Y + points[offset + 2].Y + points[offset + 3].Y) / 4;                  Vector3 center = new Vector3(centerX' centerY' 0);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = center;                    for (int i = _vertexBufferIndex - 4; i < _vertexBufferIndex; i++)                      _vertexBuffer[i].Position = Vector3.Transform(_vertexBuffer[i].Position - center' transform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: _indexBuffer[_indexBufferIndex++] = (short)(baseVertexIndex + 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: _indexBuffer[_indexBufferIndex++] = (short)(baseVertexIndex + 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: _indexBuffer[_indexBufferIndex++] = (short)(baseVertexIndex + 3);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveQuad,The following statement contains a magic number: _indexBuffer[_indexBufferIndex++] = (short)(baseVertexIndex + 3);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPoint,The following statement contains a magic number: RequestBufferSpace(4' 6);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPoint,The following statement contains a magic number: RequestBufferSpace(4' 6);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPoint,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' 4' 6' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPoint,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' 4' 6' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPoint,The following statement contains a magic number: float w2 = pen.Width / 2;
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPoint,The following statement contains a magic number: AddSegment(baseVertexIndex + 0' baseVertexIndex + 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawLine,The following statement contains a magic number: RequestBufferSpace(4' 6);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawLine,The following statement contains a magic number: RequestBufferSpace(4' 6);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawLine,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' 4' 6' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawLine,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' 4' 6' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawLine,The following statement contains a magic number: AddSegment(baseVertexIndex + 0' baseVertexIndex + 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveLine,The following statement contains a magic number: RequestBufferSpace(2' 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveLine,The following statement contains a magic number: RequestBufferSpace(2' 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveLine,The following statement contains a magic number: AddInfo(PrimitiveType.LineList' 2' 2' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveLine,The following statement contains a magic number: AddInfo(PrimitiveType.LineList' 2' 2' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitivePath,The following statement contains a magic number: RequestBufferSpace(count' (pathType == PathType.Open) ? count * 2 - 2 : count * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitivePath,The following statement contains a magic number: RequestBufferSpace(count' (pathType == PathType.Open) ? count * 2 - 2 : count * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitivePath,The following statement contains a magic number: RequestBufferSpace(count' (pathType == PathType.Open) ? count * 2 - 2 : count * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitivePath,The following statement contains a magic number: AddInfo(PrimitiveType.LineList' count' (pathType == PathType.Open) ? count * 2 - 2 : count * 2' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitivePath,The following statement contains a magic number: AddInfo(PrimitiveType.LineList' count' (pathType == PathType.Open) ? count * 2 - 2 : count * 2' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitivePath,The following statement contains a magic number: AddInfo(PrimitiveType.LineList' count' (pathType == PathType.Open) ? count * 2 - 2 : count * 2' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildCircleGeometryBuffer,The following statement contains a magic number: if (_geometryBuffer.Length < subdivisions + 1)                  Array.Resize(ref _geometryBuffer' (subdivisions + 1) * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawArc,The following statement contains a magic number: float radius = (height / 2) + (width * width) / (height * 8);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawArc,The following statement contains a magic number: float radius = (height / 2) + (width * width) / (height * 8);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveArc,The following statement contains a magic number: float radius = (height / 2) + (width * width) / (height * 8);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveArc,The following statement contains a magic number: float radius = (height / 2) + (width * width) / (height * 8);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The following statement contains a magic number: switch (bezierType)              {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The following statement contains a magic number: switch (bezierType)              {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The following statement contains a magic number: switch (bezierType)              {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The following statement contains a magic number: switch (bezierType)              {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The following statement contains a magic number: switch (bezierType)              {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The following statement contains a magic number: switch (bezierType)              {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The following statement contains a magic number: switch (bezierType)              {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The following statement contains a magic number: switch (bezierType)              {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The following statement contains a magic number: switch (bezierType)              {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The following statement contains a magic number: switch (bezierType)              {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,ClampAngle,The following statement contains a magic number: if (angle < 0)                  angle += (float)(Math.Ceiling(angle / (Math.PI * -2)) * Math.PI * 2);              else if (angle >= (Math.PI * 2))                  angle -= (float)(Math.Floor(angle / (Math.PI * 2)) * Math.PI * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,ClampAngle,The following statement contains a magic number: if (angle < 0)                  angle += (float)(Math.Ceiling(angle / (Math.PI * -2)) * Math.PI * 2);              else if (angle >= (Math.PI * 2))                  angle -= (float)(Math.Floor(angle / (Math.PI * 2)) * Math.PI * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,ClampAngle,The following statement contains a magic number: if (angle < 0)                  angle += (float)(Math.Ceiling(angle / (Math.PI * -2)) * Math.PI * 2);              else if (angle >= (Math.PI * 2))                  angle -= (float)(Math.Floor(angle / (Math.PI * 2)) * Math.PI * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,ClampAngle,The following statement contains a magic number: if (angle < 0)                  angle += (float)(Math.Ceiling(angle / (Math.PI * -2)) * Math.PI * 2);              else if (angle >= (Math.PI * 2))                  angle -= (float)(Math.Floor(angle / (Math.PI * 2)) * Math.PI * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,ClampAngle,The following statement contains a magic number: if (angle < 0)                  angle += (float)(Math.Ceiling(angle / (Math.PI * -2)) * Math.PI * 2);              else if (angle >= (Math.PI * 2))                  angle -= (float)(Math.Floor(angle / (Math.PI * 2)) * Math.PI * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,PointToAngle,The following statement contains a magic number: if (angle < 0)                  angle += Math.PI * 2;
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildArcGeometryBuffer,The following statement contains a magic number: float subLength = (float)(2 * Math.PI / subdivisions);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildArcGeometryBuffer,The following statement contains a magic number: if (_geometryBuffer.Length < vertexCount + 2)                  Array.Resize(ref _geometryBuffer' (vertexCount + 2) * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildArcGeometryBuffer,The following statement contains a magic number: if (_geometryBuffer.Length < vertexCount + 2)                  Array.Resize(ref _geometryBuffer' (vertexCount + 2) * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,BuildArcGeometryBuffer,The following statement contains a magic number: if (_geometryBuffer.Length < vertexCount + 2)                  Array.Resize(ref _geometryBuffer' (vertexCount + 2) * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillCircle,The following statement contains a magic number: RequestBufferSpace(subdivisions + 1' subdivisions * 3);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillCircle,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' subdivisions + 1' subdivisions * 3' brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillEllipse,The following statement contains a magic number: RequestBufferSpace(subdivisions + 1' subdivisions * 3);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillEllipse,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' subdivisions + 1' subdivisions * 3' brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillArc,The following statement contains a magic number: RequestBufferSpace(vertexCount + 1' (vertexCount - 1) * 3);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillArc,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' vertexCount + 1' (vertexCount - 1) * 3' brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillArc,The following statement contains a magic number: switch (arcType) {                  case ArcType.Sector:                      AddVertex(new CCVector2(center.X' center.Y)' brush);                      break;                  case ArcType.Segment:                      AddVertex(new CCVector2((_geometryBuffer[0].X + _geometryBuffer[vertexCount - 1].X) / 2'                          (_geometryBuffer[0].Y + _geometryBuffer[vertexCount - 1].Y) / 2)' brush);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillArc,The following statement contains a magic number: switch (arcType) {                  case ArcType.Sector:                      AddVertex(new CCVector2(center.X' center.Y)' brush);                      break;                  case ArcType.Segment:                      AddVertex(new CCVector2((_geometryBuffer[0].X + _geometryBuffer[vertexCount - 1].X) / 2'                          (_geometryBuffer[0].Y + _geometryBuffer[vertexCount - 1].Y) / 2)' brush);                      break;              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillRectangle,The following statement contains a magic number: _geometryBuffer[2] = new CCVector2(rect.MaxX' rect.MinY);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillRectangle,The following statement contains a magic number: _geometryBuffer[3] = new CCVector2(rect.MinX' rect.MinY);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillRectangle,The following statement contains a magic number: _geometryBuffer[2] = new CCVector2(location.X + width' location.Y + height);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillRectangle,The following statement contains a magic number: _geometryBuffer[3] = new CCVector2(location.X' location.Y + height);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: if (points.Length < offset + 4)                  throw new ArgumentException("Points array is too small for the given offset.");
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: RequestBufferSpace(4' 6);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: RequestBufferSpace(4' 6);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' 4' 6' brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' 4' 6' brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: if (points != _geometryBuffer)                  Array.Copy(points' _geometryBuffer' 4);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: if (angle != 0)              {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' center.Y' 0);                    var affineTransform = transform.toCCAffineTransform();                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' affineTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: if (angle != 0)              {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' center.Y' 0);                    var affineTransform = transform.toCCAffineTransform();                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' affineTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: if (angle != 0)              {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' center.Y' 0);                    var affineTransform = transform.toCCAffineTransform();                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' affineTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: if (angle != 0)              {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' center.Y' 0);                    var affineTransform = transform.toCCAffineTransform();                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' affineTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: if (angle != 0)              {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' center.Y' 0);                    var affineTransform = transform.toCCAffineTransform();                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' affineTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: if (angle != 0)              {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' center.Y' 0);                    var affineTransform = transform.toCCAffineTransform();                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' affineTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: if (angle != 0)              {                  float centerX = (_geometryBuffer[0].X + _geometryBuffer[1].X + _geometryBuffer[2].X + _geometryBuffer[3].X) / 4;                  float centerY = (_geometryBuffer[0].Y + _geometryBuffer[1].Y + _geometryBuffer[2].Y + _geometryBuffer[3].Y) / 4;                  CCVector2 center = new CCVector2(centerX' centerY);                    Matrix transform = Matrix.CreateRotationZ(angle);                  transform.Translation = new Vector3(center.X' center.Y' 0);                    var affineTransform = transform.toCCAffineTransform();                    for (int i = 0; i < 4; i++)                      _geometryBuffer[i] = CCVector2.Transform(_geometryBuffer[i] - center' affineTransform);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  AddVertex(_geometryBuffer[i]' brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: AddTriangle(baseVertexIndex + 0' baseVertexIndex + 1' baseVertexIndex + 3);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: AddTriangle(baseVertexIndex + 1' baseVertexIndex + 2' baseVertexIndex + 3);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillQuad,The following statement contains a magic number: AddTriangle(baseVertexIndex + 1' baseVertexIndex + 2' baseVertexIndex + 3);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddClosedPath,The following statement contains a magic number: RequestBufferSpace(count * 2' count * 6);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddClosedPath,The following statement contains a magic number: RequestBufferSpace(count * 2' count * 6);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddClosedPath,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' count * 2' count * 6' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddClosedPath,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' count * 2' count * 6' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddClosedPath,The following statement contains a magic number: for (int i = 0; i < count - 2; i++) {                  js.Advance(points[offset + i + 2]);                  AddMiteredJoint(ref js' pen' ws);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddClosedPath,The following statement contains a magic number: for (int i = 0; i < count - 2; i++) {                  js.Advance(points[offset + i + 2]);                  AddMiteredJoint(ref js' pen' ws);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddClosedPath,The following statement contains a magic number: for (int i = 0; i < count - 1; i++) {                  AddSegment(baseVertexIndex + i * 2' baseVertexIndex + (i + 1) * 2);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddClosedPath,The following statement contains a magic number: for (int i = 0; i < count - 1; i++) {                  AddSegment(baseVertexIndex + i * 2' baseVertexIndex + (i + 1) * 2);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddClosedPath,The following statement contains a magic number: AddSegment(baseVertexIndex + (count - 1) * 2' baseVertexIndex + 0);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddPath,The following statement contains a magic number: RequestBufferSpace(count * 2' (count - 1) * 6);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddPath,The following statement contains a magic number: RequestBufferSpace(count * 2' (count - 1) * 6);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddPath,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' count * 2' (count - 1) * 6' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddPath,The following statement contains a magic number: AddInfo(PrimitiveType.TriangleList' count * 2' (count - 1) * 6' pen.Brush);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddPath,The following statement contains a magic number: for (int i = 0; i < count - 2; i++) {                  js.Advance(points[offset + i + 2]);                  AddMiteredJoint(ref js' pen' ws);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddPath,The following statement contains a magic number: for (int i = 0; i < count - 2; i++) {                  js.Advance(points[offset + i + 2]);                  AddMiteredJoint(ref js' pen' ws);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddPath,The following statement contains a magic number: AddEndPoint(points[offset + count - 2]' points[offset + count - 1]' pen' _ws);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddPath,The following statement contains a magic number: for (int i = 0; i < count - 1; i++)                  AddSegment(baseVertexIndex + i * 2' baseVertexIndex + (i + 1) * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,AddPath,The following statement contains a magic number: for (int i = 0; i < count - 1; i++)                  AddSegment(baseVertexIndex + i * 2' baseVertexIndex + (i + 1) * 2);
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,RequestBufferSpace,The following statement contains a magic number: if (_infoBufferIndex + 1 > _infoBuffer.Length)              {                  Array.Resize(ref _infoBuffer' _infoBuffer.Length * 2);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,RequestBufferSpace,The following statement contains a magic number: if (_indexBufferIndex + newIndexCount >= _indexBuffer.Length)              {                  Array.Resize(ref _indexBuffer' _indexBuffer.Length * 2);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,RequestBufferSpace,The following statement contains a magic number: if (_vertexBufferIndex + newVertexCount >= _vertexBuffer.Length)              {                  Array.Resize(ref _vertexBuffer' _vertexBuffer.Length * 2);              }
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,CalculateCircleSubdivisions,The following statement contains a magic number: double slice = Math.PI * 2 / divisions;
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DefaultSubdivisions,The following statement contains a magic number: return Math.Max(8' (int)Math.Ceiling(radius / 1.5f));
Magic Number,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DefaultSubdivisions,The following statement contains a magic number: return Math.Max(8' (int)Math.Ceiling(Math.Max(xRadius' yRadius) / 1.5f));
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileOpenPath,The following statement contains a magic number: for (int i = 0; i < count - 2; i++) {                  joinSample.Advance(points[offset + i + 2]' lengths[offset + i + 2]);                    vPrevCount = vNextCount;                  vNextCount = AddJoint(i + 1' ref joinSample' ws' insetBuffer' outsetBuffer);                  if (_strokeType != StrokeType.Outline)                      AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[i]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[i + 1]);              }
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileOpenPath,The following statement contains a magic number: for (int i = 0; i < count - 2; i++) {                  joinSample.Advance(points[offset + i + 2]' lengths[offset + i + 2]);                    vPrevCount = vNextCount;                  vNextCount = AddJoint(i + 1' ref joinSample' ws' insetBuffer' outsetBuffer);                  if (_strokeType != StrokeType.Outline)                      AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[i]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[i + 1]);              }
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileOpenPath,The following statement contains a magic number: for (int i = 0; i < count - 2; i++) {                  joinSample.Advance(points[offset + i + 2]' lengths[offset + i + 2]);                    vPrevCount = vNextCount;                  vNextCount = AddJoint(i + 1' ref joinSample' ws' insetBuffer' outsetBuffer);                  if (_strokeType != StrokeType.Outline)                      AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[i]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[i + 1]);              }
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileOpenPath,The following statement contains a magic number: vNextCount = AddEndPoint(count - 1' points[offset + count - 2]' points[offset + count - 1]' ws' insetBuffer);
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileOpenPath,The following statement contains a magic number: if (_strokeType != StrokeType.Outline)                  AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[count - 2]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[count - 1]);
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileClosedPath,The following statement contains a magic number: for (int i = 0; i < count - 2; i++) {                  joinSample.Advance(points[offset + i + 2]' lengths[offset + i + 2]);                    vPrevCount = vNextCount;                  vNextCount = AddJoint(i + 1'ref joinSample' ws' insetBuffer' outsetBuffer);                  if (_strokeType != StrokeType.Outline)                      AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[i]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[i + 1]);              }
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileClosedPath,The following statement contains a magic number: for (int i = 0; i < count - 2; i++) {                  joinSample.Advance(points[offset + i + 2]' lengths[offset + i + 2]);                    vPrevCount = vNextCount;                  vNextCount = AddJoint(i + 1'ref joinSample' ws' insetBuffer' outsetBuffer);                  if (_strokeType != StrokeType.Outline)                      AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[i]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[i + 1]);              }
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileClosedPath,The following statement contains a magic number: for (int i = 0; i < count - 2; i++) {                  joinSample.Advance(points[offset + i + 2]' lengths[offset + i + 2]);                    vPrevCount = vNextCount;                  vNextCount = AddJoint(i + 1'ref joinSample' ws' insetBuffer' outsetBuffer);                  if (_strokeType != StrokeType.Outline)                      AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[i]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[i + 1]);              }
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,CompileClosedPath,The following statement contains a magic number: if (_strokeType != StrokeType.Outline) {                  AddSegment(_vertexBufferIndex - vNextCount - vPrevCount' vPrevCount' _jointCCW[count - 2]' _vertexBufferIndex - vNextCount' vNextCount' _jointCCW[count - 1]);                  AddSegment(_vertexBufferIndex - vNextCount' vNextCount' _jointCCW[count - 1]' vBaseIndex' vBaseCount' _jointCCW[0]);              }
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,IsClose,The following statement contains a magic number: return Math.Abs(a.X - b.X) < 0.001 && Math.Abs(a.Y - b.Y) < 0.001;
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,IsClose,The following statement contains a magic number: return Math.Abs(a.X - b.X) < 0.001 && Math.Abs(a.Y - b.Y) < 0.001;
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,AddJoint,The following statement contains a magic number: if (!vioCount.CCW) {                  _jointCCW[pointIndex] = false;                  _positionData[vIndex + 0] = ws.XYOutsetBuffer[0];                  for (int i = 0; i < vioCount.InsetCount; i++)                      _positionData[vIndex + 1 + i] = ws.XYInsetBuffer[i];                    for (int i = 0; i < vioCount.InsetCount - 1; i++) {                      _indexData[_indexBufferIndex++] = (short)(vIndex);                      _indexData[_indexBufferIndex++] = (short)(vIndex + i + 2);                      _indexData[_indexBufferIndex++] = (short)(vIndex + i + 1);                  }              }              else {                  _jointCCW[pointIndex] = true;                  _positionData[vIndex + 0] = ws.XYInsetBuffer[0];                  for (int i = 0; i < vioCount.OutsetCount; i++)                      _positionData[vIndex + 1 + i] = ws.XYOutsetBuffer[i];                    for (int i = 0; i < vioCount.OutsetCount - 1; i++) {                      _indexData[_indexBufferIndex++] = (short)(vIndex);                      _indexData[_indexBufferIndex++] = (short)(vIndex + i + 1);                      _indexData[_indexBufferIndex++] = (short)(vIndex + i + 2);                  }              }
Magic Number,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,AddJoint,The following statement contains a magic number: if (!vioCount.CCW) {                  _jointCCW[pointIndex] = false;                  _positionData[vIndex + 0] = ws.XYOutsetBuffer[0];                  for (int i = 0; i < vioCount.InsetCount; i++)                      _positionData[vIndex + 1 + i] = ws.XYInsetBuffer[i];                    for (int i = 0; i < vioCount.InsetCount - 1; i++) {                      _indexData[_indexBufferIndex++] = (short)(vIndex);                      _indexData[_indexBufferIndex++] = (short)(vIndex + i + 2);                      _indexData[_indexBufferIndex++] = (short)(vIndex + i + 1);                  }              }              else {                  _jointCCW[pointIndex] = true;                  _positionData[vIndex + 0] = ws.XYInsetBuffer[0];                  for (int i = 0; i < vioCount.OutsetCount; i++)                      _positionData[vIndex + 1 + i] = ws.XYOutsetBuffer[i];                    for (int i = 0; i < vioCount.OutsetCount - 1; i++) {                      _indexData[_indexBufferIndex++] = (short)(vIndex);                      _indexData[_indexBufferIndex++] = (short)(vIndex + i + 1);                      _indexData[_indexBufferIndex++] = (short)(vIndex + i + 2);                  }              }
Magic Number,LilyPath,LineCapInfo,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\LineCapInfo.cs,LineCapInfo,The following statement contains a magic number: _indexBuffer = new short[polyCount * 3];
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddArcByPoint,The following statement contains a magic number: float radius = (height / 2) + (width * width) / (height * 8);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddArcByPoint,The following statement contains a magic number: float radius = (height / 2) + (width * width) / (height * 8);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddArc,The following statement contains a magic number: float radius = (height / 2) + (width * width) / (height * 8);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddArc,The following statement contains a magic number: float radius = (height / 2) + (width * width) / (height * 8);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      if (length < 3)                          throw new ArgumentOutOfRangeException("A quadratic bezier needs at least 3 points");                      for (int i = offset + 2; i < offset + length; i += 2)                          AddBezier(points[i - 2]' points[i - 1]' points[i]);                      break;                    case BezierType.Cubic:                      if (length < 4)                          throw new ArgumentOutOfRangeException("A cubic bezier needs at least 4 points");                      for (int i = offset + 3; i < offset + length; i += 3)                          AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      break;              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      if (length < 3)                          throw new ArgumentOutOfRangeException("A quadratic bezier needs at least 3 points");                      for (int i = offset + 2; i < offset + length; i += 2)                          AddBezier(points[i - 2]' points[i - 1]' points[i]);                      break;                    case BezierType.Cubic:                      if (length < 4)                          throw new ArgumentOutOfRangeException("A cubic bezier needs at least 4 points");                      for (int i = offset + 3; i < offset + length; i += 3)                          AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      break;              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      if (length < 3)                          throw new ArgumentOutOfRangeException("A quadratic bezier needs at least 3 points");                      for (int i = offset + 2; i < offset + length; i += 2)                          AddBezier(points[i - 2]' points[i - 1]' points[i]);                      break;                    case BezierType.Cubic:                      if (length < 4)                          throw new ArgumentOutOfRangeException("A cubic bezier needs at least 4 points");                      for (int i = offset + 3; i < offset + length; i += 3)                          AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      break;              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      if (length < 3)                          throw new ArgumentOutOfRangeException("A quadratic bezier needs at least 3 points");                      for (int i = offset + 2; i < offset + length; i += 2)                          AddBezier(points[i - 2]' points[i - 1]' points[i]);                      break;                    case BezierType.Cubic:                      if (length < 4)                          throw new ArgumentOutOfRangeException("A cubic bezier needs at least 4 points");                      for (int i = offset + 3; i < offset + length; i += 3)                          AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      break;              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      if (length < 3)                          throw new ArgumentOutOfRangeException("A quadratic bezier needs at least 3 points");                      for (int i = offset + 2; i < offset + length; i += 2)                          AddBezier(points[i - 2]' points[i - 1]' points[i]);                      break;                    case BezierType.Cubic:                      if (length < 4)                          throw new ArgumentOutOfRangeException("A cubic bezier needs at least 4 points");                      for (int i = offset + 3; i < offset + length; i += 3)                          AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      break;              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      if (length < 3)                          throw new ArgumentOutOfRangeException("A quadratic bezier needs at least 3 points");                      for (int i = offset + 2; i < offset + length; i += 2)                          AddBezier(points[i - 2]' points[i - 1]' points[i]);                      break;                    case BezierType.Cubic:                      if (length < 4)                          throw new ArgumentOutOfRangeException("A cubic bezier needs at least 4 points");                      for (int i = offset + 3; i < offset + length; i += 3)                          AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      break;              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      if (length < 3)                          throw new ArgumentOutOfRangeException("A quadratic bezier needs at least 3 points");                      for (int i = offset + 2; i < offset + length; i += 2)                          AddBezier(points[i - 2]' points[i - 1]' points[i]);                      break;                    case BezierType.Cubic:                      if (length < 4)                          throw new ArgumentOutOfRangeException("A cubic bezier needs at least 4 points");                      for (int i = offset + 3; i < offset + length; i += 3)                          AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      break;              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      if (length < 3)                          throw new ArgumentOutOfRangeException("A quadratic bezier needs at least 3 points");                      for (int i = offset + 2; i < offset + length; i += 2)                          AddBezier(points[i - 2]' points[i - 1]' points[i]);                      break;                    case BezierType.Cubic:                      if (length < 4)                          throw new ArgumentOutOfRangeException("A cubic bezier needs at least 4 points");                      for (int i = offset + 3; i < offset + length; i += 3)                          AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      break;              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddBeziers,The following statement contains a magic number: switch (bezierType) {                  case BezierType.Quadratic:                      if (length < 3)                          throw new ArgumentOutOfRangeException("A quadratic bezier needs at least 3 points");                      for (int i = offset + 2; i < offset + length; i += 2)                          AddBezier(points[i - 2]' points[i - 1]' points[i]);                      break;                    case BezierType.Cubic:                      if (length < 4)                          throw new ArgumentOutOfRangeException("A cubic bezier needs at least 4 points");                      for (int i = offset + 3; i < offset + length; i += 3)                          AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      break;              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,CheckBufferFreeSpace,The following statement contains a magic number: if (_geometryBuffer.Length < _geometryIndex + vertexCount) {                  Array.Resize(ref _geometryBuffer' (_geometryIndex + vertexCount) * 2);                    if (_lengthBuffer != null)                      Array.Resize(ref _lengthBuffer' (_geometryIndex + vertexCount) * 2);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,CheckBufferFreeSpace,The following statement contains a magic number: if (_geometryBuffer.Length < _geometryIndex + vertexCount) {                  Array.Resize(ref _geometryBuffer' (_geometryIndex + vertexCount) * 2);                    if (_lengthBuffer != null)                      Array.Resize(ref _lengthBuffer' (_geometryIndex + vertexCount) * 2);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The following statement contains a magic number: float radius = (height / 2) + (width * width) / (height * 8);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The following statement contains a magic number: float radius = (height / 2) + (width * width) / (height * 8);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The following statement contains a magic number: if (height >= 0) {                  if (height < width / 2) {                      arcAngle = (Math.Abs(endAngle - startAngle) < Math.PI)                          ? endAngle - startAngle                          : endAngle + (float)Math.PI * 2 - startAngle;                  }                  else {                      arcAngle = ((endAngle - startAngle) > Math.PI)                          ? endAngle - startAngle                          : endAngle + (float)Math.PI * 2 - startAngle;                  }              }              else {                  if (-height < width / 2) {                      arcAngle = (Math.Abs(endAngle - startAngle) < Math.PI)                          ? endAngle - startAngle                          : endAngle - (float)Math.PI * 2 - startAngle;                  }                  else {                      arcAngle = ((endAngle - startAngle) > Math.PI)                          ? startAngle - endAngle                          : endAngle - (float)Math.PI * 2 - startAngle;                  }              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The following statement contains a magic number: if (height >= 0) {                  if (height < width / 2) {                      arcAngle = (Math.Abs(endAngle - startAngle) < Math.PI)                          ? endAngle - startAngle                          : endAngle + (float)Math.PI * 2 - startAngle;                  }                  else {                      arcAngle = ((endAngle - startAngle) > Math.PI)                          ? endAngle - startAngle                          : endAngle + (float)Math.PI * 2 - startAngle;                  }              }              else {                  if (-height < width / 2) {                      arcAngle = (Math.Abs(endAngle - startAngle) < Math.PI)                          ? endAngle - startAngle                          : endAngle - (float)Math.PI * 2 - startAngle;                  }                  else {                      arcAngle = ((endAngle - startAngle) > Math.PI)                          ? startAngle - endAngle                          : endAngle - (float)Math.PI * 2 - startAngle;                  }              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The following statement contains a magic number: if (height >= 0) {                  if (height < width / 2) {                      arcAngle = (Math.Abs(endAngle - startAngle) < Math.PI)                          ? endAngle - startAngle                          : endAngle + (float)Math.PI * 2 - startAngle;                  }                  else {                      arcAngle = ((endAngle - startAngle) > Math.PI)                          ? endAngle - startAngle                          : endAngle + (float)Math.PI * 2 - startAngle;                  }              }              else {                  if (-height < width / 2) {                      arcAngle = (Math.Abs(endAngle - startAngle) < Math.PI)                          ? endAngle - startAngle                          : endAngle - (float)Math.PI * 2 - startAngle;                  }                  else {                      arcAngle = ((endAngle - startAngle) > Math.PI)                          ? startAngle - endAngle                          : endAngle - (float)Math.PI * 2 - startAngle;                  }              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The following statement contains a magic number: if (height >= 0) {                  if (height < width / 2) {                      arcAngle = (Math.Abs(endAngle - startAngle) < Math.PI)                          ? endAngle - startAngle                          : endAngle + (float)Math.PI * 2 - startAngle;                  }                  else {                      arcAngle = ((endAngle - startAngle) > Math.PI)                          ? endAngle - startAngle                          : endAngle + (float)Math.PI * 2 - startAngle;                  }              }              else {                  if (-height < width / 2) {                      arcAngle = (Math.Abs(endAngle - startAngle) < Math.PI)                          ? endAngle - startAngle                          : endAngle - (float)Math.PI * 2 - startAngle;                  }                  else {                      arcAngle = ((endAngle - startAngle) > Math.PI)                          ? startAngle - endAngle                          : endAngle - (float)Math.PI * 2 - startAngle;                  }              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The following statement contains a magic number: if (height >= 0) {                  if (height < width / 2) {                      arcAngle = (Math.Abs(endAngle - startAngle) < Math.PI)                          ? endAngle - startAngle                          : endAngle + (float)Math.PI * 2 - startAngle;                  }                  else {                      arcAngle = ((endAngle - startAngle) > Math.PI)                          ? endAngle - startAngle                          : endAngle + (float)Math.PI * 2 - startAngle;                  }              }              else {                  if (-height < width / 2) {                      arcAngle = (Math.Abs(endAngle - startAngle) < Math.PI)                          ? endAngle - startAngle                          : endAngle - (float)Math.PI * 2 - startAngle;                  }                  else {                      arcAngle = ((endAngle - startAngle) > Math.PI)                          ? startAngle - endAngle                          : endAngle - (float)Math.PI * 2 - startAngle;                  }              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The following statement contains a magic number: if (height >= 0) {                  if (height < width / 2) {                      arcAngle = (Math.Abs(endAngle - startAngle) < Math.PI)                          ? endAngle - startAngle                          : endAngle + (float)Math.PI * 2 - startAngle;                  }                  else {                      arcAngle = ((endAngle - startAngle) > Math.PI)                          ? endAngle - startAngle                          : endAngle + (float)Math.PI * 2 - startAngle;                  }              }              else {                  if (-height < width / 2) {                      arcAngle = (Math.Abs(endAngle - startAngle) < Math.PI)                          ? endAngle - startAngle                          : endAngle - (float)Math.PI * 2 - startAngle;                  }                  else {                      arcAngle = ((endAngle - startAngle) > Math.PI)                          ? startAngle - endAngle                          : endAngle - (float)Math.PI * 2 - startAngle;                  }              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The following statement contains a magic number: float subLength = (float)(2 * Math.PI / subdivisions);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The following statement contains a magic number: CheckBufferFreeSpace(vertexCount + 2);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildArcGeometryBuffer,The following statement contains a magic number: if (_calculateLengths) {                  float arcLength = 2 * arcAngle * radius;                  float segmentLength = arcLength / subLength;                    for (int i = baseIndex; i < _geometryIndex; i++)                      _lengthBuffer[baseIndex + i] = _lengthBuffer[baseIndex + i - 1] + segmentLength;              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildCircleGeometryBuffer,The following statement contains a magic number: if (_calculateLengths) {                  float arcLength = 2 * (float)Math.PI * radius;                  float segmentLength = arcLength / subdivisions;                    for (int i = baseIndex; i < _geometryIndex; i++)                      _lengthBuffer[baseIndex + i] = _lengthBuffer[baseIndex + i - 1] + segmentLength;              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,CalculateCircleSubdivisions,The following statement contains a magic number: double slice = Math.PI * 2 / divisions;
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildQuadraticBezierGeometryBuffer,The following statement contains a magic number: for (int i = 0; i < subdivisions; i++' t += step) {                  if (1 - t < 5e-6)                      t = 1;                    float p0 = Bernstein(2' 0' t);                  float p1 = Bernstein(2' 1' t);                  float p2 = Bernstein(2' 2' t);                    float vx = p0 * v0.X + p1 * v1.X + p2 * v2.X;                  float vy = p0 * v0.Y + p1 * v1.Y + p2 * v2.Y;                    _geometryBuffer[_geometryIndex++] = new CCVector2(vx' vy);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildQuadraticBezierGeometryBuffer,The following statement contains a magic number: for (int i = 0; i < subdivisions; i++' t += step) {                  if (1 - t < 5e-6)                      t = 1;                    float p0 = Bernstein(2' 0' t);                  float p1 = Bernstein(2' 1' t);                  float p2 = Bernstein(2' 2' t);                    float vx = p0 * v0.X + p1 * v1.X + p2 * v2.X;                  float vy = p0 * v0.Y + p1 * v1.Y + p2 * v2.Y;                    _geometryBuffer[_geometryIndex++] = new CCVector2(vx' vy);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildQuadraticBezierGeometryBuffer,The following statement contains a magic number: for (int i = 0; i < subdivisions; i++' t += step) {                  if (1 - t < 5e-6)                      t = 1;                    float p0 = Bernstein(2' 0' t);                  float p1 = Bernstein(2' 1' t);                  float p2 = Bernstein(2' 2' t);                    float vx = p0 * v0.X + p1 * v1.X + p2 * v2.X;                  float vy = p0 * v0.Y + p1 * v1.Y + p2 * v2.Y;                    _geometryBuffer[_geometryIndex++] = new CCVector2(vx' vy);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildQuadraticBezierGeometryBuffer,The following statement contains a magic number: for (int i = 0; i < subdivisions; i++' t += step) {                  if (1 - t < 5e-6)                      t = 1;                    float p0 = Bernstein(2' 0' t);                  float p1 = Bernstein(2' 1' t);                  float p2 = Bernstein(2' 2' t);                    float vx = p0 * v0.X + p1 * v1.X + p2 * v2.X;                  float vy = p0 * v0.Y + p1 * v1.Y + p2 * v2.Y;                    _geometryBuffer[_geometryIndex++] = new CCVector2(vx' vy);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildQuadraticBezierGeometryBuffer,The following statement contains a magic number: for (int i = 0; i < subdivisions; i++' t += step) {                  if (1 - t < 5e-6)                      t = 1;                    float p0 = Bernstein(2' 0' t);                  float p1 = Bernstein(2' 1' t);                  float p2 = Bernstein(2' 2' t);                    float vx = p0 * v0.X + p1 * v1.X + p2 * v2.X;                  float vy = p0 * v0.Y + p1 * v1.Y + p2 * v2.Y;                    _geometryBuffer[_geometryIndex++] = new CCVector2(vx' vy);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildCubicBezierGeometryBuffer,The following statement contains a magic number: for (int i = 0; i < subdivisions; i++' t += step) {                  if (1 - t < 5e-6)                      t = 1;                    float p0 = Bernstein(3' 0' t);                  float p1 = Bernstein(3' 1' t);                  float p2 = Bernstein(3' 2' t);                  float p3 = Bernstein(3' 3' t);                    float vx = p0 * v0.X + p1 * v1.X + p2 * v2.X + p3 * v3.X;                  float vy = p0 * v0.Y + p1 * v1.Y + p2 * v2.Y + p3 * v3.Y;                    _geometryBuffer[_geometryIndex++] = new CCVector2(vx' vy);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildCubicBezierGeometryBuffer,The following statement contains a magic number: for (int i = 0; i < subdivisions; i++' t += step) {                  if (1 - t < 5e-6)                      t = 1;                    float p0 = Bernstein(3' 0' t);                  float p1 = Bernstein(3' 1' t);                  float p2 = Bernstein(3' 2' t);                  float p3 = Bernstein(3' 3' t);                    float vx = p0 * v0.X + p1 * v1.X + p2 * v2.X + p3 * v3.X;                  float vy = p0 * v0.Y + p1 * v1.Y + p2 * v2.Y + p3 * v3.Y;                    _geometryBuffer[_geometryIndex++] = new CCVector2(vx' vy);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildCubicBezierGeometryBuffer,The following statement contains a magic number: for (int i = 0; i < subdivisions; i++' t += step) {                  if (1 - t < 5e-6)                      t = 1;                    float p0 = Bernstein(3' 0' t);                  float p1 = Bernstein(3' 1' t);                  float p2 = Bernstein(3' 2' t);                  float p3 = Bernstein(3' 3' t);                    float vx = p0 * v0.X + p1 * v1.X + p2 * v2.X + p3 * v3.X;                  float vy = p0 * v0.Y + p1 * v1.Y + p2 * v2.Y + p3 * v3.Y;                    _geometryBuffer[_geometryIndex++] = new CCVector2(vx' vy);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildCubicBezierGeometryBuffer,The following statement contains a magic number: for (int i = 0; i < subdivisions; i++' t += step) {                  if (1 - t < 5e-6)                      t = 1;                    float p0 = Bernstein(3' 0' t);                  float p1 = Bernstein(3' 1' t);                  float p2 = Bernstein(3' 2' t);                  float p3 = Bernstein(3' 3' t);                    float vx = p0 * v0.X + p1 * v1.X + p2 * v2.X + p3 * v3.X;                  float vy = p0 * v0.Y + p1 * v1.Y + p2 * v2.Y + p3 * v3.Y;                    _geometryBuffer[_geometryIndex++] = new CCVector2(vx' vy);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildCubicBezierGeometryBuffer,The following statement contains a magic number: for (int i = 0; i < subdivisions; i++' t += step) {                  if (1 - t < 5e-6)                      t = 1;                    float p0 = Bernstein(3' 0' t);                  float p1 = Bernstein(3' 1' t);                  float p2 = Bernstein(3' 2' t);                  float p3 = Bernstein(3' 3' t);                    float vx = p0 * v0.X + p1 * v1.X + p2 * v2.X + p3 * v3.X;                  float vy = p0 * v0.Y + p1 * v1.Y + p2 * v2.Y + p3 * v3.Y;                    _geometryBuffer[_geometryIndex++] = new CCVector2(vx' vy);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildCubicBezierGeometryBuffer,The following statement contains a magic number: for (int i = 0; i < subdivisions; i++' t += step) {                  if (1 - t < 5e-6)                      t = 1;                    float p0 = Bernstein(3' 0' t);                  float p1 = Bernstein(3' 1' t);                  float p2 = Bernstein(3' 2' t);                  float p3 = Bernstein(3' 3' t);                    float vx = p0 * v0.X + p1 * v1.X + p2 * v2.X + p3 * v3.X;                  float vy = p0 * v0.Y + p1 * v1.Y + p2 * v2.Y + p3 * v3.Y;                    _geometryBuffer[_geometryIndex++] = new CCVector2(vx' vy);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,BuildCubicBezierGeometryBuffer,The following statement contains a magic number: for (int i = 0; i < subdivisions; i++' t += step) {                  if (1 - t < 5e-6)                      t = 1;                    float p0 = Bernstein(3' 0' t);                  float p1 = Bernstein(3' 1' t);                  float p2 = Bernstein(3' 2' t);                  float p3 = Bernstein(3' 3' t);                    float vx = p0 * v0.X + p1 * v1.X + p2 * v2.X + p3 * v3.X;                  float vy = p0 * v0.Y + p1 * v1.Y + p2 * v2.Y + p3 * v3.Y;                    _geometryBuffer[_geometryIndex++] = new CCVector2(vx' vy);              }
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,Factorial,The following statement contains a magic number: if (n < 0 || n > 32)                  throw new ArgumentOutOfRangeException("n"' "n must be between 0 and 32.");
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,PointToAngle,The following statement contains a magic number: if (angle < 0)                  angle += Math.PI * 2;
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,ClampAngle,The following statement contains a magic number: if (angle < 0)                  angle += (float)(Math.Ceiling(angle / (Math.PI * -2)) * Math.PI * 2);              else if (angle >= (Math.PI * 2))                  angle -= (float)(Math.Floor(angle / (Math.PI * 2)) * Math.PI * 2);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,ClampAngle,The following statement contains a magic number: if (angle < 0)                  angle += (float)(Math.Ceiling(angle / (Math.PI * -2)) * Math.PI * 2);              else if (angle >= (Math.PI * 2))                  angle -= (float)(Math.Floor(angle / (Math.PI * 2)) * Math.PI * 2);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,ClampAngle,The following statement contains a magic number: if (angle < 0)                  angle += (float)(Math.Ceiling(angle / (Math.PI * -2)) * Math.PI * 2);              else if (angle >= (Math.PI * 2))                  angle -= (float)(Math.Floor(angle / (Math.PI * 2)) * Math.PI * 2);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,ClampAngle,The following statement contains a magic number: if (angle < 0)                  angle += (float)(Math.Ceiling(angle / (Math.PI * -2)) * Math.PI * 2);              else if (angle >= (Math.PI * 2))                  angle -= (float)(Math.Floor(angle / (Math.PI * 2)) * Math.PI * 2);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,ClampAngle,The following statement contains a magic number: if (angle < 0)                  angle += (float)(Math.Ceiling(angle / (Math.PI * -2)) * Math.PI * 2);              else if (angle >= (Math.PI * 2))                  angle -= (float)(Math.Floor(angle / (Math.PI * 2)) * Math.PI * 2);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,DefaultSubdivisions,The following statement contains a magic number: return (int)Math.Ceiling(radius / 1.5);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,PointsClose,The following statement contains a magic number: return (Math.Abs(a.X - b.X) < 0.005 && Math.Abs(a.Y - b.Y) < 0.005);
Magic Number,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,PointsClose,The following statement contains a magic number: return (Math.Abs(a.X - b.X) < 0.005 && Math.Abs(a.Y - b.Y) < 0.005);
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,Pen,The following statement contains a magic number: JoinLimit = (float)(Math.PI / 8);
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,LineJoinVertexBound,The following statement contains a magic number: switch (LineJoin) {                  case LineJoin.Miter:                      return 3;                  case LineJoin.Bevel:                      return 3;              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,LineJoinVertexBound,The following statement contains a magic number: switch (LineJoin) {                  case LineJoin.Miter:                      return 3;                  case LineJoin.Bevel:                      return 3;              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,MaximumVertexCount,The following statement contains a magic number: switch (LineJoin) {                  case LineJoin.Bevel:                      expected += joinCount * 3;                      break;                    case LineJoin.Miter:                      expected += joinCount * 3;                      break;                    //case LineJoin.Round:                  //    expected += (int)Math.Ceiling(joinCount * (Width / 6f + 2));                  //    break;              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,MaximumVertexCount,The following statement contains a magic number: switch (LineJoin) {                  case LineJoin.Bevel:                      expected += joinCount * 3;                      break;                    case LineJoin.Miter:                      expected += joinCount * 3;                      break;                    //case LineJoin.Round:                  //    expected += (int)Math.Ceiling(joinCount * (Width / 6f + 2));                  //    break;              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,MaximumIndexCount,The following statement contains a magic number: return extra * 3 + (pointCount - 1) * 6;
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,MaximumIndexCount,The following statement contains a magic number: return extra * 3 + (pointCount - 1) * 6;
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeMiter,The following statement contains a magic number: switch (Alignment) {                  case PenAlignment.Center:                      float w2 = Width / 2;                        point2 = new CCVector2(a.X + w2 * edgeABt.X' a.Y + w2 * edgeABt.Y);                      point4 = new CCVector2(a.X - w2 * edgeABt.X' a.Y - w2 * edgeABt.Y);                        point1 = new CCVector2(c.X + w2 * edgeBCt.X' c.Y + w2 * edgeBCt.Y);                      point3 = new CCVector2(c.X - w2 * edgeBCt.X' c.Y - w2 * edgeBCt.Y);                      break;                    case PenAlignment.Inset:                      point2 = new CCVector2(a.X + Width * edgeABt.X' a.Y + Width * edgeABt.Y);                      point4 = a;                        point1 = new CCVector2(c.X + Width * edgeBCt.X' c.Y + Width * edgeBCt.Y);                      point3 = c;                      break;                    case PenAlignment.Outset:                      point2 = a;                      point4 = new CCVector2(a.X - Width * edgeABt.X' a.Y - Width * edgeABt.Y);                        point1 = c;                      point3 = new CCVector2(c.X - Width * edgeBCt.X' c.Y - Width * edgeBCt.Y);                      break;                    default:                      point2 = CCVector2.Zero;                      point4 = CCVector2.Zero;                        point1 = CCVector2.Zero;                      point3 = CCVector2.Zero;                      break;              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeMiter,The following statement contains a magic number: if (Math.Abs(tdiv) < .0005f) {                  point0 = new CCVector2((point2.X + point1.X) / 2' (point2.Y + point1.Y) / 2);                  point5 = new CCVector2((point4.X + point3.X) / 2' (point4.Y + point3.Y) / 2);              }              else {                  float offset01 = CCVector2.Dot(edgeBCt' point1);                  float t0 = (offset01 - CCVector2.Dot(edgeBCt' point2)) / tdiv;                    float offset35 = CCVector2.Dot(edgeBCt' point3);                  float t5 = (offset35 - CCVector2.Dot(edgeBCt' point4)) / tdiv;                    point0 = new CCVector2(point2.X + t0 * edgeAB.X' point2.Y + t0 * edgeAB.Y);                  point5 = new CCVector2(point4.X + t5 * edgeAB.X' point4.Y + t5 * edgeAB.Y);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeMiter,The following statement contains a magic number: if (Math.Abs(tdiv) < .0005f) {                  point0 = new CCVector2((point2.X + point1.X) / 2' (point2.Y + point1.Y) / 2);                  point5 = new CCVector2((point4.X + point3.X) / 2' (point4.Y + point3.Y) / 2);              }              else {                  float offset01 = CCVector2.Dot(edgeBCt' point1);                  float t0 = (offset01 - CCVector2.Dot(edgeBCt' point2)) / tdiv;                    float offset35 = CCVector2.Dot(edgeBCt' point3);                  float t5 = (offset35 - CCVector2.Dot(edgeBCt' point4)) / tdiv;                    point0 = new CCVector2(point2.X + t0 * edgeAB.X' point2.Y + t0 * edgeAB.Y);                  point5 = new CCVector2(point4.X + t5 * edgeAB.X' point4.Y + t5 * edgeAB.Y);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeMiter,The following statement contains a magic number: if (Math.Abs(tdiv) < .0005f) {                  point0 = new CCVector2((point2.X + point1.X) / 2' (point2.Y + point1.Y) / 2);                  point5 = new CCVector2((point4.X + point3.X) / 2' (point4.Y + point3.Y) / 2);              }              else {                  float offset01 = CCVector2.Dot(edgeBCt' point1);                  float t0 = (offset01 - CCVector2.Dot(edgeBCt' point2)) / tdiv;                    float offset35 = CCVector2.Dot(edgeBCt' point3);                  float t5 = (offset35 - CCVector2.Dot(edgeBCt' point4)) / tdiv;                    point0 = new CCVector2(point2.X + t0 * edgeAB.X' point2.Y + t0 * edgeAB.Y);                  point5 = new CCVector2(point4.X + t5 * edgeAB.X' point4.Y + t5 * edgeAB.Y);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeMiter,The following statement contains a magic number: if (Math.Abs(tdiv) < .0005f) {                  point0 = new CCVector2((point2.X + point1.X) / 2' (point2.Y + point1.Y) / 2);                  point5 = new CCVector2((point4.X + point3.X) / 2' (point4.Y + point3.Y) / 2);              }              else {                  float offset01 = CCVector2.Dot(edgeBCt' point1);                  float t0 = (offset01 - CCVector2.Dot(edgeBCt' point2)) / tdiv;                    float offset35 = CCVector2.Dot(edgeBCt' point3);                  float t5 = (offset35 - CCVector2.Dot(edgeBCt' point4)) / tdiv;                    point0 = new CCVector2(point2.X + t0 * edgeAB.X' point2.Y + t0 * edgeAB.Y);                  point5 = new CCVector2(point4.X + t5 * edgeAB.X' point4.Y + t5 * edgeAB.Y);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeBevel,The following statement contains a magic number: if (Cross2D(edgeAB' edgeBC) > 0) {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X - w2 * edgeABt.X' a.Y - w2 * edgeABt.Y);                          pointC = new CCVector2(c.X - w2 * edgeBCt.X' c.Y - w2 * edgeBCt.Y);                            ws.XYInsetBuffer[0] = new CCVector2(b.X + w2 * edgeABt.X' b.Y + w2 * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + w2 * edgeBCt.X' b.Y + w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          ws.XYInsetBuffer[0] = new CCVector2(b.X + Width * edgeABt.X' b.Y + Width * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + Width * edgeBCt.X' b.Y + Width * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Outset:                          pointA = new CCVector2(a.X - Width * edgeABt.X' a.Y - Width * edgeABt.Y);                          pointC = new CCVector2(c.X - Width * edgeBCt.X' c.Y - Width * edgeBCt.Y);                            ws.XYInsetBuffer[0] = b;                            vertexCount = 1;                          break;                  }                    CCVector2 point5;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point5 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset35 = CCVector2.Dot(edgeBCt' pointC);                      float t5 = (offset35 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point5 = new CCVector2(pointA.X + t5 * edgeAB.X' pointA.Y + t5 * edgeAB.Y);                  }                    ws.XYOutsetBuffer[0] = point5;                    ws.UVOutsetBuffer[0] = new CCVector2(1' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVInsetBuffer[i] = new CCVector2(0' js.LengthB);                    return new InsetOutsetCount(vertexCount' 1' false);              }              else {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X + w2 * edgeABt.X' a.Y + w2 * edgeABt.Y);                          pointC = new CCVector2(c.X + w2 * edgeBCt.X' c.Y + w2 * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = new CCVector2(b.X - w2 * edgeABt.X' b.Y - w2 * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - w2 * edgeBCt.X' b.Y - w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          pointA = new CCVector2(a.X + Width * edgeABt.X' a.Y + Width * edgeABt.Y);                          pointC = new CCVector2(c.X + Width * edgeBCt.X' c.Y + Width * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = b;                            vertexCount = 1;                          break;                        case PenAlignment.Outset:                          ws.XYOutsetBuffer[0] = new CCVector2(b.X - Width * edgeABt.X' b.Y - Width * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - Width * edgeBCt.X' b.Y - Width * edgeBCt.Y);                            vertexCount = 2;                          break;                  }                    CCVector2 point0;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point0 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset01 = CCVector2.Dot(edgeBCt' pointC);                      float t0 = (offset01 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point0 = new CCVector2(pointA.X + t0 * edgeAB.X' pointA.Y + t0 * edgeAB.Y);                  }                    ws.XYInsetBuffer[0] = point0;                    ws.UVInsetBuffer[0] = new CCVector2(0' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVOutsetBuffer[i] = new CCVector2(1' js.LengthB);                    return new InsetOutsetCount(1' vertexCount' true);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeBevel,The following statement contains a magic number: if (Cross2D(edgeAB' edgeBC) > 0) {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X - w2 * edgeABt.X' a.Y - w2 * edgeABt.Y);                          pointC = new CCVector2(c.X - w2 * edgeBCt.X' c.Y - w2 * edgeBCt.Y);                            ws.XYInsetBuffer[0] = new CCVector2(b.X + w2 * edgeABt.X' b.Y + w2 * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + w2 * edgeBCt.X' b.Y + w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          ws.XYInsetBuffer[0] = new CCVector2(b.X + Width * edgeABt.X' b.Y + Width * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + Width * edgeBCt.X' b.Y + Width * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Outset:                          pointA = new CCVector2(a.X - Width * edgeABt.X' a.Y - Width * edgeABt.Y);                          pointC = new CCVector2(c.X - Width * edgeBCt.X' c.Y - Width * edgeBCt.Y);                            ws.XYInsetBuffer[0] = b;                            vertexCount = 1;                          break;                  }                    CCVector2 point5;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point5 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset35 = CCVector2.Dot(edgeBCt' pointC);                      float t5 = (offset35 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point5 = new CCVector2(pointA.X + t5 * edgeAB.X' pointA.Y + t5 * edgeAB.Y);                  }                    ws.XYOutsetBuffer[0] = point5;                    ws.UVOutsetBuffer[0] = new CCVector2(1' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVInsetBuffer[i] = new CCVector2(0' js.LengthB);                    return new InsetOutsetCount(vertexCount' 1' false);              }              else {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X + w2 * edgeABt.X' a.Y + w2 * edgeABt.Y);                          pointC = new CCVector2(c.X + w2 * edgeBCt.X' c.Y + w2 * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = new CCVector2(b.X - w2 * edgeABt.X' b.Y - w2 * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - w2 * edgeBCt.X' b.Y - w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          pointA = new CCVector2(a.X + Width * edgeABt.X' a.Y + Width * edgeABt.Y);                          pointC = new CCVector2(c.X + Width * edgeBCt.X' c.Y + Width * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = b;                            vertexCount = 1;                          break;                        case PenAlignment.Outset:                          ws.XYOutsetBuffer[0] = new CCVector2(b.X - Width * edgeABt.X' b.Y - Width * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - Width * edgeBCt.X' b.Y - Width * edgeBCt.Y);                            vertexCount = 2;                          break;                  }                    CCVector2 point0;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point0 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset01 = CCVector2.Dot(edgeBCt' pointC);                      float t0 = (offset01 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point0 = new CCVector2(pointA.X + t0 * edgeAB.X' pointA.Y + t0 * edgeAB.Y);                  }                    ws.XYInsetBuffer[0] = point0;                    ws.UVInsetBuffer[0] = new CCVector2(0' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVOutsetBuffer[i] = new CCVector2(1' js.LengthB);                    return new InsetOutsetCount(1' vertexCount' true);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeBevel,The following statement contains a magic number: if (Cross2D(edgeAB' edgeBC) > 0) {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X - w2 * edgeABt.X' a.Y - w2 * edgeABt.Y);                          pointC = new CCVector2(c.X - w2 * edgeBCt.X' c.Y - w2 * edgeBCt.Y);                            ws.XYInsetBuffer[0] = new CCVector2(b.X + w2 * edgeABt.X' b.Y + w2 * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + w2 * edgeBCt.X' b.Y + w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          ws.XYInsetBuffer[0] = new CCVector2(b.X + Width * edgeABt.X' b.Y + Width * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + Width * edgeBCt.X' b.Y + Width * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Outset:                          pointA = new CCVector2(a.X - Width * edgeABt.X' a.Y - Width * edgeABt.Y);                          pointC = new CCVector2(c.X - Width * edgeBCt.X' c.Y - Width * edgeBCt.Y);                            ws.XYInsetBuffer[0] = b;                            vertexCount = 1;                          break;                  }                    CCVector2 point5;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point5 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset35 = CCVector2.Dot(edgeBCt' pointC);                      float t5 = (offset35 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point5 = new CCVector2(pointA.X + t5 * edgeAB.X' pointA.Y + t5 * edgeAB.Y);                  }                    ws.XYOutsetBuffer[0] = point5;                    ws.UVOutsetBuffer[0] = new CCVector2(1' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVInsetBuffer[i] = new CCVector2(0' js.LengthB);                    return new InsetOutsetCount(vertexCount' 1' false);              }              else {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X + w2 * edgeABt.X' a.Y + w2 * edgeABt.Y);                          pointC = new CCVector2(c.X + w2 * edgeBCt.X' c.Y + w2 * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = new CCVector2(b.X - w2 * edgeABt.X' b.Y - w2 * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - w2 * edgeBCt.X' b.Y - w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          pointA = new CCVector2(a.X + Width * edgeABt.X' a.Y + Width * edgeABt.Y);                          pointC = new CCVector2(c.X + Width * edgeBCt.X' c.Y + Width * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = b;                            vertexCount = 1;                          break;                        case PenAlignment.Outset:                          ws.XYOutsetBuffer[0] = new CCVector2(b.X - Width * edgeABt.X' b.Y - Width * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - Width * edgeBCt.X' b.Y - Width * edgeBCt.Y);                            vertexCount = 2;                          break;                  }                    CCVector2 point0;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point0 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset01 = CCVector2.Dot(edgeBCt' pointC);                      float t0 = (offset01 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point0 = new CCVector2(pointA.X + t0 * edgeAB.X' pointA.Y + t0 * edgeAB.Y);                  }                    ws.XYInsetBuffer[0] = point0;                    ws.UVInsetBuffer[0] = new CCVector2(0' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVOutsetBuffer[i] = new CCVector2(1' js.LengthB);                    return new InsetOutsetCount(1' vertexCount' true);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeBevel,The following statement contains a magic number: if (Cross2D(edgeAB' edgeBC) > 0) {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X - w2 * edgeABt.X' a.Y - w2 * edgeABt.Y);                          pointC = new CCVector2(c.X - w2 * edgeBCt.X' c.Y - w2 * edgeBCt.Y);                            ws.XYInsetBuffer[0] = new CCVector2(b.X + w2 * edgeABt.X' b.Y + w2 * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + w2 * edgeBCt.X' b.Y + w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          ws.XYInsetBuffer[0] = new CCVector2(b.X + Width * edgeABt.X' b.Y + Width * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + Width * edgeBCt.X' b.Y + Width * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Outset:                          pointA = new CCVector2(a.X - Width * edgeABt.X' a.Y - Width * edgeABt.Y);                          pointC = new CCVector2(c.X - Width * edgeBCt.X' c.Y - Width * edgeBCt.Y);                            ws.XYInsetBuffer[0] = b;                            vertexCount = 1;                          break;                  }                    CCVector2 point5;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point5 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset35 = CCVector2.Dot(edgeBCt' pointC);                      float t5 = (offset35 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point5 = new CCVector2(pointA.X + t5 * edgeAB.X' pointA.Y + t5 * edgeAB.Y);                  }                    ws.XYOutsetBuffer[0] = point5;                    ws.UVOutsetBuffer[0] = new CCVector2(1' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVInsetBuffer[i] = new CCVector2(0' js.LengthB);                    return new InsetOutsetCount(vertexCount' 1' false);              }              else {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X + w2 * edgeABt.X' a.Y + w2 * edgeABt.Y);                          pointC = new CCVector2(c.X + w2 * edgeBCt.X' c.Y + w2 * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = new CCVector2(b.X - w2 * edgeABt.X' b.Y - w2 * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - w2 * edgeBCt.X' b.Y - w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          pointA = new CCVector2(a.X + Width * edgeABt.X' a.Y + Width * edgeABt.Y);                          pointC = new CCVector2(c.X + Width * edgeBCt.X' c.Y + Width * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = b;                            vertexCount = 1;                          break;                        case PenAlignment.Outset:                          ws.XYOutsetBuffer[0] = new CCVector2(b.X - Width * edgeABt.X' b.Y - Width * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - Width * edgeBCt.X' b.Y - Width * edgeBCt.Y);                            vertexCount = 2;                          break;                  }                    CCVector2 point0;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point0 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset01 = CCVector2.Dot(edgeBCt' pointC);                      float t0 = (offset01 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point0 = new CCVector2(pointA.X + t0 * edgeAB.X' pointA.Y + t0 * edgeAB.Y);                  }                    ws.XYInsetBuffer[0] = point0;                    ws.UVInsetBuffer[0] = new CCVector2(0' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVOutsetBuffer[i] = new CCVector2(1' js.LengthB);                    return new InsetOutsetCount(1' vertexCount' true);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeBevel,The following statement contains a magic number: if (Cross2D(edgeAB' edgeBC) > 0) {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X - w2 * edgeABt.X' a.Y - w2 * edgeABt.Y);                          pointC = new CCVector2(c.X - w2 * edgeBCt.X' c.Y - w2 * edgeBCt.Y);                            ws.XYInsetBuffer[0] = new CCVector2(b.X + w2 * edgeABt.X' b.Y + w2 * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + w2 * edgeBCt.X' b.Y + w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          ws.XYInsetBuffer[0] = new CCVector2(b.X + Width * edgeABt.X' b.Y + Width * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + Width * edgeBCt.X' b.Y + Width * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Outset:                          pointA = new CCVector2(a.X - Width * edgeABt.X' a.Y - Width * edgeABt.Y);                          pointC = new CCVector2(c.X - Width * edgeBCt.X' c.Y - Width * edgeBCt.Y);                            ws.XYInsetBuffer[0] = b;                            vertexCount = 1;                          break;                  }                    CCVector2 point5;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point5 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset35 = CCVector2.Dot(edgeBCt' pointC);                      float t5 = (offset35 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point5 = new CCVector2(pointA.X + t5 * edgeAB.X' pointA.Y + t5 * edgeAB.Y);                  }                    ws.XYOutsetBuffer[0] = point5;                    ws.UVOutsetBuffer[0] = new CCVector2(1' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVInsetBuffer[i] = new CCVector2(0' js.LengthB);                    return new InsetOutsetCount(vertexCount' 1' false);              }              else {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X + w2 * edgeABt.X' a.Y + w2 * edgeABt.Y);                          pointC = new CCVector2(c.X + w2 * edgeBCt.X' c.Y + w2 * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = new CCVector2(b.X - w2 * edgeABt.X' b.Y - w2 * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - w2 * edgeBCt.X' b.Y - w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          pointA = new CCVector2(a.X + Width * edgeABt.X' a.Y + Width * edgeABt.Y);                          pointC = new CCVector2(c.X + Width * edgeBCt.X' c.Y + Width * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = b;                            vertexCount = 1;                          break;                        case PenAlignment.Outset:                          ws.XYOutsetBuffer[0] = new CCVector2(b.X - Width * edgeABt.X' b.Y - Width * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - Width * edgeBCt.X' b.Y - Width * edgeBCt.Y);                            vertexCount = 2;                          break;                  }                    CCVector2 point0;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point0 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset01 = CCVector2.Dot(edgeBCt' pointC);                      float t0 = (offset01 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point0 = new CCVector2(pointA.X + t0 * edgeAB.X' pointA.Y + t0 * edgeAB.Y);                  }                    ws.XYInsetBuffer[0] = point0;                    ws.UVInsetBuffer[0] = new CCVector2(0' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVOutsetBuffer[i] = new CCVector2(1' js.LengthB);                    return new InsetOutsetCount(1' vertexCount' true);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeBevel,The following statement contains a magic number: if (Cross2D(edgeAB' edgeBC) > 0) {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X - w2 * edgeABt.X' a.Y - w2 * edgeABt.Y);                          pointC = new CCVector2(c.X - w2 * edgeBCt.X' c.Y - w2 * edgeBCt.Y);                            ws.XYInsetBuffer[0] = new CCVector2(b.X + w2 * edgeABt.X' b.Y + w2 * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + w2 * edgeBCt.X' b.Y + w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          ws.XYInsetBuffer[0] = new CCVector2(b.X + Width * edgeABt.X' b.Y + Width * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + Width * edgeBCt.X' b.Y + Width * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Outset:                          pointA = new CCVector2(a.X - Width * edgeABt.X' a.Y - Width * edgeABt.Y);                          pointC = new CCVector2(c.X - Width * edgeBCt.X' c.Y - Width * edgeBCt.Y);                            ws.XYInsetBuffer[0] = b;                            vertexCount = 1;                          break;                  }                    CCVector2 point5;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point5 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset35 = CCVector2.Dot(edgeBCt' pointC);                      float t5 = (offset35 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point5 = new CCVector2(pointA.X + t5 * edgeAB.X' pointA.Y + t5 * edgeAB.Y);                  }                    ws.XYOutsetBuffer[0] = point5;                    ws.UVOutsetBuffer[0] = new CCVector2(1' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVInsetBuffer[i] = new CCVector2(0' js.LengthB);                    return new InsetOutsetCount(vertexCount' 1' false);              }              else {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X + w2 * edgeABt.X' a.Y + w2 * edgeABt.Y);                          pointC = new CCVector2(c.X + w2 * edgeBCt.X' c.Y + w2 * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = new CCVector2(b.X - w2 * edgeABt.X' b.Y - w2 * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - w2 * edgeBCt.X' b.Y - w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          pointA = new CCVector2(a.X + Width * edgeABt.X' a.Y + Width * edgeABt.Y);                          pointC = new CCVector2(c.X + Width * edgeBCt.X' c.Y + Width * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = b;                            vertexCount = 1;                          break;                        case PenAlignment.Outset:                          ws.XYOutsetBuffer[0] = new CCVector2(b.X - Width * edgeABt.X' b.Y - Width * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - Width * edgeBCt.X' b.Y - Width * edgeBCt.Y);                            vertexCount = 2;                          break;                  }                    CCVector2 point0;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point0 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset01 = CCVector2.Dot(edgeBCt' pointC);                      float t0 = (offset01 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point0 = new CCVector2(pointA.X + t0 * edgeAB.X' pointA.Y + t0 * edgeAB.Y);                  }                    ws.XYInsetBuffer[0] = point0;                    ws.UVInsetBuffer[0] = new CCVector2(0' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVOutsetBuffer[i] = new CCVector2(1' js.LengthB);                    return new InsetOutsetCount(1' vertexCount' true);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeBevel,The following statement contains a magic number: if (Cross2D(edgeAB' edgeBC) > 0) {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X - w2 * edgeABt.X' a.Y - w2 * edgeABt.Y);                          pointC = new CCVector2(c.X - w2 * edgeBCt.X' c.Y - w2 * edgeBCt.Y);                            ws.XYInsetBuffer[0] = new CCVector2(b.X + w2 * edgeABt.X' b.Y + w2 * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + w2 * edgeBCt.X' b.Y + w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          ws.XYInsetBuffer[0] = new CCVector2(b.X + Width * edgeABt.X' b.Y + Width * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + Width * edgeBCt.X' b.Y + Width * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Outset:                          pointA = new CCVector2(a.X - Width * edgeABt.X' a.Y - Width * edgeABt.Y);                          pointC = new CCVector2(c.X - Width * edgeBCt.X' c.Y - Width * edgeBCt.Y);                            ws.XYInsetBuffer[0] = b;                            vertexCount = 1;                          break;                  }                    CCVector2 point5;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point5 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset35 = CCVector2.Dot(edgeBCt' pointC);                      float t5 = (offset35 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point5 = new CCVector2(pointA.X + t5 * edgeAB.X' pointA.Y + t5 * edgeAB.Y);                  }                    ws.XYOutsetBuffer[0] = point5;                    ws.UVOutsetBuffer[0] = new CCVector2(1' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVInsetBuffer[i] = new CCVector2(0' js.LengthB);                    return new InsetOutsetCount(vertexCount' 1' false);              }              else {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X + w2 * edgeABt.X' a.Y + w2 * edgeABt.Y);                          pointC = new CCVector2(c.X + w2 * edgeBCt.X' c.Y + w2 * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = new CCVector2(b.X - w2 * edgeABt.X' b.Y - w2 * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - w2 * edgeBCt.X' b.Y - w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          pointA = new CCVector2(a.X + Width * edgeABt.X' a.Y + Width * edgeABt.Y);                          pointC = new CCVector2(c.X + Width * edgeBCt.X' c.Y + Width * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = b;                            vertexCount = 1;                          break;                        case PenAlignment.Outset:                          ws.XYOutsetBuffer[0] = new CCVector2(b.X - Width * edgeABt.X' b.Y - Width * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - Width * edgeBCt.X' b.Y - Width * edgeBCt.Y);                            vertexCount = 2;                          break;                  }                    CCVector2 point0;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point0 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset01 = CCVector2.Dot(edgeBCt' pointC);                      float t0 = (offset01 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point0 = new CCVector2(pointA.X + t0 * edgeAB.X' pointA.Y + t0 * edgeAB.Y);                  }                    ws.XYInsetBuffer[0] = point0;                    ws.UVInsetBuffer[0] = new CCVector2(0' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVOutsetBuffer[i] = new CCVector2(1' js.LengthB);                    return new InsetOutsetCount(1' vertexCount' true);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeBevel,The following statement contains a magic number: if (Cross2D(edgeAB' edgeBC) > 0) {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X - w2 * edgeABt.X' a.Y - w2 * edgeABt.Y);                          pointC = new CCVector2(c.X - w2 * edgeBCt.X' c.Y - w2 * edgeBCt.Y);                            ws.XYInsetBuffer[0] = new CCVector2(b.X + w2 * edgeABt.X' b.Y + w2 * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + w2 * edgeBCt.X' b.Y + w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          ws.XYInsetBuffer[0] = new CCVector2(b.X + Width * edgeABt.X' b.Y + Width * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + Width * edgeBCt.X' b.Y + Width * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Outset:                          pointA = new CCVector2(a.X - Width * edgeABt.X' a.Y - Width * edgeABt.Y);                          pointC = new CCVector2(c.X - Width * edgeBCt.X' c.Y - Width * edgeBCt.Y);                            ws.XYInsetBuffer[0] = b;                            vertexCount = 1;                          break;                  }                    CCVector2 point5;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point5 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset35 = CCVector2.Dot(edgeBCt' pointC);                      float t5 = (offset35 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point5 = new CCVector2(pointA.X + t5 * edgeAB.X' pointA.Y + t5 * edgeAB.Y);                  }                    ws.XYOutsetBuffer[0] = point5;                    ws.UVOutsetBuffer[0] = new CCVector2(1' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVInsetBuffer[i] = new CCVector2(0' js.LengthB);                    return new InsetOutsetCount(vertexCount' 1' false);              }              else {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X + w2 * edgeABt.X' a.Y + w2 * edgeABt.Y);                          pointC = new CCVector2(c.X + w2 * edgeBCt.X' c.Y + w2 * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = new CCVector2(b.X - w2 * edgeABt.X' b.Y - w2 * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - w2 * edgeBCt.X' b.Y - w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          pointA = new CCVector2(a.X + Width * edgeABt.X' a.Y + Width * edgeABt.Y);                          pointC = new CCVector2(c.X + Width * edgeBCt.X' c.Y + Width * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = b;                            vertexCount = 1;                          break;                        case PenAlignment.Outset:                          ws.XYOutsetBuffer[0] = new CCVector2(b.X - Width * edgeABt.X' b.Y - Width * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - Width * edgeBCt.X' b.Y - Width * edgeBCt.Y);                            vertexCount = 2;                          break;                  }                    CCVector2 point0;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point0 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset01 = CCVector2.Dot(edgeBCt' pointC);                      float t0 = (offset01 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point0 = new CCVector2(pointA.X + t0 * edgeAB.X' pointA.Y + t0 * edgeAB.Y);                  }                    ws.XYInsetBuffer[0] = point0;                    ws.UVInsetBuffer[0] = new CCVector2(0' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVOutsetBuffer[i] = new CCVector2(1' js.LengthB);                    return new InsetOutsetCount(1' vertexCount' true);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeBevel,The following statement contains a magic number: if (Cross2D(edgeAB' edgeBC) > 0) {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X - w2 * edgeABt.X' a.Y - w2 * edgeABt.Y);                          pointC = new CCVector2(c.X - w2 * edgeBCt.X' c.Y - w2 * edgeBCt.Y);                            ws.XYInsetBuffer[0] = new CCVector2(b.X + w2 * edgeABt.X' b.Y + w2 * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + w2 * edgeBCt.X' b.Y + w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          ws.XYInsetBuffer[0] = new CCVector2(b.X + Width * edgeABt.X' b.Y + Width * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + Width * edgeBCt.X' b.Y + Width * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Outset:                          pointA = new CCVector2(a.X - Width * edgeABt.X' a.Y - Width * edgeABt.Y);                          pointC = new CCVector2(c.X - Width * edgeBCt.X' c.Y - Width * edgeBCt.Y);                            ws.XYInsetBuffer[0] = b;                            vertexCount = 1;                          break;                  }                    CCVector2 point5;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point5 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset35 = CCVector2.Dot(edgeBCt' pointC);                      float t5 = (offset35 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point5 = new CCVector2(pointA.X + t5 * edgeAB.X' pointA.Y + t5 * edgeAB.Y);                  }                    ws.XYOutsetBuffer[0] = point5;                    ws.UVOutsetBuffer[0] = new CCVector2(1' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVInsetBuffer[i] = new CCVector2(0' js.LengthB);                    return new InsetOutsetCount(vertexCount' 1' false);              }              else {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X + w2 * edgeABt.X' a.Y + w2 * edgeABt.Y);                          pointC = new CCVector2(c.X + w2 * edgeBCt.X' c.Y + w2 * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = new CCVector2(b.X - w2 * edgeABt.X' b.Y - w2 * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - w2 * edgeBCt.X' b.Y - w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          pointA = new CCVector2(a.X + Width * edgeABt.X' a.Y + Width * edgeABt.Y);                          pointC = new CCVector2(c.X + Width * edgeBCt.X' c.Y + Width * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = b;                            vertexCount = 1;                          break;                        case PenAlignment.Outset:                          ws.XYOutsetBuffer[0] = new CCVector2(b.X - Width * edgeABt.X' b.Y - Width * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - Width * edgeBCt.X' b.Y - Width * edgeBCt.Y);                            vertexCount = 2;                          break;                  }                    CCVector2 point0;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point0 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset01 = CCVector2.Dot(edgeBCt' pointC);                      float t0 = (offset01 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point0 = new CCVector2(pointA.X + t0 * edgeAB.X' pointA.Y + t0 * edgeAB.Y);                  }                    ws.XYInsetBuffer[0] = point0;                    ws.UVInsetBuffer[0] = new CCVector2(0' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVOutsetBuffer[i] = new CCVector2(1' js.LengthB);                    return new InsetOutsetCount(1' vertexCount' true);              }
Magic Number,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeBevel,The following statement contains a magic number: if (Cross2D(edgeAB' edgeBC) > 0) {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X - w2 * edgeABt.X' a.Y - w2 * edgeABt.Y);                          pointC = new CCVector2(c.X - w2 * edgeBCt.X' c.Y - w2 * edgeBCt.Y);                            ws.XYInsetBuffer[0] = new CCVector2(b.X + w2 * edgeABt.X' b.Y + w2 * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + w2 * edgeBCt.X' b.Y + w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          ws.XYInsetBuffer[0] = new CCVector2(b.X + Width * edgeABt.X' b.Y + Width * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + Width * edgeBCt.X' b.Y + Width * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Outset:                          pointA = new CCVector2(a.X - Width * edgeABt.X' a.Y - Width * edgeABt.Y);                          pointC = new CCVector2(c.X - Width * edgeBCt.X' c.Y - Width * edgeBCt.Y);                            ws.XYInsetBuffer[0] = b;                            vertexCount = 1;                          break;                  }                    CCVector2 point5;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point5 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset35 = CCVector2.Dot(edgeBCt' pointC);                      float t5 = (offset35 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point5 = new CCVector2(pointA.X + t5 * edgeAB.X' pointA.Y + t5 * edgeAB.Y);                  }                    ws.XYOutsetBuffer[0] = point5;                    ws.UVOutsetBuffer[0] = new CCVector2(1' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVInsetBuffer[i] = new CCVector2(0' js.LengthB);                    return new InsetOutsetCount(vertexCount' 1' false);              }              else {                  switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X + w2 * edgeABt.X' a.Y + w2 * edgeABt.Y);                          pointC = new CCVector2(c.X + w2 * edgeBCt.X' c.Y + w2 * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = new CCVector2(b.X - w2 * edgeABt.X' b.Y - w2 * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - w2 * edgeBCt.X' b.Y - w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          pointA = new CCVector2(a.X + Width * edgeABt.X' a.Y + Width * edgeABt.Y);                          pointC = new CCVector2(c.X + Width * edgeBCt.X' c.Y + Width * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = b;                            vertexCount = 1;                          break;                        case PenAlignment.Outset:                          ws.XYOutsetBuffer[0] = new CCVector2(b.X - Width * edgeABt.X' b.Y - Width * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - Width * edgeBCt.X' b.Y - Width * edgeBCt.Y);                            vertexCount = 2;                          break;                  }                    CCVector2 point0;                    float tdiv = CCVector2.Dot(edgeBCt' edgeAB);                  if (Math.Abs(tdiv) < 0.0005f) {                      point0 = new CCVector2((pointA.X + pointC.X) / 2' (pointA.Y + pointC.Y) / 2);                  }                  else {                      float offset01 = CCVector2.Dot(edgeBCt' pointC);                      float t0 = (offset01 - CCVector2.Dot(edgeBCt' pointA)) / tdiv;                        point0 = new CCVector2(pointA.X + t0 * edgeAB.X' pointA.Y + t0 * edgeAB.Y);                  }                    ws.XYInsetBuffer[0] = point0;                    ws.UVInsetBuffer[0] = new CCVector2(0' js.LengthB);                  for (int i = 0; i < vertexCount; i++)                      ws.UVOutsetBuffer[i] = new CCVector2(1' js.LengthB);                    return new InsetOutsetCount(1' vertexCount' true);              }
Magic Number,LilyPath,Triangulator,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Triangulator.cs,Triangulate,The following statement contains a magic number: while (count >= 3) {                  bool isEar = true;                    CCVector2 a = points[offset + _triPrev[index]];                  CCVector2 b = points[offset + index];                  CCVector2 c = points[offset + _triNext[index]];                  if (TriangleIsCCW(a' b' c)) {                      int k = _triNext[_triNext[index]];                      do {                          if (PointInTriangleInclusive(points[offset + k]' a' b' c)) {                              isEar = false;                              break;                          }                          k = _triNext[k];                      } while (k != _triPrev[index]);                  }                  else {                      isEar = false;                  }                    if (isEar) {                      if (_indexComputeBuffer.Length < computeIndex + 3)                          Array.Resize(ref _indexComputeBuffer' _indexComputeBuffer.Length * 2);                        _indexComputeBuffer[computeIndex++] = offset + _triPrev[index];                      _indexComputeBuffer[computeIndex++] = offset + index;                      _indexComputeBuffer[computeIndex++] = offset + _triNext[index];                        _triNext[_triPrev[index]] = _triNext[index];                      _triPrev[_triNext[index]] = _triPrev[index];                      count--;                      index = _triPrev[index];                  }                  else {                      index = _triNext[index];                  }              }
Magic Number,LilyPath,Triangulator,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Triangulator.cs,Triangulate,The following statement contains a magic number: while (count >= 3) {                  bool isEar = true;                    CCVector2 a = points[offset + _triPrev[index]];                  CCVector2 b = points[offset + index];                  CCVector2 c = points[offset + _triNext[index]];                  if (TriangleIsCCW(a' b' c)) {                      int k = _triNext[_triNext[index]];                      do {                          if (PointInTriangleInclusive(points[offset + k]' a' b' c)) {                              isEar = false;                              break;                          }                          k = _triNext[k];                      } while (k != _triPrev[index]);                  }                  else {                      isEar = false;                  }                    if (isEar) {                      if (_indexComputeBuffer.Length < computeIndex + 3)                          Array.Resize(ref _indexComputeBuffer' _indexComputeBuffer.Length * 2);                        _indexComputeBuffer[computeIndex++] = offset + _triPrev[index];                      _indexComputeBuffer[computeIndex++] = offset + index;                      _indexComputeBuffer[computeIndex++] = offset + _triNext[index];                        _triNext[_triPrev[index]] = _triNext[index];                      _triPrev[_triNext[index]] = _triPrev[index];                      count--;                      index = _triPrev[index];                  }                  else {                      index = _triNext[index];                  }              }
Magic Number,LilyPath,Triangulator,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Triangulator.cs,Triangulate,The following statement contains a magic number: while (count >= 3) {                  bool isEar = true;                    CCVector2 a = points[offset + _triPrev[index]];                  CCVector2 b = points[offset + index];                  CCVector2 c = points[offset + _triNext[index]];                  if (TriangleIsCCW(a' b' c)) {                      int k = _triNext[_triNext[index]];                      do {                          if (PointInTriangleInclusive(points[offset + k]' a' b' c)) {                              isEar = false;                              break;                          }                          k = _triNext[k];                      } while (k != _triPrev[index]);                  }                  else {                      isEar = false;                  }                    if (isEar) {                      if (_indexComputeBuffer.Length < computeIndex + 3)                          Array.Resize(ref _indexComputeBuffer' _indexComputeBuffer.Length * 2);                        _indexComputeBuffer[computeIndex++] = offset + _triPrev[index];                      _indexComputeBuffer[computeIndex++] = offset + index;                      _indexComputeBuffer[computeIndex++] = offset + _triNext[index];                        _triNext[_triPrev[index]] = _triNext[index];                      _triPrev[_triNext[index]] = _triPrev[index];                      count--;                      index = _triPrev[index];                  }                  else {                      index = _triNext[index];                  }              }
Magic Number,LilyPath,Triangulator,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Triangulator.cs,Initialize,The following statement contains a magic number: if (_triNext.Length < count)                  Array.Resize(ref _triNext' Math.Max(_triNext.Length * 2' count));
Magic Number,LilyPath,Triangulator,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Triangulator.cs,Initialize,The following statement contains a magic number: if (_triPrev.Length < count)                  Array.Resize(ref _triPrev' Math.Min(_triPrev.Length * 2' count));
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Grid,The following statement contains a magic number: _vertexBuffer = new VertexPositionColorTexture[pointCount * 4];
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Grid,The following statement contains a magic number: _indexBuffer = new short[(pointCount * 2 + vsegCount * 2 + hsegCount * 2) * 3];
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Grid,The following statement contains a magic number: _indexBuffer = new short[(pointCount * 2 + vsegCount * 2 + hsegCount * 2) * 3];
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Grid,The following statement contains a magic number: _indexBuffer = new short[(pointCount * 2 + vsegCount * 2 + hsegCount * 2) * 3];
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Grid,The following statement contains a magic number: _indexBuffer = new short[(pointCount * 2 + vsegCount * 2 + hsegCount * 2) * 3];
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: float w2 = pen.Width / 2;
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y <= _rows; y++) {                  for (int x = 0; x <= _columns; x++) {                      float px = left + (width / _columns) * x;                      float py = top + (height / _rows) * y;                        AddVertex(_vertexBuffer' vIndex + 0' px - w2' py - w2' pen.ColorAt(0' 0' 0));                      AddVertex(_vertexBuffer' vIndex + 1' px + w2' py - w2' pen.ColorAt(0' 0' 0));                      AddVertex(_vertexBuffer' vIndex + 2' px - w2' py + w2' pen.ColorAt(0' 0' 0));                      AddVertex(_vertexBuffer' vIndex + 3' px + w2' py + w2' pen.ColorAt(0' 0' 0));                        AddQuad(_indexBuffer' iIndex' vIndex);                        vIndex += 4;                      iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y <= _rows; y++) {                  for (int x = 0; x <= _columns; x++) {                      float px = left + (width / _columns) * x;                      float py = top + (height / _rows) * y;                        AddVertex(_vertexBuffer' vIndex + 0' px - w2' py - w2' pen.ColorAt(0' 0' 0));                      AddVertex(_vertexBuffer' vIndex + 1' px + w2' py - w2' pen.ColorAt(0' 0' 0));                      AddVertex(_vertexBuffer' vIndex + 2' px - w2' py + w2' pen.ColorAt(0' 0' 0));                      AddVertex(_vertexBuffer' vIndex + 3' px + w2' py + w2' pen.ColorAt(0' 0' 0));                        AddQuad(_indexBuffer' iIndex' vIndex);                        vIndex += 4;                      iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y <= _rows; y++) {                  for (int x = 0; x <= _columns; x++) {                      float px = left + (width / _columns) * x;                      float py = top + (height / _rows) * y;                        AddVertex(_vertexBuffer' vIndex + 0' px - w2' py - w2' pen.ColorAt(0' 0' 0));                      AddVertex(_vertexBuffer' vIndex + 1' px + w2' py - w2' pen.ColorAt(0' 0' 0));                      AddVertex(_vertexBuffer' vIndex + 2' px - w2' py + w2' pen.ColorAt(0' 0' 0));                      AddVertex(_vertexBuffer' vIndex + 3' px + w2' py + w2' pen.ColorAt(0' 0' 0));                        AddQuad(_indexBuffer' iIndex' vIndex);                        vIndex += 4;                      iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y <= _rows; y++) {                  for (int x = 0; x <= _columns; x++) {                      float px = left + (width / _columns) * x;                      float py = top + (height / _rows) * y;                        AddVertex(_vertexBuffer' vIndex + 0' px - w2' py - w2' pen.ColorAt(0' 0' 0));                      AddVertex(_vertexBuffer' vIndex + 1' px + w2' py - w2' pen.ColorAt(0' 0' 0));                      AddVertex(_vertexBuffer' vIndex + 2' px - w2' py + w2' pen.ColorAt(0' 0' 0));                      AddVertex(_vertexBuffer' vIndex + 3' px + w2' py + w2' pen.ColorAt(0' 0' 0));                        AddQuad(_indexBuffer' iIndex' vIndex);                        vIndex += 4;                      iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y < _rows; y++) {                  for (int x = 0; x <= _columns; x++) {                      int baseV1 = (y * (_columns + 1) + x) * 4;                      int baseV2 = ((y + 1) * (_columns + 1) + x) * 4;                        AddQuad(_indexBuffer' iIndex' (short)(baseV1 + 2)' (short)(baseV1 + 3)' (short)(baseV2 + 0)' (short)(baseV2 + 1));                        iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y < _rows; y++) {                  for (int x = 0; x <= _columns; x++) {                      int baseV1 = (y * (_columns + 1) + x) * 4;                      int baseV2 = ((y + 1) * (_columns + 1) + x) * 4;                        AddQuad(_indexBuffer' iIndex' (short)(baseV1 + 2)' (short)(baseV1 + 3)' (short)(baseV2 + 0)' (short)(baseV2 + 1));                        iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y < _rows; y++) {                  for (int x = 0; x <= _columns; x++) {                      int baseV1 = (y * (_columns + 1) + x) * 4;                      int baseV2 = ((y + 1) * (_columns + 1) + x) * 4;                        AddQuad(_indexBuffer' iIndex' (short)(baseV1 + 2)' (short)(baseV1 + 3)' (short)(baseV2 + 0)' (short)(baseV2 + 1));                        iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y < _rows; y++) {                  for (int x = 0; x <= _columns; x++) {                      int baseV1 = (y * (_columns + 1) + x) * 4;                      int baseV2 = ((y + 1) * (_columns + 1) + x) * 4;                        AddQuad(_indexBuffer' iIndex' (short)(baseV1 + 2)' (short)(baseV1 + 3)' (short)(baseV2 + 0)' (short)(baseV2 + 1));                        iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y < _rows; y++) {                  for (int x = 0; x <= _columns; x++) {                      int baseV1 = (y * (_columns + 1) + x) * 4;                      int baseV2 = ((y + 1) * (_columns + 1) + x) * 4;                        AddQuad(_indexBuffer' iIndex' (short)(baseV1 + 2)' (short)(baseV1 + 3)' (short)(baseV2 + 0)' (short)(baseV2 + 1));                        iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y <= _rows; y++) {                  for (int x = 0; x < _columns; x++) {                      int baseV1 = (y * (_columns + 1) + x) * 4;                      int baseV2 = baseV1 + 4;                        AddQuad(_indexBuffer' iIndex' (short)(baseV1 + 1)' (short)(baseV2 + 0)' (short)(baseV1 + 3)' (short)(baseV2 + 2));                        iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y <= _rows; y++) {                  for (int x = 0; x < _columns; x++) {                      int baseV1 = (y * (_columns + 1) + x) * 4;                      int baseV2 = baseV1 + 4;                        AddQuad(_indexBuffer' iIndex' (short)(baseV1 + 1)' (short)(baseV2 + 0)' (short)(baseV1 + 3)' (short)(baseV2 + 2));                        iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y <= _rows; y++) {                  for (int x = 0; x < _columns; x++) {                      int baseV1 = (y * (_columns + 1) + x) * 4;                      int baseV2 = baseV1 + 4;                        AddQuad(_indexBuffer' iIndex' (short)(baseV1 + 1)' (short)(baseV2 + 0)' (short)(baseV1 + 3)' (short)(baseV2 + 2));                        iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y <= _rows; y++) {                  for (int x = 0; x < _columns; x++) {                      int baseV1 = (y * (_columns + 1) + x) * 4;                      int baseV2 = baseV1 + 4;                        AddQuad(_indexBuffer' iIndex' (short)(baseV1 + 1)' (short)(baseV2 + 0)' (short)(baseV1 + 3)' (short)(baseV2 + 2));                        iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,Compile,The following statement contains a magic number: for (int y = 0; y <= _rows; y++) {                  for (int x = 0; x < _columns; x++) {                      int baseV1 = (y * (_columns + 1) + x) * 4;                      int baseV2 = baseV1 + 4;                        AddQuad(_indexBuffer' iIndex' (short)(baseV1 + 1)' (short)(baseV2 + 0)' (short)(baseV1 + 3)' (short)(baseV2 + 2));                        iIndex += 6;                  }              }
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddQuad,The following statement contains a magic number: buffer[iIndex + 0] = (short)(vIndex + 2);
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddQuad,The following statement contains a magic number: buffer[iIndex + 2] = (short)(vIndex + 1);
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddQuad,The following statement contains a magic number: buffer[iIndex + 3] = (short)(vIndex + 2);
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddQuad,The following statement contains a magic number: buffer[iIndex + 3] = (short)(vIndex + 2);
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddQuad,The following statement contains a magic number: buffer[iIndex + 4] = (short)(vIndex + 1);
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddQuad,The following statement contains a magic number: buffer[iIndex + 5] = (short)(vIndex + 3);
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddQuad,The following statement contains a magic number: buffer[iIndex + 5] = (short)(vIndex + 3);
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddQuad,The following statement contains a magic number: buffer[index + 2] = tr;
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddQuad,The following statement contains a magic number: buffer[index + 3] = bl;
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddQuad,The following statement contains a magic number: buffer[index + 4] = tr;
Magic Number,LilyPath.Shapes,Grid,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Shapes\Grid.cs,AddQuad,The following statement contains a magic number: buffer[index + 5] = br;
Magic Number,LilyPath.Utility,Buffer<T>,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Utility\Buffer.cs,EnsureCapacity,The following statement contains a magic number: if (capacity > _buffer.Length) {                  capacity = 1 << (int)Math.Ceiling(Math.Log(capacity' 2));                    T[] newBuffer = new T[capacity];                  Array.Copy(_buffer' newBuffer' _buffer.Length);                  _buffer = newBuffer;              }
Magic Number,LilyPath.Utility,PenWorkspace,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Utility\PenWorkspace.cs,PenWorkspace,The following statement contains a magic number: BoundingQuad = new CCVector2[4];
Magic Number,LilyPath.Utility,PenWorkspace,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Utility\PenWorkspace.cs,PenWorkspace,The following statement contains a magic number: BoundingQuad = new CCVector2[4];
Missing Default,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The following switch statement is missing a default case: switch (bezierType)              {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Missing Default,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawBeziers,The following switch statement is missing a default case: switch (pathType)              {                  case PathType.Open:                      AddPath(_pathBuilder.Buffer' 0' _pathBuilder.Count' pen' _ws);                      break;                    case PathType.Closed:                      AddClosedPath(_pathBuilder.Buffer' 0' _pathBuilder.Count - 1' pen' _ws);                      break;              }
Missing Default,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The following switch statement is missing a default case: switch (bezierType) {                  case BezierType.Quadratic:                      for (int i = offset + 2; i < offset + count; i += 2)                          _pathBuilder.AddBezier(points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;                    case BezierType.Cubic:                      for (int i = offset + 3; i < offset + count; i += 3)                          _pathBuilder.AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      if (pathType == PathType.Closed)                          _pathBuilder.AddBezier(points[offset + count - 3]' points[offset + count - 2]' points[offset + count - 1]' points[offset]);                      break;              }
Missing Default,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,DrawPrimitiveBeziers,The following switch statement is missing a default case: switch (pathType) {                  case PathType.Open:                      DrawPrimitivePath(pen' _pathBuilder.Buffer' 0' _pathBuilder.Count' PathType.Open);                      break;                    case PathType.Closed:                      DrawPrimitivePath(pen' _pathBuilder.Buffer' 0' _pathBuilder.Count - 1' PathType.Closed);                      break;              }
Missing Default,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,FillArc,The following switch statement is missing a default case: switch (arcType) {                  case ArcType.Sector:                      AddVertex(new CCVector2(center.X' center.Y)' brush);                      break;                  case ArcType.Segment:                      AddVertex(new CCVector2((_geometryBuffer[0].X + _geometryBuffer[vertexCount - 1].X) / 2'                          (_geometryBuffer[0].Y + _geometryBuffer[vertexCount - 1].Y) / 2)' brush);                      break;              }
Missing Default,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,RenderBatch,The following switch statement is missing a default case: switch (primitiveType) {                  case PrimitiveType.LineList:                      //_device.DrawUserIndexedPrimitives(primitiveType' _vertexBuffer' vertexOffset' vertexCount' _indexBuffer' indexOffset' indexCount / 2);                      for (int io = indexOffset' ic = 0; ic < indexCount; ic++' io++)                      {                          packet.Indicies[ic] = _indexBuffer[io];                      }                      for (int tli = 0' tlo = vertexOffset; tli < vertexCount; tli++' tlo++)                      {                            var vertext = _vertexBuffer[tlo];                          var ccvertext = packet.Vertices[tli];                          ccvertext.Colors = ccvertext.Colors = vertext.Color.ToCCColor4B();                                                    //ccvertext.TexCoords.U = vertext.TextureCoordinate.X;                          //ccvertext.TexCoords.V = vertext.TextureCoordinate.Y;                          ccvertext.Vertices = new CCVertex3F(vertext.Position.X' vertext.Position.Y' vertext.Position.Z);                          packet.Vertices[tli] = ccvertext;                      }                      break;                  case PrimitiveType.TriangleList:                      //_device.DrawUserIndexedPrimitives(primitiveType' _vertexBuffer' vertexOffset' vertexCount' _indexBuffer' indexOffset' indexCount / 3);                      for (int io = indexOffset' ic = 0; ic < indexCount; ic++' io++)                      {                          packet.Indicies[ic] = _indexBuffer[io];                      }                      for (int tli = 0' tlo = vertexOffset; tli < vertexCount; tli++' tlo++)                      {                            var vertext = _vertexBuffer[tlo];                          var ccvertext = packet.Vertices[tli];                          ccvertext.Colors = vertext.Color.ToCCColor4B();                            ccvertext.TexCoords.U = vertext.TextureCoordinate.X;                          ccvertext.TexCoords.V = vertext.TextureCoordinate.Y;                          ccvertext.Vertices = new CCVertex3F(vertext.Position.X' vertext.Position.Y' vertext.Position.Z);                          packet.Vertices[tli] = ccvertext;                          }                        break;              }
Missing Default,LilyPath,DrawBatch,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\DrawBatch.cs,RenderBatch,The following switch statement is missing a default case: switch (primitiveType)              {                  case PrimitiveType.LineList:                      //_device.DrawUserIndexedPrimitives(primitiveType' _vertexBuffer' vertexOffset' vertexCount' _indexBuffer' indexOffset' indexCount / 2);                      for (int io = indexOffset' ic = 0; ic < indexCount; ic++' io++)                      {                          packet.Indicies[ic] = _indexBuffer[io];                      }                      for (int tli = 0' tlo = vertexOffset; tli < vertexCount; tli++' tlo++)                      {                            var vertext = _vertexBuffer[tlo];                          var ccvertext = packet.Vertices[tli];                          ccvertext.Colors = new CCColor4B(vertext.Color.R' vertext.Color.G' vertext.Color.B' vertext.Color.A);                          ccvertext.Vertices = new CCVertex3F(vertext.Position.X' vertext.Position.Y' vertext.Position.Z);                          packet.Vertices[tli] = ccvertext;                      }                      break;                  case PrimitiveType.TriangleList:                      //_device.DrawUserIndexedPrimitives(primitiveType' _vertexBuffer' vertexOffset' vertexCount' _indexBuffer' indexOffset' indexCount / 3);                      for (int io = indexOffset' ic = 0; ic < indexCount; ic++' io++)                      {                          packet.Indicies[ic] = _indexBuffer[io];                      }                      for (int tli = 0' tlo = vertexOffset; tli < vertexCount; tli++' tlo++)                      {                            var vertext = _vertexBuffer[tlo];                          var ccvertext = packet.Vertices[tli];                          ccvertext.Colors = vertext.Color.ToCCColor4B();                            ccvertext.TexCoords.U = vertext.TextureCoordinate.X;                          ccvertext.TexCoords.V = vertext.TextureCoordinate.Y;                          ccvertext.Vertices = new CCVertex3F(vertext.Position.X' vertext.Position.Y' vertext.Position.Z);                          packet.Vertices[tli] = ccvertext;                          }                        break;              }
Missing Default,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,GraphicsPath,The following switch statement is missing a default case: switch (pathType) {                  case PathType.Open:                      CompileOpenPath(points' null' offset' count' null);                      break;                    case PathType.Closed:                      CompileClosedPath(points' null' offset' count' null);                      break;              }
Missing Default,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,GraphicsPath,The following switch statement is missing a default case: switch (pathType) {                  case PathType.Open:                      CompileOpenPath(points' lengths' offset' count' null);                      break;                    case PathType.Closed:                      CompileClosedPath(points' lengths' offset' count' null);                      break;              }
Missing Default,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,GraphicsPath,The following switch statement is missing a default case: switch (pathType) {                  case PathType.Open:                      CompileOpenPath(points' null' offset' count' outlinePen);                      break;                    case PathType.Closed:                      CompileClosedPath(points' null' offset' count' outlinePen);                      break;              }
Missing Default,LilyPath,GraphicsPath,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\GraphicsPath.cs,AddJoint,The following switch statement is missing a default case: switch (_pen.LineJoin) {                  case LineJoin.Miter:                      vioCount = _pen.ComputeMiter(ref joinSample' ws);                      break;                  case LineJoin.Bevel:                      vioCount = _pen.ComputeBevel(ref joinSample' ws);                      break;              }
Missing Default,LilyPath,LineCapInfo,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\LineCapInfo.cs,Calculate,The following switch statement is missing a default case: switch (alignment) {                  case PenAlignment.Center:                      break;                    case PenAlignment.Inset:                      if (start) {                          tX = p.X + (-.5f * tS);                          tY = p.Y - (-.5f * tC);                      }                      else {                          tX = p.X - (-.5f * tS);                          tY = p.Y + (-.5f * tC);                      }                      break;                    case PenAlignment.Outset:                      if (start) {                          tX = p.X + (.5f * tS);                          tY = p.Y - (.5f * tC);                      }                      else {                          tX = p.X - (.5f * tS);                          tY = p.Y + (.5f * tC);                      }                      break;              }
Missing Default,LilyPath,PathBuilder,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\PathBuilder.cs,AddBeziers,The following switch statement is missing a default case: switch (bezierType) {                  case BezierType.Quadratic:                      if (length < 3)                          throw new ArgumentOutOfRangeException("A quadratic bezier needs at least 3 points");                      for (int i = offset + 2; i < offset + length; i += 2)                          AddBezier(points[i - 2]' points[i - 1]' points[i]);                      break;                    case BezierType.Cubic:                      if (length < 4)                          throw new ArgumentOutOfRangeException("A cubic bezier needs at least 4 points");                      for (int i = offset + 3; i < offset + length; i += 3)                          AddBezier(points[i - 3]' points[i - 2]' points[i - 1]' points[i]);                      break;              }
Missing Default,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,CreateLineCapInfo,The following switch statement is missing a default case: switch (lineCapType) {                  case LineCap.Flat:                      return new LineCapFlat(width);                  case LineCap.Square:                      return new LineCapSquare(width);                  case LineCap.Triangle:                      return new LineCapTriangle(width);                  case LineCap.InvTriangle:                      return new LineCapInvTriangle(width);                  case LineCap.Arrow:                      return new LineCapArrow(width);              }
Missing Default,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,LineJoinVertexBound,The following switch statement is missing a default case: switch (LineJoin) {                  case LineJoin.Miter:                      return 3;                  case LineJoin.Bevel:                      return 3;              }
Missing Default,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,MaximumVertexCount,The following switch statement is missing a default case: switch (LineJoin) {                  case LineJoin.Bevel:                      expected += joinCount * 3;                      break;                    case LineJoin.Miter:                      expected += joinCount * 3;                      break;                    //case LineJoin.Round:                  //    expected += (int)Math.Ceiling(joinCount * (Width / 6f + 2));                  //    break;              }
Missing Default,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,MaximumIndexCount,The following switch statement is missing a default case: switch (LineJoin) {                  case LineJoin.Bevel:                      extra += joinCount;                      break;                    case LineJoin.Miter:                      extra += joinCount;                      break;                    //case LineJoin.Round:                  //    extra += (int)Math.Ceiling(joinCount * (Width / 6f));                  //    break;              }
Missing Default,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeBevel,The following switch statement is missing a default case: switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X - w2 * edgeABt.X' a.Y - w2 * edgeABt.Y);                          pointC = new CCVector2(c.X - w2 * edgeBCt.X' c.Y - w2 * edgeBCt.Y);                            ws.XYInsetBuffer[0] = new CCVector2(b.X + w2 * edgeABt.X' b.Y + w2 * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + w2 * edgeBCt.X' b.Y + w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          ws.XYInsetBuffer[0] = new CCVector2(b.X + Width * edgeABt.X' b.Y + Width * edgeABt.Y);                          ws.XYInsetBuffer[1] = new CCVector2(b.X + Width * edgeBCt.X' b.Y + Width * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Outset:                          pointA = new CCVector2(a.X - Width * edgeABt.X' a.Y - Width * edgeABt.Y);                          pointC = new CCVector2(c.X - Width * edgeBCt.X' c.Y - Width * edgeBCt.Y);                            ws.XYInsetBuffer[0] = b;                            vertexCount = 1;                          break;                  }
Missing Default,LilyPath,Pen,C:\repos\mono_cocos-sharp-samples\CSLilyPath\LilyPath\Pen.cs,ComputeBevel,The following switch statement is missing a default case: switch (Alignment) {                      case PenAlignment.Center:                          float w2 = Width / 2;                          pointA = new CCVector2(a.X + w2 * edgeABt.X' a.Y + w2 * edgeABt.Y);                          pointC = new CCVector2(c.X + w2 * edgeBCt.X' c.Y + w2 * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = new CCVector2(b.X - w2 * edgeABt.X' b.Y - w2 * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - w2 * edgeBCt.X' b.Y - w2 * edgeBCt.Y);                            vertexCount = 2;                          break;                        case PenAlignment.Inset:                          pointA = new CCVector2(a.X + Width * edgeABt.X' a.Y + Width * edgeABt.Y);                          pointC = new CCVector2(c.X + Width * edgeBCt.X' c.Y + Width * edgeBCt.Y);                            ws.XYOutsetBuffer[0] = b;                            vertexCount = 1;                          break;                        case PenAlignment.Outset:                          ws.XYOutsetBuffer[0] = new CCVector2(b.X - Width * edgeABt.X' b.Y - Width * edgeABt.Y);                          ws.XYOutsetBuffer[1] = new CCVector2(b.X - Width * edgeBCt.X' b.Y - Width * edgeBCt.Y);                            vertexCount = 2;                          break;                  }
