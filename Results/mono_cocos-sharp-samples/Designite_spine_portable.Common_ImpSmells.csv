Implementation smell,Namespace,Class,File,Method,Description
Long Method,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The method has 152 lines of code.
Long Method,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The method has 111 lines of code.
Long Method,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The method has 248 lines of code.
Long Method,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The method has 110 lines of code.
Long Method,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The method has 213 lines of code.
Complex Method,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,Cyclomatic complexity of the method is 23
Complex Method,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,Cyclomatic complexity of the method is 9
Complex Method,Spine,EventTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,Cyclomatic complexity of the method is 9
Complex Method,Spine,FFDTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,Cyclomatic complexity of the method is 10
Complex Method,Spine,AnimationState,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\AnimationState.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,Spine,AnimationState,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\AnimationState.cs,Apply,Cyclomatic complexity of the method is 10
Complex Method,Spine,Atlas,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Atlas.cs,Load,Cyclomatic complexity of the method is 13
Complex Method,Spine,Parser,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,ParseByToken,Cyclomatic complexity of the method is 8
Complex Method,Spine,Parser,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,ParseString,Cyclomatic complexity of the method is 13
Complex Method,Spine,Serializer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,SerializeString,Cyclomatic complexity of the method is 10
Complex Method,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadSkeletonData,Cyclomatic complexity of the method is 22
Complex Method,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,Cyclomatic complexity of the method is 18
Complex Method,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,Cyclomatic complexity of the method is 44
Long Parameter List,Spine,Animation,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' loop' events
Long Parameter List,Spine,Animation,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Mix,The method has 6 parameters. Parameters: skeleton' lastTime' time' loop' events' alpha
Long Parameter List,Spine,Timeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The method has 5 parameters. Parameters: frameIndex' cx1' cy1' cx2' cy2
Long Parameter List,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,TranslateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,ScaleTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,ColorTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,setFrame,The method has 6 parameters. Parameters: frameIndex' time' r' g' b' a
Long Parameter List,Spine,ColorTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,AttachmentTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,EventTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,DrawOrderTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,FFDTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The method has 5 parameters. Parameters: skeleton' lastTime' time' firedEvents' alpha
Long Parameter List,Spine,SkeletonBounds,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,IntersectsSegment,The method has 5 parameters. Parameters: polygon' x1' y1' x2' y2
Long Parameter List,Spine,RegionAttachment,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\RegionAttachment.cs,SetUVs,The method has 5 parameters. Parameters: u' v' u2' v2' rotate
Long Statement,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The length of the statement  "			skeletonMoveAction = new CCSequence(new CCMoveTo(5' new CCPoint(windowSize.Width' 10))' new CCMoveTo(5' new CCPoint(10' 10)));" is 126.
Long Statement,Spine,ScaleTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The length of the statement  "			bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + FRAME_X] - lastFrameX) * percent - bone.scaleX) * alpha;" is 129.
Long Statement,Spine,ScaleTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The length of the statement  "			bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + FRAME_Y] - lastFrameY) * percent - bone.scaleY) * alpha;" is 129.
Long Statement,Spine,SkeletonBounds,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,AabbIntersectsSegment,The length of the statement  "			if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))" is 121.
Long Statement,Spine,AtlasAttachmentLoader,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\AtlasAttachmentLoader.cs,NewSkinnedMeshAttachment,The length of the statement  "			if (region == null) throw new Exception("Region not found in atlas: " + path + " (skinned mesh attachment: " + name + ")");" is 123.
Complex Conditional,Spine,Serializer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,SerializeOther,The conditional expression  "value is float                     || value is int                     || value is uint                     || value is long 						  || value is float                     || value is sbyte                     || value is byte                     || value is short                     || value is ushort                     || value is ulong                     || value is decimal"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,AabbIntersectsSegment,The conditional expression  "(x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,ContainsPoint,The conditional expression  "(vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,IntersectsSegment,The conditional expression  "((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))"  is complex.
Complex Conditional,Spine,SkeletonBounds,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,IntersectsSegment,The conditional expression  "((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))"  is complex.
Magic Number,spine_portable,GameAppDelegate,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\spine_portable\spine_portable\spine_portable.Common\GameAppDelegate.cs,ApplicationDidFinishLaunching,The following statement contains a magic number: float desiredWidth = 480f;
Magic Number,spine_portable,GameAppDelegate,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\spine_portable\spine_portable\spine_portable.Common\GameAppDelegate.cs,ApplicationDidFinishLaunching,The following statement contains a magic number: float desiredHeight = 320f;
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The following statement contains a magic number: CCMenuItemFont.FontSize = 12;
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The following statement contains a magic number: labelTimeScaleUp = new CCMenuItemFont("Up - TimeScale +"' (obj) =>                 {                     skeletonNode.TimeScale += 0.1f;                 }              ) { AnchorPoint = CCPoint.AnchorMiddleLeft };
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The following statement contains a magic number: labelTimeScaleDown = new CCMenuItemFont("Down - TimeScale -"' (obj) =>                 {                     skeletonNode.TimeScale -= 0.1f;                 }              ) { AnchorPoint = CCPoint.AnchorMiddleLeft };
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The following statement contains a magic number: skeletonNode = new CCSkeletonAnimation(name + ".json"' name + ".atlas"' 0.5f);
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The following statement contains a magic number: skeletonNode.AddAnimation(0' "walk"' true' 4);
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The following statement contains a magic number: listener.OnTouchBegan = (touch' touchEvent) =>                 {                     if (!skeletonNode.DebugBones)                     {                         skeletonNode.DebugBones = true;                      }                     else if (skeletonNode.TimeScale == 1)                         skeletonNode.TimeScale = 0.3f;                     else if (skeletonNode.Skeleton.Skin.Name == "goblin")                         skeletonNode.SetSkin("goblingirl");                     return true;                 };
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The following statement contains a magic number: keyListener.OnKeyPressed = (keyEvent) =>                 {                     switch (keyEvent.Keys)                     {                         case CCKeys.B:                             skeletonNode.DebugBones = !skeletonNode.DebugBones;                             break;                         case CCKeys.M:                             skeletonNode.DebugSlots = !skeletonNode.DebugSlots;                             break;                         case CCKeys.S:                             if (skeletonNode.Skeleton.Skin.Name == "goblin")                                 skeletonNode.SetSkin("goblingirl");                             else                                 skeletonNode.SetSkin("goblin");                             break;                         case CCKeys.Up:                             skeletonNode.TimeScale += 0.1f;                             break;                         case CCKeys.Down:                             skeletonNode.TimeScale -= 0.1f;                             break;                         case CCKeys.A:                             if (isMoving)                             { 								StopAction(skeletonActionState);                                 isMoving = false;                             }                             else                             {                                 skeletonActionState = skeletonNode.RepeatForever(skeletonMoveAction);                                 isMoving = true;                             }                             break;                         case CCKeys.P: 							Director.ReplaceScene(SpineBoyLayer.Scene(Window));                             break;                     }                  };
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The following statement contains a magic number: keyListener.OnKeyPressed = (keyEvent) =>                 {                     switch (keyEvent.Keys)                     {                         case CCKeys.B:                             skeletonNode.DebugBones = !skeletonNode.DebugBones;                             break;                         case CCKeys.M:                             skeletonNode.DebugSlots = !skeletonNode.DebugSlots;                             break;                         case CCKeys.S:                             if (skeletonNode.Skeleton.Skin.Name == "goblin")                                 skeletonNode.SetSkin("goblingirl");                             else                                 skeletonNode.SetSkin("goblin");                             break;                         case CCKeys.Up:                             skeletonNode.TimeScale += 0.1f;                             break;                         case CCKeys.Down:                             skeletonNode.TimeScale -= 0.1f;                             break;                         case CCKeys.A:                             if (isMoving)                             { 								StopAction(skeletonActionState);                                 isMoving = false;                             }                             else                             {                                 skeletonActionState = skeletonNode.RepeatForever(skeletonMoveAction);                                 isMoving = true;                             }                             break;                         case CCKeys.P: 							Director.ReplaceScene(SpineBoyLayer.Scene(Window));                             break;                     }                  };
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: menu.Position = new CCPoint(15' windowSize.Height - 85);
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: menu.Position = new CCPoint(15' windowSize.Height - 85);
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: skeletonNode.Position = new CCPoint(windowSize.Center.X' skeletonNode.ContentSize.Height / 2);
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: skeletonMoveAction = new CCSequence(new CCMoveTo(5' new CCPoint(windowSize.Width' 10))' new CCMoveTo(5' new CCPoint(10' 10)));
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: skeletonMoveAction = new CCSequence(new CCMoveTo(5' new CCPoint(windowSize.Width' 10))' new CCMoveTo(5' new CCPoint(10' 10)));
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: skeletonMoveAction = new CCSequence(new CCMoveTo(5' new CCPoint(windowSize.Width' 10))' new CCMoveTo(5' new CCPoint(10' 10)));
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: skeletonMoveAction = new CCSequence(new CCMoveTo(5' new CCPoint(windowSize.Width' 10))' new CCMoveTo(5' new CCPoint(10' 10)));
Magic Number,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,AddedToScene,The following statement contains a magic number: skeletonMoveAction = new CCSequence(new CCMoveTo(5' new CCPoint(windowSize.Width' 10))' new CCMoveTo(5' new CCPoint(10' 10)));
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following statement contains a magic number: CCMenuItemFont.FontSize = 12;
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following statement contains a magic number: labelTimeScaleUp = new CCMenuItemFont("Up - TimeScale +"' (obj) =>                 {                     skeletonNode.TimeScale += 0.1f;                 }              ) { AnchorPoint = CCPoint.AnchorMiddleLeft };
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following statement contains a magic number: labelTimeScaleDown = new CCMenuItemFont("Down - TimeScale -"' (obj) =>                 {                     skeletonNode.TimeScale -= 0.1f;                 }              ) { AnchorPoint = CCPoint.AnchorMiddleLeft };
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following statement contains a magic number: skeletonNode = new CCSkeletonAnimation(name + ".json"' name + ".atlas"' 0.25f);
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following statement contains a magic number: skeletonNode.SetMix("walk"' "jump"' 0.2f);
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following statement contains a magic number: skeletonNode.SetMix("jump"' "run"' 0.2f);
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following statement contains a magic number: TrackEntry jumpEntry = skeletonNode.AddAnimation(0' "jump"' false' 3);
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following statement contains a magic number: listener.OnTouchBegan = (touch' touchEvent) =>                 {                     if (!skeletonNode.DebugBones)                     {                         skeletonNode.DebugBones = true;                      }                     else if (skeletonNode.TimeScale == 1)                         skeletonNode.TimeScale = 0.3f;                     return true;                 };
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following statement contains a magic number: keyListener.OnKeyPressed = (keyEvent) =>                 {                     switch (keyEvent.Keys)                     {                         case CCKeys.B:                             skeletonNode.DebugBones = !skeletonNode.DebugBones;                             break;                         case CCKeys.M:                             skeletonNode.DebugSlots = !skeletonNode.DebugSlots;                             break;                         case CCKeys.Up:                             skeletonNode.TimeScale += 0.1f;                             break;                         case CCKeys.Down:                             skeletonNode.TimeScale -= 0.1f;                             break;                         case CCKeys.G:                             Director.ReplaceScene(GoblinLayer.Scene(Window));                             break; 						case CCKeys.J: 							// I truthfully do not know if this is how it is done or not 							skeletonNode.SetAnimation(0' "jump"' false); 							skeletonNode.AddAnimation(0' "run"' true); 							break;                     }                  };
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following statement contains a magic number: keyListener.OnKeyPressed = (keyEvent) =>                 {                     switch (keyEvent.Keys)                     {                         case CCKeys.B:                             skeletonNode.DebugBones = !skeletonNode.DebugBones;                             break;                         case CCKeys.M:                             skeletonNode.DebugSlots = !skeletonNode.DebugSlots;                             break;                         case CCKeys.Up:                             skeletonNode.TimeScale += 0.1f;                             break;                         case CCKeys.Down:                             skeletonNode.TimeScale -= 0.1f;                             break;                         case CCKeys.G:                             Director.ReplaceScene(GoblinLayer.Scene(Window));                             break; 						case CCKeys.J: 							// I truthfully do not know if this is how it is done or not 							skeletonNode.SetAnimation(0' "jump"' false); 							skeletonNode.AddAnimation(0' "run"' true); 							break;                     }                  };
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,AddedToScene,The following statement contains a magic number: menu.Position = new CCPoint(15' windowSize.Height - 70);
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,AddedToScene,The following statement contains a magic number: menu.Position = new CCPoint(15' windowSize.Height - 70);
Magic Number,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,AddedToScene,The following statement contains a magic number: skeletonNode.Position = new CCPoint(windowSize.Center.X' 10);
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: float skeletonR = color3b.R / 255f;
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: float skeletonG = color3b.G / 255f;
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: float skeletonB = color3b.B / 255f;
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: float skeletonA = Opacity / 255f;
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: var item = skeletonGeometry.CreateGeometryInstance(4' 6);
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: var item = skeletonGeometry.CreateGeometryInstance(4' 6);
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: var worldVertices = new float[1000];
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: verticesCount = 8;
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: CCPoint[] slotVertices = new CCPoint[verticesCount/2];
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: debugger.DrawPolygon(slotVertices' verticesCount / 2' CCColor4B.Transparent' 1' DebugSlotColor);
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The following statement contains a magic number: debugger.DrawDot(new CCPoint(bone.WorldX' bone.WorldY)' 3' DebugBoneColor);
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,boundingBox,The following statement contains a magic number: var worldVertices = new float[1000];
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,boundingBox,The following statement contains a magic number: verticesCount = 8;
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateRegionAttachmentQuad,The following statement contains a magic number: float[] vertices = new float[8];
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateRegionAttachmentQuad,The following statement contains a magic number: float r = slot.Skeleton.R * slot.R * 255;
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateRegionAttachmentQuad,The following statement contains a magic number: float g = slot.Skeleton.G * slot.G * 255;
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateRegionAttachmentQuad,The following statement contains a magic number: float b = slot.Skeleton.B * slot.B * 255;
Magic Number,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateRegionAttachmentQuad,The following statement contains a magic number: float a = normalizedAlpha * 255;
Magic Number,Spine,Animation,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,binarySearch,The following statement contains a magic number: int high = values.Length / step - 2;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,CurveTimeline,The following statement contains a magic number: curves = new float[(frameCount - 1) * 6];
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetLinear,The following statement contains a magic number: curves[frameIndex * 6] = LINEAR;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetStepped,The following statement contains a magic number: curves[frameIndex * 6] = STEPPED;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float pre1 = 3 * subdiv_step;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float pre2 = 3 * subdiv_step2;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float pre4 = 6 * subdiv_step2;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float pre5 = 6 * subdiv_step3;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float tmp1x = -cx1 * 2 + cx2;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float tmp1y = -cy1 * 2 + cy2;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float tmp2x = (cx1 - cx2) * 3 + 1;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: float tmp2y = (cy1 - cy2) * 3 + 1;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: int i = frameIndex * 6;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: curves[i + 2] = tmp1x * pre4 + tmp2x * pre5;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: curves[i + 3] = tmp1y * pre4 + tmp2y * pre5;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: curves[i + 4] = tmp2x * pre5;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetCurve,The following statement contains a magic number: curves[i + 5] = tmp2y * pre5;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,GetCurvePercent,The following statement contains a magic number: int curveIndex = frameIndex * 6;
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,GetCurvePercent,The following statement contains a magic number: float ddfx = curves[curveIndex + 2];
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,GetCurvePercent,The following statement contains a magic number: float ddfy = curves[curveIndex + 3];
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,GetCurvePercent,The following statement contains a magic number: float dddfx = curves[curveIndex + 4];
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,GetCurvePercent,The following statement contains a magic number: float dddfy = curves[curveIndex + 5];
Magic Number,Spine,CurveTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,GetCurvePercent,The following statement contains a magic number: int i = BEZIER_SEGMENTS - 2;
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,RotateTimeline,The following statement contains a magic number: frames = new float[frameCount * 2];
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetFrame,The following statement contains a magic number: frameIndex *= 2;
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: amount -= 360;
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: amount > 180
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: amount += 360;
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: amount < -180
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: time >= frames[frames.Length - 2]
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: int frameIndex = Animation.binarySearch(frames' time' 2);
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent(frameIndex / 2 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: amount -= 360;
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: amount > 180
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: amount += 360;
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: amount < -180
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: amount -= 360;
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: amount > 180
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: amount += 360;
Magic Number,Spine,RotateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: amount < -180
Magic Number,Spine,TranslateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,TranslateTimeline,The following statement contains a magic number: frames = new float[frameCount * 3];
Magic Number,Spine,TranslateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetFrame,The following statement contains a magic number: frameIndex *= 3;
Magic Number,Spine,TranslateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,SetFrame,The following statement contains a magic number: frames[frameIndex + 2] = y;
Magic Number,Spine,TranslateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: bone.x += (bone.data.x + frames[frames.Length - 2] - bone.x) * alpha;
Magic Number,Spine,TranslateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: time >= frames[frames.Length - 3]
Magic Number,Spine,TranslateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: int frameIndex = Animation.binarySearch(frames' time' 3);
Magic Number,Spine,TranslateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: float lastFrameX = frames[frameIndex - 2];
Magic Number,Spine,TranslateTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent(frameIndex / 3 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));
Magic Number,Spine,ScaleTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: bone.scaleX += (bone.data.scaleX - 1 + frames[frames.Length - 2] - bone.scaleX) * alpha;
Magic Number,Spine,ScaleTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: time >= frames[frames.Length - 3]
Magic Number,Spine,ScaleTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: int frameIndex = Animation.binarySearch(frames' time' 3);
Magic Number,Spine,ScaleTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: float lastFrameX = frames[frameIndex - 2];
Magic Number,Spine,ScaleTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: percent = GetCurvePercent(frameIndex / 3 - 1' percent < 0 ? 0 : (percent > 1 ? 1 : percent));
Magic Number,Spine,ColorTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,ColorTimeline,The following statement contains a magic number: frames = new float[frameCount * 5];
Magic Number,Spine,ColorTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,setFrame,The following statement contains a magic number: frameIndex *= 5;
Magic Number,Spine,ColorTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,setFrame,The following statement contains a magic number: frames[frameIndex + 2] = g;
Magic Number,Spine,ColorTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,setFrame,The following statement contains a magic number: frames[frameIndex + 3] = b;
Magic Number,Spine,ColorTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,setFrame,The following statement contains a magic number: frames[frameIndex + 4] = a;
Magic Number,Spine,ColorTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: r = frames[i - 3];
Magic Number,Spine,ColorTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: g = frames[i - 2];
Magic Number,Spine,ColorTimeline,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Animation.cs,Apply,The following statement contains a magic number: time >= frames[frames.Length - 5]
Magic Number,Spine,AnimationState,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\AnimationState.cs,SetCurrent,The following statement contains a magic number: previous != null && current.mixTime / current.mixDuration < 0.5f
Magic Number,Spine,Atlas,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Atlas.cs,Load,The following statement contains a magic number: String[] tuple = new String[4];
Magic Number,Spine,Atlas,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Atlas.cs,readTuple,The following statement contains a magic number: i < 3
Magic Number,Spine,Bone,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Bone.cs,UpdateWorldTransform,The following statement contains a magic number: float radians = worldRotation * (float)Math.PI / 180;
Magic Number,Spine,Parser,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,ParseString,The following statement contains a magic number: switch (c) {                     case '"':                         parsing = false;                         break;                     case '\\':                         if (json.Peek() == -1) {                             parsing = false;                             break;                         }                           c = NextChar;                         switch (c) {                         case '"':                         case '\\':                         case '/':                             s.Append(c);                             break;                         case 'b':                             s.Append('\b');                             break;                         case 'f':                             s.Append('\f');                             break;                         case 'n':                             s.Append('\n');                             break;                         case 'r':                             s.Append('\r');                             break;                         case 't':                             s.Append('\t');                             break;                         case 'u':                             var hex = new StringBuilder();                               for (int i=0; i< 4; i++) {                                 hex.Append(NextChar);                             }                               s.Append((char) Convert.ToInt32(hex.ToString()' 16));                             break;                         }                         break;                     default:                         s.Append(c);                         break;                     }
Magic Number,Spine,Parser,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,ParseString,The following statement contains a magic number: switch (c) {                     case '"':                         parsing = false;                         break;                     case '\\':                         if (json.Peek() == -1) {                             parsing = false;                             break;                         }                           c = NextChar;                         switch (c) {                         case '"':                         case '\\':                         case '/':                             s.Append(c);                             break;                         case 'b':                             s.Append('\b');                             break;                         case 'f':                             s.Append('\f');                             break;                         case 'n':                             s.Append('\n');                             break;                         case 'r':                             s.Append('\r');                             break;                         case 't':                             s.Append('\t');                             break;                         case 'u':                             var hex = new StringBuilder();                               for (int i=0; i< 4; i++) {                                 hex.Append(NextChar);                             }                               s.Append((char) Convert.ToInt32(hex.ToString()' 16));                             break;                         }                         break;                     default:                         s.Append(c);                         break;                     }
Magic Number,Spine,Serializer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,SerializeString,The following statement contains a magic number: switch (c) {                     case '"':                         builder.Append("\\\"");                         break;                     case '\\':                         builder.Append("\\\\");                         break;                     case '\b':                         builder.Append("\\b");                         break;                     case '\f':                         builder.Append("\\f");                         break;                     case '\n':                         builder.Append("\\n");                         break;                     case '\r':                         builder.Append("\\r");                         break;                     case '\t':                         builder.Append("\\t");                         break;                     default:                         int codepoint = Convert.ToInt32(c);                         if ((codepoint >= 32) && (codepoint <= 126)) {                             builder.Append(c);                         }                         else {                             builder.Append("\\u" + Convert.ToString(codepoint' 16).PadLeft(4' '0'));                         }                         break;                     }
Magic Number,Spine,Serializer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,SerializeString,The following statement contains a magic number: switch (c) {                     case '"':                         builder.Append("\\\"");                         break;                     case '\\':                         builder.Append("\\\\");                         break;                     case '\b':                         builder.Append("\\b");                         break;                     case '\f':                         builder.Append("\\f");                         break;                     case '\n':                         builder.Append("\\n");                         break;                     case '\r':                         builder.Append("\\r");                         break;                     case '\t':                         builder.Append("\\t");                         break;                     default:                         int codepoint = Convert.ToInt32(c);                         if ((codepoint >= 32) && (codepoint <= 126)) {                             builder.Append(c);                         }                         else {                             builder.Append("\\u" + Convert.ToString(codepoint' 16).PadLeft(4' '0'));                         }                         break;                     }
Magic Number,Spine,Serializer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,SerializeString,The following statement contains a magic number: switch (c) {                     case '"':                         builder.Append("\\\"");                         break;                     case '\\':                         builder.Append("\\\\");                         break;                     case '\b':                         builder.Append("\\b");                         break;                     case '\f':                         builder.Append("\\f");                         break;                     case '\n':                         builder.Append("\\n");                         break;                     case '\r':                         builder.Append("\\r");                         break;                     case '\t':                         builder.Append("\\t");                         break;                     default:                         int codepoint = Convert.ToInt32(c);                         if ((codepoint >= 32) && (codepoint <= 126)) {                             builder.Append(c);                         }                         else {                             builder.Append("\\u" + Convert.ToString(codepoint' 16).PadLeft(4' '0'));                         }                         break;                     }
Magic Number,Spine,Serializer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,SerializeString,The following statement contains a magic number: switch (c) {                     case '"':                         builder.Append("\\\"");                         break;                     case '\\':                         builder.Append("\\\\");                         break;                     case '\b':                         builder.Append("\\b");                         break;                     case '\f':                         builder.Append("\\f");                         break;                     case '\n':                         builder.Append("\\n");                         break;                     case '\r':                         builder.Append("\\r");                         break;                     case '\t':                         builder.Append("\\t");                         break;                     default:                         int codepoint = Convert.ToInt32(c);                         if ((codepoint >= 32) && (codepoint <= 126)) {                             builder.Append(c);                         }                         else {                             builder.Append("\\u" + Convert.ToString(codepoint' 16).PadLeft(4' '0'));                         }                         break;                     }
Magic Number,Spine,SkeletonBounds,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,ContainsPoint,The following statement contains a magic number: int prevIndex = nn - 2;
Magic Number,Spine,SkeletonBounds,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,IntersectsSegment,The following statement contains a magic number: float x3 = vertices[nn - 2]' y3 = vertices[nn - 1];
Magic Number,Spine,Polygon,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonBounds.cs,Polygon,The following statement contains a magic number: Vertices = new float[16];
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: slotData.b = ToColor(color' 2);
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadSkeletonData,The following statement contains a magic number: slotData.a = ToColor(color' 3);
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following statement contains a magic number: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ToColor,The following statement contains a magic number: hexString.Length != 8
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32(hexString.Substring(colorIndex * 2' 2)' 16) / (float)255;
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32(hexString.Substring(colorIndex * 2' 2)' 16) / (float)255;
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32(hexString.Substring(colorIndex * 2' 2)' 16) / (float)255;
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ToColor,The following statement contains a magic number: return Convert.ToInt32(hexString.Substring(colorIndex * 2' 2)' 16) / (float)255;
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: timeline.setFrame(frameIndex' time' ToColor(c' 0)' ToColor(c' 1)' ToColor(c' 2)' ToColor(c' 3));
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: timeline.setFrame(frameIndex' time' ToColor(c' 0)' ToColor(c' 1)' ToColor(c' 2)' ToColor(c' 3));
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 5 - 5]);
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 5 - 5]);
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 2 - 2]);
Magic Number,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAnimation,The following statement contains a magic number: duration = Math.Max(duration' timeline.frames[timeline.FrameCount * 2 - 2]);
Magic Number,Spine,RegionAttachment,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\RegionAttachment.cs,UpdateOffset,The following statement contains a magic number: float localX = -width / 2 * scaleX + regionOffsetX * regionScaleX;
Magic Number,Spine,RegionAttachment,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\RegionAttachment.cs,UpdateOffset,The following statement contains a magic number: float localY = -height / 2 * scaleY + regionOffsetY * regionScaleY;
Magic Number,Spine,RegionAttachment,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\RegionAttachment.cs,UpdateOffset,The following statement contains a magic number: float radians = rotation * (float)Math.PI / 180;
Magic Number,Spine,SkinnedMeshAttachment,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Attachments\SkinnedMeshAttachment.cs,ComputeWorldVertices,The following statement contains a magic number: float vx = weights[b]' vy = weights[b + 1]' weight = weights[b + 2];
Duplicate Code,CocosSharp.Spine,CCSkeleton,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-cocossharp\CCSkeleton.cs,UpdateSkeletonGeometry,The method contains a code clone-set at the following line numbers (starting from the method definition): ((93' 125)' (137' 169))
Missing Default,spine_cocossharp,GoblinLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\GoblinLayer.cs,GoblinLayer,The following switch statement is missing a default case: switch (keyEvent.Keys)                     {                         case CCKeys.B:                             skeletonNode.DebugBones = !skeletonNode.DebugBones;                             break;                         case CCKeys.M:                             skeletonNode.DebugSlots = !skeletonNode.DebugSlots;                             break;                         case CCKeys.S:                             if (skeletonNode.Skeleton.Skin.Name == "goblin")                                 skeletonNode.SetSkin("goblingirl");                             else                                 skeletonNode.SetSkin("goblin");                             break;                         case CCKeys.Up:                             skeletonNode.TimeScale += 0.1f;                             break;                         case CCKeys.Down:                             skeletonNode.TimeScale -= 0.1f;                             break;                         case CCKeys.A:                             if (isMoving)                             { 								StopAction(skeletonActionState);                                 isMoving = false;                             }                             else                             {                                 skeletonActionState = skeletonNode.RepeatForever(skeletonMoveAction);                                 isMoving = true;                             }                             break;                         case CCKeys.P: 							Director.ReplaceScene(SpineBoyLayer.Scene(Window));                             break;                     }
Missing Default,spine_cocossharp,SpineBoyLayer,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\example\Common\src\SpineBoyLayer.cs,SpineBoyLayer,The following switch statement is missing a default case: switch (keyEvent.Keys)                     {                         case CCKeys.B:                             skeletonNode.DebugBones = !skeletonNode.DebugBones;                             break;                         case CCKeys.M:                             skeletonNode.DebugSlots = !skeletonNode.DebugSlots;                             break;                         case CCKeys.Up:                             skeletonNode.TimeScale += 0.1f;                             break;                         case CCKeys.Down:                             skeletonNode.TimeScale -= 0.1f;                             break;                         case CCKeys.G:                             Director.ReplaceScene(GoblinLayer.Scene(Window));                             break; 						case CCKeys.J: 							// I truthfully do not know if this is how it is done or not 							skeletonNode.SetAnimation(0' "jump"' false); 							skeletonNode.AddAnimation(0' "run"' true); 							break;                     }
Missing Default,Spine,Parser,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\Json.cs,ParseString,The following switch statement is missing a default case: switch (c) {                         case '"':                         case '\\':                         case '/':                             s.Append(c);                             break;                         case 'b':                             s.Append('\b');                             break;                         case 'f':                             s.Append('\f');                             break;                         case 'n':                             s.Append('\n');                             break;                         case 'r':                             s.Append('\r');                             break;                         case 't':                             s.Append('\t');                             break;                         case 'u':                             var hex = new StringBuilder();                               for (int i=0; i< 4; i++) {                                 hex.Append(NextChar);                             }                               s.Append((char) Convert.ToInt32(hex.ToString()' 16));                             break;                         }
Missing Default,Spine,SkeletonJson,C:\research\architectureSmells\repos\mono_cocos-sharp-samples\Spine\src\SpineCocosSharp\SpineCocosSharp\spine-csharp\src\SkeletonJson.cs,ReadAttachment,The following switch statement is missing a default case: switch (type) { 			case AttachmentType.region: 				RegionAttachment region = attachmentLoader.NewRegionAttachment(skin' name' path); 				if (region == null) return null; 				region.Path = path; 				region.x = GetFloat(map' "x"' 0) * Scale; 				region.y = GetFloat(map' "y"' 0) * Scale; 				region.scaleX = GetFloat(map' "scaleX"' 1); 				region.scaleY = GetFloat(map' "scaleY"' 1); 				region.rotation = GetFloat(map' "rotation"' 0); 				region.width = GetFloat(map' "width"' 32) * Scale; 				region.height = GetFloat(map' "height"' 32) * Scale; 				region.UpdateOffset();  				if (map.ContainsKey("color")) { 					var color = (String)map["color"]; 					region.r = ToColor(color' 0); 					region.g = ToColor(color' 1); 					region.b = ToColor(color' 2); 					region.a = ToColor(color' 3); 				}  				return region; 			case AttachmentType.mesh: { 					MeshAttachment mesh = attachmentLoader.NewMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path;  					mesh.vertices = GetFloatArray(map' "vertices"' Scale); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = GetFloatArray(map' "uvs"' 1); 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.skinnedmesh: { 					SkinnedMeshAttachment mesh = attachmentLoader.NewSkinnedMeshAttachment(skin' name' path); 					if (mesh == null) return null;  					mesh.Path = path; 					float[] uvs = GetFloatArray(map' "uvs"' 1); 					float[] vertices = GetFloatArray(map' "vertices"' 1); 					var weights = new List<float>(uvs.Length * 3 * 3); 					var bones = new List<int>(uvs.Length * 3); 					float scale = Scale; 					for (int i = 0' n = vertices.Length; i < n; ) { 						int boneCount = (int)vertices[i++]; 						bones.Add(boneCount); 						for (int nn = i + boneCount * 4; i < nn; ) { 							bones.Add((int)vertices[i]); 							weights.Add(vertices[i + 1] * scale); 							weights.Add(vertices[i + 2] * scale); 							weights.Add(vertices[i + 3]); 							i += 4; 						} 					} 					mesh.bones = bones.ToArray(); 					mesh.weights = weights.ToArray(); 					mesh.triangles = GetIntArray(map' "triangles"); 					mesh.regionUVs = uvs; 					mesh.UpdateUVs();  					if (map.ContainsKey("color")) { 						var color = (String)map["color"]; 						mesh.r = ToColor(color' 0); 						mesh.g = ToColor(color' 1); 						mesh.b = ToColor(color' 2); 						mesh.a = ToColor(color' 3); 					}  					mesh.HullLength = GetInt(map' "hull"' 0) * 2; 					if (map.ContainsKey("edges")) mesh.Edges = GetIntArray(map' "edges"); 					mesh.Width = GetInt(map' "width"' 0) * Scale; 					mesh.Height = GetInt(map' "height"' 0) * Scale;  					return mesh; 				} 			case AttachmentType.boundingbox: 				BoundingBoxAttachment box = attachmentLoader.NewBoundingBoxAttachment(skin' name); 				if (box == null) return null; 				box.vertices = GetFloatArray(map' "vertices"' Scale); 				return box; 			}
