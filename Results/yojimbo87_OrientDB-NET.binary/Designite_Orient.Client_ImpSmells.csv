Implementation smell,Namespace,Class,File,Method,Description
Long Method,Orient.Client,ODocument,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\Types\ODocument.cs,GetField,The method has 65 lines of code.
Long Method,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,Request,The method has 79 lines of code.
Long Method,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,Response,The method has 71 lines of code.
Long Method,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The method has 70 lines of code.
Complex Method,Orient.Client,OCommandResult,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\Query\OCommandResult.cs,ToSingle,Cyclomatic complexity of the method is 8
Complex Method,Orient.Client,ODocument,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\Types\ODocument.cs,GetField,Cyclomatic complexity of the method is 12
Complex Method,Orient.Client,ODocument,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\Types\ODocument.cs,SetField,Cyclomatic complexity of the method is 7
Complex Method,Orient.Client.Mapping,TypeMapper,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Mapping\TypeMapper.cs,TypeMapper,Cyclomatic complexity of the method is 21
Complex Method,Orient.Client.Protocol,SqlQuery,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Query\SqlQuery.cs,Set,Cyclomatic complexity of the method is 8
Complex Method,Orient.Client.Protocol,SqlQuery,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Query\SqlQuery.cs,ToString,Cyclomatic complexity of the method is 13
Complex Method,Orient.Client.Protocol,SqlQuery,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Query\SqlQuery.cs,GenerateSelectQuery,Cyclomatic complexity of the method is 8
Complex Method,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,ExecuteOperation,Cyclomatic complexity of the method is 23
Complex Method,Orient.Client.Protocol.Operations,LoadRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\LoadRecord.cs,Response,Cyclomatic complexity of the method is 14
Complex Method,Orient.Client.Protocol.Operations,LoadRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\LoadRecord.cs,ReadPrimaryResult,Cyclomatic complexity of the method is 13
Complex Method,Orient.Client.Protocol.Operations,TransactionRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\TransactionRecord.cs,AddToRequest,Cyclomatic complexity of the method is 14
Complex Method,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,Request,Cyclomatic complexity of the method is 13
Complex Method,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,Response,Cyclomatic complexity of the method is 33
Complex Method,Orient.Client.Protocol.Operations,DbOpen,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbOpen.cs,Response,Cyclomatic complexity of the method is 8
Complex Method,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,SerializeValue,Cyclomatic complexity of the method is 18
Complex Method,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseFieldName,Cyclomatic complexity of the method is 28
Complex Method,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseMap,Cyclomatic complexity of the method is 8
Complex Method,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,Cyclomatic complexity of the method is 30
Complex Method,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRidBags,Cyclomatic complexity of the method is 8
Complex Method,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseList,Cyclomatic complexity of the method is 20
Complex Method,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseSet,Cyclomatic complexity of the method is 20
Complex Method,Orient.Client.Transactions,ORIDUpdater,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Transactions\ORIDUpdater.cs,ORIDUpdater,Cyclomatic complexity of the method is 16
Long Parameter List,Orient.Client,OClient,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\OClient.cs,CreateDatabasePool,The method has 8 parameters.
Long Parameter List,Orient.Client,OServer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\OServer.cs,OServer,The method has 4 parameters.
Long Parameter List,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,Connection,The method has 8 parameters.
Long Parameter List,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,Connection,The method has 4 parameters.
Long Parameter List,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,InitializeDatabaseConnection,The method has 4 parameters.
Long Parameter List,Orient.Client.Protocol,DatabasePool,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\DatabasePool.cs,DatabasePool,The method has 8 parameters.
Long Parameter List,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,Deserialize,The method has 5 parameters.
Long Parameter List,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseString,The method has 4 parameters.
Long Parameter List,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRecordID,The method has 4 parameters.
Long Parameter List,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseMap,The method has 4 parameters.
Long Parameter List,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The method has 4 parameters.
Long Parameter List,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRidBags,The method has 4 parameters.
Long Parameter List,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseEmbeddedDocument,The method has 4 parameters.
Long Parameter List,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseList,The method has 4 parameters.
Long Parameter List,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseSet,The method has 4 parameters.
Long Statement,Orient.Client,OClient,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\OClient.cs,CreateDatabasePool,The length of the statement  "		DatabasePool databasePool = new DatabasePool (hostname' port' databaseName' databaseType' userName' userPassword' poolSize' alias); " is 131.
Long Statement,Orient.Client,OClient,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\OClient.cs,ReleaseConnection,The length of the statement  "					connection = new Connection (pool.Hostname' pool.Port' pool.DatabaseName' pool.DatabaseType' pool.UserName' pool.UserPassword' alias' true); " is 140.
Long Statement,Orient.Client,ODocument,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\Types\ODocument.cs,GetField,The length of the statement  "	var result = type.IsPrimitive || type == typeof(string) || type.IsArray ? default(T) : (T)Activator.CreateInstance (type); " is 122.
Long Statement,Orient.Client.API,OTransaction,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\OTransaction.cs,Insert,The length of the statement  "		throw new InvalidOperationException ("Objects to be updated or deleted via a transaction must already be in the database"); " is 123.
Long Statement,Orient.Client.Mapping,CollectionNamedFieldMapping,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Mapping\CollectionFieldMapping.cs,MapToNamedField,The length of the statement  "	if (collection == null)// if we only have one item currently stored (but scope for more) we create a temporary list and put our single item in it. " is 146.
Long Statement,Orient.Client.Mapping,CollectionNamedFieldMapping,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Mapping\CollectionFieldMapping.cs,NeedsNoConversion,The length of the statement  "	return elementType.IsPrimitive || (elementType == typeof(string)) || (elementType == typeof(DateTime)) || (elementType == typeof(decimal)) || (elementType == typeof(ORID)); " is 172.
Long Statement,Orient.Client.Mapping,FastConstructor,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Mapping\FastPropertyAccessor.cs,BuildConstructor,The length of the statement  "		throw new MissingMethodException (type.Name + " has so public constructore with 1 parameter of type " + typeof(T).Name); " is 120.
Long Statement,Orient.Client.Protocol,BinaryReaderHelper,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\BinaryReaderHelper.cs,ReadBytesRequired,The length of the statement  "		throw new EndOfStreamException (string.Format ("{0} bytes required from stream' but only {1} returned."' byteCount' result.Length)); " is 132.
Long Statement,Orient.Client.Protocol,SqlQuery,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Query\SqlQuery.cs,GenerateDeleteEdgeQuery,The length of the statement  "		query += string.Join (" "' Q.Delete' Q.Edge' _compiler.Value (Q.Class)' Q.From' _compiler.Value (Q.From)' Q.To' _compiler.Value (Q.To)); " is 136.
Long Statement,Orient.Client.Protocol.Operations,CommitTransaction,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\CommitTransaction.cs,Request,The length of the statement  "	//request.DataItems.Add(new RequestDataItem() { Type = "int"' Data = BinarySerializer.ToArray(-1) });  // data segment id " is 121.
Long Statement,Orient.Client.Protocol.Operations,CommitTransaction,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\CommitTransaction.cs,Request,The length of the statement  "	//request.DataItems.Add(new RequestDataItem() {Type = "string"' Data = BinarySerializer.ToArray(_document.Serialize())}); " is 121.
Long Statement,Orient.Client.Protocol.Operations,LoadRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\LoadRecord.cs,ReadAssociatedResult,The length of the statement  "	var document = RecordSerializer.Deserialize (new ORID (clusterId' clusterPosition)' recordVersion' ORecordType.Document' 0' record); " is 132.
Long Statement,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,Serialize,The length of the statement  "		throw new OException (OExceptionType.Serialization' "Document doesn't contain @OClassName field which is required for serialization."); " is 135.
Long Statement,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRecordID,The length of the statement  "	while ((i < recordString.Length) && (recordString [i] != ''') && (recordString [i] != ')') && (recordString [i] != ']') && (recordString [i] != '>')) { " is 151.
Long Statement,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The length of the statement  "	while ((i < recordString.Length) && (recordString [i] != ''') && (recordString [i] != ')') && (recordString [i] != ']') && (recordString [i] != '>')) { " is 151.
Long Statement,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The length of the statement  "		else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) { " is 134.
Complex Conditional,Orient.Client,OClient,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\OClient.cs,ReturnConnection,The conditional expression  "(pool != null) && (pool.CurrentSize < pool.PoolSize) && connection.IsActive && connection.IsReusable"  is complex.
Empty Catch Block,Orient.Client.Protocol.Operations,CommitTransaction,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\CommitTransaction.cs,Response,The method has an empty catch block.
Empty Catch Block,Orient.Client.Protocol.Operations,CreateRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\CreateRecord.cs,Response,The method has an empty catch block.
Magic Number,Orient.Client,OClient,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\OClient.cs,OClient,The following statement contains a magic number: BufferLenght = 1024;  
Magic Number,Orient.Client,ORID,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\Types\ORID.cs,FastParse,The following statement contains a magic number: while (offset < s.Length) {  	int iVal = s [offset] - '0';  	if (iVal < 0 || iVal > 9)  		break;  	result = result * 10 + iVal;  	offset++;  }  
Magic Number,Orient.Client,ORID,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\Types\ORID.cs,FastParse,The following statement contains a magic number: while (offset < s.Length) {  	int iVal = s [offset] - '0';  	if (iVal < 0 || iVal > 9)  		break;  	result = result * 10 + iVal;  	offset++;  }  
Magic Number,Orient.Client,ORID,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\Types\ORID.cs,FastParse,The following statement contains a magic number: if (iVal < 0 || iVal > 9)  	break;  
Magic Number,Orient.Client,ORID,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\Types\ORID.cs,FastParse,The following statement contains a magic number: result = result * 10 + iVal;  
Magic Number,Orient.Client,ORID,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\Types\ORID.cs,GetHashCode,The following statement contains a magic number: return (ClusterId * 17) ^ ClusterPosition.GetHashCode ();  
Magic Number,Orient.Client,OServer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\OServer.cs,Databases,The following statement contains a magic number: foreach (var item in databases) {  	string[] keyValue = item.Split (':');  	returnValue.Add (keyValue [0]' keyValue [1] + ":" + keyValue [2]);  }  
Magic Number,Orient.Client,OServer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\API\OServer.cs,Databases,The following statement contains a magic number: returnValue.Add (keyValue [0]' keyValue [1] + ":" + keyValue [2]);  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,ExecuteOperation,The following statement contains a magic number: foreach (RequestDataItem item in request.DataItems) {  	switch (item.Type) {  	case "byte":  	case "short":  	case "int":  	case "long":  		Send (item.Data);  		break;  	case "record":  		buffer = new byte[2 + item.Data.Length];  		Buffer.BlockCopy (BinarySerializer.ToArray (item.Data.Length)' 0' buffer' 0' 2);  		Buffer.BlockCopy (item.Data' 0' buffer' 2' item.Data.Length);  		Send (buffer);  		break;  	case "bytes":  	case "string":  	case "strings":  		//buffer = new byte[4 + item.Data.Length];  		//Buffer.BlockCopy(BinarySerializer.ToArray(item.Data.Length)' 0' buffer' 0' 4);  		//Buffer.BlockCopy(item.Data' 0' buffer' 4' item.Data.Length);  		//Send(buffer);  		Send (BinarySerializer.ToArray (item.Data.Length));  		Send (item.Data);  		break;  	default:  		break;  	}  }  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,ExecuteOperation,The following statement contains a magic number: foreach (RequestDataItem item in request.DataItems) {  	switch (item.Type) {  	case "byte":  	case "short":  	case "int":  	case "long":  		Send (item.Data);  		break;  	case "record":  		buffer = new byte[2 + item.Data.Length];  		Buffer.BlockCopy (BinarySerializer.ToArray (item.Data.Length)' 0' buffer' 0' 2);  		Buffer.BlockCopy (item.Data' 0' buffer' 2' item.Data.Length);  		Send (buffer);  		break;  	case "bytes":  	case "string":  	case "strings":  		//buffer = new byte[4 + item.Data.Length];  		//Buffer.BlockCopy(BinarySerializer.ToArray(item.Data.Length)' 0' buffer' 0' 4);  		//Buffer.BlockCopy(item.Data' 0' buffer' 4' item.Data.Length);  		//Send(buffer);  		Send (BinarySerializer.ToArray (item.Data.Length));  		Send (item.Data);  		break;  	default:  		break;  	}  }  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,ExecuteOperation,The following statement contains a magic number: foreach (RequestDataItem item in request.DataItems) {  	switch (item.Type) {  	case "byte":  	case "short":  	case "int":  	case "long":  		Send (item.Data);  		break;  	case "record":  		buffer = new byte[2 + item.Data.Length];  		Buffer.BlockCopy (BinarySerializer.ToArray (item.Data.Length)' 0' buffer' 0' 2);  		Buffer.BlockCopy (item.Data' 0' buffer' 2' item.Data.Length);  		Send (buffer);  		break;  	case "bytes":  	case "string":  	case "strings":  		//buffer = new byte[4 + item.Data.Length];  		//Buffer.BlockCopy(BinarySerializer.ToArray(item.Data.Length)' 0' buffer' 0' 4);  		//Buffer.BlockCopy(item.Data' 0' buffer' 4' item.Data.Length);  		//Send(buffer);  		Send (BinarySerializer.ToArray (item.Data.Length));  		Send (item.Data);  		break;  	default:  		break;  	}  }  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,ExecuteOperation,The following statement contains a magic number: switch (item.Type) {  case "byte":  case "short":  case "int":  case "long":  	Send (item.Data);  	break;  case "record":  	buffer = new byte[2 + item.Data.Length];  	Buffer.BlockCopy (BinarySerializer.ToArray (item.Data.Length)' 0' buffer' 0' 2);  	Buffer.BlockCopy (item.Data' 0' buffer' 2' item.Data.Length);  	Send (buffer);  	break;  case "bytes":  case "string":  case "strings":  	//buffer = new byte[4 + item.Data.Length];  	//Buffer.BlockCopy(BinarySerializer.ToArray(item.Data.Length)' 0' buffer' 0' 4);  	//Buffer.BlockCopy(item.Data' 0' buffer' 4' item.Data.Length);  	//Send(buffer);  	Send (BinarySerializer.ToArray (item.Data.Length));  	Send (item.Data);  	break;  default:  	break;  }  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,ExecuteOperation,The following statement contains a magic number: switch (item.Type) {  case "byte":  case "short":  case "int":  case "long":  	Send (item.Data);  	break;  case "record":  	buffer = new byte[2 + item.Data.Length];  	Buffer.BlockCopy (BinarySerializer.ToArray (item.Data.Length)' 0' buffer' 0' 2);  	Buffer.BlockCopy (item.Data' 0' buffer' 2' item.Data.Length);  	Send (buffer);  	break;  case "bytes":  case "string":  case "strings":  	//buffer = new byte[4 + item.Data.Length];  	//Buffer.BlockCopy(BinarySerializer.ToArray(item.Data.Length)' 0' buffer' 0' 4);  	//Buffer.BlockCopy(item.Data' 0' buffer' 4' item.Data.Length);  	//Send(buffer);  	Send (BinarySerializer.ToArray (item.Data.Length));  	Send (item.Data);  	break;  default:  	break;  }  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,ExecuteOperation,The following statement contains a magic number: switch (item.Type) {  case "byte":  case "short":  case "int":  case "long":  	Send (item.Data);  	break;  case "record":  	buffer = new byte[2 + item.Data.Length];  	Buffer.BlockCopy (BinarySerializer.ToArray (item.Data.Length)' 0' buffer' 0' 2);  	Buffer.BlockCopy (item.Data' 0' buffer' 2' item.Data.Length);  	Send (buffer);  	break;  case "bytes":  case "string":  case "strings":  	//buffer = new byte[4 + item.Data.Length];  	//Buffer.BlockCopy(BinarySerializer.ToArray(item.Data.Length)' 0' buffer' 0' 4);  	//Buffer.BlockCopy(item.Data' 0' buffer' 4' item.Data.Length);  	//Send(buffer);  	Send (BinarySerializer.ToArray (item.Data.Length));  	Send (item.Data);  	break;  default:  	break;  }  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,ExecuteOperation,The following statement contains a magic number: buffer = new byte[2 + item.Data.Length];  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,ExecuteOperation,The following statement contains a magic number: Buffer.BlockCopy (BinarySerializer.ToArray (item.Data.Length)' 0' buffer' 0' 2);  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,ExecuteOperation,The following statement contains a magic number: Buffer.BlockCopy (item.Data' 0' buffer' 2' item.Data.Length);  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,InitializeDatabaseConnection,The following statement contains a magic number: _networkStream.Read (_readBuffer' 0' 2);  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,InitializeDatabaseConnection,The following statement contains a magic number: OClient.ProtocolVersion = ProtocolVersion = BinarySerializer.ToShort (_readBuffer.Take (2).ToArray ());  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,InitializeServerConnection,The following statement contains a magic number: _networkStream.Read (_readBuffer' 0' 2);  
Magic Number,Orient.Client.Protocol,Connection,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Connection.cs,InitializeServerConnection,The following statement contains a magic number: OClient.ProtocolVersion = ProtocolVersion = BinarySerializer.ToShort (_readBuffer.Take (2).ToArray ());  
Magic Number,Orient.Client.Protocol,Response,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Response.cs,Receive,The following statement contains a magic number: if (Status == ResponseStatus.ERROR) {  	string exceptionString = "";  	byte followByte = reader.ReadByte ();  	while (followByte == 1) {  		int exceptionClassLength = reader.ReadInt32EndianAware ();  		exceptionString += System.Text.Encoding.Default.GetString (reader.ReadBytes (exceptionClassLength)) + ": ";  		int exceptionMessageLength = reader.ReadInt32EndianAware ();  		// don't read exception message string if it's null  		if (exceptionMessageLength != -1) {  			exceptionString += System.Text.Encoding.Default.GetString (reader.ReadBytes (exceptionMessageLength)) + "\n";  		}  		followByte = reader.ReadByte ();  	}  	if (OClient.ProtocolVersion >= 19) {  		int serializedVersionLength = reader.ReadInt32EndianAware ();  		var buffer = reader.ReadBytes (serializedVersionLength);  	}  	throw new OException (OExceptionType.Operation' exceptionString);  }  
Magic Number,Orient.Client.Protocol,Response,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Response.cs,Receive,The following statement contains a magic number: if (OClient.ProtocolVersion >= 19) {  	int serializedVersionLength = reader.ReadInt32EndianAware ();  	var buffer = reader.ReadBytes (serializedVersionLength);  }  
Magic Number,Orient.Client.Protocol.Operations,CommitTransaction,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\CommitTransaction.cs,Response,The following statement contains a magic number: if (OClient.ProtocolVersion >= 20) {  	try//if (reader.BaseStream.CanRead && reader.PeekChar() != -1)  	 {  		int collectionChangesCount = reader.ReadInt32EndianAware ();  		for (var i = 0; i < collectionChangesCount; i++) {  			//    throw new NotImplementedException("don't understand what to do with this yet");  			long mBitsOfId = reader.ReadInt64EndianAware ();  			long lBitsOfId = reader.ReadInt64EndianAware ();  			var updatedFileId = reader.ReadInt64EndianAware ();  			var updatedPageIndex = reader.ReadInt64EndianAware ();  			var updatedPageOffset = reader.ReadInt32EndianAware ();  		}  	} catch (Exception ex) {  	}  }  
Magic Number,Orient.Client.Protocol.Operations,CreateRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\CreateRecord.cs,Request,The following statement contains a magic number: if (OClient.ProtocolVersion < 24) {  	request.DataItems.Add (new RequestDataItem () {  		Type = "int"'  		Data = BinarySerializer.ToArray ((int)-1)  	});  	// data segment id  }  
Magic Number,Orient.Client.Protocol.Operations,CreateRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\CreateRecord.cs,Response,The following statement contains a magic number: if (OClient.ProtocolVersion >= 11) {  	_document.OVersion = reader.ReadInt32EndianAware ();  }  
Magic Number,Orient.Client.Protocol.Operations,CreateRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\CreateRecord.cs,Response,The following statement contains a magic number: if (OClient.ProtocolVersion >= 20) {  	try//if (reader.BaseStream.CanRead && reader.PeekChar() != -1)  	 {  		int collectionChangesCount = reader.ReadInt32EndianAware ();  		for (var i = 0; i < collectionChangesCount; i++) {  			//    throw new NotImplementedException("don't understand what to do with this yet");  			var mostSigBits = reader.ReadInt64EndianAware ();  			var leastSigBits = reader.ReadInt64EndianAware ();  			var updatedFileId = reader.ReadInt64EndianAware ();  			var updatedPageIndex = reader.ReadInt64EndianAware ();  			var updatedPageOffset = reader.ReadInt32EndianAware ();  		}  	} catch (Exception ex) {  	}  }  
Magic Number,Orient.Client.Protocol.Operations,DbReload,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbReload.cs,Response,The following statement contains a magic number: if (clusterCount > 0) {  	List<OCluster> clusters = new List<OCluster> ();  	for (int i = 1; i <= clusterCount; i++) {  		OCluster cluster = new OCluster ();  		int clusterNameLength = reader.ReadInt32EndianAware ();  		cluster.Name = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterNameLength));  		cluster.Id = reader.ReadInt16EndianAware ();  		if (OClient.ProtocolVersion < 24) {  			int clusterTypeLength = reader.ReadInt32EndianAware ();  			string clusterType = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterTypeLength));  			//cluster.Type = (OClusterType)Enum.Parse(typeof(OClusterType)' clusterType' true);  			if (OClient.ProtocolVersion >= 12)  				cluster.DataSegmentID = reader.ReadInt16EndianAware ();  			else  				cluster.DataSegmentID = 0;  		}  		clusters.Add (cluster);  	}  	document.SetField ("Clusters"' clusters);  }  
Magic Number,Orient.Client.Protocol.Operations,DbReload,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbReload.cs,Response,The following statement contains a magic number: if (clusterCount > 0) {  	List<OCluster> clusters = new List<OCluster> ();  	for (int i = 1; i <= clusterCount; i++) {  		OCluster cluster = new OCluster ();  		int clusterNameLength = reader.ReadInt32EndianAware ();  		cluster.Name = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterNameLength));  		cluster.Id = reader.ReadInt16EndianAware ();  		if (OClient.ProtocolVersion < 24) {  			int clusterTypeLength = reader.ReadInt32EndianAware ();  			string clusterType = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterTypeLength));  			//cluster.Type = (OClusterType)Enum.Parse(typeof(OClusterType)' clusterType' true);  			if (OClient.ProtocolVersion >= 12)  				cluster.DataSegmentID = reader.ReadInt16EndianAware ();  			else  				cluster.DataSegmentID = 0;  		}  		clusters.Add (cluster);  	}  	document.SetField ("Clusters"' clusters);  }  
Magic Number,Orient.Client.Protocol.Operations,DbReload,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbReload.cs,Response,The following statement contains a magic number: for (int i = 1; i <= clusterCount; i++) {  	OCluster cluster = new OCluster ();  	int clusterNameLength = reader.ReadInt32EndianAware ();  	cluster.Name = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterNameLength));  	cluster.Id = reader.ReadInt16EndianAware ();  	if (OClient.ProtocolVersion < 24) {  		int clusterTypeLength = reader.ReadInt32EndianAware ();  		string clusterType = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterTypeLength));  		//cluster.Type = (OClusterType)Enum.Parse(typeof(OClusterType)' clusterType' true);  		if (OClient.ProtocolVersion >= 12)  			cluster.DataSegmentID = reader.ReadInt16EndianAware ();  		else  			cluster.DataSegmentID = 0;  	}  	clusters.Add (cluster);  }  
Magic Number,Orient.Client.Protocol.Operations,DbReload,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbReload.cs,Response,The following statement contains a magic number: for (int i = 1; i <= clusterCount; i++) {  	OCluster cluster = new OCluster ();  	int clusterNameLength = reader.ReadInt32EndianAware ();  	cluster.Name = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterNameLength));  	cluster.Id = reader.ReadInt16EndianAware ();  	if (OClient.ProtocolVersion < 24) {  		int clusterTypeLength = reader.ReadInt32EndianAware ();  		string clusterType = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterTypeLength));  		//cluster.Type = (OClusterType)Enum.Parse(typeof(OClusterType)' clusterType' true);  		if (OClient.ProtocolVersion >= 12)  			cluster.DataSegmentID = reader.ReadInt16EndianAware ();  		else  			cluster.DataSegmentID = 0;  	}  	clusters.Add (cluster);  }  
Magic Number,Orient.Client.Protocol.Operations,DbReload,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbReload.cs,Response,The following statement contains a magic number: if (OClient.ProtocolVersion < 24) {  	int clusterTypeLength = reader.ReadInt32EndianAware ();  	string clusterType = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterTypeLength));  	//cluster.Type = (OClusterType)Enum.Parse(typeof(OClusterType)' clusterType' true);  	if (OClient.ProtocolVersion >= 12)  		cluster.DataSegmentID = reader.ReadInt16EndianAware ();  	else  		cluster.DataSegmentID = 0;  }  
Magic Number,Orient.Client.Protocol.Operations,DbReload,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbReload.cs,Response,The following statement contains a magic number: if (OClient.ProtocolVersion < 24) {  	int clusterTypeLength = reader.ReadInt32EndianAware ();  	string clusterType = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterTypeLength));  	//cluster.Type = (OClusterType)Enum.Parse(typeof(OClusterType)' clusterType' true);  	if (OClient.ProtocolVersion >= 12)  		cluster.DataSegmentID = reader.ReadInt16EndianAware ();  	else  		cluster.DataSegmentID = 0;  }  
Magic Number,Orient.Client.Protocol.Operations,DbReload,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbReload.cs,Response,The following statement contains a magic number: if (OClient.ProtocolVersion >= 12)  	cluster.DataSegmentID = reader.ReadInt16EndianAware ();  else  	cluster.DataSegmentID = 0;  
Magic Number,Orient.Client.Protocol.Operations,LoadRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\LoadRecord.cs,Request,The following statement contains a magic number: if (OClient.ProtocolVersion >= 9)  	// Ignore Cache 1-true' 0-false  	request.AddDataItem ((byte)0);  
Magic Number,Orient.Client.Protocol.Operations,LoadRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\LoadRecord.cs,Request,The following statement contains a magic number: if (OClient.ProtocolVersion >= 13)  	// Load tombstones 1-true ' 0-false  	request.AddDataItem ((byte)0);  
Magic Number,Orient.Client.Protocol.Operations,TransactionRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\TransactionRecord.cs,AddToRequest,The following statement contains a magic number: switch (RecordType) {  case RecordType.Create:  	request.AddDataItem (GetDocument ().Serialize ());  	break;  case RecordType.Delete:  	request.AddDataItem (Version);  	break;  case RecordType.Update:  	request.AddDataItem (Version);  	//request.AddDataItem((byte)1);  	request.AddDataItem (GetDocument ().Serialize ());  	if (OClient.ProtocolVersion >= 23) {  		request.AddDataItem ((byte)1);  		// updateContent flag   	}  	break;  default:  	throw new InvalidOperationException ();  }  
Magic Number,Orient.Client.Protocol.Operations,TransactionRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\TransactionRecord.cs,AddToRequest,The following statement contains a magic number: if (OClient.ProtocolVersion >= 23) {  	request.AddDataItem ((byte)1);  	// updateContent flag   }  
Magic Number,Orient.Client.Protocol.Operations,Connect,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Connect.cs,Request,The following statement contains a magic number: if (OClient.ProtocolVersion > 7) {  	request.DataItems.Add (new RequestDataItem () {  		Type = "string"'  		Data = BinarySerializer.ToArray (OClient.DriverName)  	});  	request.DataItems.Add (new RequestDataItem () {  		Type = "string"'  		Data = BinarySerializer.ToArray (OClient.DriverVersion)  	});  	request.DataItems.Add (new RequestDataItem () {  		Type = "short"'  		Data = BinarySerializer.ToArray (OClient.ProtocolVersion)  	});  	request.DataItems.Add (new RequestDataItem () {  		Type = "string"'  		Data = BinarySerializer.ToArray (OClient.ClientID)  	});  }  
Magic Number,Orient.Client.Protocol.Operations,Connect,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Connect.cs,Request,The following statement contains a magic number: if (OClient.ProtocolVersion > 21) {  	request.DataItems.Add (new RequestDataItem {  		Type = "string"'  		Data = BinarySerializer.ToArray (OClient.SerializationImpl)  	});  }  
Magic Number,Orient.Client.Protocol.Operations,DbDrop,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbDrop.cs,Request,The following statement contains a magic number: if (OClient.ProtocolVersion >= 16)  	//since 1.5 snapshot but not in 1.5  	request.DataItems.Add (new RequestDataItem () {  		Type = "string"'  		Data = BinarySerializer.ToArray (StorageType.ToString ().ToLower ())  	});  
Magic Number,Orient.Client.Protocol.Operations,DbExist,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbExist.cs,Request,The following statement contains a magic number: if (OClient.ProtocolVersion >= 16)  	//since 1.5 snapshot but not in 1.5  	request.DataItems.Add (new RequestDataItem () {  		Type = "string"'  		Data = BinarySerializer.ToArray (StorageType.ToString ().ToLower ())  	});  
Magic Number,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,Request,The following statement contains a magic number: request.DataItems.Add (new RequestDataItem () {  	Type = "int"'  	Data = BinarySerializer.ToArray (//4 + // this int  	4 + // class name int length  	BinarySerializer.Length (className) + 4 + // limit int length  	4 + // text int length  	BinarySerializer.Length (CommandPayload.Text) + 4 + // fetch plant int length  	BinarySerializer.Length (CommandPayload.FetchPlan) + 4// serialized params int (disable)  	)  });  
Magic Number,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,Request,The following statement contains a magic number: request.DataItems.Add (new RequestDataItem () {  	Type = "int"'  	Data = BinarySerializer.ToArray (//4 + // this int  	4 + // class name int length  	BinarySerializer.Length (className) + 4 + // limit int length  	4 + // text int length  	BinarySerializer.Length (CommandPayload.Text) + 4 + // fetch plant int length  	BinarySerializer.Length (CommandPayload.FetchPlan) + 4// serialized params int (disable)  	)  });  
Magic Number,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,Request,The following statement contains a magic number: request.DataItems.Add (new RequestDataItem () {  	Type = "int"'  	Data = BinarySerializer.ToArray (//4 + // this int  	4 + // class name int length  	BinarySerializer.Length (className) + 4 + // limit int length  	4 + // text int length  	BinarySerializer.Length (CommandPayload.Text) + 4 + // fetch plant int length  	BinarySerializer.Length (CommandPayload.FetchPlan) + 4// serialized params int (disable)  	)  });  
Magic Number,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,Request,The following statement contains a magic number: request.DataItems.Add (new RequestDataItem () {  	Type = "int"'  	Data = BinarySerializer.ToArray (//4 + // this int  	4 + // class name int length  	BinarySerializer.Length (className) + 4 + // limit int length  	4 + // text int length  	BinarySerializer.Length (CommandPayload.Text) + 4 + // fetch plant int length  	BinarySerializer.Length (CommandPayload.FetchPlan) + 4// serialized params int (disable)  	)  });  
Magic Number,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,Request,The following statement contains a magic number: request.DataItems.Add (new RequestDataItem () {  	Type = "int"'  	Data = BinarySerializer.ToArray (//4 + // this int  	4 + // class name int length  	BinarySerializer.Length (className) + 4 + // limit int length  	4 + // text int length  	BinarySerializer.Length (CommandPayload.Text) + 4 + // fetch plant int length  	BinarySerializer.Length (CommandPayload.FetchPlan) + 4// serialized params int (disable)  	)  });  
Magic Number,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,Response,The following statement contains a magic number: if (OperationMode == OperationMode.Asynchronous) {  	List<ODocument> documents = new List<ODocument> ();  	while (payloadStatus != PayloadStatus.NoRemainingRecords) {  		ODocument document = ParseDocument (reader);  		switch (payloadStatus) {  		case PayloadStatus.ResultSet:  			documents.Add (document);  			break;  		case PayloadStatus.PreFetched:  			//client cache  			response.Connection.Database.ClientCache [document.ORID] = document;  			break;  		default:  			break;  		}  		payloadStatus = (PayloadStatus)reader.ReadByte ();  	}  	responseDocument.SetField ("Content"' documents);  } else {  	int contentLength;  	switch (payloadStatus) {  	case PayloadStatus.NullResult:  		// 'n'  		// nothing to do  		break;  	case PayloadStatus.SingleRecord:  		// 'r'  		ODocument document = ParseDocument (reader);  		responseDocument.SetField ("Content"' document);  		break;  	case PayloadStatus.SerializedResult:  		// 'a'  		// TODO: how to parse result - string?  		contentLength = reader.ReadInt32EndianAware ();  		string serialized = System.Text.Encoding.Default.GetString (reader.ReadBytes (contentLength));  		responseDocument.SetField ("Content"' serialized);  		break;  	case PayloadStatus.RecordCollection:  		// 'l'  		List<ODocument> documents = new List<ODocument> ();  		int recordsCount = reader.ReadInt32EndianAware ();  		for (int i = 0; i < recordsCount; i++) {  			documents.Add (ParseDocument (reader));  		}  		responseDocument.SetField ("Content"' documents);  		break;  	default:  		break;  	}  	if (OClient.ProtocolVersion >= 17) {  		//Load the fetched records in cache  		while ((payloadStatus = (PayloadStatus)reader.ReadByte ()) != PayloadStatus.NoRemainingRecords) {  			ODocument document = ParseDocument (reader);  			if (document != null && payloadStatus == PayloadStatus.PreFetched) {  				//Put in the client local cache  				response.Connection.Database.ClientCache [document.ORID] = document;  			}  		}  	}  }  
Magic Number,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,Response,The following statement contains a magic number: if (OClient.ProtocolVersion >= 17) {  	//Load the fetched records in cache  	while ((payloadStatus = (PayloadStatus)reader.ReadByte ()) != PayloadStatus.NoRemainingRecords) {  		ODocument document = ParseDocument (reader);  		if (document != null && payloadStatus == PayloadStatus.PreFetched) {  			//Put in the client local cache  			response.Connection.Database.ClientCache [document.ORID] = document;  		}  	}  }  
Magic Number,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,ParseDocument,The following statement contains a magic number: if (classId == -2)// NULL   {  } else if (classId == -3)// record id   {  	ORID orid = new ORID ();  	orid.ClusterId = reader.ReadInt16EndianAware ();  	orid.ClusterPosition = reader.ReadInt64EndianAware ();  	document = new ODocument ();  	document.ORID = orid;  	document.OClassId = classId;  } else {  	ORecordType type = (ORecordType)reader.ReadByte ();  	ORID orid = new ORID ();  	orid.ClusterId = reader.ReadInt16EndianAware ();  	orid.ClusterPosition = reader.ReadInt64EndianAware ();  	int version = reader.ReadInt32EndianAware ();  	int recordLength = reader.ReadInt32EndianAware ();  	byte[] rawRecord = reader.ReadBytes (recordLength);  	document = RecordSerializer.Deserialize (orid' version' type' classId' rawRecord);  }  
Magic Number,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,ParseDocument,The following statement contains a magic number: if (classId == -2)// NULL   {  } else if (classId == -3)// record id   {  	ORID orid = new ORID ();  	orid.ClusterId = reader.ReadInt16EndianAware ();  	orid.ClusterPosition = reader.ReadInt64EndianAware ();  	document = new ODocument ();  	document.ORID = orid;  	document.OClassId = classId;  } else {  	ORecordType type = (ORecordType)reader.ReadByte ();  	ORID orid = new ORID ();  	orid.ClusterId = reader.ReadInt16EndianAware ();  	orid.ClusterPosition = reader.ReadInt64EndianAware ();  	int version = reader.ReadInt32EndianAware ();  	int recordLength = reader.ReadInt32EndianAware ();  	byte[] rawRecord = reader.ReadBytes (recordLength);  	document = RecordSerializer.Deserialize (orid' version' type' classId' rawRecord);  }  
Magic Number,Orient.Client.Protocol.Operations,Command,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\Command.cs,ParseDocument,The following statement contains a magic number: if (classId == -3)// record id   {  	ORID orid = new ORID ();  	orid.ClusterId = reader.ReadInt16EndianAware ();  	orid.ClusterPosition = reader.ReadInt64EndianAware ();  	document = new ODocument ();  	document.ORID = orid;  	document.OClassId = classId;  } else {  	ORecordType type = (ORecordType)reader.ReadByte ();  	ORID orid = new ORID ();  	orid.ClusterId = reader.ReadInt16EndianAware ();  	orid.ClusterPosition = reader.ReadInt64EndianAware ();  	int version = reader.ReadInt32EndianAware ();  	int recordLength = reader.ReadInt32EndianAware ();  	byte[] rawRecord = reader.ReadBytes (recordLength);  	document = RecordSerializer.Deserialize (orid' version' type' classId' rawRecord);  }  
Magic Number,Orient.Client.Protocol.Operations,DbOpen,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbOpen.cs,Request,The following statement contains a magic number: if (OClient.ProtocolVersion >= 7) {  	request.DataItems.Add (new RequestDataItem () {  		Type = "string"'  		Data = BinarySerializer.ToArray (OClient.DriverName)  	});  	request.DataItems.Add (new RequestDataItem () {  		Type = "string"'  		Data = BinarySerializer.ToArray (OClient.DriverVersion)  	});  	request.DataItems.Add (new RequestDataItem () {  		Type = "short"'  		Data = BinarySerializer.ToArray (OClient.ProtocolVersion)  	});  	request.DataItems.Add (new RequestDataItem () {  		Type = "string"'  		Data = BinarySerializer.ToArray (OClient.ClientID)  	});  }  
Magic Number,Orient.Client.Protocol.Operations,DbOpen,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbOpen.cs,Request,The following statement contains a magic number: if (OClient.ProtocolVersion > 21) {  	request.DataItems.Add (new RequestDataItem {  		Type = "string"'  		Data = BinarySerializer.ToArray (OClient.SerializationImpl)  	});  }  
Magic Number,Orient.Client.Protocol.Operations,DbOpen,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbOpen.cs,Request,The following statement contains a magic number: if (OClient.ProtocolVersion >= 8) {  	request.DataItems.Add (new RequestDataItem () {  		Type = "string"'  		Data = BinarySerializer.ToArray (DatabaseType.ToString ().ToLower ())  	});  }  
Magic Number,Orient.Client.Protocol.Operations,DbOpen,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbOpen.cs,Response,The following statement contains a magic number: if (OClient.ProtocolVersion >= 7)  	clusterCount = (int)reader.ReadInt16EndianAware ();  else  	clusterCount = reader.ReadInt32EndianAware ();  
Magic Number,Orient.Client.Protocol.Operations,DbOpen,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbOpen.cs,Response,The following statement contains a magic number: if (clusterCount > 0) {  	List<OCluster> clusters = new List<OCluster> ();  	for (int i = 1; i <= clusterCount; i++) {  		OCluster cluster = new OCluster ();  		int clusterNameLength = reader.ReadInt32EndianAware ();  		cluster.Name = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterNameLength));  		cluster.Id = reader.ReadInt16EndianAware ();  		if (OClient.ProtocolVersion < 24) {  			int clusterTypeLength = reader.ReadInt32EndianAware ();  			string clusterType = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterTypeLength));  			//cluster.Type = (OClusterType)Enum.Parse(typeof(OClusterType)' clusterType' true);  			if (OClient.ProtocolVersion >= 12)  				cluster.DataSegmentID = reader.ReadInt16EndianAware ();  			else  				cluster.DataSegmentID = 0;  		}  		clusters.Add (cluster);  	}  	document.SetField ("Clusters"' clusters);  }  
Magic Number,Orient.Client.Protocol.Operations,DbOpen,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbOpen.cs,Response,The following statement contains a magic number: if (clusterCount > 0) {  	List<OCluster> clusters = new List<OCluster> ();  	for (int i = 1; i <= clusterCount; i++) {  		OCluster cluster = new OCluster ();  		int clusterNameLength = reader.ReadInt32EndianAware ();  		cluster.Name = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterNameLength));  		cluster.Id = reader.ReadInt16EndianAware ();  		if (OClient.ProtocolVersion < 24) {  			int clusterTypeLength = reader.ReadInt32EndianAware ();  			string clusterType = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterTypeLength));  			//cluster.Type = (OClusterType)Enum.Parse(typeof(OClusterType)' clusterType' true);  			if (OClient.ProtocolVersion >= 12)  				cluster.DataSegmentID = reader.ReadInt16EndianAware ();  			else  				cluster.DataSegmentID = 0;  		}  		clusters.Add (cluster);  	}  	document.SetField ("Clusters"' clusters);  }  
Magic Number,Orient.Client.Protocol.Operations,DbOpen,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbOpen.cs,Response,The following statement contains a magic number: for (int i = 1; i <= clusterCount; i++) {  	OCluster cluster = new OCluster ();  	int clusterNameLength = reader.ReadInt32EndianAware ();  	cluster.Name = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterNameLength));  	cluster.Id = reader.ReadInt16EndianAware ();  	if (OClient.ProtocolVersion < 24) {  		int clusterTypeLength = reader.ReadInt32EndianAware ();  		string clusterType = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterTypeLength));  		//cluster.Type = (OClusterType)Enum.Parse(typeof(OClusterType)' clusterType' true);  		if (OClient.ProtocolVersion >= 12)  			cluster.DataSegmentID = reader.ReadInt16EndianAware ();  		else  			cluster.DataSegmentID = 0;  	}  	clusters.Add (cluster);  }  
Magic Number,Orient.Client.Protocol.Operations,DbOpen,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbOpen.cs,Response,The following statement contains a magic number: for (int i = 1; i <= clusterCount; i++) {  	OCluster cluster = new OCluster ();  	int clusterNameLength = reader.ReadInt32EndianAware ();  	cluster.Name = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterNameLength));  	cluster.Id = reader.ReadInt16EndianAware ();  	if (OClient.ProtocolVersion < 24) {  		int clusterTypeLength = reader.ReadInt32EndianAware ();  		string clusterType = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterTypeLength));  		//cluster.Type = (OClusterType)Enum.Parse(typeof(OClusterType)' clusterType' true);  		if (OClient.ProtocolVersion >= 12)  			cluster.DataSegmentID = reader.ReadInt16EndianAware ();  		else  			cluster.DataSegmentID = 0;  	}  	clusters.Add (cluster);  }  
Magic Number,Orient.Client.Protocol.Operations,DbOpen,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbOpen.cs,Response,The following statement contains a magic number: if (OClient.ProtocolVersion < 24) {  	int clusterTypeLength = reader.ReadInt32EndianAware ();  	string clusterType = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterTypeLength));  	//cluster.Type = (OClusterType)Enum.Parse(typeof(OClusterType)' clusterType' true);  	if (OClient.ProtocolVersion >= 12)  		cluster.DataSegmentID = reader.ReadInt16EndianAware ();  	else  		cluster.DataSegmentID = 0;  }  
Magic Number,Orient.Client.Protocol.Operations,DbOpen,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbOpen.cs,Response,The following statement contains a magic number: if (OClient.ProtocolVersion < 24) {  	int clusterTypeLength = reader.ReadInt32EndianAware ();  	string clusterType = System.Text.Encoding.Default.GetString (reader.ReadBytes (clusterTypeLength));  	//cluster.Type = (OClusterType)Enum.Parse(typeof(OClusterType)' clusterType' true);  	if (OClient.ProtocolVersion >= 12)  		cluster.DataSegmentID = reader.ReadInt16EndianAware ();  	else  		cluster.DataSegmentID = 0;  }  
Magic Number,Orient.Client.Protocol.Operations,DbOpen,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\DbOpen.cs,Response,The following statement contains a magic number: if (OClient.ProtocolVersion >= 12)  	cluster.DataSegmentID = reader.ReadInt16EndianAware ();  else  	cluster.DataSegmentID = 0;  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,SerializeValue,The following statement contains a magic number: switch (Type.GetTypeCode (valueType)) {  case TypeCode.Empty:  	// null case is empty  	break;  case TypeCode.Boolean:  	return value.ToString ().ToLower ();  case TypeCode.Byte:  	return value.ToString () + "b";  case TypeCode.Int16:  	return value.ToString () + "s";  case TypeCode.Int32:  	return value.ToString ();  case TypeCode.Int64:  	return value.ToString () + "l";  case TypeCode.Single:  	return ((float)value).ToString (CultureInfo.InvariantCulture) + "f";  case TypeCode.Double:  	return ((double)value).ToString (CultureInfo.InvariantCulture) + "d";  case TypeCode.Decimal:  	return ((decimal)value).ToString (CultureInfo.InvariantCulture) + "c";  case TypeCode.DateTime:  	DateTime unixEpoch = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  	return ((long)((DateTime)value - unixEpoch).TotalMilliseconds).ToString () + "t";  case TypeCode.String:  case TypeCode.Char:  	// strings must escape these characters:  	// " -> \"  	// \ -> \\  	string stringValue = value.ToString ();  	// escape quotes  	stringValue = stringValue.Replace ("\\"' "\\\\");  	// escape backslashes  	stringValue = stringValue.Replace ("\""' "\\" + "\"");  	return "\"" + stringValue + "\"";  case TypeCode.Object:  	return SerializeObjectValue (value' valueType);  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseString,The following statement contains a magic number: while (recordString [i] != '"') {  	// strings must escape these characters:  	// " -> \"  	// \ -> \\  	// therefore there needs to be a check for valid end of the string which  	// is quote character that is not preceeded by backslash character \  	if ((recordString [i] == '\\') && (recordString [i + 1] == '"')) {  		i = i + 2;  	} else {  		i++;  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseString,The following statement contains a magic number: if ((recordString [i] == '\\') && (recordString [i + 1] == '"')) {  	i = i + 2;  } else {  	i++;  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseString,The following statement contains a magic number: i = i + 2;  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if (stringValue.Length > 0) {  	// binary content  	if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  		stringValue = stringValue.Substring (1' stringValue.Length - 2);  		// need to be able for base64 encoding which requires content to be devidable by 4  		int mod4 = stringValue.Length % 4;  		if (mod4 > 0) {  			stringValue += new string ('='' 4 - mod4);  		}  		value = Convert.FromBase64String (stringValue);  	} // datetime or date  	else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  		// Unix timestamp is miliseconds past epoch  		DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  		string foo = stringValue.Substring (0' stringValue.Length - 1);  		double d = double.Parse (foo);  		value = epoch.AddMilliseconds (d).ToUniversalTime ();  	} // boolean  	else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  		value = (stringValue == "true") ? true : false;  	} // numbers  	else {  		char lastCharacter = stringValue [stringValue.Length - 1];  		switch (lastCharacter) {  		case 'b':  			value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 's':  			value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'l':  			value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'f':  			value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'd':  			value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'c':  			value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		default:  			value = int.Parse (stringValue);  			break;  		}  	}  } // null  else if (stringValue.Length == 0) {  	value = null;  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if (stringValue.Length > 0) {  	// binary content  	if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  		stringValue = stringValue.Substring (1' stringValue.Length - 2);  		// need to be able for base64 encoding which requires content to be devidable by 4  		int mod4 = stringValue.Length % 4;  		if (mod4 > 0) {  			stringValue += new string ('='' 4 - mod4);  		}  		value = Convert.FromBase64String (stringValue);  	} // datetime or date  	else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  		// Unix timestamp is miliseconds past epoch  		DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  		string foo = stringValue.Substring (0' stringValue.Length - 1);  		double d = double.Parse (foo);  		value = epoch.AddMilliseconds (d).ToUniversalTime ();  	} // boolean  	else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  		value = (stringValue == "true") ? true : false;  	} // numbers  	else {  		char lastCharacter = stringValue [stringValue.Length - 1];  		switch (lastCharacter) {  		case 'b':  			value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 's':  			value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'l':  			value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'f':  			value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'd':  			value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'c':  			value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		default:  			value = int.Parse (stringValue);  			break;  		}  	}  } // null  else if (stringValue.Length == 0) {  	value = null;  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if (stringValue.Length > 0) {  	// binary content  	if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  		stringValue = stringValue.Substring (1' stringValue.Length - 2);  		// need to be able for base64 encoding which requires content to be devidable by 4  		int mod4 = stringValue.Length % 4;  		if (mod4 > 0) {  			stringValue += new string ('='' 4 - mod4);  		}  		value = Convert.FromBase64String (stringValue);  	} // datetime or date  	else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  		// Unix timestamp is miliseconds past epoch  		DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  		string foo = stringValue.Substring (0' stringValue.Length - 1);  		double d = double.Parse (foo);  		value = epoch.AddMilliseconds (d).ToUniversalTime ();  	} // boolean  	else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  		value = (stringValue == "true") ? true : false;  	} // numbers  	else {  		char lastCharacter = stringValue [stringValue.Length - 1];  		switch (lastCharacter) {  		case 'b':  			value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 's':  			value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'l':  			value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'f':  			value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'd':  			value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'c':  			value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		default:  			value = int.Parse (stringValue);  			break;  		}  	}  } // null  else if (stringValue.Length == 0) {  	value = null;  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if (stringValue.Length > 0) {  	// binary content  	if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  		stringValue = stringValue.Substring (1' stringValue.Length - 2);  		// need to be able for base64 encoding which requires content to be devidable by 4  		int mod4 = stringValue.Length % 4;  		if (mod4 > 0) {  			stringValue += new string ('='' 4 - mod4);  		}  		value = Convert.FromBase64String (stringValue);  	} // datetime or date  	else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  		// Unix timestamp is miliseconds past epoch  		DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  		string foo = stringValue.Substring (0' stringValue.Length - 1);  		double d = double.Parse (foo);  		value = epoch.AddMilliseconds (d).ToUniversalTime ();  	} // boolean  	else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  		value = (stringValue == "true") ? true : false;  	} // numbers  	else {  		char lastCharacter = stringValue [stringValue.Length - 1];  		switch (lastCharacter) {  		case 'b':  			value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 's':  			value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'l':  			value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'f':  			value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'd':  			value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'c':  			value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		default:  			value = int.Parse (stringValue);  			break;  		}  	}  } // null  else if (stringValue.Length == 0) {  	value = null;  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if (stringValue.Length > 0) {  	// binary content  	if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  		stringValue = stringValue.Substring (1' stringValue.Length - 2);  		// need to be able for base64 encoding which requires content to be devidable by 4  		int mod4 = stringValue.Length % 4;  		if (mod4 > 0) {  			stringValue += new string ('='' 4 - mod4);  		}  		value = Convert.FromBase64String (stringValue);  	} // datetime or date  	else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  		// Unix timestamp is miliseconds past epoch  		DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  		string foo = stringValue.Substring (0' stringValue.Length - 1);  		double d = double.Parse (foo);  		value = epoch.AddMilliseconds (d).ToUniversalTime ();  	} // boolean  	else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  		value = (stringValue == "true") ? true : false;  	} // numbers  	else {  		char lastCharacter = stringValue [stringValue.Length - 1];  		switch (lastCharacter) {  		case 'b':  			value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 's':  			value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'l':  			value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'f':  			value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'd':  			value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'c':  			value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		default:  			value = int.Parse (stringValue);  			break;  		}  	}  } // null  else if (stringValue.Length == 0) {  	value = null;  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if (stringValue.Length > 0) {  	// binary content  	if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  		stringValue = stringValue.Substring (1' stringValue.Length - 2);  		// need to be able for base64 encoding which requires content to be devidable by 4  		int mod4 = stringValue.Length % 4;  		if (mod4 > 0) {  			stringValue += new string ('='' 4 - mod4);  		}  		value = Convert.FromBase64String (stringValue);  	} // datetime or date  	else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  		// Unix timestamp is miliseconds past epoch  		DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  		string foo = stringValue.Substring (0' stringValue.Length - 1);  		double d = double.Parse (foo);  		value = epoch.AddMilliseconds (d).ToUniversalTime ();  	} // boolean  	else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  		value = (stringValue == "true") ? true : false;  	} // numbers  	else {  		char lastCharacter = stringValue [stringValue.Length - 1];  		switch (lastCharacter) {  		case 'b':  			value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 's':  			value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'l':  			value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'f':  			value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'd':  			value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'c':  			value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		default:  			value = int.Parse (stringValue);  			break;  		}  	}  } // null  else if (stringValue.Length == 0) {  	value = null;  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if (stringValue.Length > 0) {  	// binary content  	if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  		stringValue = stringValue.Substring (1' stringValue.Length - 2);  		// need to be able for base64 encoding which requires content to be devidable by 4  		int mod4 = stringValue.Length % 4;  		if (mod4 > 0) {  			stringValue += new string ('='' 4 - mod4);  		}  		value = Convert.FromBase64String (stringValue);  	} // datetime or date  	else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  		// Unix timestamp is miliseconds past epoch  		DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  		string foo = stringValue.Substring (0' stringValue.Length - 1);  		double d = double.Parse (foo);  		value = epoch.AddMilliseconds (d).ToUniversalTime ();  	} // boolean  	else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  		value = (stringValue == "true") ? true : false;  	} // numbers  	else {  		char lastCharacter = stringValue [stringValue.Length - 1];  		switch (lastCharacter) {  		case 'b':  			value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 's':  			value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'l':  			value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  			break;  		case 'f':  			value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'd':  			value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		case 'c':  			value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  			break;  		default:  			value = int.Parse (stringValue);  			break;  		}  	}  } // null  else if (stringValue.Length == 0) {  	value = null;  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  	stringValue = stringValue.Substring (1' stringValue.Length - 2);  	// need to be able for base64 encoding which requires content to be devidable by 4  	int mod4 = stringValue.Length % 4;  	if (mod4 > 0) {  		stringValue += new string ('='' 4 - mod4);  	}  	value = Convert.FromBase64String (stringValue);  } // datetime or date  else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  	// Unix timestamp is miliseconds past epoch  	DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  	string foo = stringValue.Substring (0' stringValue.Length - 1);  	double d = double.Parse (foo);  	value = epoch.AddMilliseconds (d).ToUniversalTime ();  } // boolean  else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  	value = (stringValue == "true") ? true : false;  } // numbers  else {  	char lastCharacter = stringValue [stringValue.Length - 1];  	switch (lastCharacter) {  	case 'b':  		value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 's':  		value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'l':  		value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'f':  		value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'd':  		value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'c':  		value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	default:  		value = int.Parse (stringValue);  		break;  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  	stringValue = stringValue.Substring (1' stringValue.Length - 2);  	// need to be able for base64 encoding which requires content to be devidable by 4  	int mod4 = stringValue.Length % 4;  	if (mod4 > 0) {  		stringValue += new string ('='' 4 - mod4);  	}  	value = Convert.FromBase64String (stringValue);  } // datetime or date  else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  	// Unix timestamp is miliseconds past epoch  	DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  	string foo = stringValue.Substring (0' stringValue.Length - 1);  	double d = double.Parse (foo);  	value = epoch.AddMilliseconds (d).ToUniversalTime ();  } // boolean  else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  	value = (stringValue == "true") ? true : false;  } // numbers  else {  	char lastCharacter = stringValue [stringValue.Length - 1];  	switch (lastCharacter) {  	case 'b':  		value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 's':  		value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'l':  		value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'f':  		value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'd':  		value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'c':  		value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	default:  		value = int.Parse (stringValue);  		break;  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  	stringValue = stringValue.Substring (1' stringValue.Length - 2);  	// need to be able for base64 encoding which requires content to be devidable by 4  	int mod4 = stringValue.Length % 4;  	if (mod4 > 0) {  		stringValue += new string ('='' 4 - mod4);  	}  	value = Convert.FromBase64String (stringValue);  } // datetime or date  else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  	// Unix timestamp is miliseconds past epoch  	DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  	string foo = stringValue.Substring (0' stringValue.Length - 1);  	double d = double.Parse (foo);  	value = epoch.AddMilliseconds (d).ToUniversalTime ();  } // boolean  else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  	value = (stringValue == "true") ? true : false;  } // numbers  else {  	char lastCharacter = stringValue [stringValue.Length - 1];  	switch (lastCharacter) {  	case 'b':  		value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 's':  		value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'l':  		value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'f':  		value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'd':  		value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'c':  		value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	default:  		value = int.Parse (stringValue);  		break;  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  	stringValue = stringValue.Substring (1' stringValue.Length - 2);  	// need to be able for base64 encoding which requires content to be devidable by 4  	int mod4 = stringValue.Length % 4;  	if (mod4 > 0) {  		stringValue += new string ('='' 4 - mod4);  	}  	value = Convert.FromBase64String (stringValue);  } // datetime or date  else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  	// Unix timestamp is miliseconds past epoch  	DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  	string foo = stringValue.Substring (0' stringValue.Length - 1);  	double d = double.Parse (foo);  	value = epoch.AddMilliseconds (d).ToUniversalTime ();  } // boolean  else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  	value = (stringValue == "true") ? true : false;  } // numbers  else {  	char lastCharacter = stringValue [stringValue.Length - 1];  	switch (lastCharacter) {  	case 'b':  		value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 's':  		value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'l':  		value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'f':  		value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'd':  		value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'c':  		value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	default:  		value = int.Parse (stringValue);  		break;  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  	stringValue = stringValue.Substring (1' stringValue.Length - 2);  	// need to be able for base64 encoding which requires content to be devidable by 4  	int mod4 = stringValue.Length % 4;  	if (mod4 > 0) {  		stringValue += new string ('='' 4 - mod4);  	}  	value = Convert.FromBase64String (stringValue);  } // datetime or date  else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  	// Unix timestamp is miliseconds past epoch  	DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  	string foo = stringValue.Substring (0' stringValue.Length - 1);  	double d = double.Parse (foo);  	value = epoch.AddMilliseconds (d).ToUniversalTime ();  } // boolean  else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  	value = (stringValue == "true") ? true : false;  } // numbers  else {  	char lastCharacter = stringValue [stringValue.Length - 1];  	switch (lastCharacter) {  	case 'b':  		value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 's':  		value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'l':  		value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'f':  		value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'd':  		value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'c':  		value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	default:  		value = int.Parse (stringValue);  		break;  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  	stringValue = stringValue.Substring (1' stringValue.Length - 2);  	// need to be able for base64 encoding which requires content to be devidable by 4  	int mod4 = stringValue.Length % 4;  	if (mod4 > 0) {  		stringValue += new string ('='' 4 - mod4);  	}  	value = Convert.FromBase64String (stringValue);  } // datetime or date  else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  	// Unix timestamp is miliseconds past epoch  	DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  	string foo = stringValue.Substring (0' stringValue.Length - 1);  	double d = double.Parse (foo);  	value = epoch.AddMilliseconds (d).ToUniversalTime ();  } // boolean  else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  	value = (stringValue == "true") ? true : false;  } // numbers  else {  	char lastCharacter = stringValue [stringValue.Length - 1];  	switch (lastCharacter) {  	case 'b':  		value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 's':  		value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'l':  		value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'f':  		value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'd':  		value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'c':  		value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	default:  		value = int.Parse (stringValue);  		break;  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if ((stringValue.Length > 2) && (stringValue [0] == '_') && (stringValue [stringValue.Length - 1] == '_')) {  	stringValue = stringValue.Substring (1' stringValue.Length - 2);  	// need to be able for base64 encoding which requires content to be devidable by 4  	int mod4 = stringValue.Length % 4;  	if (mod4 > 0) {  		stringValue += new string ('='' 4 - mod4);  	}  	value = Convert.FromBase64String (stringValue);  } // datetime or date  else if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  	// Unix timestamp is miliseconds past epoch  	DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  	string foo = stringValue.Substring (0' stringValue.Length - 1);  	double d = double.Parse (foo);  	value = epoch.AddMilliseconds (d).ToUniversalTime ();  } // boolean  else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  	value = (stringValue == "true") ? true : false;  } // numbers  else {  	char lastCharacter = stringValue [stringValue.Length - 1];  	switch (lastCharacter) {  	case 'b':  		value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 's':  		value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'l':  		value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'f':  		value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'd':  		value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'c':  		value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	default:  		value = int.Parse (stringValue);  		break;  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: stringValue = stringValue.Substring (1' stringValue.Length - 2);  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if (mod4 > 0) {  	stringValue += new string ('='' 4 - mod4);  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: stringValue += new string ('='' 4 - mod4);  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  	// Unix timestamp is miliseconds past epoch  	DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  	string foo = stringValue.Substring (0' stringValue.Length - 1);  	double d = double.Parse (foo);  	value = epoch.AddMilliseconds (d).ToUniversalTime ();  } // boolean  else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  	value = (stringValue == "true") ? true : false;  } // numbers  else {  	char lastCharacter = stringValue [stringValue.Length - 1];  	switch (lastCharacter) {  	case 'b':  		value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 's':  		value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'l':  		value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'f':  		value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'd':  		value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'c':  		value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	default:  		value = int.Parse (stringValue);  		break;  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  	// Unix timestamp is miliseconds past epoch  	DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  	string foo = stringValue.Substring (0' stringValue.Length - 1);  	double d = double.Parse (foo);  	value = epoch.AddMilliseconds (d).ToUniversalTime ();  } // boolean  else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  	value = (stringValue == "true") ? true : false;  } // numbers  else {  	char lastCharacter = stringValue [stringValue.Length - 1];  	switch (lastCharacter) {  	case 'b':  		value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 's':  		value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'l':  		value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'f':  		value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'd':  		value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'c':  		value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	default:  		value = int.Parse (stringValue);  		break;  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if ((stringValue.Length > 2) && (stringValue [stringValue.Length - 1] == 't') || (stringValue [stringValue.Length - 1] == 'a')) {  	// Unix timestamp is miliseconds past epoch  	DateTime epoch = new DateTime (1970' 1' 1' 0' 0' 0' 0' DateTimeKind.Utc);  	string foo = stringValue.Substring (0' stringValue.Length - 1);  	double d = double.Parse (foo);  	value = epoch.AddMilliseconds (d).ToUniversalTime ();  } // boolean  else if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  	value = (stringValue == "true") ? true : false;  } // numbers  else {  	char lastCharacter = stringValue [stringValue.Length - 1];  	switch (lastCharacter) {  	case 'b':  		value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 's':  		value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'l':  		value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'f':  		value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'd':  		value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'c':  		value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	default:  		value = int.Parse (stringValue);  		break;  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseValue,The following statement contains a magic number: if ((stringValue.Length > 2) && (stringValue == "true") || (stringValue == "false")) {  	value = (stringValue == "true") ? true : false;  } // numbers  else {  	char lastCharacter = stringValue [stringValue.Length - 1];  	switch (lastCharacter) {  	case 'b':  		value = byte.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 's':  		value = short.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'l':  		value = long.Parse (stringValue.Substring (0' stringValue.Length - 1));  		break;  	case 'f':  		value = float.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'd':  		value = double.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	case 'c':  		value = decimal.Parse (stringValue.Substring (0' stringValue.Length - 1)' CultureInfo.InvariantCulture);  		break;  	default:  		value = int.Parse (stringValue);  		break;  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRidBags,The following statement contains a magic number: using (var stream = new MemoryStream (value))  	using (var reader = new BinaryReader (stream)) {  		var first = reader.ReadByte ();  		int offset = 1;  		if ((first & 2) == 2) {  			// uuid parsing is not implemented  			offset += 16;  		}  		if ((first & 1) == 1)// 1 - embedded'0 - tree-based   		 {  			var entriesSize = reader.ReadInt32EndianAware ();  			for (int j = 0; j < entriesSize; j++) {  				var clusterid = reader.ReadInt16EndianAware ();  				var clusterposition = reader.ReadInt64EndianAware ();  				rids.Add (new ORID (clusterid' clusterposition));  			}  		} else {  			throw new NotImplementedException ("tree based ridbag");  		}  	}  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRidBags,The following statement contains a magic number: using (var stream = new MemoryStream (value))  	using (var reader = new BinaryReader (stream)) {  		var first = reader.ReadByte ();  		int offset = 1;  		if ((first & 2) == 2) {  			// uuid parsing is not implemented  			offset += 16;  		}  		if ((first & 1) == 1)// 1 - embedded'0 - tree-based   		 {  			var entriesSize = reader.ReadInt32EndianAware ();  			for (int j = 0; j < entriesSize; j++) {  				var clusterid = reader.ReadInt16EndianAware ();  				var clusterposition = reader.ReadInt64EndianAware ();  				rids.Add (new ORID (clusterid' clusterposition));  			}  		} else {  			throw new NotImplementedException ("tree based ridbag");  		}  	}  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRidBags,The following statement contains a magic number: using (var stream = new MemoryStream (value))  	using (var reader = new BinaryReader (stream)) {  		var first = reader.ReadByte ();  		int offset = 1;  		if ((first & 2) == 2) {  			// uuid parsing is not implemented  			offset += 16;  		}  		if ((first & 1) == 1)// 1 - embedded'0 - tree-based   		 {  			var entriesSize = reader.ReadInt32EndianAware ();  			for (int j = 0; j < entriesSize; j++) {  				var clusterid = reader.ReadInt16EndianAware ();  				var clusterposition = reader.ReadInt64EndianAware ();  				rids.Add (new ORID (clusterid' clusterposition));  			}  		} else {  			throw new NotImplementedException ("tree based ridbag");  		}  	}  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRidBags,The following statement contains a magic number: using (var reader = new BinaryReader (stream)) {  	var first = reader.ReadByte ();  	int offset = 1;  	if ((first & 2) == 2) {  		// uuid parsing is not implemented  		offset += 16;  	}  	if ((first & 1) == 1)// 1 - embedded'0 - tree-based   	 {  		var entriesSize = reader.ReadInt32EndianAware ();  		for (int j = 0; j < entriesSize; j++) {  			var clusterid = reader.ReadInt16EndianAware ();  			var clusterposition = reader.ReadInt64EndianAware ();  			rids.Add (new ORID (clusterid' clusterposition));  		}  	} else {  		throw new NotImplementedException ("tree based ridbag");  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRidBags,The following statement contains a magic number: using (var reader = new BinaryReader (stream)) {  	var first = reader.ReadByte ();  	int offset = 1;  	if ((first & 2) == 2) {  		// uuid parsing is not implemented  		offset += 16;  	}  	if ((first & 1) == 1)// 1 - embedded'0 - tree-based   	 {  		var entriesSize = reader.ReadInt32EndianAware ();  		for (int j = 0; j < entriesSize; j++) {  			var clusterid = reader.ReadInt16EndianAware ();  			var clusterposition = reader.ReadInt64EndianAware ();  			rids.Add (new ORID (clusterid' clusterposition));  		}  	} else {  		throw new NotImplementedException ("tree based ridbag");  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRidBags,The following statement contains a magic number: using (var reader = new BinaryReader (stream)) {  	var first = reader.ReadByte ();  	int offset = 1;  	if ((first & 2) == 2) {  		// uuid parsing is not implemented  		offset += 16;  	}  	if ((first & 1) == 1)// 1 - embedded'0 - tree-based   	 {  		var entriesSize = reader.ReadInt32EndianAware ();  		for (int j = 0; j < entriesSize; j++) {  			var clusterid = reader.ReadInt16EndianAware ();  			var clusterposition = reader.ReadInt64EndianAware ();  			rids.Add (new ORID (clusterid' clusterposition));  		}  	} else {  		throw new NotImplementedException ("tree based ridbag");  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRidBags,The following statement contains a magic number: if ((first & 2) == 2) {  	// uuid parsing is not implemented  	offset += 16;  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRidBags,The following statement contains a magic number: if ((first & 2) == 2) {  	// uuid parsing is not implemented  	offset += 16;  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRidBags,The following statement contains a magic number: if ((first & 2) == 2) {  	// uuid parsing is not implemented  	offset += 16;  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseRidBags,The following statement contains a magic number: offset += 16;  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseEmbeddedDocument,The following statement contains a magic number: if ((i < 15) && (recordString.Length > 15) && (recordString.Substring (i' 15).Equals ("ORIDs@pageSize:"))) {  	OLinkCollection linkCollection = new OLinkCollection ();  	i = ParseLinkCollection (i' recordString' linkCollection);  	document [fieldName] = linkCollection;  } else {  	// create new dictionary which would hold K/V pairs of embedded document  	ODocument embeddedDocument = new ODocument ();  	// assign embedded object  	if (document [fieldName] == null) {  		document [fieldName] = embeddedDocument;  	} else if (document [fieldName] is HashSet<object>) {  		((HashSet<object>)document [fieldName]).Add (embeddedDocument);  	} else {  		((List<object>)document [fieldName]).Add (embeddedDocument);  	}  	// start parsing field names until the closing bracket of embedded document is reached  	while (recordString [i] != ')') {  		i = ParseFieldName (i' recordString' embeddedDocument);  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseEmbeddedDocument,The following statement contains a magic number: if ((i < 15) && (recordString.Length > 15) && (recordString.Substring (i' 15).Equals ("ORIDs@pageSize:"))) {  	OLinkCollection linkCollection = new OLinkCollection ();  	i = ParseLinkCollection (i' recordString' linkCollection);  	document [fieldName] = linkCollection;  } else {  	// create new dictionary which would hold K/V pairs of embedded document  	ODocument embeddedDocument = new ODocument ();  	// assign embedded object  	if (document [fieldName] == null) {  		document [fieldName] = embeddedDocument;  	} else if (document [fieldName] is HashSet<object>) {  		((HashSet<object>)document [fieldName]).Add (embeddedDocument);  	} else {  		((List<object>)document [fieldName]).Add (embeddedDocument);  	}  	// start parsing field names until the closing bracket of embedded document is reached  	while (recordString [i] != ')') {  		i = ParseFieldName (i' recordString' embeddedDocument);  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseEmbeddedDocument,The following statement contains a magic number: if ((i < 15) && (recordString.Length > 15) && (recordString.Substring (i' 15).Equals ("ORIDs@pageSize:"))) {  	OLinkCollection linkCollection = new OLinkCollection ();  	i = ParseLinkCollection (i' recordString' linkCollection);  	document [fieldName] = linkCollection;  } else {  	// create new dictionary which would hold K/V pairs of embedded document  	ODocument embeddedDocument = new ODocument ();  	// assign embedded object  	if (document [fieldName] == null) {  		document [fieldName] = embeddedDocument;  	} else if (document [fieldName] is HashSet<object>) {  		((HashSet<object>)document [fieldName]).Add (embeddedDocument);  	} else {  		((List<object>)document [fieldName]).Add (embeddedDocument);  	}  	// start parsing field names until the closing bracket of embedded document is reached  	while (recordString [i] != ')') {  		i = ParseFieldName (i' recordString' embeddedDocument);  	}  }  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseLinkCollection,The following statement contains a magic number: i += 15;  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseLinkCollection,The following statement contains a magic number: i = index + 6;  
Magic Number,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,ParseLinkCollection,The following statement contains a magic number: i = index + 9;  
Missing Default,Orient.Client.Mapping,TypeMapper,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Mapping\TypeMapper.cs,TypeMapper,The following switch statement is missing a default case: switch (propertyName) {  case "ORID":  	_fields.Add (new ORIDFieldMapping<T> (propertyInfo));  	continue;  case "OVersion":  	_fields.Add (new OVersionFieldMapping<T> (propertyInfo));  	continue;  case "OClassId":  	_fields.Add (new OClassIdFieldMapping<T> (propertyInfo));  	continue;  case "OClassName":  	_fields.Add (new OClassNameFieldMapping<T> (propertyInfo));  	continue;  }  
Missing Default,Orient.Client.Protocol.Operations,LoadRecord,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Operations\LoadRecord.cs,ReadPrimaryResult,The following switch statement is missing a default case: switch (recordType) {  case ORecordType.Document:  	string serialized = System.Text.Encoding.Default.GetString (readBytes);  	document = RecordSerializer.Deserialize (serialized);  	document.ORID = _orid;  	document.OVersion = version;  	responseDocument.SetField ("Content"' document);  	break;  case ORecordType.RawBytes:  	document.SetField ("RawBytes"' readBytes);  	responseDocument.SetField ("Content"' document);  	break;  case ORecordType.FlatData:  	break;  }  
Missing Default,Orient.Client.Protocol.Serializers,RecordSerializer,D:\newReposJune17\yojimbo87_OrientDB-NET.binary\src\Orient\Orient.Client\Protocol\Serializers\RecordSerializer.cs,SerializeValue,The following switch statement is missing a default case: switch (Type.GetTypeCode (valueType)) {  case TypeCode.Empty:  	// null case is empty  	break;  case TypeCode.Boolean:  	return value.ToString ().ToLower ();  case TypeCode.Byte:  	return value.ToString () + "b";  case TypeCode.Int16:  	return value.ToString () + "s";  case TypeCode.Int32:  	return value.ToString ();  case TypeCode.Int64:  	return value.ToString () + "l";  case TypeCode.Single:  	return ((float)value).ToString (CultureInfo.InvariantCulture) + "f";  case TypeCode.Double:  	return ((double)value).ToString (CultureInfo.InvariantCulture) + "d";  case TypeCode.Decimal:  	return ((decimal)value).ToString (CultureInfo.InvariantCulture) + "c";  case TypeCode.DateTime:  	DateTime unixEpoch = new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);  	return ((long)((DateTime)value - unixEpoch).TotalMilliseconds).ToString () + "t";  case TypeCode.String:  case TypeCode.Char:  	// strings must escape these characters:  	// " -> \"  	// \ -> \\  	string stringValue = value.ToString ();  	// escape quotes  	stringValue = stringValue.Replace ("\\"' "\\\\");  	// escape backslashes  	stringValue = stringValue.Replace ("\""' "\\" + "\"");  	return "\"" + stringValue + "\"";  case TypeCode.Object:  	return SerializeObjectValue (value' valueType);  }  
