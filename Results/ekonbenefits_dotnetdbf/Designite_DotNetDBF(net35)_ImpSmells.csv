Implementation smell,Namespace,Class,File,Method,Description
Long Method,DotNetDBF,DBFReader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFReader.cs,NextRecord,The method has 214 lines of code.
Long Method,DotNetDBF,DBFWriter,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFWriter.cs,WriteRecord,The method has 134 lines of code.
Complex Method,DotNetDBF,DBFReader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFReader.cs,NextRecord,Cyclomatic complexity of the method is 19
Complex Method,DotNetDBF,DBFWriter,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFWriter.cs,AddRecord,Cyclomatic complexity of the method is 13
Complex Method,DotNetDBF,DBFWriter,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFWriter.cs,WriteRecord,Cyclomatic complexity of the method is 15
Long Parameter List,DotNetDBF,Utils,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\Utils.cs,textPadding,The method has 5 parameters. Parameters: text' charEncoding' length' alignment' paddingByte
Complex Conditional,DotNetDBF,DBFReader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFReader.cs,NextRecord,The conditional expression  "tOrderdSelectIndexes.Count == j && j != 0                          ||                          (tOrderdSelectIndexes.Count > j && tOrderdSelectIndexes[j] > i && tOrderdSelectIndexes[j] != k)"  is complex.
Complex Conditional,DotNetDBF,DBFReader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFReader.cs,NextRecord,The conditional expression  "t_logical == 'Y' || t_logical == 't'                                  || t_logical == 'T'                                  || t_logical == 't'"  is complex.
Magic Number,DotNetDBF,DBFField,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFField.cs,Read,The following statement contains a magic number: reader.Read(fieldName' 1' 10);
Magic Number,DotNetDBF,DBFField,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFField.cs,Read,The following statement contains a magic number: reader.Read(reserv4' 0' 7);
Magic Number,DotNetDBF,DBFField,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFField.cs,Write,The following statement contains a magic number: writer.Write(new byte[11 - fieldName.Length]'                            0'                            11 - fieldName.Length);
Magic Number,DotNetDBF,DBFField,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFField.cs,Write,The following statement contains a magic number: writer.Write(new byte[11 - fieldName.Length]'                            0'                            11 - fieldName.Length);
Magic Number,DotNetDBF,DBFHeader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFHeader.cs,Write,The following statement contains a magic number: Year = (byte) (tNow.Year - 1900);
Magic Number,DotNetDBF,DBFReader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFReader.cs,DBFReader,The following statement contains a magic number: var t_dataStartIndex = _header.HeaderLength                                         - (32 + (32 * _header.FieldArray.Length))                                         - 1;
Magic Number,DotNetDBF,DBFReader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFReader.cs,DBFReader,The following statement contains a magic number: var t_dataStartIndex = _header.HeaderLength                                         - (32 + (32 * _header.FieldArray.Length))                                         - 1;
Magic Number,DotNetDBF,DBFReader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFReader.cs,DBFReader,The following statement contains a magic number: var t_dataStartIndex = _header.HeaderLength                                         - (32 + (32 * _header.FieldArray.Length))                                         - 1;
Magic Number,DotNetDBF,DBFReader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFReader.cs,DBFReader,The following statement contains a magic number: var t_dataStartIndex = _header.HeaderLength                                         - (32 + (32 * _header.FieldArray.Length))                                         - 1;
Magic Number,DotNetDBF,DBFReader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFReader.cs,NextRecord,The following statement contains a magic number: switch (_header.FieldArray[i].DataType)                      {                          case NativeDbType.Char:                                var b_array = new byte[                                  _header.FieldArray[i].FieldLength                                  ];                              _dataInputStream.Read(b_array' 0' b_array.Length);                                recordObjects[i] = CharEncoding.GetString(b_array).TrimEnd();                              break;                            case NativeDbType.Date:                                var t_byte_year = new byte[4];                              _dataInputStream.Read(t_byte_year'                                  0'                                  t_byte_year.Length);                                var t_byte_month = new byte[2];                              _dataInputStream.Read(t_byte_month'                                  0'                                  t_byte_month.Length);                                var t_byte_day = new byte[2];                              _dataInputStream.Read(t_byte_day'                                  0'                                  t_byte_day.Length);                                try                              {                                  var tYear = CharEncoding.GetString(t_byte_year);                                  var tMonth = CharEncoding.GetString(t_byte_month);                                  var tDay = CharEncoding.GetString(t_byte_day);                                    if (int.TryParse(tYear' out var tIntYear) &&                                      int.TryParse(tMonth' out var tIntMonth) &&                                      int.TryParse(tDay' out var tIntDay))                                  {                                      recordObjects[i] = new DateTime(                                          tIntYear'                                          tIntMonth'                                          tIntDay);                                  }                                  else                                  {                                      recordObjects[i] = null;                                  }                              }                              catch (ArgumentOutOfRangeException)                              {                                  /* this field may be empty or may have improper value set */                                  recordObjects[i] = null;                              }                                break;                            case NativeDbType.Float:                                try                              {                                  var t_float = new byte[                                      _header.FieldArray[i].FieldLength                                      ];                                  _dataInputStream.Read(t_float' 0' t_float.Length);                                  var tParsed = CharEncoding.GetString(t_float);                                  var tLast = tParsed.Substring(tParsed.Length - 1);                                  if (tParsed.Length > 0                                      && tLast != " "                                      && tLast != NullSymbol)                                  {                                      //                                      // A Float in FoxPro has 20 significant digits' since it is                                      // stored as a string with possible E-postfix notation.                                      // An IEEE 754 float or double can not handle this number of digits                                      // correctly. Therefor the only correct implementation is to use a decimal.                                      //                                      recordObjects[i] = decimal.Parse(tParsed'                                          NumberStyles.Float | NumberStyles.AllowLeadingWhite'                                          NumberFormatInfo.InvariantInfo);                                  }                                  else                                  {                                      recordObjects[i] = null;                                  }                              }                              catch (FormatException e)                              {                                  throw new DBFException("Failed to parse Float"'                                      e);                              }                                break;                            case NativeDbType.Numeric:                                try                              {                                  var t_numeric = new byte[                                      _header.FieldArray[i].FieldLength                                      ];                                  _dataInputStream.Read(t_numeric'                                      0'                                      t_numeric.Length);                                  var tParsed =                                      CharEncoding.GetString(t_numeric);                                  var tLast = tParsed.Substring(tParsed.Length - 1);                                  if (tParsed.Length > 0                                      && tLast != " "                                      && tLast != NullSymbol)                                  {                                      recordObjects[i] = decimal.Parse(tParsed'                                          NumberStyles.Float | NumberStyles.AllowLeadingWhite'                                          NumberFormatInfo.InvariantInfo);                                  }                                  else                                  {                                      recordObjects[i] = null;                                  }                              }                              catch (FormatException e)                              {                                  throw new DBFException(                                      "Failed to parse Number"' e);                              }                                break;                            case NativeDbType.Logical:                                var t_logical = _dataInputStream.ReadByte();                              //todo find out whats really valid                              if (t_logical == 'Y' || t_logical == 't'                                  || t_logical == 'T'                                  || t_logical == 't')                              {                                  recordObjects[i] = true;                              }                              else if (t_logical == DBFFieldType.UnknownByte)                              {                                  recordObjects[i] = DBNull.Value;                              }                              else                              {                                  recordObjects[i] = false;                              }                              break;                            case NativeDbType.Memo:                              if (                                    string.IsNullOrEmpty(_dataMemoLoc) &&                                     _dataMemo is null)                              {                                  throw new Exception("Memo Location Not Set");                              }                                  var rawMemoPointer = _dataInputStream.ReadBytes(_header.FieldArray[i].FieldLength);                              var memoPointer = CharEncoding.GetString(rawMemoPointer);                              if (string.IsNullOrEmpty(memoPointer))                              {                                  recordObjects[i] = DBNull.Value;                                  break;                              }                                if (!long.TryParse(memoPointer' out var tBlock))                              {                                  //Because Memo files can vary and are often the least important data'                                   //we will return null when it doesn't match our format.                                  recordObjects[i] = DBNull.Value;                                  break;                              }                                  recordObjects[i] = new MemoValue(tBlock' this'                                   _dataMemoLoc'                                  GetLazyStreamFromLocation());                              break;                          default:                              {                                  byte[] data = _dataInputStream.ReadBytes(_header.FieldArray[i].FieldLength);                                    recordObjects[i] = data != null ? (object)data : DBNull.Value;                                    break;                              }                      }
Magic Number,DotNetDBF,DBFReader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFReader.cs,NextRecord,The following statement contains a magic number: switch (_header.FieldArray[i].DataType)                      {                          case NativeDbType.Char:                                var b_array = new byte[                                  _header.FieldArray[i].FieldLength                                  ];                              _dataInputStream.Read(b_array' 0' b_array.Length);                                recordObjects[i] = CharEncoding.GetString(b_array).TrimEnd();                              break;                            case NativeDbType.Date:                                var t_byte_year = new byte[4];                              _dataInputStream.Read(t_byte_year'                                  0'                                  t_byte_year.Length);                                var t_byte_month = new byte[2];                              _dataInputStream.Read(t_byte_month'                                  0'                                  t_byte_month.Length);                                var t_byte_day = new byte[2];                              _dataInputStream.Read(t_byte_day'                                  0'                                  t_byte_day.Length);                                try                              {                                  var tYear = CharEncoding.GetString(t_byte_year);                                  var tMonth = CharEncoding.GetString(t_byte_month);                                  var tDay = CharEncoding.GetString(t_byte_day);                                    if (int.TryParse(tYear' out var tIntYear) &&                                      int.TryParse(tMonth' out var tIntMonth) &&                                      int.TryParse(tDay' out var tIntDay))                                  {                                      recordObjects[i] = new DateTime(                                          tIntYear'                                          tIntMonth'                                          tIntDay);                                  }                                  else                                  {                                      recordObjects[i] = null;                                  }                              }                              catch (ArgumentOutOfRangeException)                              {                                  /* this field may be empty or may have improper value set */                                  recordObjects[i] = null;                              }                                break;                            case NativeDbType.Float:                                try                              {                                  var t_float = new byte[                                      _header.FieldArray[i].FieldLength                                      ];                                  _dataInputStream.Read(t_float' 0' t_float.Length);                                  var tParsed = CharEncoding.GetString(t_float);                                  var tLast = tParsed.Substring(tParsed.Length - 1);                                  if (tParsed.Length > 0                                      && tLast != " "                                      && tLast != NullSymbol)                                  {                                      //                                      // A Float in FoxPro has 20 significant digits' since it is                                      // stored as a string with possible E-postfix notation.                                      // An IEEE 754 float or double can not handle this number of digits                                      // correctly. Therefor the only correct implementation is to use a decimal.                                      //                                      recordObjects[i] = decimal.Parse(tParsed'                                          NumberStyles.Float | NumberStyles.AllowLeadingWhite'                                          NumberFormatInfo.InvariantInfo);                                  }                                  else                                  {                                      recordObjects[i] = null;                                  }                              }                              catch (FormatException e)                              {                                  throw new DBFException("Failed to parse Float"'                                      e);                              }                                break;                            case NativeDbType.Numeric:                                try                              {                                  var t_numeric = new byte[                                      _header.FieldArray[i].FieldLength                                      ];                                  _dataInputStream.Read(t_numeric'                                      0'                                      t_numeric.Length);                                  var tParsed =                                      CharEncoding.GetString(t_numeric);                                  var tLast = tParsed.Substring(tParsed.Length - 1);                                  if (tParsed.Length > 0                                      && tLast != " "                                      && tLast != NullSymbol)                                  {                                      recordObjects[i] = decimal.Parse(tParsed'                                          NumberStyles.Float | NumberStyles.AllowLeadingWhite'                                          NumberFormatInfo.InvariantInfo);                                  }                                  else                                  {                                      recordObjects[i] = null;                                  }                              }                              catch (FormatException e)                              {                                  throw new DBFException(                                      "Failed to parse Number"' e);                              }                                break;                            case NativeDbType.Logical:                                var t_logical = _dataInputStream.ReadByte();                              //todo find out whats really valid                              if (t_logical == 'Y' || t_logical == 't'                                  || t_logical == 'T'                                  || t_logical == 't')                              {                                  recordObjects[i] = true;                              }                              else if (t_logical == DBFFieldType.UnknownByte)                              {                                  recordObjects[i] = DBNull.Value;                              }                              else                              {                                  recordObjects[i] = false;                              }                              break;                            case NativeDbType.Memo:                              if (                                    string.IsNullOrEmpty(_dataMemoLoc) &&                                     _dataMemo is null)                              {                                  throw new Exception("Memo Location Not Set");                              }                                  var rawMemoPointer = _dataInputStream.ReadBytes(_header.FieldArray[i].FieldLength);                              var memoPointer = CharEncoding.GetString(rawMemoPointer);                              if (string.IsNullOrEmpty(memoPointer))                              {                                  recordObjects[i] = DBNull.Value;                                  break;                              }                                if (!long.TryParse(memoPointer' out var tBlock))                              {                                  //Because Memo files can vary and are often the least important data'                                   //we will return null when it doesn't match our format.                                  recordObjects[i] = DBNull.Value;                                  break;                              }                                  recordObjects[i] = new MemoValue(tBlock' this'                                   _dataMemoLoc'                                  GetLazyStreamFromLocation());                              break;                          default:                              {                                  byte[] data = _dataInputStream.ReadBytes(_header.FieldArray[i].FieldLength);                                    recordObjects[i] = data != null ? (object)data : DBNull.Value;                                    break;                              }                      }
Magic Number,DotNetDBF,DBFReader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFReader.cs,NextRecord,The following statement contains a magic number: switch (_header.FieldArray[i].DataType)                      {                          case NativeDbType.Char:                                var b_array = new byte[                                  _header.FieldArray[i].FieldLength                                  ];                              _dataInputStream.Read(b_array' 0' b_array.Length);                                recordObjects[i] = CharEncoding.GetString(b_array).TrimEnd();                              break;                            case NativeDbType.Date:                                var t_byte_year = new byte[4];                              _dataInputStream.Read(t_byte_year'                                  0'                                  t_byte_year.Length);                                var t_byte_month = new byte[2];                              _dataInputStream.Read(t_byte_month'                                  0'                                  t_byte_month.Length);                                var t_byte_day = new byte[2];                              _dataInputStream.Read(t_byte_day'                                  0'                                  t_byte_day.Length);                                try                              {                                  var tYear = CharEncoding.GetString(t_byte_year);                                  var tMonth = CharEncoding.GetString(t_byte_month);                                  var tDay = CharEncoding.GetString(t_byte_day);                                    if (int.TryParse(tYear' out var tIntYear) &&                                      int.TryParse(tMonth' out var tIntMonth) &&                                      int.TryParse(tDay' out var tIntDay))                                  {                                      recordObjects[i] = new DateTime(                                          tIntYear'                                          tIntMonth'                                          tIntDay);                                  }                                  else                                  {                                      recordObjects[i] = null;                                  }                              }                              catch (ArgumentOutOfRangeException)                              {                                  /* this field may be empty or may have improper value set */                                  recordObjects[i] = null;                              }                                break;                            case NativeDbType.Float:                                try                              {                                  var t_float = new byte[                                      _header.FieldArray[i].FieldLength                                      ];                                  _dataInputStream.Read(t_float' 0' t_float.Length);                                  var tParsed = CharEncoding.GetString(t_float);                                  var tLast = tParsed.Substring(tParsed.Length - 1);                                  if (tParsed.Length > 0                                      && tLast != " "                                      && tLast != NullSymbol)                                  {                                      //                                      // A Float in FoxPro has 20 significant digits' since it is                                      // stored as a string with possible E-postfix notation.                                      // An IEEE 754 float or double can not handle this number of digits                                      // correctly. Therefor the only correct implementation is to use a decimal.                                      //                                      recordObjects[i] = decimal.Parse(tParsed'                                          NumberStyles.Float | NumberStyles.AllowLeadingWhite'                                          NumberFormatInfo.InvariantInfo);                                  }                                  else                                  {                                      recordObjects[i] = null;                                  }                              }                              catch (FormatException e)                              {                                  throw new DBFException("Failed to parse Float"'                                      e);                              }                                break;                            case NativeDbType.Numeric:                                try                              {                                  var t_numeric = new byte[                                      _header.FieldArray[i].FieldLength                                      ];                                  _dataInputStream.Read(t_numeric'                                      0'                                      t_numeric.Length);                                  var tParsed =                                      CharEncoding.GetString(t_numeric);                                  var tLast = tParsed.Substring(tParsed.Length - 1);                                  if (tParsed.Length > 0                                      && tLast != " "                                      && tLast != NullSymbol)                                  {                                      recordObjects[i] = decimal.Parse(tParsed'                                          NumberStyles.Float | NumberStyles.AllowLeadingWhite'                                          NumberFormatInfo.InvariantInfo);                                  }                                  else                                  {                                      recordObjects[i] = null;                                  }                              }                              catch (FormatException e)                              {                                  throw new DBFException(                                      "Failed to parse Number"' e);                              }                                break;                            case NativeDbType.Logical:                                var t_logical = _dataInputStream.ReadByte();                              //todo find out whats really valid                              if (t_logical == 'Y' || t_logical == 't'                                  || t_logical == 'T'                                  || t_logical == 't')                              {                                  recordObjects[i] = true;                              }                              else if (t_logical == DBFFieldType.UnknownByte)                              {                                  recordObjects[i] = DBNull.Value;                              }                              else                              {                                  recordObjects[i] = false;                              }                              break;                            case NativeDbType.Memo:                              if (                                    string.IsNullOrEmpty(_dataMemoLoc) &&                                     _dataMemo is null)                              {                                  throw new Exception("Memo Location Not Set");                              }                                  var rawMemoPointer = _dataInputStream.ReadBytes(_header.FieldArray[i].FieldLength);                              var memoPointer = CharEncoding.GetString(rawMemoPointer);                              if (string.IsNullOrEmpty(memoPointer))                              {                                  recordObjects[i] = DBNull.Value;                                  break;                              }                                if (!long.TryParse(memoPointer' out var tBlock))                              {                                  //Because Memo files can vary and are often the least important data'                                   //we will return null when it doesn't match our format.                                  recordObjects[i] = DBNull.Value;                                  break;                              }                                  recordObjects[i] = new MemoValue(tBlock' this'                                   _dataMemoLoc'                                  GetLazyStreamFromLocation());                              break;                          default:                              {                                  byte[] data = _dataInputStream.ReadBytes(_header.FieldArray[i].FieldLength);                                    recordObjects[i] = data != null ? (object)data : DBNull.Value;                                    break;                              }                      }
Magic Number,DotNetDBF,DBFWriter,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFWriter.cs,WriteRecord,The following statement contains a magic number: switch (header.FieldArray[j].DataType)                  {                      case NativeDbType.Char:                          if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var str_value = objectArray[j].ToString();                              dataOutput.Write(                                  Utils.textPadding(str_value'                                      CharEncoding'                                      header.FieldArray[j].                                          FieldLength                                  )                              );                          }                          else                          {                              dataOutput.Write(                                  Utils.textPadding(""'                                      CharEncoding'                                      header.FieldArray[j].                                          FieldLength                                  )                              );                          }                            break;                        case NativeDbType.Date:                          if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var tDate = (DateTime) objectArray[j];                                dataOutput.Write(                                  CharEncoding.GetBytes(tDate.ToString("yyyyMMdd")));                          }                          else                          {                              dataOutput.Write(                                  Utils.FillArray(new byte[8]' DBFFieldType.Space));                          }                            break;                        case NativeDbType.Float:                            if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var tDouble = Convert.ToDecimal(objectArray[j]);                              dataOutput.Write(                                  Utils.NumericFormating(                                      tDouble'                                      CharEncoding'                                      header.FieldArray[j].FieldLength'                                      header.FieldArray[j].DecimalCount                                  )                              );                          }                          else                          {                              dataOutput.Write(                                  Utils.textPadding(                                      NullSymbol'                                      CharEncoding'                                      header.FieldArray[j].FieldLength'                                      Utils.ALIGN_RIGHT                                  )                              );                          }                            break;                        case NativeDbType.Numeric:                            if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var tDecimal = Convert.ToDecimal(objectArray[j]);                              dataOutput.Write(                                  Utils.NumericFormating(                                      tDecimal'                                      CharEncoding'                                      header.FieldArray[j].FieldLength'                                      header.FieldArray[j].DecimalCount                                  )                              );                          }                          else                          {                              dataOutput.Write(                                  Utils.textPadding(                                      NullSymbol'                                      CharEncoding'                                      header.FieldArray[j].FieldLength'                                      Utils.ALIGN_RIGHT                                  )                              );                          }                            break;                      case NativeDbType.Logical:                            if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              if ((bool) objectArray[j])                              {                                  dataOutput.Write(DBFFieldType.True);                              }                              else                              {                                  dataOutput.Write(DBFFieldType.False);                              }                          }                          else                          {                              dataOutput.Write(DBFFieldType.UnknownByte);                          }                            break;                        case NativeDbType.Memo:                          if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var tMemoValue = ((MemoValue) objectArray[j]);                                tMemoValue.Write(this);                                dataOutput.Write(Utils.NumericFormating(tMemoValue.Block' CharEncoding' 10' 0));                          }                          else                          {                              dataOutput.Write(                                  Utils.textPadding(""'                                      CharEncoding'                                      10                                  )                              );                          }                              break;                        default:                          throw new DBFException("Unknown field type "                                                 + header.FieldArray[j].DataType);                  }
Magic Number,DotNetDBF,DBFWriter,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFWriter.cs,WriteRecord,The following statement contains a magic number: switch (header.FieldArray[j].DataType)                  {                      case NativeDbType.Char:                          if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var str_value = objectArray[j].ToString();                              dataOutput.Write(                                  Utils.textPadding(str_value'                                      CharEncoding'                                      header.FieldArray[j].                                          FieldLength                                  )                              );                          }                          else                          {                              dataOutput.Write(                                  Utils.textPadding(""'                                      CharEncoding'                                      header.FieldArray[j].                                          FieldLength                                  )                              );                          }                            break;                        case NativeDbType.Date:                          if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var tDate = (DateTime) objectArray[j];                                dataOutput.Write(                                  CharEncoding.GetBytes(tDate.ToString("yyyyMMdd")));                          }                          else                          {                              dataOutput.Write(                                  Utils.FillArray(new byte[8]' DBFFieldType.Space));                          }                            break;                        case NativeDbType.Float:                            if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var tDouble = Convert.ToDecimal(objectArray[j]);                              dataOutput.Write(                                  Utils.NumericFormating(                                      tDouble'                                      CharEncoding'                                      header.FieldArray[j].FieldLength'                                      header.FieldArray[j].DecimalCount                                  )                              );                          }                          else                          {                              dataOutput.Write(                                  Utils.textPadding(                                      NullSymbol'                                      CharEncoding'                                      header.FieldArray[j].FieldLength'                                      Utils.ALIGN_RIGHT                                  )                              );                          }                            break;                        case NativeDbType.Numeric:                            if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var tDecimal = Convert.ToDecimal(objectArray[j]);                              dataOutput.Write(                                  Utils.NumericFormating(                                      tDecimal'                                      CharEncoding'                                      header.FieldArray[j].FieldLength'                                      header.FieldArray[j].DecimalCount                                  )                              );                          }                          else                          {                              dataOutput.Write(                                  Utils.textPadding(                                      NullSymbol'                                      CharEncoding'                                      header.FieldArray[j].FieldLength'                                      Utils.ALIGN_RIGHT                                  )                              );                          }                            break;                      case NativeDbType.Logical:                            if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              if ((bool) objectArray[j])                              {                                  dataOutput.Write(DBFFieldType.True);                              }                              else                              {                                  dataOutput.Write(DBFFieldType.False);                              }                          }                          else                          {                              dataOutput.Write(DBFFieldType.UnknownByte);                          }                            break;                        case NativeDbType.Memo:                          if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var tMemoValue = ((MemoValue) objectArray[j]);                                tMemoValue.Write(this);                                dataOutput.Write(Utils.NumericFormating(tMemoValue.Block' CharEncoding' 10' 0));                          }                          else                          {                              dataOutput.Write(                                  Utils.textPadding(""'                                      CharEncoding'                                      10                                  )                              );                          }                              break;                        default:                          throw new DBFException("Unknown field type "                                                 + header.FieldArray[j].DataType);                  }
Magic Number,DotNetDBF,DBFWriter,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBFWriter.cs,WriteRecord,The following statement contains a magic number: switch (header.FieldArray[j].DataType)                  {                      case NativeDbType.Char:                          if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var str_value = objectArray[j].ToString();                              dataOutput.Write(                                  Utils.textPadding(str_value'                                      CharEncoding'                                      header.FieldArray[j].                                          FieldLength                                  )                              );                          }                          else                          {                              dataOutput.Write(                                  Utils.textPadding(""'                                      CharEncoding'                                      header.FieldArray[j].                                          FieldLength                                  )                              );                          }                            break;                        case NativeDbType.Date:                          if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var tDate = (DateTime) objectArray[j];                                dataOutput.Write(                                  CharEncoding.GetBytes(tDate.ToString("yyyyMMdd")));                          }                          else                          {                              dataOutput.Write(                                  Utils.FillArray(new byte[8]' DBFFieldType.Space));                          }                            break;                        case NativeDbType.Float:                            if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var tDouble = Convert.ToDecimal(objectArray[j]);                              dataOutput.Write(                                  Utils.NumericFormating(                                      tDouble'                                      CharEncoding'                                      header.FieldArray[j].FieldLength'                                      header.FieldArray[j].DecimalCount                                  )                              );                          }                          else                          {                              dataOutput.Write(                                  Utils.textPadding(                                      NullSymbol'                                      CharEncoding'                                      header.FieldArray[j].FieldLength'                                      Utils.ALIGN_RIGHT                                  )                              );                          }                            break;                        case NativeDbType.Numeric:                            if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var tDecimal = Convert.ToDecimal(objectArray[j]);                              dataOutput.Write(                                  Utils.NumericFormating(                                      tDecimal'                                      CharEncoding'                                      header.FieldArray[j].FieldLength'                                      header.FieldArray[j].DecimalCount                                  )                              );                          }                          else                          {                              dataOutput.Write(                                  Utils.textPadding(                                      NullSymbol'                                      CharEncoding'                                      header.FieldArray[j].FieldLength'                                      Utils.ALIGN_RIGHT                                  )                              );                          }                            break;                      case NativeDbType.Logical:                            if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              if ((bool) objectArray[j])                              {                                  dataOutput.Write(DBFFieldType.True);                              }                              else                              {                                  dataOutput.Write(DBFFieldType.False);                              }                          }                          else                          {                              dataOutput.Write(DBFFieldType.UnknownByte);                          }                            break;                        case NativeDbType.Memo:                          if (objectArray[j] != null && objectArray[j] != DBNull.Value)                          {                              var tMemoValue = ((MemoValue) objectArray[j]);                                tMemoValue.Write(this);                                dataOutput.Write(Utils.NumericFormating(tMemoValue.Block' CharEncoding' 10' 0));                          }                          else                          {                              dataOutput.Write(                                  Utils.textPadding(""'                                      CharEncoding'                                      10                                  )                              );                          }                              break;                        default:                          throw new DBFException("Unknown field type "                                                 + header.FieldArray[j].DataType);                  }
Magic Number,DotNetDBF,DBTHeader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBTHeader.cs,Write,The following statement contains a magic number: dataOutput.Write(new byte[12]);
Magic Number,DotNetDBF,DBTHeader,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\DBTHeader.cs,Write,The following statement contains a magic number: dataOutput.Write(new byte[495]);
Missing Default,DotNetDBF,Utils,D:\research\architectureSmells\repos\ekonbenefits_dotnetdbf\DotNetDBF\Utils.cs,textPadding,The following switch statement is missing a default case: switch (alignment)              {                  case ALIGN_LEFT:                      Array.Copy(inputBytes'                          0'                          byte_array'                          0'                          inputBytes.Length);                      break;                    case ALIGN_RIGHT:                      var t_offset = length - text.Length;                      Array.Copy(inputBytes'                          0'                          byte_array'                          t_offset'                          inputBytes.Length);                      break;              }
