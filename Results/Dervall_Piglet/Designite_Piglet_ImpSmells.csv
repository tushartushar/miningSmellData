Implementation smell,Namespace,Class,File,Method,Description
Long Method,Piglet.Lexer.Construction,DFA,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\DFA.cs,Minimize,The method has 191 lines of code.
Long Method,Piglet.Lexer.Construction,RegExLexer,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\RegExLexer.cs,NextToken,The method has 208 lines of code.
Complex Method,Piglet.Common,CompressedTable,F:\newReposMay17\Dervall_Piglet\Piglet\Common\CompressedTable.cs,CompressedTable,Cyclomatic complexity of the method is 10
Complex Method,Piglet.Lexer.Construction,CharSet,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\CharSet.cs,ClipRange,Cyclomatic complexity of the method is 9
Complex Method,Piglet.Lexer.Construction,DFA,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\DFA.cs,Create,Cyclomatic complexity of the method is 11
Complex Method,Piglet.Lexer.Construction,DFA,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\DFA.cs,Minimize,Cyclomatic complexity of the method is 15
Complex Method,Piglet.Lexer.Construction,FiniteAutomata,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\FiniteAutomata.cs,FindNewRanges,Cyclomatic complexity of the method is 8
Complex Method,Piglet.Lexer.Construction,NfaBuilder,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\NfaBuilder.cs,Create,Cyclomatic complexity of the method is 27
Complex Method,Piglet.Lexer.Construction,RegExLexer,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\RegExLexer.cs,EscapedCharToAcceptCharRange,Cyclomatic complexity of the method is 22
Complex Method,Piglet.Lexer.Construction,RegExLexer,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\RegExLexer.cs,NextToken,Cyclomatic complexity of the method is 24
Complex Method,Piglet.Lexer.Construction,ShuntingYard,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\ShuntingYard.cs,ShuntedTokens,Cyclomatic complexity of the method is 19
Complex Method,Piglet.Lexer.Runtime,TransitionTable,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Runtime\TransitionTable.cs,TransitionTable,Cyclomatic complexity of the method is 13
Complex Method,Piglet.Parser.Configuration.Fluent,FluentRule,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Configuration\Fluent\FluentRule.cs,ConfigureProductions,Cyclomatic complexity of the method is 11
Complex Method,Piglet.Parser.Construction,ParserBuilder,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,CreateParseTable,Cyclomatic complexity of the method is 16
Complex Method,Piglet.Parser.Construction,ParserBuilder,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,SetActionTable,Cyclomatic complexity of the method is 10
Complex Method,Piglet.Parser.Construction,ParserBuilder,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,CalculateFirst,Cyclomatic complexity of the method is 9
Complex Method,Piglet.Parser.Construction,ParserBuilder,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,Closure,Cyclomatic complexity of the method is 11
Complex Method,Piglet.Parser,LRParser,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,Cyclomatic complexity of the method is 12
Long Parameter List,Piglet.Lexer.Construction.DotNotation,DotNotation,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\DotNotation\DotNotation.cs,GetDfaAndNfaGraphs,The method has 5 parameters.
Long Statement,Piglet.Lexer.Construction,CharRange,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\CharRange.cs,ToString,The length of the statement  "	return From == To ? ToGraphSafeString (From) : string.Format ("{0}-{1}"' ToGraphSafeString (From)' ToGraphSafeString (To)); " is 123.
Long Statement,Piglet.Lexer.Construction,FiniteAutomata,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\FiniteAutomata.cs,DistinguishValidInputs,The length of the statement  "	var beginningsAndEnds = ranges.Select (f => f.From).Concat (ranges.Select (f => f.To == char.MaxValue ? f.To : (char)(f.To + 1))).ToArray (); " is 141.
Long Statement,Piglet.Lexer.Construction,FiniteAutomata,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\FiniteAutomata.cs,DistinguishValidInputs,The length of the statement  "		transition.ValidInput = new CharSet (transition.ValidInput.Ranges.SelectMany (range => FindNewRanges (range' distinguishedRanges))); " is 132.
Long Statement,Piglet.Lexer.Construction,NFA,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\NFA.cs,Copy,The length of the statement  "		var newTransition = new Transition<State> (stateMap [transition.From]' stateMap [transition.To]' transition.ValidInput); " is 120.
Long Statement,Piglet.Lexer.Construction,NFA,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\NFA.cs,Closure,The length of the statement  "	State[] closureStates = (from e in Transitions.Where (f => states.Contains (f.From) && !f.ValidInput.Any () && !visitedStates.Contains (f.To)) " is 142.
Long Statement,Piglet.Lexer.Runtime,DfaLexer,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Runtime\DfaLexer.cs,GetNextState,The length of the statement  "	return dfa.Transitions.Where (f => f.From == state && f.ValidInput.Ranges.Any (r => r.From <= input && r.To >= input)).Select (f => f.To).SingleOrDefault (); " is 157.
Long Statement,Piglet.Lexer.Runtime,NfaLexer,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Runtime\NfaLexer.cs,GetAction,The length of the statement  "	return action != null && action.Item2.Item2 != null ? action.Item2 : new Tuple<int' Func<string' T>> (int.MinValue' null); " is 122.
Long Statement,Piglet.Lexer.Runtime,NfaLexer,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Runtime\NfaLexer.cs,GetNextState,The length of the statement  "	nextState.UnionWith (nfa.Closure (nfa.Transitions.Where (t => t.ValidInput.ContainsChar (input) && state.Contains (t.From)).Select (f => f.To).ToArray ())); " is 156.
Long Statement,Piglet.Lexer.Configuration,LexerConfigurator,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Configuration\LexerConfigurator.cs,CreateLexer,The length of the statement  "	IList<NFA> nfas = tokens.Select (token => NfaBuilder.Create (new ShuntingYard (new RegExLexer (new StringReader (token.Item1))))).ToList (); " is 140.
Long Statement,Piglet.Lexer.Construction.DotNotation,DotNotation,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\DotNotation\DotNotation.cs,AsDotNotation,The length of the statement  "		sb.Append (string.Format ("\t{0} -> {1} [label=\"{2}\"]\n"' transition.From.StateNumber' transition.To.StateNumber' transition.TransitionLabel ().Replace ("\\"' "\\\\").Replace ("\""' "\\\""))); " is 194.
Long Statement,Piglet.Lexer.Construction.DotNotation,DotNotation,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\DotNotation\DotNotation.cs,AsDotNotation,The length of the statement  "		sb.AppendFormat ("\t{0} [{1}{2}]\n"' state.StateNumber' state.AcceptState ? "shape=\"doublecircle\"" : ""' currentStates.Contains (state) ? string.Format (" fillcolor=\"{0}\" style=\"filled\""' matchSuccessful ? "green" : "red") : ""); " is 235.
Long Statement,Piglet.Parser.Configuration.Fluent,FluentParserConfigurator,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Configuration\Fluent\FluentParserConfigurator.cs,ParamsToTerminalArray,The length of the statement  "	return p.OfType<string> ().Select (f => configurator.CreateTerminal (Regex.Escape (f))).Concat (p.OfType<FluentExpression> ().Select (f => f.Terminal)).ToArray (); " is 163.
Long Statement,Piglet.Parser.Configuration.Fluent,FluentRule,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Configuration\Fluent\FluentRule.cs,ConfigureProductions,The length of the statement  "			var indexNames = production.Select ((f' index) => new Tuple<int' string> (index' f.Name)).Where (f => f.Item2 != null).ToArray (); " is 130.
Long Statement,Piglet.Parser.Configuration,ParserConfigurator,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Configuration\ParserConfigurator.cs,SetSymbolAssociativity,The length of the statement  "			throw new ParserConfigurationException (string.Format ("Terminal {0} has been declared to have a precedence multiple times"' terminal.DebugName)); " is 146.
Long Statement,Piglet.Parser.Construction,ParserBuilder,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,CreateParser,The length of the statement  "	return new LRParser<T> (parseTable' ((Terminal<T>)grammar.ErrorToken).TokenNumber' grammar.EndOfInputTerminal.TokenNumber' grammar.AllSymbols.OfType<Terminal<T>> ().Select (f => f.DebugName).ToArray ()); " is 203.
Long Statement,Piglet.Parser.Construction,ParserBuilder,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,CalculateNullable,The length of the statement  "				bool symbolIsNullable = production.Symbols.All (symbol => !(symbol is Terminal<T>) && nullable.Contains ((NonTerminal<T>)symbol)); " is 130.
Long Statement,Piglet.Parser.Construction,ParserBuilder,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,CreateParseTable,The length of the statement  "	// Useful point to look at the table' and everything the builder has generated' since after this point the grammar is pretty much destroyed. " is 140.
Long Statement,Piglet.Parser.Construction,ParserBuilder,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,SetActionTable,The length of the statement  "			Terminal<T> shiftingTerminal = grammar.AllSymbols.OfType<Terminal<T>> ().First (f => f.TokenNumber == shiftTokenNumber); " is 120.
Long Statement,Piglet.Parser.Construction,ParserBuilder,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,SetActionTable,The length of the statement  "			var reducePrecedence = productionRule.ContextPrecedence ?? grammar.GetPrecedence (productionRule.Symbols.Reverse ().OfType<ITerminal<T>> ().FirstOrDefault ()); " is 159.
Long Statement,Piglet.Parser.Construction,ParserBuilder,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,Closure,The length of the statement  "			var newLr1Items = grammar.ProductionRules.Where (f => f.ResultSymbol == symbolRightOfDot).Select (f => new Lr1Item<T> (f' 0' lookaheads)); " is 138.
Long Statement,Piglet.Parser.Construction.Debug,DotNotation,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\Debug\DotNotation.cs,AsDotNotation,The length of the statement  "		graph.Append (string.Format ("\t\"I{0}\" -> \"I{1}\" [label=\"{2}\"]\n"' itemSets.IndexOf (transition.From)' itemSets.IndexOf (transition.To)' (transition.OnSymbol.DebugName ?? "").Replace ("\\"' "\\\\").Replace ("\""' "\\\""))); " is 229.
Long Statement,Piglet.Parser.Construction.Debug,ParseTableToString,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\Debug\ParseTableToString.cs,ToDebugString,The length of the statement  "		}).Concat (grammar.AllSymbols.OfType<NonTerminal<T>> ().Where (f => f.ProductionRules.All (p => p.ResultSymbol != grammar.AcceptSymbol)).Select (f => table.Goto [i' f.TokenNumber - numTerminals] == short.MinValue ? "" : table.Goto [i' f.TokenNumber - numTerminals].ToString ()))).ToArray<object> (); " is 299.
Long Statement,Piglet.Parser,LRParser,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The length of the statement  "				exception = new ParseException (string.Format ("Illegal token {0}. Expected {1}"' terminalDebugNames [input.Item1]' string.Join ("'"' expectedTokens))) { " is 153.
Long Statement,Piglet.Parser,LRParser,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The length of the statement  "				for (; parseTable.Action [state' input.Item1] == short.MinValue && input.Item1 != endOfInputTokenNumber; input = lexerInstance.Next ()) " is 135.
Magic Number,Piglet.Common,CompressedTable,F:\newReposMay17\Dervall_Piglet\Piglet\Common\CompressedTable.cs,CompressedTable,The following statement contains a magic number: for (int state = 1; state < numStates; ++state) {  	var stateActions = StateActions (state' uncompressed).ToArray ();  	var hash = stateActions.Aggregate (0' (acc' x) => (acc * 397) ^ x);  	// Need to run *past* the table in order to add wholly incompatible matches  	// this will not index out of the table' so there is no need to worry.  	var tableCount = table.Count ();  	for (int displacementIndex = 0; displacementIndex <= tableCount; ++displacementIndex) {  		if (displacementIndex < offsetHashes.Count && offsetHashes [displacementIndex] != hash) {  			continue;  		}  		bool spotFound = true;  		int offset = displacementIndex;  		foreach (var stateAction in stateActions) {  			if (offset >= tableCount) {  				// Run out of table to check' but is still OK.  				break;  			}  			if (stateAction != table [offset]) {  				// Not found  				spotFound = false;  				break;  			}  			++offset;  		}  		// Exiting the loop' if a spot is found add the correct displacement index  		if (spotFound) {  			displacement [state] = displacementIndex;  			// Add to the state table as much as is needed.  			table.AddRange (stateActions.Skip (offset - displacementIndex));  			// Add the hashes that does not exist up to the displacement index  			for (int i = offsetHashes.Count; i < displacementIndex; ++i) {  				var offsetHash = 0;  				for (int j = i; j < stateActions.Length; ++j) {  					offsetHash = (offsetHash * 397) ^ table [j];  				}  				offsetHashes.Add (offsetHash);  			}  			offsetHashes.Add (hash);  			// Break loop to process next state.  			break;  		}  	}  }  
Magic Number,Piglet.Common,CompressedTable,F:\newReposMay17\Dervall_Piglet\Piglet\Common\CompressedTable.cs,CompressedTable,The following statement contains a magic number: for (int state = 1; state < numStates; ++state) {  	var stateActions = StateActions (state' uncompressed).ToArray ();  	var hash = stateActions.Aggregate (0' (acc' x) => (acc * 397) ^ x);  	// Need to run *past* the table in order to add wholly incompatible matches  	// this will not index out of the table' so there is no need to worry.  	var tableCount = table.Count ();  	for (int displacementIndex = 0; displacementIndex <= tableCount; ++displacementIndex) {  		if (displacementIndex < offsetHashes.Count && offsetHashes [displacementIndex] != hash) {  			continue;  		}  		bool spotFound = true;  		int offset = displacementIndex;  		foreach (var stateAction in stateActions) {  			if (offset >= tableCount) {  				// Run out of table to check' but is still OK.  				break;  			}  			if (stateAction != table [offset]) {  				// Not found  				spotFound = false;  				break;  			}  			++offset;  		}  		// Exiting the loop' if a spot is found add the correct displacement index  		if (spotFound) {  			displacement [state] = displacementIndex;  			// Add to the state table as much as is needed.  			table.AddRange (stateActions.Skip (offset - displacementIndex));  			// Add the hashes that does not exist up to the displacement index  			for (int i = offsetHashes.Count; i < displacementIndex; ++i) {  				var offsetHash = 0;  				for (int j = i; j < stateActions.Length; ++j) {  					offsetHash = (offsetHash * 397) ^ table [j];  				}  				offsetHashes.Add (offsetHash);  			}  			offsetHashes.Add (hash);  			// Break loop to process next state.  			break;  		}  	}  }  
Magic Number,Piglet.Common,CompressedTable,F:\newReposMay17\Dervall_Piglet\Piglet\Common\CompressedTable.cs,CompressedTable,The following statement contains a magic number: for (int displacementIndex = 0; displacementIndex <= tableCount; ++displacementIndex) {  	if (displacementIndex < offsetHashes.Count && offsetHashes [displacementIndex] != hash) {  		continue;  	}  	bool spotFound = true;  	int offset = displacementIndex;  	foreach (var stateAction in stateActions) {  		if (offset >= tableCount) {  			// Run out of table to check' but is still OK.  			break;  		}  		if (stateAction != table [offset]) {  			// Not found  			spotFound = false;  			break;  		}  		++offset;  	}  	// Exiting the loop' if a spot is found add the correct displacement index  	if (spotFound) {  		displacement [state] = displacementIndex;  		// Add to the state table as much as is needed.  		table.AddRange (stateActions.Skip (offset - displacementIndex));  		// Add the hashes that does not exist up to the displacement index  		for (int i = offsetHashes.Count; i < displacementIndex; ++i) {  			var offsetHash = 0;  			for (int j = i; j < stateActions.Length; ++j) {  				offsetHash = (offsetHash * 397) ^ table [j];  			}  			offsetHashes.Add (offsetHash);  		}  		offsetHashes.Add (hash);  		// Break loop to process next state.  		break;  	}  }  
Magic Number,Piglet.Common,CompressedTable,F:\newReposMay17\Dervall_Piglet\Piglet\Common\CompressedTable.cs,CompressedTable,The following statement contains a magic number: if (spotFound) {  	displacement [state] = displacementIndex;  	// Add to the state table as much as is needed.  	table.AddRange (stateActions.Skip (offset - displacementIndex));  	// Add the hashes that does not exist up to the displacement index  	for (int i = offsetHashes.Count; i < displacementIndex; ++i) {  		var offsetHash = 0;  		for (int j = i; j < stateActions.Length; ++j) {  			offsetHash = (offsetHash * 397) ^ table [j];  		}  		offsetHashes.Add (offsetHash);  	}  	offsetHashes.Add (hash);  	// Break loop to process next state.  	break;  }  
Magic Number,Piglet.Common,CompressedTable,F:\newReposMay17\Dervall_Piglet\Piglet\Common\CompressedTable.cs,CompressedTable,The following statement contains a magic number: for (int i = offsetHashes.Count; i < displacementIndex; ++i) {  	var offsetHash = 0;  	for (int j = i; j < stateActions.Length; ++j) {  		offsetHash = (offsetHash * 397) ^ table [j];  	}  	offsetHashes.Add (offsetHash);  }  
Magic Number,Piglet.Common,CompressedTable,F:\newReposMay17\Dervall_Piglet\Piglet\Common\CompressedTable.cs,CompressedTable,The following statement contains a magic number: for (int j = i; j < stateActions.Length; ++j) {  	offsetHash = (offsetHash * 397) ^ table [j];  }  
Magic Number,Piglet.Common,CompressedTable,F:\newReposMay17\Dervall_Piglet\Piglet\Common\CompressedTable.cs,CompressedTable,The following statement contains a magic number: offsetHash = (offsetHash * 397) ^ table [j];  
Magic Number,Piglet.Lexer.Construction,CharRange,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\CharRange.cs,ToGraphSafeString,The following statement contains a magic number: return c >= 33 && c <= 0x7e ? c.ToString () : string.Format ("0x{0:x2}"' (int)c);  
Magic Number,Piglet.Lexer.Construction,CharRange,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\CharRange.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return (From.GetHashCode () * 397) ^ To.GetHashCode ();  }  
Magic Number,Piglet.Lexer.Construction,CharRange,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\CharRange.cs,GetHashCode,The following statement contains a magic number: return (From.GetHashCode () * 397) ^ To.GetHashCode ();  
Magic Number,Piglet.Lexer.Construction,CharSet,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\CharSet.cs,CharSet,The following statement contains a magic number: if (ranges.Length % 2 != 0)  	throw new ArgumentException ("Number of chars in ranges must be an even number");  
Magic Number,Piglet.Lexer.Construction,CharSet,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\CharSet.cs,CharSet,The following statement contains a magic number: for (int i = 0; i < ranges.Length; i += 2) {  	AddRange (ranges [i]' ranges [i + 1]' combine);  }  
Magic Number,Piglet.Lexer.Construction,CharSet,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\CharSet.cs,CharSet,The following statement contains a magic number: i += 2
Magic Number,Piglet.Lexer.Construction,FiniteAutomata,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\FiniteAutomata.cs,FindNewRanges,The following statement contains a magic number: while (true) {  	int pivot = a + (b - a) / 2;  	int cmp = range.From - distinguishedRanges [pivot].From;  	if (cmp == 0) {  		startIndex = pivot;  		break;  	}  	if (cmp < 0) {  		b = pivot;  	} else {  		a = pivot;  	}  }  
Magic Number,Piglet.Lexer.Construction,FiniteAutomata,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\FiniteAutomata.cs,FindNewRanges,The following statement contains a magic number: while (true) {  	int pivot = a2 + (b2 - a2) / 2;  	int cmp = c - distinguishedRanges [pivot].To;  	if (cmp == 0) {  		for (int i = startIndex; i <= pivot; ++i) {  			CharRange f = distinguishedRanges [i];  			yield return new CharRange {  				From = f.From'  				To = f.To == char.MaxValue ? f.To : (char)(f.To - 1)  			};  		}  		yield break;  	}  	if (cmp < 0) {  		b2 = pivot;  	} else {  		a2 = pivot;  	}  }  
Magic Number,Piglet.Lexer.Runtime,TransitionTable,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Runtime\TransitionTable.cs,TransitionTable,The following statement contains a magic number: asciiIndices = new int[256];  
Magic Number,Piglet.Parser.Configuration.Fluent,FluentParserConfigurator,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Configuration\Fluent\FluentParserConfigurator.cs,MakeListRule,The following statement contains a magic number: if (separator != null) {  	listRule.AddProduction (listRule' separator' ((FluentRule)rule).NonTerminal).SetReduceFunction (f => {  		var list = (List<TListType>)f [0];  		list.Add ((TListType)f [2]);  		return list;  	});  } else {  	listRule.AddProduction (listRule' ((FluentRule)rule).NonTerminal).SetReduceFunction (f => {  		var list = (List<TListType>)f [0];  		list.Add ((TListType)f [1]);  		return list;  	});  }  
Magic Number,Piglet.Parser.Configuration.Fluent,FluentParserConfigurator,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Configuration\Fluent\FluentParserConfigurator.cs,MakeListRule,The following statement contains a magic number: listRule.AddProduction (listRule' separator' ((FluentRule)rule).NonTerminal).SetReduceFunction (f => {  	var list = (List<TListType>)f [0];  	list.Add ((TListType)f [2]);  	return list;  });  
Magic Number,Piglet.Parser.Configuration.Fluent,FluentParserConfigurator,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Configuration\Fluent\FluentParserConfigurator.cs,MakeListRule,The following statement contains a magic number: list.Add ((TListType)f [2]);  
Magic Number,Piglet.Parser.Construction.Debug,ParseTableToString,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\Debug\ParseTableToString.cs,ToDebugString,The following statement contains a magic number: for (int i = 0; i < numStates; ++i) {  	object[] formatParams = new[] {  		i.ToString ()  	}.Concat (grammar.AllSymbols.OfType<Terminal<T>> ().Select (f => {  		var actionValue = table.Action [i' f.TokenNumber];  		if (actionValue == short.MaxValue) {  			return "acc";  		}  		if (actionValue == short.MinValue) {  			return "";  		}  		if (actionValue < 0) {  			return "r" + -(actionValue + 1);  		}  		return "s" + actionValue;  	}).Concat (grammar.AllSymbols.OfType<NonTerminal<T>> ().Where (f => f.ProductionRules.All (p => p.ResultSymbol != grammar.AcceptSymbol)).Select (f => table.Goto [i' f.TokenNumber - numTerminals] == short.MinValue ? "" : table.Goto [i' f.TokenNumber - numTerminals].ToString ()))).ToArray<object> ();  	// If formatparams is all empty' we have run out of table to process.  	// This is perhaps not the best way to determine if the table has ended but the grammar  	// has no idea of the number of states' and I'd rather not mess up the interface  	// with methods to get the number of states.  	if (formatParams.Distinct ().Count () == 2) {  		// All empty strings and one state.  		break;  	}  	sb.Append (string.Format (format' formatParams));  }  
Magic Number,Piglet.Parser.Construction.Debug,ParseTableToString,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\Construction\Debug\ParseTableToString.cs,ToDebugString,The following statement contains a magic number: if (formatParams.Distinct ().Count () == 2) {  	// All empty strings and one state.  	break;  }  
Magic Number,Piglet.Parser,LRParser,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The following statement contains a magic number: while (true) {  	int state = parseStack.Peek ();  	int action = parseTable.Action [state' input.Item1];  	if (action >= 0) {  		if (action == short.MaxValue) {  			// Accept!  			return valueStack.Pop ();  		}  		// Shift  		parseStack.Push (input.Item1);  		// Push token unto stack  		parseStack.Push (action);  		// Push state unto stack  		// Shift token value unto value stack  		valueStack.Push (input.Item2);  		// Lex next token  		input = lexerInstance.Next ();  	} else {  		if (action == short.MinValue) {  			// Get the expected tokens  			string[] expectedTokens = GetExpectedTokenNames (state).ToArray ();  			// Create an exception that either might be thrown or may be handed to the error handling routine.  			exception = new ParseException (string.Format ("Illegal token {0}. Expected {1}"' terminalDebugNames [input.Item1]' string.Join ("'"' expectedTokens))) {  				LexerState = lexerInstance'  				FoundToken = terminalDebugNames [input.Item1]'  				ExpectedTokens = expectedTokens'  				FoundTokenId = input.Item1'  				ParserState = state  			};  			// Go for error recovery!  			while (parseTable.Action [parseStack.Peek ()' errorTokenNumber] == short.MinValue) {  				// If we run out of stack while searching for the error handler' throw the exception  				// This is what happens when there is no error handler defined at all.  				if (parseStack.Count <= 2)  					throw exception;  				parseStack.Pop ();  				// Pop state  				parseStack.Pop ();  				// Pop token  				valueStack.Pop ();  				// Pop whatever value  			}  			// Shift the error token unto the stack  			state = parseStack.Peek ();  			parseStack.Push (errorTokenNumber);  			parseStack.Push (parseTable.Action [state' errorTokenNumber]);  			valueStack.Push (default(T));  			state = parseStack.Peek ();  			// We have now found a state where error recovery is enabled. This means that we   			// continue to scan the input stream looking for something which is accepted.  			// End of input will cause the exception to be thrown  			for (; parseTable.Action [state' input.Item1] == short.MinValue && input.Item1 != endOfInputTokenNumber; input = lexerInstance.Next ())  				;  			// nom nom nom  			// Ran out of file looking for the end of the error rule  			if (input.Item1 == endOfInputTokenNumber)  				throw exception;  			// If we get here we are pretty cool' continue running the parser. The actual error recovery routine will be  			// called as soon as the error rule itself is reduced.  		} else {  			// Get the right reduction rule to apply  			var reductionRule = parseTable.ReductionRules [-(action + 1)];  			for (int i = 0; i < reductionRule.NumTokensToPop * 2; ++i) {  				parseStack.Pop ();  			}  			// Transfer to state found in goto table  			int stateOnTopOfStack = parseStack.Peek ();  			parseStack.Push (reductionRule.TokenToPush);  			parseStack.Push (parseTable.Goto [stateOnTopOfStack' reductionRule.TokenToPush]);  			// Get tokens off the value stack for the OnReduce function to run on  			var onReduceParams = new T[reductionRule.NumTokensToPop];  			// Need to do it in reverse since thats how the stack is organized  			for (int i = reductionRule.NumTokensToPop - 1; i >= 0; --i) {  				onReduceParams [i] = valueStack.Pop ();  			}  			// This calls the reduction function with the possible exception set. The exception could be cleared here' but  			// there is no real reason to do so' since all the normal rules will ignore it' and all the error rules are guaranteed  			// to have the exception set prior to entering the reduction function.  			var reduceFunc = reductionRule.OnReduce;  			valueStack.Push (reduceFunc == null ? default(T) : reduceFunc (exception' onReduceParams));  		}  	}  }  
Magic Number,Piglet.Parser,LRParser,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The following statement contains a magic number: while (true) {  	int state = parseStack.Peek ();  	int action = parseTable.Action [state' input.Item1];  	if (action >= 0) {  		if (action == short.MaxValue) {  			// Accept!  			return valueStack.Pop ();  		}  		// Shift  		parseStack.Push (input.Item1);  		// Push token unto stack  		parseStack.Push (action);  		// Push state unto stack  		// Shift token value unto value stack  		valueStack.Push (input.Item2);  		// Lex next token  		input = lexerInstance.Next ();  	} else {  		if (action == short.MinValue) {  			// Get the expected tokens  			string[] expectedTokens = GetExpectedTokenNames (state).ToArray ();  			// Create an exception that either might be thrown or may be handed to the error handling routine.  			exception = new ParseException (string.Format ("Illegal token {0}. Expected {1}"' terminalDebugNames [input.Item1]' string.Join ("'"' expectedTokens))) {  				LexerState = lexerInstance'  				FoundToken = terminalDebugNames [input.Item1]'  				ExpectedTokens = expectedTokens'  				FoundTokenId = input.Item1'  				ParserState = state  			};  			// Go for error recovery!  			while (parseTable.Action [parseStack.Peek ()' errorTokenNumber] == short.MinValue) {  				// If we run out of stack while searching for the error handler' throw the exception  				// This is what happens when there is no error handler defined at all.  				if (parseStack.Count <= 2)  					throw exception;  				parseStack.Pop ();  				// Pop state  				parseStack.Pop ();  				// Pop token  				valueStack.Pop ();  				// Pop whatever value  			}  			// Shift the error token unto the stack  			state = parseStack.Peek ();  			parseStack.Push (errorTokenNumber);  			parseStack.Push (parseTable.Action [state' errorTokenNumber]);  			valueStack.Push (default(T));  			state = parseStack.Peek ();  			// We have now found a state where error recovery is enabled. This means that we   			// continue to scan the input stream looking for something which is accepted.  			// End of input will cause the exception to be thrown  			for (; parseTable.Action [state' input.Item1] == short.MinValue && input.Item1 != endOfInputTokenNumber; input = lexerInstance.Next ())  				;  			// nom nom nom  			// Ran out of file looking for the end of the error rule  			if (input.Item1 == endOfInputTokenNumber)  				throw exception;  			// If we get here we are pretty cool' continue running the parser. The actual error recovery routine will be  			// called as soon as the error rule itself is reduced.  		} else {  			// Get the right reduction rule to apply  			var reductionRule = parseTable.ReductionRules [-(action + 1)];  			for (int i = 0; i < reductionRule.NumTokensToPop * 2; ++i) {  				parseStack.Pop ();  			}  			// Transfer to state found in goto table  			int stateOnTopOfStack = parseStack.Peek ();  			parseStack.Push (reductionRule.TokenToPush);  			parseStack.Push (parseTable.Goto [stateOnTopOfStack' reductionRule.TokenToPush]);  			// Get tokens off the value stack for the OnReduce function to run on  			var onReduceParams = new T[reductionRule.NumTokensToPop];  			// Need to do it in reverse since thats how the stack is organized  			for (int i = reductionRule.NumTokensToPop - 1; i >= 0; --i) {  				onReduceParams [i] = valueStack.Pop ();  			}  			// This calls the reduction function with the possible exception set. The exception could be cleared here' but  			// there is no real reason to do so' since all the normal rules will ignore it' and all the error rules are guaranteed  			// to have the exception set prior to entering the reduction function.  			var reduceFunc = reductionRule.OnReduce;  			valueStack.Push (reduceFunc == null ? default(T) : reduceFunc (exception' onReduceParams));  		}  	}  }  
Magic Number,Piglet.Parser,LRParser,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The following statement contains a magic number: if (action >= 0) {  	if (action == short.MaxValue) {  		// Accept!  		return valueStack.Pop ();  	}  	// Shift  	parseStack.Push (input.Item1);  	// Push token unto stack  	parseStack.Push (action);  	// Push state unto stack  	// Shift token value unto value stack  	valueStack.Push (input.Item2);  	// Lex next token  	input = lexerInstance.Next ();  } else {  	if (action == short.MinValue) {  		// Get the expected tokens  		string[] expectedTokens = GetExpectedTokenNames (state).ToArray ();  		// Create an exception that either might be thrown or may be handed to the error handling routine.  		exception = new ParseException (string.Format ("Illegal token {0}. Expected {1}"' terminalDebugNames [input.Item1]' string.Join ("'"' expectedTokens))) {  			LexerState = lexerInstance'  			FoundToken = terminalDebugNames [input.Item1]'  			ExpectedTokens = expectedTokens'  			FoundTokenId = input.Item1'  			ParserState = state  		};  		// Go for error recovery!  		while (parseTable.Action [parseStack.Peek ()' errorTokenNumber] == short.MinValue) {  			// If we run out of stack while searching for the error handler' throw the exception  			// This is what happens when there is no error handler defined at all.  			if (parseStack.Count <= 2)  				throw exception;  			parseStack.Pop ();  			// Pop state  			parseStack.Pop ();  			// Pop token  			valueStack.Pop ();  			// Pop whatever value  		}  		// Shift the error token unto the stack  		state = parseStack.Peek ();  		parseStack.Push (errorTokenNumber);  		parseStack.Push (parseTable.Action [state' errorTokenNumber]);  		valueStack.Push (default(T));  		state = parseStack.Peek ();  		// We have now found a state where error recovery is enabled. This means that we   		// continue to scan the input stream looking for something which is accepted.  		// End of input will cause the exception to be thrown  		for (; parseTable.Action [state' input.Item1] == short.MinValue && input.Item1 != endOfInputTokenNumber; input = lexerInstance.Next ())  			;  		// nom nom nom  		// Ran out of file looking for the end of the error rule  		if (input.Item1 == endOfInputTokenNumber)  			throw exception;  		// If we get here we are pretty cool' continue running the parser. The actual error recovery routine will be  		// called as soon as the error rule itself is reduced.  	} else {  		// Get the right reduction rule to apply  		var reductionRule = parseTable.ReductionRules [-(action + 1)];  		for (int i = 0; i < reductionRule.NumTokensToPop * 2; ++i) {  			parseStack.Pop ();  		}  		// Transfer to state found in goto table  		int stateOnTopOfStack = parseStack.Peek ();  		parseStack.Push (reductionRule.TokenToPush);  		parseStack.Push (parseTable.Goto [stateOnTopOfStack' reductionRule.TokenToPush]);  		// Get tokens off the value stack for the OnReduce function to run on  		var onReduceParams = new T[reductionRule.NumTokensToPop];  		// Need to do it in reverse since thats how the stack is organized  		for (int i = reductionRule.NumTokensToPop - 1; i >= 0; --i) {  			onReduceParams [i] = valueStack.Pop ();  		}  		// This calls the reduction function with the possible exception set. The exception could be cleared here' but  		// there is no real reason to do so' since all the normal rules will ignore it' and all the error rules are guaranteed  		// to have the exception set prior to entering the reduction function.  		var reduceFunc = reductionRule.OnReduce;  		valueStack.Push (reduceFunc == null ? default(T) : reduceFunc (exception' onReduceParams));  	}  }  
Magic Number,Piglet.Parser,LRParser,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The following statement contains a magic number: if (action >= 0) {  	if (action == short.MaxValue) {  		// Accept!  		return valueStack.Pop ();  	}  	// Shift  	parseStack.Push (input.Item1);  	// Push token unto stack  	parseStack.Push (action);  	// Push state unto stack  	// Shift token value unto value stack  	valueStack.Push (input.Item2);  	// Lex next token  	input = lexerInstance.Next ();  } else {  	if (action == short.MinValue) {  		// Get the expected tokens  		string[] expectedTokens = GetExpectedTokenNames (state).ToArray ();  		// Create an exception that either might be thrown or may be handed to the error handling routine.  		exception = new ParseException (string.Format ("Illegal token {0}. Expected {1}"' terminalDebugNames [input.Item1]' string.Join ("'"' expectedTokens))) {  			LexerState = lexerInstance'  			FoundToken = terminalDebugNames [input.Item1]'  			ExpectedTokens = expectedTokens'  			FoundTokenId = input.Item1'  			ParserState = state  		};  		// Go for error recovery!  		while (parseTable.Action [parseStack.Peek ()' errorTokenNumber] == short.MinValue) {  			// If we run out of stack while searching for the error handler' throw the exception  			// This is what happens when there is no error handler defined at all.  			if (parseStack.Count <= 2)  				throw exception;  			parseStack.Pop ();  			// Pop state  			parseStack.Pop ();  			// Pop token  			valueStack.Pop ();  			// Pop whatever value  		}  		// Shift the error token unto the stack  		state = parseStack.Peek ();  		parseStack.Push (errorTokenNumber);  		parseStack.Push (parseTable.Action [state' errorTokenNumber]);  		valueStack.Push (default(T));  		state = parseStack.Peek ();  		// We have now found a state where error recovery is enabled. This means that we   		// continue to scan the input stream looking for something which is accepted.  		// End of input will cause the exception to be thrown  		for (; parseTable.Action [state' input.Item1] == short.MinValue && input.Item1 != endOfInputTokenNumber; input = lexerInstance.Next ())  			;  		// nom nom nom  		// Ran out of file looking for the end of the error rule  		if (input.Item1 == endOfInputTokenNumber)  			throw exception;  		// If we get here we are pretty cool' continue running the parser. The actual error recovery routine will be  		// called as soon as the error rule itself is reduced.  	} else {  		// Get the right reduction rule to apply  		var reductionRule = parseTable.ReductionRules [-(action + 1)];  		for (int i = 0; i < reductionRule.NumTokensToPop * 2; ++i) {  			parseStack.Pop ();  		}  		// Transfer to state found in goto table  		int stateOnTopOfStack = parseStack.Peek ();  		parseStack.Push (reductionRule.TokenToPush);  		parseStack.Push (parseTable.Goto [stateOnTopOfStack' reductionRule.TokenToPush]);  		// Get tokens off the value stack for the OnReduce function to run on  		var onReduceParams = new T[reductionRule.NumTokensToPop];  		// Need to do it in reverse since thats how the stack is organized  		for (int i = reductionRule.NumTokensToPop - 1; i >= 0; --i) {  			onReduceParams [i] = valueStack.Pop ();  		}  		// This calls the reduction function with the possible exception set. The exception could be cleared here' but  		// there is no real reason to do so' since all the normal rules will ignore it' and all the error rules are guaranteed  		// to have the exception set prior to entering the reduction function.  		var reduceFunc = reductionRule.OnReduce;  		valueStack.Push (reduceFunc == null ? default(T) : reduceFunc (exception' onReduceParams));  	}  }  
Magic Number,Piglet.Parser,LRParser,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The following statement contains a magic number: if (action == short.MinValue) {  	// Get the expected tokens  	string[] expectedTokens = GetExpectedTokenNames (state).ToArray ();  	// Create an exception that either might be thrown or may be handed to the error handling routine.  	exception = new ParseException (string.Format ("Illegal token {0}. Expected {1}"' terminalDebugNames [input.Item1]' string.Join ("'"' expectedTokens))) {  		LexerState = lexerInstance'  		FoundToken = terminalDebugNames [input.Item1]'  		ExpectedTokens = expectedTokens'  		FoundTokenId = input.Item1'  		ParserState = state  	};  	// Go for error recovery!  	while (parseTable.Action [parseStack.Peek ()' errorTokenNumber] == short.MinValue) {  		// If we run out of stack while searching for the error handler' throw the exception  		// This is what happens when there is no error handler defined at all.  		if (parseStack.Count <= 2)  			throw exception;  		parseStack.Pop ();  		// Pop state  		parseStack.Pop ();  		// Pop token  		valueStack.Pop ();  		// Pop whatever value  	}  	// Shift the error token unto the stack  	state = parseStack.Peek ();  	parseStack.Push (errorTokenNumber);  	parseStack.Push (parseTable.Action [state' errorTokenNumber]);  	valueStack.Push (default(T));  	state = parseStack.Peek ();  	// We have now found a state where error recovery is enabled. This means that we   	// continue to scan the input stream looking for something which is accepted.  	// End of input will cause the exception to be thrown  	for (; parseTable.Action [state' input.Item1] == short.MinValue && input.Item1 != endOfInputTokenNumber; input = lexerInstance.Next ())  		;  	// nom nom nom  	// Ran out of file looking for the end of the error rule  	if (input.Item1 == endOfInputTokenNumber)  		throw exception;  	// If we get here we are pretty cool' continue running the parser. The actual error recovery routine will be  	// called as soon as the error rule itself is reduced.  } else {  	// Get the right reduction rule to apply  	var reductionRule = parseTable.ReductionRules [-(action + 1)];  	for (int i = 0; i < reductionRule.NumTokensToPop * 2; ++i) {  		parseStack.Pop ();  	}  	// Transfer to state found in goto table  	int stateOnTopOfStack = parseStack.Peek ();  	parseStack.Push (reductionRule.TokenToPush);  	parseStack.Push (parseTable.Goto [stateOnTopOfStack' reductionRule.TokenToPush]);  	// Get tokens off the value stack for the OnReduce function to run on  	var onReduceParams = new T[reductionRule.NumTokensToPop];  	// Need to do it in reverse since thats how the stack is organized  	for (int i = reductionRule.NumTokensToPop - 1; i >= 0; --i) {  		onReduceParams [i] = valueStack.Pop ();  	}  	// This calls the reduction function with the possible exception set. The exception could be cleared here' but  	// there is no real reason to do so' since all the normal rules will ignore it' and all the error rules are guaranteed  	// to have the exception set prior to entering the reduction function.  	var reduceFunc = reductionRule.OnReduce;  	valueStack.Push (reduceFunc == null ? default(T) : reduceFunc (exception' onReduceParams));  }  
Magic Number,Piglet.Parser,LRParser,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The following statement contains a magic number: if (action == short.MinValue) {  	// Get the expected tokens  	string[] expectedTokens = GetExpectedTokenNames (state).ToArray ();  	// Create an exception that either might be thrown or may be handed to the error handling routine.  	exception = new ParseException (string.Format ("Illegal token {0}. Expected {1}"' terminalDebugNames [input.Item1]' string.Join ("'"' expectedTokens))) {  		LexerState = lexerInstance'  		FoundToken = terminalDebugNames [input.Item1]'  		ExpectedTokens = expectedTokens'  		FoundTokenId = input.Item1'  		ParserState = state  	};  	// Go for error recovery!  	while (parseTable.Action [parseStack.Peek ()' errorTokenNumber] == short.MinValue) {  		// If we run out of stack while searching for the error handler' throw the exception  		// This is what happens when there is no error handler defined at all.  		if (parseStack.Count <= 2)  			throw exception;  		parseStack.Pop ();  		// Pop state  		parseStack.Pop ();  		// Pop token  		valueStack.Pop ();  		// Pop whatever value  	}  	// Shift the error token unto the stack  	state = parseStack.Peek ();  	parseStack.Push (errorTokenNumber);  	parseStack.Push (parseTable.Action [state' errorTokenNumber]);  	valueStack.Push (default(T));  	state = parseStack.Peek ();  	// We have now found a state where error recovery is enabled. This means that we   	// continue to scan the input stream looking for something which is accepted.  	// End of input will cause the exception to be thrown  	for (; parseTable.Action [state' input.Item1] == short.MinValue && input.Item1 != endOfInputTokenNumber; input = lexerInstance.Next ())  		;  	// nom nom nom  	// Ran out of file looking for the end of the error rule  	if (input.Item1 == endOfInputTokenNumber)  		throw exception;  	// If we get here we are pretty cool' continue running the parser. The actual error recovery routine will be  	// called as soon as the error rule itself is reduced.  } else {  	// Get the right reduction rule to apply  	var reductionRule = parseTable.ReductionRules [-(action + 1)];  	for (int i = 0; i < reductionRule.NumTokensToPop * 2; ++i) {  		parseStack.Pop ();  	}  	// Transfer to state found in goto table  	int stateOnTopOfStack = parseStack.Peek ();  	parseStack.Push (reductionRule.TokenToPush);  	parseStack.Push (parseTable.Goto [stateOnTopOfStack' reductionRule.TokenToPush]);  	// Get tokens off the value stack for the OnReduce function to run on  	var onReduceParams = new T[reductionRule.NumTokensToPop];  	// Need to do it in reverse since thats how the stack is organized  	for (int i = reductionRule.NumTokensToPop - 1; i >= 0; --i) {  		onReduceParams [i] = valueStack.Pop ();  	}  	// This calls the reduction function with the possible exception set. The exception could be cleared here' but  	// there is no real reason to do so' since all the normal rules will ignore it' and all the error rules are guaranteed  	// to have the exception set prior to entering the reduction function.  	var reduceFunc = reductionRule.OnReduce;  	valueStack.Push (reduceFunc == null ? default(T) : reduceFunc (exception' onReduceParams));  }  
Magic Number,Piglet.Parser,LRParser,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The following statement contains a magic number: while (parseTable.Action [parseStack.Peek ()' errorTokenNumber] == short.MinValue) {  	// If we run out of stack while searching for the error handler' throw the exception  	// This is what happens when there is no error handler defined at all.  	if (parseStack.Count <= 2)  		throw exception;  	parseStack.Pop ();  	// Pop state  	parseStack.Pop ();  	// Pop token  	valueStack.Pop ();  	// Pop whatever value  }  
Magic Number,Piglet.Parser,LRParser,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The following statement contains a magic number: if (parseStack.Count <= 2)  	throw exception;  
Magic Number,Piglet.Parser,LRParser,F:\newReposMay17\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The following statement contains a magic number: for (int i = 0; i < reductionRule.NumTokensToPop * 2; ++i) {  	parseStack.Pop ();  }  
Missing Default,Piglet.Lexer.Construction,RegExLexer,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\RegExLexer.cs,EscapedCharToAcceptCharsInClass,The following switch statement is missing a default case: switch (c) {  case '-':  case '^':  	return SingleChar (c);  }  
Missing Default,Piglet.Lexer.Construction,ShuntingYard,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\ShuntingYard.cs,PreceedingTypeRequiresConcat,The following switch statement is missing a default case: switch (type) {  case RegExToken.TokenType.OperatorMul:  case RegExToken.TokenType.OperatorQuestion:  case RegExToken.TokenType.OperatorPlus:  case RegExToken.TokenType.Accept:  case RegExToken.TokenType.OperatorCloseParanthesis:  case RegExToken.TokenType.NumberedRepeat:  	return true;  }  
Missing Default,Piglet.Lexer.Construction,ShuntingYard,F:\newReposMay17\Dervall_Piglet\Piglet\Lexer\Construction\ShuntingYard.cs,NextTypeRequiresConcat,The following switch statement is missing a default case: switch (type) {  case RegExToken.TokenType.Accept:  case RegExToken.TokenType.OperatorOpenParanthesis:  	return true;  }  
