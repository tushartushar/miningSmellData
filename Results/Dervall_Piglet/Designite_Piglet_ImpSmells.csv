Implementation smell,Namespace,Class,File,Method,Description
Long Method,Piglet.Lexer.Construction,DFA,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\DFA.cs,Minimize,The method has 232 lines of code.
Long Method,Piglet.Lexer.Construction,RegExLexer,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\RegExLexer.cs,NextToken,The method has 209 lines of code.
Long Method,Piglet.Parser.Construction,ParserBuilder<T>,C:\repos\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,CreateParseTable,The method has 108 lines of code.
Long Method,Piglet.Parser.Construction,ParserBuilder<T>,C:\repos\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,SetActionTable,The method has 105 lines of code.
Long Method,Piglet.Parser,LRParser<T>,C:\repos\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The method has 103 lines of code.
Complex Method,Piglet.Common,CompressedTable,C:\repos\Dervall_Piglet\Piglet\Common\CompressedTable.cs,CompressedTable,Cyclomatic complexity of the method is 10
Complex Method,Piglet.Lexer.Construction,CharSet,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\CharSet.cs,ClipRange,Cyclomatic complexity of the method is 9
Complex Method,Piglet.Lexer.Construction,DFA,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\DFA.cs,Create,Cyclomatic complexity of the method is 11
Complex Method,Piglet.Lexer.Construction,DFA,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\DFA.cs,Minimize,Cyclomatic complexity of the method is 14
Complex Method,Piglet.Lexer.Construction,FiniteAutomata<TState>,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\FiniteAutomata.cs,FindNewRanges,Cyclomatic complexity of the method is 8
Complex Method,Piglet.Lexer.Runtime,TransitionTable<T>,C:\repos\Dervall_Piglet\Piglet\Lexer\Runtime\TransitionTable.cs,TransitionTable,Cyclomatic complexity of the method is 13
Complex Method,Piglet.Parser.Construction,ParserBuilder<T>,C:\repos\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,CreateParseTable,Cyclomatic complexity of the method is 8
Complex Method,Piglet.Parser.Construction,ParserBuilder<T>,C:\repos\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,Closure,Cyclomatic complexity of the method is 11
Long Parameter List,Piglet.Lexer.Construction.DotNotation,DotNotation,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\DotNotation\DotNotation.cs,GetDfaAndNfaGraphs,The method has 5 parameters. Parameters: regex' input' minimize' nfaString' dfaString
Long Statement,Piglet.Lexer.Construction,CharSet,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\CharSet.cs,ClipRange,The length of the statement  "                    foreach (var charRange in ClipRange(new CharRange {From = @from' To = (char)(excludedRange.From - 1)}' excludedCharRanges)) " is 123.
Long Statement,Piglet.Lexer.Construction,CharSet,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\CharSet.cs,ClipRange,The length of the statement  "                    foreach (var charRange in ClipRange(new CharRange { From = (char)(excludedRange.To + 1)' To = to }' excludedCharRanges)) " is 120.
Long Statement,Piglet.Lexer.Construction,DFA,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\DFA.cs,Create,The length of the statement  "                        var oldState = dfa.States.FirstOrDefault(f => f.NfaStates.SetEquals(newState.NfaStates));/* f.NfaStates.Count == newState.NfaStates.Count &&  " is 140.
Long Statement,Piglet.Lexer.Construction,FiniteAutomata<TState>,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\FiniteAutomata.cs,DistinguishValidInputs,The length of the statement  "			var beginningsAndEnds = ranges.Select(f => f.From).Concat(ranges.Select(f => f.To == char.MaxValue ? f.To : (char)(f.To+1))).ToArray(); " is 135.
Long Statement,Piglet.Lexer.Construction,FiniteAutomata<TState>,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\FiniteAutomata.cs,DistinguishValidInputs,The length of the statement  "				transition.ValidInput = new CharSet(transition.ValidInput.Ranges.SelectMany(range => FindNewRanges(range' distinguishedRanges))); " is 129.
Long Statement,Piglet.Lexer.Construction,NFA,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\NFA.cs,Closure,The length of the statement  "                (from e in Transitions.Where(f => states.Contains(f.From) && !f.ValidInput.Any() && !visitedStates.Contains(f.To)) select e.To).ToArray(); " is 138.
Long Statement,Piglet.Lexer.Runtime,NfaLexer<T>,C:\repos\Dervall_Piglet\Piglet\Lexer\Runtime\NfaLexer.cs,GetAction,The length of the statement  "            return action != null && action.Item2.Item2 != null ? action.Item2 : new Tuple<int' Func<string' T>>(int.MinValue' null); " is 121.
Long Statement,Piglet.Lexer.Configuration,LexerConfigurator<T>,C:\repos\Dervall_Piglet\Piglet\Lexer\Configuration\LexerConfigurator.cs,CreateLexer,The length of the statement  "            IList<NFA> nfas = tokens.Select(token => NfaBuilder.Create(new ShuntingYard(new RegExLexer( new StringReader(token.Item1))))).ToList(); " is 135.
Long Statement,Piglet.Parser.Configuration.Fluent,FluentRule,C:\repos\Dervall_Piglet\Piglet\Parser\Configuration\Fluent\FluentRule.cs,ConfigureProductions,The length of the statement  "                    var indexNames = production.Select((f' index) => new Tuple<int' string>(index' f.Name)).Where(f => f.Item2 != null).ToArray(); " is 126.
Long Statement,Piglet.Parser.Configuration,ParserConfigurator<T>,C:\repos\Dervall_Piglet\Piglet\Parser\Configuration\ParserConfigurator.cs,AugmentGrammar,The length of the statement  "            augmentedStart.AddProduction(startSymbol); // This production is never reduced' parser accepts when its about to reduce. No reduce action. " is 138.
Long Statement,Piglet.Parser.Construction,ParserBuilder<T>,C:\repos\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,CalculateNullable,The length of the statement  "                        bool symbolIsNullable = production.Symbols.All(symbol => !(symbol is Terminal<T>) && nullable.Contains((NonTerminal<T>)symbol)); " is 128.
Long Statement,Piglet.Parser.Construction,ParserBuilder<T>,C:\repos\Dervall_Piglet\Piglet\Parser\Construction\ParserBuilder.cs,CreateParseTable,The length of the statement  "            // Useful point to look at the table' and everything the builder has generated' since after this point the grammar is pretty much destroyed. " is 140.
Long Statement,Piglet.Parser.Construction.Debug,ParseTableToString,C:\repos\Dervall_Piglet\Piglet\Parser\Construction\Debug\ParseTableToString.cs,ToDebugString,The length of the statement  "            sb.Append(string.Format(format' new[] { "STATE" }.Concat(grammar.AllSymbols.Select(f => f.DebugName)).ToArray<object>())); " is 122.
Long Statement,Piglet.Parser.Construction.Debug,ParseTableToString,C:\repos\Dervall_Piglet\Piglet\Parser\Construction\Debug\ParseTableToString.cs,ToDebugString,The length of the statement  "                }).Concat(grammar.AllSymbols.OfType<NonTerminal<T>>().Where(f => f.ProductionRules.All(p => p.ResultSymbol != grammar.AcceptSymbol)).Select(f => table.Goto[i' f.TokenNumber - numTerminals] == " is 191.
Magic Number,Piglet.Common,CompressedTable,C:\repos\Dervall_Piglet\Piglet\Common\CompressedTable.cs,CompressedTable,The following statement contains a magic number: for (int state = 1; state < numStates; ++state)              {                  var stateActions = StateActions(state' uncompressed).ToArray();              	var hash = stateActions.Aggregate(0' (acc' x) => (acc * 397) ^ x);                    // Need to run *past* the table in order to add wholly incompatible matches                  // this will not index out of the table' so there is no need to worry.                  var tableCount = table.Count();                    for (int displacementIndex = 0; displacementIndex <= tableCount; ++displacementIndex)                  {                  	if (displacementIndex < offsetHashes.Count && offsetHashes[displacementIndex] != hash)                  	{  						continue;                  	}                    	bool spotFound = true;                      int offset = displacementIndex;                      foreach (var stateAction in stateActions)                      {                          if (offset >= tableCount)                          {                              // Run out of table to check' but is still OK.                              break;                          }                          if (stateAction != table[offset])                          {                              // Not found                              spotFound = false;                              break;                          }                          ++offset;                      }                        // Exiting the loop' if a spot is found add the correct displacement index                      if (spotFound)                      {                          displacement[state] = displacementIndex;                            // Add to the state table as much as is needed.                          table.AddRange(stateActions.Skip(offset - displacementIndex));    						// Add the hashes that does not exist up to the displacement index  						for (int i = offsetHashes.Count; i < displacementIndex; ++i)  						{  							var offsetHash = 0;  							for (int j = i; j < stateActions.Length; ++j )  							{  								offsetHash = (offsetHash * 397) ^ table[j];  							}  							offsetHashes.Add(offsetHash);  						}                      	offsetHashes.Add(hash);                        	// Break loop to process next state.  							break;                      }                  }              }
Magic Number,Piglet.Common,CompressedTable,C:\repos\Dervall_Piglet\Piglet\Common\CompressedTable.cs,CompressedTable,The following statement contains a magic number: for (int state = 1; state < numStates; ++state)              {                  var stateActions = StateActions(state' uncompressed).ToArray();              	var hash = stateActions.Aggregate(0' (acc' x) => (acc * 397) ^ x);                    // Need to run *past* the table in order to add wholly incompatible matches                  // this will not index out of the table' so there is no need to worry.                  var tableCount = table.Count();                    for (int displacementIndex = 0; displacementIndex <= tableCount; ++displacementIndex)                  {                  	if (displacementIndex < offsetHashes.Count && offsetHashes[displacementIndex] != hash)                  	{  						continue;                  	}                    	bool spotFound = true;                      int offset = displacementIndex;                      foreach (var stateAction in stateActions)                      {                          if (offset >= tableCount)                          {                              // Run out of table to check' but is still OK.                              break;                          }                          if (stateAction != table[offset])                          {                              // Not found                              spotFound = false;                              break;                          }                          ++offset;                      }                        // Exiting the loop' if a spot is found add the correct displacement index                      if (spotFound)                      {                          displacement[state] = displacementIndex;                            // Add to the state table as much as is needed.                          table.AddRange(stateActions.Skip(offset - displacementIndex));    						// Add the hashes that does not exist up to the displacement index  						for (int i = offsetHashes.Count; i < displacementIndex; ++i)  						{  							var offsetHash = 0;  							for (int j = i; j < stateActions.Length; ++j )  							{  								offsetHash = (offsetHash * 397) ^ table[j];  							}  							offsetHashes.Add(offsetHash);  						}                      	offsetHashes.Add(hash);                        	// Break loop to process next state.  							break;                      }                  }              }
Magic Number,Piglet.Lexer.Construction,CharRange,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\CharRange.cs,ToGraphSafeString,The following statement contains a magic number: return c >= 33 && c <= 0x7e                         ? c.ToString()                         : string.Format("0x{0:x2}"' (int)c);
Magic Number,Piglet.Lexer.Construction,CharRange,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\CharRange.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (From.GetHashCode()*397) ^ To.GetHashCode();              }
Magic Number,Piglet.Lexer.Construction,CharSet,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\CharSet.cs,CharSet,The following statement contains a magic number: if (ranges.Length % 2 != 0)                  throw new ArgumentException("Number of chars in ranges must be an even number");
Magic Number,Piglet.Lexer.Construction,CharSet,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\CharSet.cs,CharSet,The following statement contains a magic number: for (int i = 0; i < ranges.Length; i += 2)              {                  AddRange(ranges[i]' ranges[i+1]' combine);              }
Magic Number,Piglet.Lexer.Construction,FiniteAutomata<TState>,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\FiniteAutomata.cs,DistinguishValidInputs,The following statement contains a magic number: var distinguishedRanges = new List<CharRange>(pivot * 2);
Magic Number,Piglet.Lexer.Construction,FiniteAutomata<TState>,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\FiniteAutomata.cs,FindNewRanges,The following statement contains a magic number: while (true)  			{  				int pivot = a + (b - a) / 2;    				int cmp = range.From - distinguishedRanges[pivot].From;    				if (cmp == 0)  				{  					startIndex = pivot;  					break;  				}  				  				if (cmp < 0)  				{  					b = pivot;  				}  				else  				{  					a = pivot;  				}  			}
Magic Number,Piglet.Lexer.Construction,FiniteAutomata<TState>,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\FiniteAutomata.cs,FindNewRanges,The following statement contains a magic number: while (true)  			{  				int pivot = a2 + (b2 - a2) / 2;    				int cmp = c - distinguishedRanges[pivot].To;    				if (cmp == 0)  				{  					for (int i = startIndex; i <= pivot; ++i)  					{  						CharRange f = distinguishedRanges[i];  						yield return new CharRange { From = f.From' To = f.To == char.MaxValue ? f.To : (char) (f.To - 1) };  					}  					yield break;  				}    				if (cmp < 0)  				{  					b2 = pivot;  				}  				else  				{  					a2 = pivot;  				}  			}
Magic Number,Piglet.Lexer.Runtime,TransitionTable<T>,C:\repos\Dervall_Piglet\Piglet\Lexer\Runtime\TransitionTable.cs,TransitionTable,The following statement contains a magic number: asciiIndices = new int[256];
Magic Number,Piglet.Parser.Configuration.Fluent,FluentParserConfigurator,C:\repos\Dervall_Piglet\Piglet\Parser\Configuration\Fluent\FluentParserConfigurator.cs,MakeListRule,The following statement contains a magic number: if (separator != null)              {                  listRule.AddProduction(listRule' separator' ((FluentRule)rule).NonTerminal).SetReduceFunction(f =>                  {                      var list = (List<TListType>)f[0];                      list.Add((TListType)f[2]);                      return list;                  });              }              else              {                  listRule.AddProduction(listRule' ((FluentRule)rule).NonTerminal).SetReduceFunction(f =>                  {                      var list = (List<TListType>)f[0];                      list.Add((TListType)f[1]);                      return list;                  });              }
Magic Number,Piglet.Parser.Construction.Debug,ParseTableToString,C:\repos\Dervall_Piglet\Piglet\Parser\Construction\Debug\ParseTableToString.cs,ToDebugString,The following statement contains a magic number: for (int i = 0; i<numStates; ++i)              {                  object[] formatParams = new[] { i.ToString() }.Concat(grammar.AllSymbols.OfType<Terminal<T>>().Select(f =>                  {                      var actionValue = table.Action[i' f.TokenNumber];                      if (actionValue == short.MaxValue)                      {                          return "acc";                      }                        if (actionValue == short.MinValue)                      {                          return "";                      }                        if (actionValue < 0)                      {                          return "r" + -(actionValue + 1);                      }                        return "s" + actionValue;                  }).Concat(grammar.AllSymbols.OfType<NonTerminal<T>>().Where(f => f.ProductionRules.All(p => p.ResultSymbol != grammar.AcceptSymbol)).Select(f => table.Goto[i' f.TokenNumber - numTerminals] ==                                                                                        short.MinValue                                                                                            ? ""                                                                                            : table.Goto[i' f.TokenNumber - numTerminals].ToString()))).ToArray<object>();                                    // If formatparams is all empty' we have run out of table to process.                  // This is perhaps not the best way to determine if the table has ended but the grammar                  // has no idea of the number of states' and I'd rather not mess up the interface                  // with methods to get the number of states.                  if (formatParams.Distinct().Count() == 2)                  {                      // All empty strings and one state.                      break;                  }                    sb.Append(string.Format(format' formatParams));              }
Magic Number,Piglet.Parser,LRParser<T>,C:\repos\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The following statement contains a magic number: while (true)              {                  int state = parseStack.Peek();                  int action = parseTable.Action[state' input.Item1];                  if (action >= 0)                  {                      if (action == short.MaxValue)                      {                          // Accept!                          return valueStack.Pop();                      }                        // Shift                      parseStack.Push(input.Item1);   // Push token unto stack                      parseStack.Push(action);        // Push state unto stack                        // Shift token value unto value stack                      valueStack.Push(input.Item2);                        // Lex next token                      input = lexerInstance.Next();                  }                  else                  {                      if (action == short.MinValue)                      {                          // Get the expected tokens                          string[] expectedTokens = GetExpectedTokenNames(state).ToArray();                                                    // Create an exception that either might be thrown or may be handed to the error handling routine.                          exception = new ParseException(string.Format("Illegal token {0}. Expected {1}"'                               terminalDebugNames[input.Item1]' string.Join("'"' expectedTokens)))                                          {                                              LexerState = lexerInstance'                                              FoundToken = terminalDebugNames[input.Item1]'                                              ExpectedTokens = expectedTokens'                                              FoundTokenId = input.Item1'                                              ParserState = state                                          };                            // Go for error recovery!                          while (parseTable.Action[parseStack.Peek()' errorTokenNumber] == short.MinValue)                          {                              // If we run out of stack while searching for the error handler' throw the exception                              // This is what happens when there is no error handler defined at all.                              if (parseStack.Count <= 2)                                  throw exception;                                parseStack.Pop(); // Pop state                              parseStack.Pop(); // Pop token                              valueStack.Pop(); // Pop whatever value                          }                            // Shift the error token unto the stack                          state = parseStack.Peek();                          parseStack.Push(errorTokenNumber);                          parseStack.Push(parseTable.Action[state' errorTokenNumber]);                          valueStack.Push(default(T));                          state = parseStack.Peek();                            // We have now found a state where error recovery is enabled. This means that we                           // continue to scan the input stream looking for something which is accepted.                          // End of input will cause the exception to be thrown                          for (; parseTable.Action[state' input.Item1] == short.MinValue &&                                 input.Item1 != endOfInputTokenNumber; input = lexerInstance.Next())                              ; // nom nom nom                            // Ran out of file looking for the end of the error rule                          if (input.Item1 == endOfInputTokenNumber)                              throw exception;                                                    // If we get here we are pretty cool' continue running the parser. The actual error recovery routine will be                          // called as soon as the error rule itself is reduced.                      }                      else                      {                          // Get the right reduction rule to apply                          var reductionRule = parseTable.ReductionRules[-(action + 1)];                          for (int i = 0; i < reductionRule.NumTokensToPop*2; ++i)                          {                              parseStack.Pop();                          }                            // Transfer to state found in goto table                          int stateOnTopOfStack = parseStack.Peek();                          parseStack.Push(reductionRule.TokenToPush);                          parseStack.Push(parseTable.Goto[stateOnTopOfStack' reductionRule.TokenToPush]);                            // Get tokens off the value stack for the OnReduce function to run on                          var onReduceParams = new T[reductionRule.NumTokensToPop];                            // Need to do it in reverse since thats how the stack is organized                          for (int i = reductionRule.NumTokensToPop - 1; i >= 0; --i)                          {                              onReduceParams[i] = valueStack.Pop();                          }                            // This calls the reduction function with the possible exception set. The exception could be cleared here' but                          // there is no real reason to do so' since all the normal rules will ignore it' and all the error rules are guaranteed                          // to have the exception set prior to entering the reduction function.                          var reduceFunc = reductionRule.OnReduce;                          valueStack.Push(reduceFunc == null ? default(T) : reduceFunc(exception' onReduceParams));                      }                  }              }
Magic Number,Piglet.Parser,LRParser<T>,C:\repos\Dervall_Piglet\Piglet\Parser\LRParser.cs,Parse,The following statement contains a magic number: while (true)              {                  int state = parseStack.Peek();                  int action = parseTable.Action[state' input.Item1];                  if (action >= 0)                  {                      if (action == short.MaxValue)                      {                          // Accept!                          return valueStack.Pop();                      }                        // Shift                      parseStack.Push(input.Item1);   // Push token unto stack                      parseStack.Push(action);        // Push state unto stack                        // Shift token value unto value stack                      valueStack.Push(input.Item2);                        // Lex next token                      input = lexerInstance.Next();                  }                  else                  {                      if (action == short.MinValue)                      {                          // Get the expected tokens                          string[] expectedTokens = GetExpectedTokenNames(state).ToArray();                                                    // Create an exception that either might be thrown or may be handed to the error handling routine.                          exception = new ParseException(string.Format("Illegal token {0}. Expected {1}"'                               terminalDebugNames[input.Item1]' string.Join("'"' expectedTokens)))                                          {                                              LexerState = lexerInstance'                                              FoundToken = terminalDebugNames[input.Item1]'                                              ExpectedTokens = expectedTokens'                                              FoundTokenId = input.Item1'                                              ParserState = state                                          };                            // Go for error recovery!                          while (parseTable.Action[parseStack.Peek()' errorTokenNumber] == short.MinValue)                          {                              // If we run out of stack while searching for the error handler' throw the exception                              // This is what happens when there is no error handler defined at all.                              if (parseStack.Count <= 2)                                  throw exception;                                parseStack.Pop(); // Pop state                              parseStack.Pop(); // Pop token                              valueStack.Pop(); // Pop whatever value                          }                            // Shift the error token unto the stack                          state = parseStack.Peek();                          parseStack.Push(errorTokenNumber);                          parseStack.Push(parseTable.Action[state' errorTokenNumber]);                          valueStack.Push(default(T));                          state = parseStack.Peek();                            // We have now found a state where error recovery is enabled. This means that we                           // continue to scan the input stream looking for something which is accepted.                          // End of input will cause the exception to be thrown                          for (; parseTable.Action[state' input.Item1] == short.MinValue &&                                 input.Item1 != endOfInputTokenNumber; input = lexerInstance.Next())                              ; // nom nom nom                            // Ran out of file looking for the end of the error rule                          if (input.Item1 == endOfInputTokenNumber)                              throw exception;                                                    // If we get here we are pretty cool' continue running the parser. The actual error recovery routine will be                          // called as soon as the error rule itself is reduced.                      }                      else                      {                          // Get the right reduction rule to apply                          var reductionRule = parseTable.ReductionRules[-(action + 1)];                          for (int i = 0; i < reductionRule.NumTokensToPop*2; ++i)                          {                              parseStack.Pop();                          }                            // Transfer to state found in goto table                          int stateOnTopOfStack = parseStack.Peek();                          parseStack.Push(reductionRule.TokenToPush);                          parseStack.Push(parseTable.Goto[stateOnTopOfStack' reductionRule.TokenToPush]);                            // Get tokens off the value stack for the OnReduce function to run on                          var onReduceParams = new T[reductionRule.NumTokensToPop];                            // Need to do it in reverse since thats how the stack is organized                          for (int i = reductionRule.NumTokensToPop - 1; i >= 0; --i)                          {                              onReduceParams[i] = valueStack.Pop();                          }                            // This calls the reduction function with the possible exception set. The exception could be cleared here' but                          // there is no real reason to do so' since all the normal rules will ignore it' and all the error rules are guaranteed                          // to have the exception set prior to entering the reduction function.                          var reduceFunc = reductionRule.OnReduce;                          valueStack.Push(reduceFunc == null ? default(T) : reduceFunc(exception' onReduceParams));                      }                  }              }
Missing Default,Piglet.Lexer.Construction,RegExLexer,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\RegExLexer.cs,EscapedCharToAcceptCharsInClass,The following switch statement is missing a default case: switch (c)              {                  case '-':                  case '^':                      return SingleChar(c);                }
Missing Default,Piglet.Lexer.Construction,ShuntingYard,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\ShuntingYard.cs,PreceedingTypeRequiresConcat,The following switch statement is missing a default case: switch (type)              {                  case RegExToken.TokenType.OperatorMul:                  case RegExToken.TokenType.OperatorQuestion:                  case RegExToken.TokenType.OperatorPlus:                  case RegExToken.TokenType.Accept:                  case RegExToken.TokenType.OperatorCloseParanthesis:                  case RegExToken.TokenType.NumberedRepeat:                      return true;              }
Missing Default,Piglet.Lexer.Construction,ShuntingYard,C:\repos\Dervall_Piglet\Piglet\Lexer\Construction\ShuntingYard.cs,NextTypeRequiresConcat,The following switch statement is missing a default case: switch (type)              {                  case RegExToken.TokenType.Accept:                  case RegExToken.TokenType.OperatorOpenParanthesis:                      return true;                }
