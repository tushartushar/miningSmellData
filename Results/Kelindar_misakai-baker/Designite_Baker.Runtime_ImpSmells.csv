Implementation smell,Namespace,Class,File,Method,Description
Long Method,Baker.Text,ColorSlice,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssColorName.cs,ColorSlice,The method has 151 lines of code.
Long Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseMediaQuery,The method has 108 lines of code.
Long Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseDeclarationList,The method has 120 lines of code.
Long Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseTerm,The method has 193 lines of code.
Long Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRgb,The method has 183 lines of code.
Long Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,Append,The method has 430 lines of code.
Long Method,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,NextToken,The method has 138 lines of code.
Long Method,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanComment,The method has 144 lines of code.
Long Method,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanAtKeyword,The method has 108 lines of code.
Long Method,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,The method has 123 lines of code.
Long Method,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanNum,The method has 117 lines of code.
Long Method,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,GetString,The method has 117 lines of code.
Long Method,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,GetNum,The method has 103 lines of code.
Long Method,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The method has 251 lines of code.
Long Method,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,returnBlocks,The method has 196 lines of code.
Long Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The method has 106 lines of code.
Long Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineReturnWithExpression,The method has 131 lines of code.
Long Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The method has 790 lines of code.
Long Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The method has 280 lines of code.
Long Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The method has 105 lines of code.
Long Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The method has 209 lines of code.
Long Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The method has 197 lines of code.
Long Method,Baker.Text,JsConstantWrapper,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsConstantWrapper.cs,EscapeString,The method has 134 lines of code.
Long Method,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalThisOperator,The method has 100 lines of code.
Long Method,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,The method has 142 lines of code.
Long Method,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheRight,The method has 115 lines of code.
Long Method,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoBinaryOperator,The method has 182 lines of code.
Long Method,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The method has 118 lines of code.
Long Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The method has 174 lines of code.
Long Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The method has 102 lines of code.
Long Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The method has 104 lines of code.
Long Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,EscapeString,The method has 165 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,Parse,The method has 131 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseStatements,The method has 109 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseStatement,The method has 266 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseIdentifierInitializer,The method has 164 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseIfStatement,The method has 159 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseForStatement,The method has 304 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseDoStatement,The method has 130 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseSwitchStatement,The method has 238 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseTryStatement,The method has 200 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseFunction,The method has 289 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseExpression,The method has 136 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseUnaryExpression,The method has 264 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseLeftHandSideExpression,The method has 535 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The method has 109 lines of code.
Long Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,MemberExpression,The method has 193 lines of code.
Long Method,Baker.Text,JsReorderScopeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsReorderScopeVisitor.cs,RelocateVar,The method has 144 lines of code.
Long Method,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The method has 656 lines of code.
Long Method,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanNumber,The method has 145 lines of code.
Long Method,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The method has 313 lines of code.
Long Method,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PPSkipToDirective,The method has 101 lines of code.
Long Method,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,ToArguments,The method has 119 lines of code.
Long Method,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,Parse,The method has 1238 lines of code.
Long Method,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,GetBlockPattern,The method has 127 lines of code.
Complex Method,Baker.Text,YamlDynamic,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Yaml\YamlDynamic.cs,TryConvertToBasicType,Cyclomatic complexity of the method is 15
Complex Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseMedia,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseMediaQuery,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseDeclarationList,Cyclomatic complexity of the method is 9
Complex Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRule,Cyclomatic complexity of the method is 11
Complex Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseSelector,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseAttrib,Cyclomatic complexity of the method is 9
Complex Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRgb,Cyclomatic complexity of the method is 14
Complex Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,NextSignificantToken,Cyclomatic complexity of the method is 12
Complex Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,SkipToClose,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,Append,Cyclomatic complexity of the method is 23
Complex Method,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanComment,Cyclomatic complexity of the method is 10
Complex Method,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,Cyclomatic complexity of the method is 10
Complex Method,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,GetNum,Cyclomatic complexity of the method is 13
Complex Method,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,Cyclomatic complexity of the method is 33
Complex Method,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,returnBlocks,Cyclomatic complexity of the method is 29
Complex Method,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,ManualRenameFields,Cyclomatic complexity of the method is 9
Complex Method,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,AutoRenameFields,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 53
Complex Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 22
Complex Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 11
Complex Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 11
Complex Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 11
Complex Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 12
Complex Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 21
Complex Method,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 13
Complex Method,Baker.Text,ReferenceComparer,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsCrunchEnumerator.cs,Compare,Cyclomatic complexity of the method is 10
Complex Method,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoBinaryOperator,Cyclomatic complexity of the method is 11
Complex Method,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoWhileNode,Cyclomatic complexity of the method is 9
Complex Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 12
Complex Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 12
Complex Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 11
Complex Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,WriteToStream,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,OutputFunctionArgsAndBody,Cyclomatic complexity of the method is 11
Complex Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseIdentifierInitializer,Cyclomatic complexity of the method is 12
Complex Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseForStatement,Cyclomatic complexity of the method is 11
Complex Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseSwitchStatement,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseTryStatement,Cyclomatic complexity of the method is 12
Complex Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseFunction,Cyclomatic complexity of the method is 15
Complex Method,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseExpression,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,JsReorderScopeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsReorderScopeVisitor.cs,Apply,Cyclomatic complexity of the method is 12
Complex Method,Baker.Text,JsReorderScopeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsReorderScopeVisitor.cs,IsMinificationHint,Cyclomatic complexity of the method is 9
Complex Method,Baker.Text,JsResolutionVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsResolutionVisitor.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanNumber,Cyclomatic complexity of the method is 12
Complex Method,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,Cyclomatic complexity of the method is 10
Complex Method,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,SkipMultilineComment,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,Cyclomatic complexity of the method is 10
Complex Method,Baker.Text,MinifierError,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierError.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,ToArguments,Cyclomatic complexity of the method is 13
Complex Method,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,FormParagraphs,Cyclomatic complexity of the method is 8
Complex Method,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,handleTrailingParens,Cyclomatic complexity of the method is 9
Long Parameter List,Baker.Text,Options,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\TypeScript\TypeScript.cs,Options,The method has 5 parameters. Parameters: emitComments' generateDeclaration' generateSourceMaps' outPath' targetVersion
Long Parameter List,Baker.Text,CssException,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,CssException,The method has 6 parameters. Parameters: errorNum' source' severity' line' pos' message
Long Parameter List,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The method has 10 parameters. Parameters: html' preBlocks' taBlocks' scriptBlocks' styleBlocks' eventBlocks' condCommentBlocks' skipBlocks' lineBreakBlocks' userBlocks
Long Parameter List,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,returnBlocks,The method has 10 parameters. Parameters: html' preBlocks' taBlocks' scriptBlocks' styleBlocks' eventBlocks' condCommentBlocks' skipBlocks' lineBreakBlocks' userBlocks
Long Parameter List,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,processPreservedBlocks,The method has 9 parameters. Parameters: preBlocks' taBlocks' scriptBlocks' styleBlocks' eventBlocks' condCommentBlocks' skipBlocks' lineBreakBlocks' userBlocks
Long Parameter List,Baker.Text,IJsSourceMap,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\IJsSourceMap.cs,MarkSegment,The method has 5 parameters. Parameters: node' startLine' startColumn' name' context
Long Parameter List,Baker.Text,JsContext,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsContext.cs,JsContext,The method has 8 parameters. Parameters: document' startLineNumber' startLinePosition' startPosition' endLineNumber' endLinePosition' endPosition' token
Long Parameter List,Baker.Text,JsScriptSharpSourceMap,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScriptSharpSourceMap.cs,MarkSegment,The method has 5 parameters. Parameters: node' startLine' startColumn' name' context
Long Parameter List,Baker.Text,JsV3SourceMap,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsV3SourceMap.cs,MarkSegment,The method has 5 parameters. Parameters: node' startLine' startColumn' name' context
Long Parameter List,Baker.Text,JsV3SourceMap,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsV3SourceMap.cs,CreateSegment,The method has 6 parameters. Parameters: destinationLine' destinationColumn' sourceLine' sourceColumn' fileName' symbolName
Long Parameter List,Baker.Text,MinifierError,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierError.cs,MinifierError,The method has 11 parameters. Parameters: isError' severity' subcategory' errorCode' helpKeyword' file' startLine' startColumn' endLine' endColumn' message
Long Identifier,Baker.Text,YamlDynamic,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Yaml\YamlDynamic.cs,,The length of the parameter ConvertableGenericCollectionTypes is 33.
Long Identifier,Baker.Text,YamlDynamic,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Yaml\YamlDynamic.cs,,The length of the parameter ConvertableGenericDictionaryTypes is 33.
Long Identifier,Baker.Text,NoSkipTokenSet,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,,The length of the parameter s_BlockConditionNoSkipTokenSet is 30.
Long Identifier,Baker.Text,NoSkipTokenSet,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,,The length of the parameter s_EndOfStatementNoSkipTokenSet is 30.
Long Identifier,Baker.Text,NoSkipTokenSet,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,,The length of the parameter s_ExpressionListNoSkipTokenSet is 30.
Long Identifier,Baker.Text,NoSkipTokenSet,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,,The length of the parameter s_PostfixExpressionNoSkipTokenSet is 33.
Long Identifier,Baker.Text,NoSkipTokenSet,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,,The length of the parameter s_StartStatementNoSkipTokenSet is 30.
Long Identifier,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The length of the parameter scanForRegularExpressionLiterals is 32.
Long Identifier,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,,The length of the parameter m_conditionalCompilationIfLevel is 31.
Long Statement,Baker,SiteProject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Site\SiteProject.Main.cs,FromDisk,The length of the statement  "                throw new FileNotFoundException("Unable to load the project' as the directory specified does not exist. Directory: " + path.FullName); " is 134.
Long Statement,Baker.Text,YamlDynamic,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Yaml\YamlDynamic.cs,TryGetValueByKeyAndType,The length of the statement  "            return IsNullableType(type) ? SuccessfullyGetValue(new YamlDynamic((YamlNode)null)' out result) : FailToGetValue(out result); " is 125.
Long Statement,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseProduct,The length of the statement  "                    || (CurrentTokenType == TokenType.Identifier && string.Compare(CurrentTokenText' "mod"' StringComparison.OrdinalIgnoreCase) == 0)) " is 130.
Long Statement,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ReportError,The length of the statement  "            string message = CssStrings.ResourceManager.GetString(errorNumber.ToString()' CssStrings.Culture).FormatInvariant(arguments); " is 125.
Long Statement,Baker.Text,HtmlCompressorStatistics,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressorStatistics.cs,ToString,The length of the statement  "			return String.Format("Time={0}' Preserved={1}' Original={2}' Compressed={3}"' time' preservedSize' originalMetrics' compressedMetrics); " is 135.
Long Statement,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,IsIterativeReference,The length of the statement  "                || (regExp != null && regExp.PatternSwitches != null && regExp.PatternSwitches.IndexOf("g"' StringComparison.OrdinalIgnoreCase) >= 0)) " is 134.
Long Statement,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,AutoRenameFields,The length of the statement  "                            || (field.OuterField != null && !field.IsGenerated && field.OwningScope != null && !field.OwningScope.IsKnownAtCompileTime)) " is 124.
Long Statement,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,AutoRenameFields,The length of the statement  "                            || !(m_settings.RemoveFunctionExpressionNames && m_settings.IsModificationAllowed(JsTreeModifications.RemoveFunctionExpressionNames)))) " is 135.
Long Statement,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineTwoExpressions,The length of the statement  "                    var binOp = new JsBinaryOperator(prevBinary.Operand2.Context.Clone().CombineWith(curBinary.Operand2.Context)' prevBinary.Parser) " is 128.
Long Statement,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineTwoExpressions,The length of the statement  "                    var binOp = JsCommaOperator.CombineWithComma(prevBinary.Context.Clone().CombineWith(curBinary.Context)' m_parser' prevBinary' curBinary); " is 137.
Long Statement,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineTwoExpressions,The length of the statement  "                var binOp = JsCommaOperator.CombineWithComma(node[ndx - 1].Context.Clone().CombineWith(node[ndx].Context)' m_parser' node[ndx - 1]' node[ndx]); " is 143.
Long Statement,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The length of the statement  "                if (m_parser.Settings.StripDebugStatements && m_parser.Settings.IsModificationAllowed(JsTreeModifications.StripDebugStatements)) " is 128.
Long Statement,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The length of the statement  "                        node.Parent.ReplaceChild(node' new JsConstantWrapper(double.PositiveInfinity' JsPrimitiveType.Number' node.Context' m_parser)); " is 127.
Long Statement,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The length of the statement  "                if (node.IsCCSpecialCase && m_parser.Settings.IsModificationAllowed(JsTreeModifications.RemoveUnnecessaryCCOnStatements)) " is 121.
Long Statement,Baker.Text,JsContext,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsContext.cs,HandleError,The length of the statement  "            if ((errorId != JsError.UndeclaredVariable && errorId != JsError.UndeclaredFunction) || !Document.HasAlreadySeenErrorFor(Code)) " is 127.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,ReplaceMemberBracketWithDot,The length of the statement  "                        if (JsScanner.IsSafeIdentifier(combinedString) && !JsScanner.IsKeyword(combinedString' parentCall.EnclosingScope.UseStrict)) " is 124.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,The length of the statement  "                && (node.OperatorToken == JsToken.BitwiseAnd || node.OperatorToken == JsToken.BitwiseOr || node.OperatorToken == JsToken.BitwiseXor)) " is 133.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LessThan,The length of the statement  "                        newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) < 0' JsPrimitiveType.Boolean' null' m_parser); " is 138.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LessThanOrEqual,The length of the statement  "                        newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) <= 0' JsPrimitiveType.Boolean' null' m_parser); " is 139.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,GreaterThan,The length of the statement  "                        newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) > 0' JsPrimitiveType.Boolean' null' m_parser); " is 138.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,GreaterThanOrEqual,The length of the statement  "                        newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) >= 0' JsPrimitiveType.Boolean' null' m_parser); " is 139.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Equal,The length of the statement  "                                newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) == 0' JsPrimitiveType.Boolean' null' m_parser); " is 139.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,NotEqual,The length of the statement  "                                newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) != 0' JsPrimitiveType.Boolean' null' m_parser); " is 139.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictEqual,The length of the statement  "                                newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) == 0' JsPrimitiveType.Boolean' null' m_parser); " is 139.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictNotEqual,The length of the statement  "                                newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) != 0' JsPrimitiveType.Boolean' null' m_parser); " is 139.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoBinaryOperator,The length of the statement  "                                        new JsConstantWrapper(node.OperatorToken == JsToken.StrictEqual ? false : true' JsPrimitiveType.Boolean' node.Context' m_parser)); " is 130.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The length of the statement  "                                ReplaceNodeWithLiteral(node' new JsConstantWrapper(literalOperand.ToNumber()' JsPrimitiveType.Number' node.Context' m_parser)); " is 127.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The length of the statement  "                                ReplaceNodeWithLiteral(node' new JsConstantWrapper(-literalOperand.ToNumber()' JsPrimitiveType.Number' node.Context' m_parser)); " is 128.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The length of the statement  "                                ReplaceNodeWithLiteral(node' new JsConstantWrapper(Convert.ToDouble(~literalOperand.ToInt32())' JsPrimitiveType.Number' node.Context' m_parser)); " is 145.
Long Statement,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The length of the statement  "                                ReplaceNodeWithLiteral(node' new JsConstantWrapper(!literalOperand.ToBoolean()' JsPrimitiveType.Boolean' node.Context' m_parser)); " is 130.
Long Statement,Baker.Text,JsGlobalScope,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsGlobalScope.cs,SetAssumedGlobals,The length of the statement  "                m_assumedGlobals = settings.KnownGlobalCollection == null ? new HashSet<string>() : new HashSet<string>(settings.KnownGlobalCollection); " is 136.
Long Statement,Baker.Text,JsonOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsonOutputVisitor.cs,GetSmallestRep,The length of the statement  "                    if (int.TryParse(match.Result("${eng}") + match.Result("${pow}")' NumberStyles.Integer' CultureInfo.InvariantCulture' out exponent)) " is 132.
Long Statement,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Apply,The length of the statement  "                settings.IfNotNull(s => s.SymbolsMap.IfNotNull(m => m.EndOutputRun(outputVisitor.m_lineCount' outputVisitor.m_lineLength))); " is 124.
Long Statement,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The length of the statement  "                    && (node.FalseBlock == null || (!node.TrueBlock.EncloseBlock(EncloseBlockType.IfWithoutElse) && !node.TrueBlock.EncloseBlock(EncloseBlockType.SingleDoWhile))) " is 158.
Long Statement,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The length of the statement  "                            || (node.ConditionalCommentContainsOn && !m_settings.IsModificationAllowed(JsTreeModifications.RemoveUnnecessaryCCOnStatements))) " is 129.
Long Statement,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,InsertSpaceIfNeeded,The length of the statement  "                else if ((m_lastCharacter == '@' || JsScanner.IsValidIdentifierPart(m_lastCharacter)) && JsScanner.IsValidIdentifierPart(ch)) " is 125.
Long Statement,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,InsertSpaceIfNeeded,The length of the statement  "            else if ((m_lastCharacter == '@' || JsScanner.IsValidIdentifierPart(m_lastCharacter)) && JsScanner.IsValidIdentifierPart(text)) " is 127.
Long Statement,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseStatements,The length of the statement  "                                } while (m_currentToken.Token != JsToken.EndOfFile && !TokenInList(NoSkipTokenSet.s_TopLevelNoSkipTokenSet' m_currentToken.Token) " is 129.
Long Statement,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseForStatement,The length of the statement  "                                            condOrColl = new JsConstantWrapper(true' JsPrimitiveType.Boolean' CurrentPositionContext()' this); // what could we put here? " is 125.
Long Statement,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseContinueStatement,The length of the statement  "            if (!m_foundEndOfLine && (JsToken.Identifier == m_currentToken.Token || (label = JsKeyword.CanBeIdentifier(m_currentToken.Token)) != null)) " is 139.
Long Statement,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseBreakStatement,The length of the statement  "            if (!m_foundEndOfLine && (JsToken.Identifier == m_currentToken.Token || (label = JsKeyword.CanBeIdentifier(m_currentToken.Token)) != null)) " is 139.
Long Statement,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseSwitchStatement,The length of the statement  "                                while (JsToken.RightCurly != m_currentToken.Token && JsToken.Case != m_currentToken.Token && JsToken.Default != m_currentToken.Token) " is 133.
Long Statement,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseLeftHandSideExpression,The length of the statement  "                                        if (ConvertNumericLiteralToDouble(m_currentToken.Code' (m_currentToken.Token == JsToken.IntegerLiteral)' out doubleValue)) " is 122.
Long Statement,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ScanNextToken,The length of the statement  "                EchoWriter.IfNotNull(w => { if (!Settings.PreprocessOnly || nextToken.Token != JsToken.PreprocessorDirective) w.Write(nextToken.Code); }); " is 138.
Long Statement,Baker.Text,JsResolutionVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsResolutionVisitor.cs,Visit,The length of the statement  "                node.FunctionScope = new JsFunctionScope(parentScope' node.FunctionType != JsFunctionType.Declaration' m_settings' node) " is 120.
Long Statement,Baker.Text,JsResolutionVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsResolutionVisitor.cs,Visit,The length of the statement  "                    node.CatchBlock.BlockScope = new JsCatchScope(CurrentLexicalScope' node.CatchBlock.Context' m_settings' node.CatchParameter) " is 124.
Long Statement,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The length of the statement  "                m_decodedString = m_strSourceCode.Substring(m_currentToken.StartPosition + 1' m_currentPosition - m_currentToken.StartPosition - numDelimiters); " is 144.
Long Statement,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,GetOperatorPrecedence,The length of the statement  "            return op == null || op.Token == JsToken.None ? JsOperatorPrecedence.None : JsScanner.s_OperatorsPrec[op.Token - JsToken.FirstBinaryOperator]; " is 142.
Long Statement,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,InitOperatorsPrec,The length of the statement  "            JsOperatorPrecedence[] operatorsPrec = new JsOperatorPrecedence[JsToken.LastOperator - JsToken.FirstBinaryOperator + 1]; " is 120.
Long Statement,Baker.Text,JsScriptSharpSourceMap,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScriptSharpSourceMap.cs,StartSymbol,The length of the statement  "                return JavaScriptSymbol.StartNew(node' startLine + m_lineOffset' startColumn + m_columnOffset' GetSourceFileIndex(node.Context.Document.FileContext)); " is 150.
Long Statement,Baker.Text,JsScriptSharpSourceMap,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScriptSharpSourceMap.cs,MarkSegment,The length of the statement  "                var nameSymbol = JavaScriptSymbol.StartNew(fakeLookup' startLine' startColumn' GetSourceFileIndex(functionObject.Context.Document.FileContext)); " is 144.
Long Statement,Baker.Text,JsSourceMapFactory,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsSourceMapFactory.cs,Create,The length of the statement  "            else if (string.Compare(implementationName' JsScriptSharpSourceMap.ImplementationName' StringComparison.OrdinalIgnoreCase) == 0) " is 128.
Long Statement,Baker.Text,JsV3SourceMap,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsV3SourceMap.cs,CreateSegment,The length of the statement  "                DestinationColumn = m_lastDestinationColumn < 0 || m_lastDestinationLine < destinationLine ? destinationColumn : destinationColumn - m_lastDestinationColumn' " is 157.
Long Statement,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,AnchorRefShortcutEvaluator,The length of the statement  "            string linkID = Regex.Replace(linkText.ToLowerInvariant()' @"[ ]*\n[ ]*"' " ");  // lower case and remove newlines / extra spaces " is 129.
Long Statement,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,ProcessListItems,The length of the statement  "                    if (!isInsideParagraphlessListItem) // only the outer-most item should run this' otherwise it's run multiple times for the inner ones " is 133.
Long Statement,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,BlockQuoteEvaluator,The length of the statement  "            bq = Regex.Replace(bq' @"(\s*<pre>.+?</pre>)"' new MatchEvaluator(BlockQuoteEvaluator2)' RegexOptions.IgnorePatternWhitespace | RegexOptions.Singleline); " is 153.
Long Statement,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,handleTrailingParens,The length of the statement  "            // We're not using a *real* lookbehind' because of links with in links' like <a href="http://web.archive.org/web/20121130000728/http://www.google.com/"> " is 152.
Long Statement,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,DoAutoLinks,The length of the statement  "                text = Regex.Replace(text' pattern' new MatchEvaluator(EmailEvaluator)' RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace); " is 136.
Long Statement,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,EscapeSpecialCharsWithinTagAttributes,The length of the statement  "                    if (_autoHyperlink && value.StartsWith("<!")) // escape slashes in comments to prevent autolinking there -- http://meta.stackoverflow.com/questions/95987/html-comment-containing-url-breaks-if-followed-by-another-html-comment " is 224.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,HandleCharset,The conditional expression  "string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseStylesheet,The conditional expression  "ParseRule() == Parsed.True                || ParseMedia() == Parsed.True                || ParsePage() == Parsed.True                || ParseFontFace() == Parsed.True                || ParseKeyFrames() == Parsed.True                || ParseAtKeyword() == Parsed.True  			  || ParseAspNetBlock() == Parsed.True"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseStylesheet,The conditional expression  "ParseRule() == Parsed.True                    || ParseMedia() == Parsed.True                    || ParsePage() == Parsed.True                    || ParseFontFace() == Parsed.True                    || ParseAtKeyword() == Parsed.True  				  || ParseAspNetBlock() == Parsed.True"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseSCDOCDCComments,The conditional expression  "CurrentTokenType == TokenType.Space                || CurrentTokenType == TokenType.Comment                || CurrentTokenType == TokenType.CommentOpen                || CurrentTokenType == TokenType.CommentClose                || (CurrentTokenType == TokenType.Character && CurrentTokenText == ";")"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseMedia,The conditional expression  "ParseRule() == Parsed.True                            || ParseMedia() == Parsed.True                            || ParsePage() == Parsed.True                            || ParseFontFace() == Parsed.True                            || ParseAtKeyword() == Parsed.True                            || ParseAspNetBlock() == Parsed.True"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseMediaQuery,The conditional expression  "(CurrentTokenType == TokenType.Identifier                  && string.Compare(CurrentTokenText' "AND"' StringComparison.OrdinalIgnoreCase) == 0)                  || (CurrentTokenType == TokenType.Function                  && string.Compare(CurrentTokenText' "AND("' StringComparison.OrdinalIgnoreCase) == 0)"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseDeclarationList,The conditional expression  "(CurrentTokenType != TokenType.Character                          || (CurrentTokenText != ";" && CurrentTokenText != "}"))                          && !m_scanner.EndOfFile"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseDeclarationList,The conditional expression  "CurrentTokenType != TokenType.Character                              || (CurrentTokenText != "}" && CurrentTokenText != ";")                              || (comments.Length > 0 && comments != "/* */" && comments != "/**/")"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseCombinator,The conditional expression  "CurrentTokenType == TokenType.Character                && (CurrentTokenText == "+" || CurrentTokenText == ">" || CurrentTokenText == "~")"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseAttrib,The conditional expression  "(CurrentTokenType == TokenType.Character && CurrentTokenText == "=")                    || (CurrentTokenType == TokenType.Includes)                    || (CurrentTokenType == TokenType.DashMatch)                    || (CurrentTokenType == TokenType.PrefixMatch)                    || (CurrentTokenType == TokenType.SuffixMatch)                    || (CurrentTokenType == TokenType.SubstringMatch)"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseExpressionFunction,The conditional expression  "!m_scanner.EndOfFile                    && (CurrentTokenType != TokenType.Character                      || CurrentTokenText != ")"                      || parenLevel > 0)"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseHexcolor,The conditional expression  "(colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)                      && colorHash.EndsWith("\t"' StringComparison.Ordinal)"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseProduct,The conditional expression  "(CurrentTokenType == TokenType.Character && (CurrentTokenText == "*" || CurrentTokenText == "/"))                      || (CurrentTokenType == TokenType.Identifier && string.Compare(CurrentTokenText' "mod"' StringComparison.OrdinalIgnoreCase) == 0)"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,SkipToEndOfStatement,The conditional expression  "CurrentTokenType == TokenType.Character                      && (CurrentTokenText == "(" || CurrentTokenText == "[" || CurrentTokenText == "{")"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,SkipToEndOfDeclaration,The conditional expression  "!m_scanner.EndOfFile                  && (CurrentTokenType != TokenType.Character                    || (CurrentTokenText != ";" && CurrentTokenText != "}"))"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,SkipToEndOfDeclaration,The conditional expression  "CurrentTokenType == TokenType.Character                      && (CurrentTokenText == "(" || CurrentTokenText == "[" || CurrentTokenText == "{")"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,SkipToClose,The conditional expression  "CurrentTokenType == TokenType.Character                      && (CurrentTokenText == "(" || CurrentTokenText == "[" || CurrentTokenText == "{")"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,Append,The conditional expression  "(firstChar < 'A' || 'Z' < firstChar)                                  && (firstChar < 'a' || 'z' < firstChar)                                  && firstChar != '\\'"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,Append,The conditional expression  "nextChar != '-'                                  && nextChar != '_'                                  && nextChar != ' '                                  && ('0' > nextChar || nextChar > '9')                                  && ('a' > nextChar || nextChar > 'z')                                  && ('A' > nextChar || nextChar > 'Z')"  is complex.
Complex Conditional,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,Append,The conditional expression  "(protectNextHexCharacter && CssScanner.IsH(unescapedSubstring[0]))                                          || (textEndsInEscapeSequence && unescapedSubstring[0] == ' ')"  is complex.
Complex Conditional,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,The conditional expression  "m_currentChar != '\0'                  && count < 6                  && (m_currentChar == '?' || (!hasQuestions && IsH(m_currentChar)))"  is complex.
Complex Conditional,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanNum,The conditional expression  "num == "0"                               && tokenType != TokenType.Dimension                              && tokenType != TokenType.Angle                              && tokenType != TokenType.Time                              && tokenType != TokenType.Frequency                              && tokenType != TokenType.Resolution"  is complex.
Complex Conditional,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,GetNmStart,The conditional expression  "IsNonAscii(m_currentChar)                    || (m_currentChar == '_')                    || ('a' <= m_currentChar && m_currentChar <= 'z')                    || ('A' <= m_currentChar && m_currentChar <= 'Z')"  is complex.
Complex Conditional,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,GetString,The conditional expression  "(m_currentChar == ' ')                        || (m_currentChar == '\t')                        || (m_currentChar == '!')                        || (m_currentChar == '#')                        || (m_currentChar == '$')                        || (m_currentChar == '%')                        || (m_currentChar == '&')                        || ('(' <= m_currentChar && m_currentChar <= '~')                        || (m_currentChar == (delimiter == '"' ? '\'' : '"'))"  is complex.
Complex Conditional,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,GetUrl,The conditional expression  "IsNonAscii(m_currentChar)                    || (m_currentChar == '!')                    || (m_currentChar == '#')                    || (m_currentChar == '$')                    || (m_currentChar == '%')                    || (m_currentChar == '&')                    || ('*' <= m_currentChar && m_currentChar <= '~')"  is complex.
Complex Conditional,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,AnalyzeNonGlobalScope,The conditional expression  "!variableField.IsReferenced                      && !variableField.IsGenerated                      && variableField.OuterField == null                      && variableField.FieldType != JsFieldType.CatchError                      && variableField.FieldType != JsFieldType.GhostCatch                      && variableField.OriginalContext != null"  is complex.
Complex Conditional,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,AnalyzeNonGlobalScope,The conditional expression  "variableField.RefCount == 1                      && this.IsKnownAtCompileTime                      && m_settings.RemoveUnneededCode                      && m_settings.IsModificationAllowed(JsTreeModifications.RemoveUnusedVariables)"  is complex.
Complex Conditional,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,UnreferencedFunction,The conditional expression  "this.IsKnownAtCompileTime                          && m_settings.MinifyCode                          && m_settings.RemoveUnneededCode                          && !(this is JsBlockScope)"  is complex.
Complex Conditional,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,SingleReferenceVariableField,The conditional expression  "!reference.IsAssignment                              && reference.VariableField != null                              && reference.VariableField.OuterField == null                              && reference.VariableField.CanCrunch                              && varDecl.Index < reference.Index                              && !IsIterativeReference(varDecl.Initializer' reference)"  is complex.
Complex Conditional,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,IsIterativeReference,The conditional expression  "initializer is JsArrayLiteral                   || initializer is JsObjectLiteral                  || (regExp != null && regExp.PatternSwitches != null && regExp.PatternSwitches.IndexOf("g"' StringComparison.OrdinalIgnoreCase) >= 0)"  is complex.
Complex Conditional,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,AutoRenameFields,The conditional expression  "!field.CanCrunch || field.CrunchedName != null                              || (field.OuterField != null && !field.IsGenerated && field.OwningScope != null && !field.OwningScope.IsKnownAtCompileTime)"  is complex.
Complex Conditional,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,AutoRenameFields,The conditional expression  "localField.CanCrunch                              && (localField.RefCount > 0 || localField.IsDeclared || localField.IsPlaceholder                              || !(m_settings.RemoveFunctionExpressionNames && m_settings.IsModificationAllowed(JsTreeModifications.RemoveFunctionExpressionNames)))"  is complex.
Complex Conditional,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,GetUncrunchedLocals,The conditional expression  "variableField != null && variableField.OuterField == null && variableField.CrunchedName == null                      && variableField.CanCrunch && !variableField.WasRemoved"  is complex.
Complex Conditional,Baker.Text,JsActivationObject,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsActivationObject.cs,GetUncrunchedLocals,The conditional expression  "(m_settings.LocalRenaming == JsLocalRenaming.CrunchAll                          || !variableField.Name.StartsWith("L_"' StringComparison.Ordinal))                          && !(m_settings.PreserveFunctionNames && variableField.IsFunction)"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "(node.Parent is JsBlock || (node.Parent is JsCommaOperator && node.Parent.Parent is JsBlock))                      && (node.OperatorToken == JsToken.LogicalOr || node.OperatorToken == JsToken.LogicalAnd)"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineTwoExpressions,The conditional expression  "prevBinary != null                  && curBinary != null                  && prevBinary.IsAssign                  && curBinary.IsAssign                  && curBinary.OperatorToken != JsToken.Assign                  && (lookup = curBinary.Operand1 as JsLookup) != null                  && prevBinary.Operand1.IsEquivalentTo(curBinary.Operand1)"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,CombineWithPreviousVar,The conditional expression  "binaryOp != null                  && binaryOp.IsAssign                  && (lookup = binaryOp.Operand1 as JsLookup) != null                  && lookup.VariableField != null                  && !ContainsReference(binaryOp.Operand2' lookup.VariableField)                  && previousVar[previousVar.Count - 1].VariableField == lookup.VariableField"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "ifNode != null                              && ifNode.TrueBlock != null                              && ifNode.TrueBlock.Count > 0                              && ifNode.FalseBlock != null"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node[ndx] is JsReturnNode                              || node[ndx] is JsBreak                              || node[ndx] is JsContinueNode                              || node[ndx] is JsThrowNode"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "ifNode != null && ifNode.FalseBlock == null                          && ifNode.TrueBlock.Count == 1                          && (returnNode = ifNode.TrueBlock[0] as JsReturnNode) != null"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "indexPrevious >= 0                           && lastReturn != null                          && (previousIf = node[indexPrevious] as JsIfNode) != null                          && previousIf.TrueBlock != null && previousIf.TrueBlock.Count == 1                          && previousIf.FalseBlock == null"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "ifNode != null                              && ifNode.FalseBlock == null                              && ifNode.TrueBlock != null                              && ifNode.TrueBlock.Count == 1"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "ifNode != null                                  && ifNode.FalseBlock == null                                  && ifNode.TrueBlock != null                                  && ifNode.TrueBlock.Count == 1"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,IsIfReturnExpr,The conditional expression  "ifNode != null                  && ifNode.FalseBlock == null                  && ifNode.TrueBlock != null                  && ifNode.TrueBlock.Count == 1"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node.Arguments == null                                || node.Arguments.Count != 1                                || (constWrapper != null && !constWrapper.IsNumericLiteral)"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties                              && m_parser.Settings.IsModificationAllowed(JsTreeModifications.PropertyRenaming)                              && !string.IsNullOrEmpty(newName = m_parser.Settings.GetNewName(argText))"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "callNode != null                          && callNode.InBrackets                          && callNode.Function.IsWindowLookup                          && callNode.Arguments.IsSingleConstantArgument("eval")"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Optimize,The conditional expression  "unary != null && unary.OperatorToken == JsToken.LogicalNot                  && !unary.OperatorInConditionalCompilationComment                  && m_parser.Settings.IsModificationAllowed(JsTreeModifications.IfNotTrueFalseToIfFalseTrue)"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node.PrimitiveType == JsPrimitiveType.String                      && node.Parser.Settings.ErrorIfNotInlineSafe                      && node.Context != null                      && StringSourceIsNotInlineSafe(node.Context.Code)"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "m_parser.Settings.StripDebugStatements                       && m_parser.Settings.IsModificationAllowed(JsTreeModifications.StripDebugStatements)                       && node.Body != null                       && node.Body.IsDebuggerStatement"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "m_parser.Settings.StripDebugStatements                       && m_parser.Settings.IsModificationAllowed(JsTreeModifications.StripDebugStatements)                       && node.Body != null                       && node.Body.IsDebuggerStatement                       && node.Body.BlockScope == null"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "m_parser.Settings.StripDebugStatements                       && m_parser.Settings.IsModificationAllowed(JsTreeModifications.StripDebugStatements)                       && node.Body != null                       && node.Body.BlockScope == null                       && node.Body.IsDebuggerStatement"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node.Name.IsNullOrWhiteSpace()                      || (node.IsExpression                          && node.RefCount == 0                          && m_parser.Settings.RemoveFunctionExpressionNames                          && m_parser.Settings.IsModificationAllowed(JsTreeModifications.RemoveFunctionExpressionNames))"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node.FalseBlock == null                      && node.TrueBlock != null                      && node.TrueBlock.Count == 1                      && m_parser.Settings.IsModificationAllowed(JsTreeModifications.CombineNestedIfs)"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node.PrimitiveType == JsPrimitiveType.String                      && m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties                      && m_parser.Settings.IsModificationAllowed(JsTreeModifications.PropertyRenaming)"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "lookup != null                          && lookup.VariableField != null                          && lookup.VariableField.OuterField == null                          && (binaryOp = lookup.Parent as JsBinaryOperator) != null                          && binaryOp.IsAssign                          && !lookup.VariableField.IsReferencedInnerScope"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "!(lastStatement is JsBreak) && !(lastStatement is JsContinueNode)                                                && !(lastStatement is JsReturnNode) && !(lastStatement is JsThrowNode)"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "node.FinallyBlock != null && node.FinallyBlock.Count == 0 && node.CatchBlock != null                      && m_parser.Settings.IsModificationAllowed(JsTreeModifications.RemoveEmptyFinally)"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "lookup.VariableField == null                                  || lookup.VariableField.FieldType == JsFieldType.UndefinedGlobal                                  || lookup.VariableField.FieldType == JsFieldType.Arguments                                  || (lookup.VariableField.FieldType == JsFieldType.Predefined && string.CompareOrdinal(lookup.Name' "eval") == 0)"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "m_parser.Settings.StripDebugStatements                       && m_parser.Settings.IsModificationAllowed(JsTreeModifications.StripDebugStatements)                       && node.Body != null                       && node.Body.IsDebuggerStatement"  is complex.
Complex Conditional,Baker.Text,JsAnalyzeNodeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsAnalyzeNodeVisitor.cs,Visit,The conditional expression  "m_parser.Settings.StripDebugStatements                       && m_parser.Settings.IsModificationAllowed(JsTreeModifications.StripDebugStatements)                       && node.Body != null                       && node.Body.IsDebuggerStatement"  is complex.
Complex Conditional,Baker.Text,ReferenceComparer,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsCrunchEnumerator.cs,Compare,The conditional expression  "(left.FieldType == JsFieldType.Argument || left.FieldType == JsFieldType.CatchError)                  && (right.FieldType == JsFieldType.Argument || right.FieldType == JsFieldType.CatchError)"  is complex.
Complex Conditional,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,ReplaceMemberBracketWithDot,The conditional expression  "m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties                          && m_parser.Settings.IsModificationAllowed(JsTreeModifications.PropertyRenaming)                          && !string.IsNullOrEmpty(newName = m_parser.Settings.GetNewName(combinedString))"  is complex.
Complex Conditional,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,The conditional expression  "(leftOperator.OperatorToken == JsToken.Multiply && node.OperatorToken == JsToken.Divide)                  || (leftOperator.OperatorToken == JsToken.Divide && node.OperatorToken == JsToken.Multiply)"  is complex.
Complex Conditional,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,The conditional expression  "otherOverThis != null && NoMultiplicativeOverOrUnderFlow(otherConstant' thisConstant' otherOverThis)                          && (thisOverOther == null || otherOverThisLength < thisOverOtherLength)"  is complex.
Complex Conditional,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,The conditional expression  "node.OperatorToken == leftOperator.OperatorToken                  && (node.OperatorToken == JsToken.BitwiseAnd || node.OperatorToken == JsToken.BitwiseOr || node.OperatorToken == JsToken.BitwiseXor)"  is complex.
Complex Conditional,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalFarToTheLeft,The conditional expression  "otherOverThis != null && NoMultiplicativeOverOrUnderFlow(otherConstant' thisConstant' otherOverThis)                          && (thisOverOther == null || otherOverThisLength < thisOverOtherLength)"  is complex.
Complex Conditional,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheRight,The conditional expression  "leftOverRight != null && NoMultiplicativeOverOrUnderFlow(thisConstant' otherConstant' leftOverRight)                          && (rightOverLeft == null || leftOverRightLength < rightOverLeftLength)"  is complex.
Complex Conditional,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalFarToTheRight,The conditional expression  "otherOverThis != null && NoMultiplicativeOverOrUnderFlow(otherConstant' thisConstant' otherOverThis)                          && (thisOverOther == null || otherOverThisLength < thisOverOtherLength)"  is complex.
Complex Conditional,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoBinaryOperator,The conditional expression  "lookup != null && node.OperatorToken == JsToken.Minus && right.IsIntegerLiteral && right.ToNumber() == 0"  is complex.
Complex Conditional,Baker.Text,JsFinalPassVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsFinalPassVisitor.cs,Visit,The conditional expression  "node.OperatorToken == JsToken.Comma                      && m_parser.Settings.IsModificationAllowed(JsTreeModifications.UnfoldCommaExpressionStatements)                      && ((parentBlock = node.Parent as JsBlock) != null)                      && (parentBlock.Parent == null                          || parentBlock.Parent is JsFunctionObject                          || parentBlock.Parent is JsTryNode                          || parentBlock.Parent is JsSwitchCase                          || parentBlock.Count > 1)"  is complex.
Complex Conditional,Baker.Text,JsMatchPropertiesVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsMatchPropertiesVisitor.cs,Visit,The conditional expression  "node != null                  && m_index > 0                  && node.InBrackets                  && node.Arguments != null                  && node.Arguments.Count == 1"  is complex.
Complex Conditional,Baker.Text,JsMatchPropertiesVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsMatchPropertiesVisitor.cs,Visit,The conditional expression  "string.CompareOrdinal(node.Name' m_parts[0]) == 0                      && (node.VariableField == null || node.VariableField.FieldType == JsFieldType.UndefinedGlobal                       || node.VariableField.FieldType == JsFieldType.Global)"  is complex.
Complex Conditional,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The conditional expression  "newExpression != null && newExpression.IsConstructor                                  && (newExpression.Arguments == null || newExpression.Arguments.Count == 0)"  is complex.
Complex Conditional,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The conditional expression  "node.Context == null || !node.Context.HasCode                              || (!node.MayHaveIssues && m_settings.IsModificationAllowed(JsTreeModifications.MinifyNumericLiterals))"  is complex.
Complex Conditional,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The conditional expression  "node.TrueBlock.Count == 1                      && (node.FalseBlock == null || (!node.TrueBlock.EncloseBlock(EncloseBlockType.IfWithoutElse) && !node.TrueBlock.EncloseBlock(EncloseBlockType.SingleDoWhile)))                      && (!m_settings.MacSafariQuirks || !(node.TrueBlock[0] is JsFunctionObject))"  is complex.
Complex Conditional,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The conditional expression  "constantWrapper.Context == null                              || !constantWrapper.Context.HasCode                              || (m_settings.IsModificationAllowed(JsTreeModifications.MinifyNumericLiterals) && !constantWrapper.MayHaveIssues)"  is complex.
Complex Conditional,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The conditional expression  "callNode != null                                  && callNode.IsConstructor                                  && (callNode.Arguments == null || callNode.Arguments.Count == 0)"  is complex.
Complex Conditional,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseForStatement,The conditional expression  "isLHS && (JsToken.In == m_currentToken.Token                                  || (m_currentToken.Token == JsToken.Identifier && string.CompareOrdinal(m_currentToken.Code' "of") == 0))"  is complex.
Complex Conditional,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseFunction,The conditional expression  "m_currentToken.Token != JsToken.LeftParenthesis                          && m_currentToken.Token != JsToken.LeftCurly                          && m_currentToken.Token != JsToken.Semicolon                          && m_currentToken.Token != JsToken.EndOfFile"  is complex.
Complex Conditional,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseExpression,The conditional expression  "JsScanner.IsProcessableOperator(m_currentToken.Token)                          && inToken != m_currentToken.Token                          && (!single || m_currentToken.Token != JsToken.Comma)"  is complex.
Complex Conditional,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ScanNextToken,The conditional expression  "nextToken.Token == JsToken.WhiteSpace                  || nextToken.Token == JsToken.EndOfLine                  || nextToken.Token == JsToken.SingleLineComment                  || nextToken.Token == JsToken.MultipleLineComment                  || nextToken.Token == JsToken.Error                  || nextToken.Token == JsToken.PreprocessorDirective"  is complex.
Complex Conditional,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ScanNextToken,The conditional expression  "nextToken.HasCode                           && ((nextToken.Code.Length > 2 && nextToken.Code[2] == '!')                           || (nextToken.Code.IndexOf("@preserve"' StringComparison.OrdinalIgnoreCase) >= 0)                          || (nextToken.Code.IndexOf("@license"' StringComparison.OrdinalIgnoreCase) >= 0))"  is complex.
Complex Conditional,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,PeekToken,The conditional expression  "peekToken.Token == JsToken.WhiteSpace                  || peekToken.Token == JsToken.EndOfLine                  || peekToken.Token == JsToken.Error                  || peekToken.Token == JsToken.SingleLineComment                  || peekToken.Token == JsToken.MultipleLineComment                  || peekToken.Token == JsToken.PreprocessorDirective                  || peekToken.Token == JsToken.ConditionalCommentEnd                  || peekToken.Token == JsToken.ConditionalCommentStart                  || peekToken.Token == JsToken.ConditionalCompilationElse                  || peekToken.Token == JsToken.ConditionalCompilationElseIf                  || peekToken.Token == JsToken.ConditionalCompilationEnd                  || peekToken.Token == JsToken.ConditionalCompilationIf                  || peekToken.Token == JsToken.ConditionalCompilationOn                  || peekToken.Token == JsToken.ConditionalCompilationSet                  || peekToken.Token == JsToken.ConditionalCompilationVariable                  || peekToken.Token == JsToken.ConditionalIf"  is complex.
Complex Conditional,Baker.Text,JsResolutionVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsResolutionVisitor.cs,ResolveLookup,The conditional expression  "callNode != null && callNode.InBrackets                              && callNode.Arguments.Count == 1                              && callNode.Arguments[0] is JsConstantWrapper                              && callNode.Arguments[0].FindPrimitiveType() == JsPrimitiveType.String"  is complex.
Complex Conditional,Baker.Text,JsResolutionVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsResolutionVisitor.cs,ResolveGhostedFunctions,The conditional expression  "parentAssignment == null || parentAssignment.OperatorToken != JsToken.Assign                              || parentAssignment.Operand2 != funcObject                              || (lookup = parentAssignment.Operand1 as JsLookup) == null                              || lookup.Name != funcObject.Name"  is complex.
Complex Conditional,Baker.Text,JsResolutionVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsResolutionVisitor.cs,Visit,The conditional expression  "node.BlockScope == null                      && node.Parent != null                      && !(node.Parent is JsSwitchCase)                      && !(node.Parent is JsFunctionObject)                      && !(node.Parent is JsConditionalCompilationComment)"  is complex.
Complex Conditional,Baker.Text,JsResolutionVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsResolutionVisitor.cs,Visit,The conditional expression  "node.BlockScope != null                      && !(node.BlockScope is JsWithScope)                      && !(node.BlockScope is JsCatchScope)                      && node.BlockScope.LexicallyDeclaredNames.Count == 0"  is complex.
Complex Conditional,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanLineTerminator,The conditional expression  "(ch = GetChar(m_currentPosition)) == '\r' || ch == '\n' || ch == '\u2028' || ch == '\u2029'"  is complex.
Complex Conditional,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,SkipToEndOfLine,The conditional expression  "c != 0                  && c != '\n'                  && c != '\r'                  && c != '\x2028'                  && c != '\x2029'"  is complex.
Complex Conditional,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsValidIdentifierStart,The conditional expression  "('a' <= letter && letter <= 'z') || ('A' <= letter && letter <= 'Z') || letter == '_' || letter == '$'"  is complex.
Complex Conditional,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsSafeIdentifierStart,The conditional expression  "('a' <= letter && letter <= 'z') || ('A' <= letter && letter <= 'Z') || letter == '_' || letter == '$'"  is complex.
Complex Conditional,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsValidIdentifierPart,The conditional expression  "('a' <= letter && letter <= 'z')                  || ('A' <= letter && letter <= 'Z')                  || ('0' <= letter && letter <= '9')                  || letter == '_'                  || letter == '$'                  || letter == 0x200c                      || letter == 0x200d"  is complex.
Complex Conditional,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsSafeIdentifierPart,The conditional expression  "('a' <= letter && letter <= 'z')                  || ('A' <= letter && letter <= 'Z')                  || ('0' <= letter && letter <= '9')                  || letter == '_'                  || letter == '$'"  is complex.
Complex Conditional,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The conditional expression  "str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5])"  is complex.
Complex Conditional,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,Parse,The conditional expression  "thisArg.Length > 1                        && (thisArg.StartsWith("-"' StringComparison.Ordinal) // this is a normal hyphen (minus character)                        || thisArg.StartsWith(""' StringComparison.Ordinal) // this character is what Word will convert a hyphen to                        || (!m_isMono && thisArg.StartsWith("/"' StringComparison.Ordinal)))"  is complex.
Empty Catch Block,Baker,AssetInputFile,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Execution\AssetInputFile.cs,Refresh,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Multiply,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Divide,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Modulo,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,NumericAddition,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Minus,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LeftShift,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,RightShift,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,UnsignedRightShift,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LessThan,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LessThanOrEqual,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,GreaterThan,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,GreaterThanOrEqual,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Equal,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Equal,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,NotEqual,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,NotEqual,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictEqual,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictNotEqual,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,BitwiseAnd,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,BitwiseOr,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,BitwiseXor,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LogicalAnd,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,LogicalOr,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoConditional,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoConditionalCompilationElseIf,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoConditionalCompilationIf,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoDoWhile,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoForNode,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoIfNode,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoWhileNode,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseStatements,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsScriptSharpSourceMap,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScriptSharpSourceMap.cs,MakeRelative,The method has an empty catch block.
Empty Catch Block,Baker.Text,JsV3SourceMap,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsV3SourceMap.cs,MakeRelative,The method has an empty catch block.
Magic Number,Baker,AssetHeader,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Execution\AssetHeader.cs,FromString,The following statement contains a magic number: endOffset = content.IndexOf("---"' 3) + 3 ;
Magic Number,Baker,AssetHeader,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Execution\AssetHeader.cs,FromString,The following statement contains a magic number: endOffset = content.IndexOf("---"' 3) + 3 ;
Magic Number,Baker,AssetHeader,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Execution\AssetHeader.cs,FromString,The following statement contains a magic number: return new AssetHeader(                  content.Substring(3' endOffset - 6).Trim()                  );
Magic Number,Baker,AssetHeader,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Execution\AssetHeader.cs,FromString,The following statement contains a magic number: return new AssetHeader(                  content.Substring(3' endOffset - 6).Trim()                  );
Magic Number,Baker,SiteWatcher,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Site\SiteWatcher.cs,Bind,The following statement contains a magic number: this.Timer.Change(0' 100);
Magic Number,Baker,SiteWatcher,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Site\SiteWatcher.cs,OnTick,The following statement contains a magic number: if (now < this.ChangeCurrent + TimeSpan.FromMilliseconds(350))                  return;
Magic Number,Baker.Processors,PngOptimizer,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Processors\PngOptimizer.cs,Process,The following statement contains a magic number: try              {                  // Minify css                  var quantizer = new WuQuantizer();                  using (var bitmap = new Bitmap(Bitmap.FromStream(input.Content.AsStream())))                  {                      using (var quantized = quantizer.QuantizeImage(bitmap' 10' 70))                      using( var output = new MemoryStream())                      {                          // Save to the output stream                          quantized.Save(output' ImageFormat.Png);                            // Minified successfully                          Tracing.Info("PNG"' "Optimized " + input.RelativeName);                            // Return processed output                          return AssetOutputFile.Create(input' output);                      }                  }              }              catch(Exception ex)              {                  // We didn't manage to create anything                  Tracing.Error("PNG"' ex);                  return null;              }
Magic Number,Baker.Processors,PngOptimizer,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Processors\PngOptimizer.cs,Process,The following statement contains a magic number: try              {                  // Minify css                  var quantizer = new WuQuantizer();                  using (var bitmap = new Bitmap(Bitmap.FromStream(input.Content.AsStream())))                  {                      using (var quantized = quantizer.QuantizeImage(bitmap' 10' 70))                      using( var output = new MemoryStream())                      {                          // Save to the output stream                          quantized.Save(output' ImageFormat.Png);                            // Minified successfully                          Tracing.Info("PNG"' "Optimized " + input.RelativeName);                            // Return processed output                          return AssetOutputFile.Create(input' output);                      }                  }              }              catch(Exception ex)              {                  // We didn't manage to create anything                  Tracing.Error("PNG"' ex);                  return null;              }
Magic Number,Baker.Text,YamlDynamic,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Yaml\YamlDynamic.cs,IsGenericEnumDictionary,The following statement contains a magic number: if (genericTypeArgs.Length != 2)              {                  return false;              }
Magic Number,Baker.Text,CssEncoderFallbackBuffer,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\CssEncoderFallback.cs,GetEncoding,The following statement contains a magic number: if (hexValue.Length > 6)              {                  // should we throw an exception?                  // or return an empty string?                  return s_giveUpString;              }
Magic Number,Baker.Text,CssEncoderFallbackBuffer,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\CssEncoderFallback.cs,GetEncoding,The following statement contains a magic number: return "\\{0}{1}".FormatInvariant(hexValue' (hexValue.Length < 6 ? " " : string.Empty));
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: if (source.StartsWith("\u00ef\u00bb\u00bf"' StringComparison.Ordinal))              {                  // if the first three characters are EF BB BF' then the source file had a UTF-8 BOM in it' but                   // the BOM didn't get stripped. We MIGHT have some issues: the file indicated it's UTF-8 encoded'                  // but if we didn't properly decode the BOM' then other non-ASCII character sequences might also be                  // improperly decoded. Because that's an IF' we will only throw a pri-1 "programmer may not have intended this"                  // error. However' first check to see if there's a @charset "ascii"; statement at the front. If so'                  // then don't throw any error at all because everything should be ascii' in which case we're most-likely                  // good to go. The quote may be single or double' and the ASCII part should be case-insensentive.                  var charsetAscii = "@charset ";                  if (string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0)                  {                      // we either don't have a @charset statement' or it's pointing to something other than ASCII' in which                      // case we might have a problem here. But because that's a "MIGHT'" let's make it a pri-1 instead of                      // a pri-0. If there are any problems' the output will be wonky and the developer can up the warning-level                      // and see this error' then use the proper encoding to read the source.                       ReportError(1' CssErrorCode.PossibleCharsetError);                  }                    // remove the BOM                  source = source.Substring(3);              }              else if (source.StartsWith("\u00fe\u00ff\u0000\u0000"' StringComparison.Ordinal)                  || source.StartsWith("\u0000\u0000\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-32 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(4);              }              else if (source.StartsWith("\u00fe\u00ff"' StringComparison.Ordinal)                  || source.StartsWith("\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-16 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(2);              }              else if (source.Length > 0 && source[0] == '\ufeff')              {                  // properly-decoded UNICODE BOM was at the front. Everything should be okay' but strip it                  // so it doesn't interfere with the rest of the processing.                  source = source.Substring(1);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: if (source.StartsWith("\u00ef\u00bb\u00bf"' StringComparison.Ordinal))              {                  // if the first three characters are EF BB BF' then the source file had a UTF-8 BOM in it' but                   // the BOM didn't get stripped. We MIGHT have some issues: the file indicated it's UTF-8 encoded'                  // but if we didn't properly decode the BOM' then other non-ASCII character sequences might also be                  // improperly decoded. Because that's an IF' we will only throw a pri-1 "programmer may not have intended this"                  // error. However' first check to see if there's a @charset "ascii"; statement at the front. If so'                  // then don't throw any error at all because everything should be ascii' in which case we're most-likely                  // good to go. The quote may be single or double' and the ASCII part should be case-insensentive.                  var charsetAscii = "@charset ";                  if (string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0)                  {                      // we either don't have a @charset statement' or it's pointing to something other than ASCII' in which                      // case we might have a problem here. But because that's a "MIGHT'" let's make it a pri-1 instead of                      // a pri-0. If there are any problems' the output will be wonky and the developer can up the warning-level                      // and see this error' then use the proper encoding to read the source.                       ReportError(1' CssErrorCode.PossibleCharsetError);                  }                    // remove the BOM                  source = source.Substring(3);              }              else if (source.StartsWith("\u00fe\u00ff\u0000\u0000"' StringComparison.Ordinal)                  || source.StartsWith("\u0000\u0000\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-32 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(4);              }              else if (source.StartsWith("\u00fe\u00ff"' StringComparison.Ordinal)                  || source.StartsWith("\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-16 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(2);              }              else if (source.Length > 0 && source[0] == '\ufeff')              {                  // properly-decoded UNICODE BOM was at the front. Everything should be okay' but strip it                  // so it doesn't interfere with the rest of the processing.                  source = source.Substring(1);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: if (source.StartsWith("\u00ef\u00bb\u00bf"' StringComparison.Ordinal))              {                  // if the first three characters are EF BB BF' then the source file had a UTF-8 BOM in it' but                   // the BOM didn't get stripped. We MIGHT have some issues: the file indicated it's UTF-8 encoded'                  // but if we didn't properly decode the BOM' then other non-ASCII character sequences might also be                  // improperly decoded. Because that's an IF' we will only throw a pri-1 "programmer may not have intended this"                  // error. However' first check to see if there's a @charset "ascii"; statement at the front. If so'                  // then don't throw any error at all because everything should be ascii' in which case we're most-likely                  // good to go. The quote may be single or double' and the ASCII part should be case-insensentive.                  var charsetAscii = "@charset ";                  if (string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0)                  {                      // we either don't have a @charset statement' or it's pointing to something other than ASCII' in which                      // case we might have a problem here. But because that's a "MIGHT'" let's make it a pri-1 instead of                      // a pri-0. If there are any problems' the output will be wonky and the developer can up the warning-level                      // and see this error' then use the proper encoding to read the source.                       ReportError(1' CssErrorCode.PossibleCharsetError);                  }                    // remove the BOM                  source = source.Substring(3);              }              else if (source.StartsWith("\u00fe\u00ff\u0000\u0000"' StringComparison.Ordinal)                  || source.StartsWith("\u0000\u0000\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-32 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(4);              }              else if (source.StartsWith("\u00fe\u00ff"' StringComparison.Ordinal)                  || source.StartsWith("\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-16 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(2);              }              else if (source.Length > 0 && source[0] == '\ufeff')              {                  // properly-decoded UNICODE BOM was at the front. Everything should be okay' but strip it                  // so it doesn't interfere with the rest of the processing.                  source = source.Substring(1);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: if (source.StartsWith("\u00ef\u00bb\u00bf"' StringComparison.Ordinal))              {                  // if the first three characters are EF BB BF' then the source file had a UTF-8 BOM in it' but                   // the BOM didn't get stripped. We MIGHT have some issues: the file indicated it's UTF-8 encoded'                  // but if we didn't properly decode the BOM' then other non-ASCII character sequences might also be                  // improperly decoded. Because that's an IF' we will only throw a pri-1 "programmer may not have intended this"                  // error. However' first check to see if there's a @charset "ascii"; statement at the front. If so'                  // then don't throw any error at all because everything should be ascii' in which case we're most-likely                  // good to go. The quote may be single or double' and the ASCII part should be case-insensentive.                  var charsetAscii = "@charset ";                  if (string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0)                  {                      // we either don't have a @charset statement' or it's pointing to something other than ASCII' in which                      // case we might have a problem here. But because that's a "MIGHT'" let's make it a pri-1 instead of                      // a pri-0. If there are any problems' the output will be wonky and the developer can up the warning-level                      // and see this error' then use the proper encoding to read the source.                       ReportError(1' CssErrorCode.PossibleCharsetError);                  }                    // remove the BOM                  source = source.Substring(3);              }              else if (source.StartsWith("\u00fe\u00ff\u0000\u0000"' StringComparison.Ordinal)                  || source.StartsWith("\u0000\u0000\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-32 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(4);              }              else if (source.StartsWith("\u00fe\u00ff"' StringComparison.Ordinal)                  || source.StartsWith("\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-16 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(2);              }              else if (source.Length > 0 && source[0] == '\ufeff')              {                  // properly-decoded UNICODE BOM was at the front. Everything should be okay' but strip it                  // so it doesn't interfere with the rest of the processing.                  source = source.Substring(1);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: if (source.StartsWith("\u00ef\u00bb\u00bf"' StringComparison.Ordinal))              {                  // if the first three characters are EF BB BF' then the source file had a UTF-8 BOM in it' but                   // the BOM didn't get stripped. We MIGHT have some issues: the file indicated it's UTF-8 encoded'                  // but if we didn't properly decode the BOM' then other non-ASCII character sequences might also be                  // improperly decoded. Because that's an IF' we will only throw a pri-1 "programmer may not have intended this"                  // error. However' first check to see if there's a @charset "ascii"; statement at the front. If so'                  // then don't throw any error at all because everything should be ascii' in which case we're most-likely                  // good to go. The quote may be single or double' and the ASCII part should be case-insensentive.                  var charsetAscii = "@charset ";                  if (string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0)                  {                      // we either don't have a @charset statement' or it's pointing to something other than ASCII' in which                      // case we might have a problem here. But because that's a "MIGHT'" let's make it a pri-1 instead of                      // a pri-0. If there are any problems' the output will be wonky and the developer can up the warning-level                      // and see this error' then use the proper encoding to read the source.                       ReportError(1' CssErrorCode.PossibleCharsetError);                  }                    // remove the BOM                  source = source.Substring(3);              }              else if (source.StartsWith("\u00fe\u00ff\u0000\u0000"' StringComparison.Ordinal)                  || source.StartsWith("\u0000\u0000\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-32 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(4);              }              else if (source.StartsWith("\u00fe\u00ff"' StringComparison.Ordinal)                  || source.StartsWith("\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-16 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(2);              }              else if (source.Length > 0 && source[0] == '\ufeff')              {                  // properly-decoded UNICODE BOM was at the front. Everything should be okay' but strip it                  // so it doesn't interfere with the rest of the processing.                  source = source.Substring(1);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: if (source.StartsWith("\u00ef\u00bb\u00bf"' StringComparison.Ordinal))              {                  // if the first three characters are EF BB BF' then the source file had a UTF-8 BOM in it' but                   // the BOM didn't get stripped. We MIGHT have some issues: the file indicated it's UTF-8 encoded'                  // but if we didn't properly decode the BOM' then other non-ASCII character sequences might also be                  // improperly decoded. Because that's an IF' we will only throw a pri-1 "programmer may not have intended this"                  // error. However' first check to see if there's a @charset "ascii"; statement at the front. If so'                  // then don't throw any error at all because everything should be ascii' in which case we're most-likely                  // good to go. The quote may be single or double' and the ASCII part should be case-insensentive.                  var charsetAscii = "@charset ";                  if (string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0)                  {                      // we either don't have a @charset statement' or it's pointing to something other than ASCII' in which                      // case we might have a problem here. But because that's a "MIGHT'" let's make it a pri-1 instead of                      // a pri-0. If there are any problems' the output will be wonky and the developer can up the warning-level                      // and see this error' then use the proper encoding to read the source.                       ReportError(1' CssErrorCode.PossibleCharsetError);                  }                    // remove the BOM                  source = source.Substring(3);              }              else if (source.StartsWith("\u00fe\u00ff\u0000\u0000"' StringComparison.Ordinal)                  || source.StartsWith("\u0000\u0000\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-32 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(4);              }              else if (source.StartsWith("\u00fe\u00ff"' StringComparison.Ordinal)                  || source.StartsWith("\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-16 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(2);              }              else if (source.Length > 0 && source[0] == '\ufeff')              {                  // properly-decoded UNICODE BOM was at the front. Everything should be okay' but strip it                  // so it doesn't interfere with the rest of the processing.                  source = source.Substring(1);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: if (source.StartsWith("\u00ef\u00bb\u00bf"' StringComparison.Ordinal))              {                  // if the first three characters are EF BB BF' then the source file had a UTF-8 BOM in it' but                   // the BOM didn't get stripped. We MIGHT have some issues: the file indicated it's UTF-8 encoded'                  // but if we didn't properly decode the BOM' then other non-ASCII character sequences might also be                  // improperly decoded. Because that's an IF' we will only throw a pri-1 "programmer may not have intended this"                  // error. However' first check to see if there's a @charset "ascii"; statement at the front. If so'                  // then don't throw any error at all because everything should be ascii' in which case we're most-likely                  // good to go. The quote may be single or double' and the ASCII part should be case-insensentive.                  var charsetAscii = "@charset ";                  if (string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0)                  {                      // we either don't have a @charset statement' or it's pointing to something other than ASCII' in which                      // case we might have a problem here. But because that's a "MIGHT'" let's make it a pri-1 instead of                      // a pri-0. If there are any problems' the output will be wonky and the developer can up the warning-level                      // and see this error' then use the proper encoding to read the source.                       ReportError(1' CssErrorCode.PossibleCharsetError);                  }                    // remove the BOM                  source = source.Substring(3);              }              else if (source.StartsWith("\u00fe\u00ff\u0000\u0000"' StringComparison.Ordinal)                  || source.StartsWith("\u0000\u0000\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-32 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(4);              }              else if (source.StartsWith("\u00fe\u00ff"' StringComparison.Ordinal)                  || source.StartsWith("\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-16 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(2);              }              else if (source.Length > 0 && source[0] == '\ufeff')              {                  // properly-decoded UNICODE BOM was at the front. Everything should be okay' but strip it                  // so it doesn't interfere with the rest of the processing.                  source = source.Substring(1);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,HandleCharset,The following statement contains a magic number: if (source.StartsWith("\u00ef\u00bb\u00bf"' StringComparison.Ordinal))              {                  // if the first three characters are EF BB BF' then the source file had a UTF-8 BOM in it' but                   // the BOM didn't get stripped. We MIGHT have some issues: the file indicated it's UTF-8 encoded'                  // but if we didn't properly decode the BOM' then other non-ASCII character sequences might also be                  // improperly decoded. Because that's an IF' we will only throw a pri-1 "programmer may not have intended this"                  // error. However' first check to see if there's a @charset "ascii"; statement at the front. If so'                  // then don't throw any error at all because everything should be ascii' in which case we're most-likely                  // good to go. The quote may be single or double' and the ASCII part should be case-insensentive.                  var charsetAscii = "@charset ";                  if (string.CompareOrdinal(source' 3' charsetAscii' 0' charsetAscii.Length) != 0                      || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')                      || string.Compare(source' 4 + charsetAscii.Length' "ascii"' 0' 5' StringComparison.OrdinalIgnoreCase) != 0)                  {                      // we either don't have a @charset statement' or it's pointing to something other than ASCII' in which                      // case we might have a problem here. But because that's a "MIGHT'" let's make it a pri-1 instead of                      // a pri-0. If there are any problems' the output will be wonky and the developer can up the warning-level                      // and see this error' then use the proper encoding to read the source.                       ReportError(1' CssErrorCode.PossibleCharsetError);                  }                    // remove the BOM                  source = source.Substring(3);              }              else if (source.StartsWith("\u00fe\u00ff\u0000\u0000"' StringComparison.Ordinal)                  || source.StartsWith("\u0000\u0000\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-32 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(4);              }              else if (source.StartsWith("\u00fe\u00ff"' StringComparison.Ordinal)                  || source.StartsWith("\u00ff\u00fe"' StringComparison.Ordinal))              {                  // apparently we had a UTF-16 BOM (either BE or LE) that wasn't stripped. Remove it now.                  // throw a syntax-level error because the rest of the file is probably whack.                  ReportError(0' CssErrorCode.PossibleCharsetError);                  source = source.Substring(2);              }              else if (source.Length > 0 && source[0] == '\ufeff')              {                  // properly-decoded UNICODE BOM was at the front. Everything should be okay' but strip it                  // so it doesn't interfere with the rest of the processing.                  source = source.Substring(1);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseAtKeyword,The following statement contains a magic number: if (CurrentTokenType == TokenType.AtKeyword)              {                  // only report an unexpected at-keyword IF the identifier doesn't start                   // with a hyphen' because that would be a vendor-specific at-keyword'                  // which is theoretically okay.                  if (!CurrentTokenText.StartsWith("@-"' StringComparison.OrdinalIgnoreCase))                  {                      ReportError(2' CssErrorCode.UnexpectedAtKeyword' CurrentTokenText);                  }                    SkipToEndOfStatement();                  AppendCurrent();                  SkipSpace();                  NewLine();                  parsed = Parsed.True;              }              else if (CurrentTokenType == TokenType.CharacterSetSymbol)              {                  // we found a charset at-rule. Problem is' @charset can only be the VERY FIRST token                  // in the file' and we process it special. So if we get here' then it's NOT the first                  // token' and clients will ignore it. Throw a warning' but still process it.                  ReportError(2' CssErrorCode.UnexpectedCharset' CurrentTokenText);                  parsed = ParseCharset();              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseAtKeyword,The following statement contains a magic number: if (CurrentTokenType == TokenType.AtKeyword)              {                  // only report an unexpected at-keyword IF the identifier doesn't start                   // with a hyphen' because that would be a vendor-specific at-keyword'                  // which is theoretically okay.                  if (!CurrentTokenText.StartsWith("@-"' StringComparison.OrdinalIgnoreCase))                  {                      ReportError(2' CssErrorCode.UnexpectedAtKeyword' CurrentTokenText);                  }                    SkipToEndOfStatement();                  AppendCurrent();                  SkipSpace();                  NewLine();                  parsed = Parsed.True;              }              else if (CurrentTokenType == TokenType.CharacterSetSymbol)              {                  // we found a charset at-rule. Problem is' @charset can only be the VERY FIRST token                  // in the file' and we process it special. So if we get here' then it's NOT the first                  // token' and clients will ignore it. Throw a warning' but still process it.                  ReportError(2' CssErrorCode.UnexpectedCharset' CurrentTokenText);                  parsed = ParseCharset();              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRule,The following statement contains a magic number: if (parsed == Parsed.True)              {                  if (m_scanner.EndOfFile)                  {                      // we parsed a selector expecting this to be a rule' but then WHAM! we hit                      // the end of the file. That isn't correct. Throw an error.                      ReportError(0' CssErrorCode.UnexpectedEndOfFile);                  }                    while (!m_scanner.EndOfFile)                  {                      if (CurrentTokenType != TokenType.Character                          || (CurrentTokenText != "'" && CurrentTokenText != "{"))                      {                          ReportError(0' CssErrorCode.ExpectedCommaOrOpenBrace' CurrentTokenText);                          SkipToEndOfStatement();                          AppendCurrent();                          SkipSpace();                          break;                      }                      if (CurrentTokenText == "{")                      {                          // REVIEW: IE6 has an issue where the "first-letter" and "first-line"                           // pseudo-classes need to be separated from the opening curly-brace                           // of the following rule set by a space or it doesn't get picked up.                           // So if the last-outputted word was "first-letter" or "first-line"'                          // add a space now (since we know the next character at this point                           // is the opening brace of a rule-set).                          // Maybe some day this should be removed or put behind an "IE6-compat" switch.                          if (m_lastOutputString == "first-letter" || m_lastOutputString == "first-line")                          {                              Append(' ');                          }                            // don't allow margin at-keywords                          parsed = ParseDeclarationBlock(false);                          break;                      }                        Append(''');                        // check the line length before each new declaration -- if we're past the threshold' start a new line                      if (m_lineLength >= Settings.LineBreakThreshold)                      {                          AddNewLine();                      }                      else if (Settings.OutputMode == MinifierOutputMode.MultipleLines)                      {                          Append(' ');                      }                        SkipSpace();                        if (ParseSelector() != Parsed.True)                      {                          if (CurrentTokenType == TokenType.Character && CurrentTokenText == "{")                          {                              // the author ended the last selector with a comma' but didn't include                              // the next selector before starting the declaration block. Or maybe it's there'                              // but commented out. Still okay' but flag a style warning.                              ReportError(4' CssErrorCode.ExpectedSelector' CurrentTokenText);                              continue;                          }                          else                          {                              // not something we know about -- skip the whole statement                              ReportError(0' CssErrorCode.ExpectedSelector' CurrentTokenText);                              SkipToEndOfStatement();                          }                          AppendCurrent();                          SkipSpace();                          break;                      }                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseSelector,The following statement contains a magic number: if (parsed == Parsed.False && CurrentTokenType != TokenType.None)              {                  // no selector? See if it starts with a combinator.                  // common IE-7 hack to start with a combinator' because that browser will assume a beginning *                  var currentContext = m_currentToken.Context;                  var possibleCombinator = CurrentTokenText;                  parsed = ParseCombinator();                  if (parsed == Parsed.True)                  {                      ReportError(4' CssErrorCode.HackGeneratesInvalidCss' currentContext' possibleCombinator);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseClass,The following statement contains a magic number: if (CurrentTokenType == TokenType.Character                && CurrentTokenText == ".")              {                  AppendCurrent();                  NextToken();                    if (CurrentTokenType == TokenType.Identifier)                  {                      AppendCurrent();                      NextToken();                      parsed = Parsed.True;                  }                  else                  {                      ReportError(0' CssErrorCode.ExpectedIdentifier' CurrentTokenText);                  }              }              else if (CurrentTokenType == TokenType.Dimension || CurrentTokenType == TokenType.Number)              {                  string rawNumber = m_scanner.RawNumber;                  if (rawNumber != null && rawNumber.StartsWith("."' StringComparison.Ordinal))                  {                      // if we are expecting a class but we got dimension or number that starts with a period'                      // then what we REALLY have is a class name that starts with a digit. If it's all digits'                      // it will be a number' and it it's just an identifier that starts with a digit' it will                      // be a dimension.                      // The problem here is that both of those those token type format the number' eg:                       // .000foo would get shrunk to 0foo.                      // Be sure to use the RawNumber property on the scanner to get the raw text exactly as                      // it was from the input                      parsed = Parsed.True;                        // but check the next token to see if it's an identifier.                      // if the next token is an identifier with no whitespace between it and the previous                      // "number'" then it's part of this identifier                      NextToken();                      if (CurrentTokenType == TokenType.Identifier)                      {                          // add that identifier to the raw number                          rawNumber += CurrentTokenText;                          NextToken();                      }                        // report a low-sev warning before outputting the raw number text and advancing                      ReportError(2' CssErrorCode.PossibleInvalidClassName' rawNumber);                      Append(rawNumber);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseDeclaration,The following statement contains a magic number: if (CurrentTokenType == TokenType.Character                   && (CurrentTokenText == "*" || CurrentTokenText == "."))              {                  // spot a low-pri error because this is actually invalid CSS                  // taking advantage of an IE "feature"                  ReportError(4' CssErrorCode.HackGeneratesInvalidCss' CurrentTokenText);                    // save the prefix and skip it                  prefix = CurrentTokenText;                  NextToken();              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParsePrio,The following statement contains a magic number: if (CurrentTokenType == TokenType.ImportantSymbol)              {                  if (Settings.OutputMode == MinifierOutputMode.MultipleLines)                  {                      Append(' ');                  }                  AppendCurrent();                  SkipSpace();                    // a common IE7-and-below hack is to append another ! at the end of !important.                  if (CurrentTokenType == TokenType.Character && CurrentTokenText == "!")                  {                      ReportError(4' CssErrorCode.HackGeneratesInvalidCss' CurrentTokenText);                      AppendCurrent();                      SkipSpace();                  }                    parsed = Parsed.True;              }              else if (CurrentTokenType == TokenType.Character && CurrentTokenText == "!")              {                  // another common IE7-and-below hack is to use an identifier OTHER than "important". All other browsers will see this                  // as an error' but IE7 and below will keep on processing. A common thing is to put !ie at the end to mark                  // the declaration as only for IE.                  if (Settings.OutputMode == MinifierOutputMode.MultipleLines)                  {                      Append(' ');                  }                    AppendCurrent();                  NextToken();                  if (CurrentTokenType == TokenType.Identifier)                  {                      ReportError(4' CssErrorCode.HackGeneratesInvalidCss' CurrentTokenText);                        AppendCurrent();                      SkipSpace();                      parsed = Parsed.True;                  }                  else                  {                      // but we need SOME identifier here....                      ReportError(0' CssErrorCode.ExpectedIdentifier' CurrentTokenText);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParsePrio,The following statement contains a magic number: if (CurrentTokenType == TokenType.ImportantSymbol)              {                  if (Settings.OutputMode == MinifierOutputMode.MultipleLines)                  {                      Append(' ');                  }                  AppendCurrent();                  SkipSpace();                    // a common IE7-and-below hack is to append another ! at the end of !important.                  if (CurrentTokenType == TokenType.Character && CurrentTokenText == "!")                  {                      ReportError(4' CssErrorCode.HackGeneratesInvalidCss' CurrentTokenText);                      AppendCurrent();                      SkipSpace();                  }                    parsed = Parsed.True;              }              else if (CurrentTokenType == TokenType.Character && CurrentTokenText == "!")              {                  // another common IE7-and-below hack is to use an identifier OTHER than "important". All other browsers will see this                  // as an error' but IE7 and below will keep on processing. A common thing is to put !ie at the end to mark                  // the declaration as only for IE.                  if (Settings.OutputMode == MinifierOutputMode.MultipleLines)                  {                      Append(' ');                  }                    AppendCurrent();                  NextToken();                  if (CurrentTokenType == TokenType.Identifier)                  {                      ReportError(4' CssErrorCode.HackGeneratesInvalidCss' CurrentTokenText);                        AppendCurrent();                      SkipSpace();                      parsed = Parsed.True;                  }                  else                  {                      // but we need SOME identifier here....                      ReportError(0' CssErrorCode.ExpectedIdentifier' CurrentTokenText);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseTerm,The following statement contains a magic number: switch (CurrentTokenType)              {                  case TokenType.Hash:                      if (hasUnary)                      {                          ReportError(0' CssErrorCode.HashAfterUnaryNotAllowed' CurrentTokenText);                      }                        if (wasEmpty)                      {                          Append(' ');                          wasEmpty = false;                      }                      if (ParseHexcolor() == Parsed.False)                      {                          ReportError(0' CssErrorCode.ExpectedHexColor' CurrentTokenText);                            // we expected the hash token to be a proper color -- but it's not.                          // we threw an error -- go ahead and output the token as-is and keep going.                          AppendCurrent();                          NextToken();                      }                      parsed = Parsed.True;                      break;                    case TokenType.String:                  case TokenType.Identifier:                  case TokenType.Uri:                  //case TokenType.RGB:                  case TokenType.UnicodeRange:                      if (hasUnary)                      {                          ReportError(0' CssErrorCode.TokenAfterUnaryNotAllowed' CurrentTokenText);                      }                        // wasEmpty will be false if we DIDN'T find an operator                      // as the last token. If we had an operator' then we can ignore                      // any whitespace; but if we DIDN'T find an operator' then we                      // will need to preserve a whitespace character to keep them                       // separated.                      if (wasEmpty)                      {                          // if we had skipped any space' then add one now                          if (m_skippedSpace)                          {                              Append(' ');                          }                                                    wasEmpty = false;                      }                        AppendCurrent();                      SkipSpace();                      parsed = Parsed.True;                      break;                    case TokenType.Dimension:                      ReportError(2' CssErrorCode.UnexpectedDimension' CurrentTokenText);                      goto case TokenType.Number;                    case TokenType.Number:                  case TokenType.Percentage:                  case TokenType.AbsoluteLength:                  case TokenType.RelativeLength:                  case TokenType.Angle:                  case TokenType.Time:                  case TokenType.Frequency:                  case TokenType.Resolution:                      if (wasEmpty)                      {                          Append(' ');                          wasEmpty = false;                      }                        AppendCurrent();                      SkipSpace();                      parsed = Parsed.True;                      break;                    case TokenType.ProgId:                      if (wasEmpty)                      {                          Append(' ');                          wasEmpty = false;                      }                      if (ParseProgId() == Parsed.False)                      {                          ReportError(0' CssErrorCode.ExpectedProgId' CurrentTokenText);                      }                      parsed = Parsed.True;                      break;                    case TokenType.Function:                      if (wasEmpty)                      {                          Append(' ');                          wasEmpty = false;                      }                      if (ParseFunction() == Parsed.False)                      {                          ReportError(0' CssErrorCode.ExpectedFunction' CurrentTokenText);                      }                      parsed = Parsed.True;                      break;                    case TokenType.Character:                      if (CurrentTokenText == "(")                      {                          // the term starts with an opening paren.                          // parse an expression followed by the close paren.                          if (wasEmpty)                          {                              if (m_skippedSpace)                              {                                  Append(' ');                              }                                wasEmpty = false;                          }                            AppendCurrent();                          SkipSpace();                            if (ParseExpr() == Parsed.False)                          {                              ReportError(0' CssErrorCode.ExpectedExpression' CurrentTokenText);                          }                            if (CurrentTokenType == TokenType.Character                              && CurrentTokenText == ")")                          {                              AppendCurrent();                              parsed = Parsed.True;                                // the closing paren can only be followed IMMEDIATELY by the opening brace                              // without any space if it's a repeat syntax.                              m_skippedSpace = false;                              NextRawToken();                              if (CurrentTokenType == TokenType.Space)                              {                                  m_skippedSpace = true;                              }                                // if the next token is an opening brace' then this might be                              // a repeat operator                              if (CurrentTokenType == TokenType.Character                                  && CurrentTokenText == "[")                              {                                  AppendCurrent();                                  SkipSpace();                                    if (CurrentTokenType == TokenType.Number)                                  {                                      AppendCurrent();                                      SkipSpace();                                        if (CurrentTokenType == TokenType.Character                                          && CurrentTokenText == "]")                                      {                                          AppendCurrent();                                          SkipSpace();                                      }                                      else                                      {                                          ReportError(0' CssErrorCode.ExpectedClosingBracket' CurrentTokenText);                                          parsed = Parsed.False;                                      }                                  }                                  else                                  {                                      ReportError(0' CssErrorCode.ExpectedNumber' CurrentTokenText);                                      parsed = Parsed.False;                                  }                              }                          }                          else                          {                              ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                          }                      }                      else                      {                          goto default;                      }                      break;                    default:                      if (hasUnary)                      {                          ReportError(0' CssErrorCode.UnexpectedToken' CurrentTokenText);                      }                      break;              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseProgId,The following statement contains a magic number: if (CurrentTokenType == TokenType.ProgId)              {                  ReportError(4' CssErrorCode.ProgIdIEOnly);                    // set the state flag that tells us we should NOT abbreviate color                  // hash values as we are parsing our parameters                  m_noColorAbbreviation = true;                    // append the progid and opening paren                  AppendCurrent();                  SkipSpace();                    // the rest is a series of parameters: name=value' separated                  // by commas and ending with a close paren                  while (CurrentTokenType == TokenType.Identifier)                  {                      AppendCurrent();                      SkipSpace();                        if (CurrentTokenType != TokenType.Character                        && CurrentTokenText != "=")                      {                          ReportError(0' CssErrorCode.ExpectedEqualSign' CurrentTokenText);                      }                        Append('=');                      SkipSpace();                        if (ParseTerm(false) != Parsed.True)                      {                          ReportError(0' CssErrorCode.ExpectedTerm' CurrentTokenText);                      }                        if (CurrentTokenType == TokenType.Character                        && CurrentTokenText == "'")                      {                          Append(''');                          SkipSpace();                      }                  }                    // reset the color-abbreviation flag                  m_noColorAbbreviation = false;                    // make sure we're at the close paren                  if (CurrentTokenType == TokenType.Character                    && CurrentTokenText == ")")                  {                      Append(')');                      SkipSpace();                  }                  else                  {                      ReportError(0' CssErrorCode.UnexpectedToken' CurrentTokenText);                  }                  parsed = Parsed.True;              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRgb,The following statement contains a magic number: if (CurrentTokenType == TokenType.Function                  && string.Compare(CurrentTokenText' "rgb("' StringComparison.OrdinalIgnoreCase) == 0)              {                  // rgb function parsing                  var useRGB = false;                  var crunchedRGB = false;                  // converting to #rrggbb or #rgb IF we don't find any significant comments!                  // skip any space or comments                  var rgb = new int[3];                    // we're going to be building up the rgb function just in case we need it                  var sbRGB = new StringBuilder();                  sbRGB.Append(CurrentTokenText.ToLowerInvariant());                    var comments = NextSignificantToken();                  if (comments.Length > 0)                  {                      // add the comments                      sbRGB.Append(comments);                      // and signal that we need to use the RGB function because of them                      useRGB = true;                  }                    for (var ndx = 0; ndx < 3; ++ndx)                  {                      // if this isn't the first number' we better find a comma separator                      if (ndx > 0)                      {                          if (CurrentTokenType == TokenType.Character && CurrentTokenText == "'")                          {                              // add it to the rgb string builder                              sbRGB.Append(''');                          }                          else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                                // closing paren is the end of the function! exit the loop                              useRGB = true;                              break;                          }                          else                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                              sbRGB.Append(CurrentTokenText);                              useRGB = true;                          }                            // skip to the next significant                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // although we ALLOW negative numbers here' we'll trim them                      // later. But in the mean time' save a negation flag.                      var negateNumber = false;                      if (CurrentTokenType == TokenType.Character && CurrentTokenText == "-")                      {                          negateNumber = true;                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // we might adjust the value' so save the token text                      var tokenText = CurrentTokenText;                        if (CurrentTokenType != TokenType.Number && CurrentTokenType != TokenType.Percentage)                      {                          ReportError(0' CssErrorCode.ExpectedRgbNumberOrPercentage' CurrentTokenText);                          useRGB = true;                      }                      else                      {                          if (CurrentTokenType == TokenType.Number)                          {                              // get the number value                              float numberValue;                              if (tokenText.TryParseSingleInvariant(out numberValue))                              {                                  numberValue *= (negateNumber ? -1 : 1);                                  // make sure it's between 0 and 255                                  if (numberValue < 0)                                  {                                      tokenText = "0";                                      rgb[ndx] = 0;                                  }                                  else if (numberValue > 255)                                  {                                      tokenText = "255";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(numberValue);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                          else                          {                              // percentage                              float percentageValue;                              if (tokenText.Substring(0' tokenText.Length - 1).TryParseSingleInvariant(out percentageValue))                              {                                  percentageValue *= (negateNumber ? -1 : 1);                                  if (percentageValue < 0)                                  {                                      tokenText = "0%";                                      rgb[ndx] = 0;                                  }                                  else if (percentageValue > 100)                                  {                                      tokenText = "100%";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(percentageValue * 255 / 100);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                      }                        // add the number to the rgb string builder                      sbRGB.Append(tokenText);                        // skip to the next significant                      comments = NextSignificantToken();                      if (comments.Length > 0)                      {                          // add the comments                          sbRGB.Append(comments);                          // and signal that we need to use the RGB function because of them                          useRGB = true;                      }                  }                    if (useRGB)                  {                      // something prevented us from collapsing the rgb function                      // just output the rgb function we've been building up                      Append(sbRGB.ToString());                  }                  else                  {                      // we can collapse it to either #rrggbb or #rgb                      // calculate the full hex string and crunch it                      var fullCode = "#{0:x2}{1:x2}{2:x2}".FormatInvariant(rgb[0]' rgb[1]' rgb[2]);                      var hexString = CrunchHexColor(fullCode' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexString);                        // set the flag so we know we don't want to add the closing paren                      crunchedRGB = true;                  }                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                  {                      if (!crunchedRGB)                      {                          AppendCurrent();                      }                        SkipSpace();                      parsed = Parsed.True;                  }                  else                  {                      ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRgb,The following statement contains a magic number: if (CurrentTokenType == TokenType.Function                  && string.Compare(CurrentTokenText' "rgb("' StringComparison.OrdinalIgnoreCase) == 0)              {                  // rgb function parsing                  var useRGB = false;                  var crunchedRGB = false;                  // converting to #rrggbb or #rgb IF we don't find any significant comments!                  // skip any space or comments                  var rgb = new int[3];                    // we're going to be building up the rgb function just in case we need it                  var sbRGB = new StringBuilder();                  sbRGB.Append(CurrentTokenText.ToLowerInvariant());                    var comments = NextSignificantToken();                  if (comments.Length > 0)                  {                      // add the comments                      sbRGB.Append(comments);                      // and signal that we need to use the RGB function because of them                      useRGB = true;                  }                    for (var ndx = 0; ndx < 3; ++ndx)                  {                      // if this isn't the first number' we better find a comma separator                      if (ndx > 0)                      {                          if (CurrentTokenType == TokenType.Character && CurrentTokenText == "'")                          {                              // add it to the rgb string builder                              sbRGB.Append(''');                          }                          else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                                // closing paren is the end of the function! exit the loop                              useRGB = true;                              break;                          }                          else                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                              sbRGB.Append(CurrentTokenText);                              useRGB = true;                          }                            // skip to the next significant                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // although we ALLOW negative numbers here' we'll trim them                      // later. But in the mean time' save a negation flag.                      var negateNumber = false;                      if (CurrentTokenType == TokenType.Character && CurrentTokenText == "-")                      {                          negateNumber = true;                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // we might adjust the value' so save the token text                      var tokenText = CurrentTokenText;                        if (CurrentTokenType != TokenType.Number && CurrentTokenType != TokenType.Percentage)                      {                          ReportError(0' CssErrorCode.ExpectedRgbNumberOrPercentage' CurrentTokenText);                          useRGB = true;                      }                      else                      {                          if (CurrentTokenType == TokenType.Number)                          {                              // get the number value                              float numberValue;                              if (tokenText.TryParseSingleInvariant(out numberValue))                              {                                  numberValue *= (negateNumber ? -1 : 1);                                  // make sure it's between 0 and 255                                  if (numberValue < 0)                                  {                                      tokenText = "0";                                      rgb[ndx] = 0;                                  }                                  else if (numberValue > 255)                                  {                                      tokenText = "255";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(numberValue);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                          else                          {                              // percentage                              float percentageValue;                              if (tokenText.Substring(0' tokenText.Length - 1).TryParseSingleInvariant(out percentageValue))                              {                                  percentageValue *= (negateNumber ? -1 : 1);                                  if (percentageValue < 0)                                  {                                      tokenText = "0%";                                      rgb[ndx] = 0;                                  }                                  else if (percentageValue > 100)                                  {                                      tokenText = "100%";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(percentageValue * 255 / 100);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                      }                        // add the number to the rgb string builder                      sbRGB.Append(tokenText);                        // skip to the next significant                      comments = NextSignificantToken();                      if (comments.Length > 0)                      {                          // add the comments                          sbRGB.Append(comments);                          // and signal that we need to use the RGB function because of them                          useRGB = true;                      }                  }                    if (useRGB)                  {                      // something prevented us from collapsing the rgb function                      // just output the rgb function we've been building up                      Append(sbRGB.ToString());                  }                  else                  {                      // we can collapse it to either #rrggbb or #rgb                      // calculate the full hex string and crunch it                      var fullCode = "#{0:x2}{1:x2}{2:x2}".FormatInvariant(rgb[0]' rgb[1]' rgb[2]);                      var hexString = CrunchHexColor(fullCode' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexString);                        // set the flag so we know we don't want to add the closing paren                      crunchedRGB = true;                  }                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                  {                      if (!crunchedRGB)                      {                          AppendCurrent();                      }                        SkipSpace();                      parsed = Parsed.True;                  }                  else                  {                      ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRgb,The following statement contains a magic number: if (CurrentTokenType == TokenType.Function                  && string.Compare(CurrentTokenText' "rgb("' StringComparison.OrdinalIgnoreCase) == 0)              {                  // rgb function parsing                  var useRGB = false;                  var crunchedRGB = false;                  // converting to #rrggbb or #rgb IF we don't find any significant comments!                  // skip any space or comments                  var rgb = new int[3];                    // we're going to be building up the rgb function just in case we need it                  var sbRGB = new StringBuilder();                  sbRGB.Append(CurrentTokenText.ToLowerInvariant());                    var comments = NextSignificantToken();                  if (comments.Length > 0)                  {                      // add the comments                      sbRGB.Append(comments);                      // and signal that we need to use the RGB function because of them                      useRGB = true;                  }                    for (var ndx = 0; ndx < 3; ++ndx)                  {                      // if this isn't the first number' we better find a comma separator                      if (ndx > 0)                      {                          if (CurrentTokenType == TokenType.Character && CurrentTokenText == "'")                          {                              // add it to the rgb string builder                              sbRGB.Append(''');                          }                          else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                                // closing paren is the end of the function! exit the loop                              useRGB = true;                              break;                          }                          else                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                              sbRGB.Append(CurrentTokenText);                              useRGB = true;                          }                            // skip to the next significant                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // although we ALLOW negative numbers here' we'll trim them                      // later. But in the mean time' save a negation flag.                      var negateNumber = false;                      if (CurrentTokenType == TokenType.Character && CurrentTokenText == "-")                      {                          negateNumber = true;                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // we might adjust the value' so save the token text                      var tokenText = CurrentTokenText;                        if (CurrentTokenType != TokenType.Number && CurrentTokenType != TokenType.Percentage)                      {                          ReportError(0' CssErrorCode.ExpectedRgbNumberOrPercentage' CurrentTokenText);                          useRGB = true;                      }                      else                      {                          if (CurrentTokenType == TokenType.Number)                          {                              // get the number value                              float numberValue;                              if (tokenText.TryParseSingleInvariant(out numberValue))                              {                                  numberValue *= (negateNumber ? -1 : 1);                                  // make sure it's between 0 and 255                                  if (numberValue < 0)                                  {                                      tokenText = "0";                                      rgb[ndx] = 0;                                  }                                  else if (numberValue > 255)                                  {                                      tokenText = "255";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(numberValue);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                          else                          {                              // percentage                              float percentageValue;                              if (tokenText.Substring(0' tokenText.Length - 1).TryParseSingleInvariant(out percentageValue))                              {                                  percentageValue *= (negateNumber ? -1 : 1);                                  if (percentageValue < 0)                                  {                                      tokenText = "0%";                                      rgb[ndx] = 0;                                  }                                  else if (percentageValue > 100)                                  {                                      tokenText = "100%";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(percentageValue * 255 / 100);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                      }                        // add the number to the rgb string builder                      sbRGB.Append(tokenText);                        // skip to the next significant                      comments = NextSignificantToken();                      if (comments.Length > 0)                      {                          // add the comments                          sbRGB.Append(comments);                          // and signal that we need to use the RGB function because of them                          useRGB = true;                      }                  }                    if (useRGB)                  {                      // something prevented us from collapsing the rgb function                      // just output the rgb function we've been building up                      Append(sbRGB.ToString());                  }                  else                  {                      // we can collapse it to either #rrggbb or #rgb                      // calculate the full hex string and crunch it                      var fullCode = "#{0:x2}{1:x2}{2:x2}".FormatInvariant(rgb[0]' rgb[1]' rgb[2]);                      var hexString = CrunchHexColor(fullCode' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexString);                        // set the flag so we know we don't want to add the closing paren                      crunchedRGB = true;                  }                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                  {                      if (!crunchedRGB)                      {                          AppendCurrent();                      }                        SkipSpace();                      parsed = Parsed.True;                  }                  else                  {                      ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRgb,The following statement contains a magic number: if (CurrentTokenType == TokenType.Function                  && string.Compare(CurrentTokenText' "rgb("' StringComparison.OrdinalIgnoreCase) == 0)              {                  // rgb function parsing                  var useRGB = false;                  var crunchedRGB = false;                  // converting to #rrggbb or #rgb IF we don't find any significant comments!                  // skip any space or comments                  var rgb = new int[3];                    // we're going to be building up the rgb function just in case we need it                  var sbRGB = new StringBuilder();                  sbRGB.Append(CurrentTokenText.ToLowerInvariant());                    var comments = NextSignificantToken();                  if (comments.Length > 0)                  {                      // add the comments                      sbRGB.Append(comments);                      // and signal that we need to use the RGB function because of them                      useRGB = true;                  }                    for (var ndx = 0; ndx < 3; ++ndx)                  {                      // if this isn't the first number' we better find a comma separator                      if (ndx > 0)                      {                          if (CurrentTokenType == TokenType.Character && CurrentTokenText == "'")                          {                              // add it to the rgb string builder                              sbRGB.Append(''');                          }                          else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                                // closing paren is the end of the function! exit the loop                              useRGB = true;                              break;                          }                          else                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                              sbRGB.Append(CurrentTokenText);                              useRGB = true;                          }                            // skip to the next significant                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // although we ALLOW negative numbers here' we'll trim them                      // later. But in the mean time' save a negation flag.                      var negateNumber = false;                      if (CurrentTokenType == TokenType.Character && CurrentTokenText == "-")                      {                          negateNumber = true;                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // we might adjust the value' so save the token text                      var tokenText = CurrentTokenText;                        if (CurrentTokenType != TokenType.Number && CurrentTokenType != TokenType.Percentage)                      {                          ReportError(0' CssErrorCode.ExpectedRgbNumberOrPercentage' CurrentTokenText);                          useRGB = true;                      }                      else                      {                          if (CurrentTokenType == TokenType.Number)                          {                              // get the number value                              float numberValue;                              if (tokenText.TryParseSingleInvariant(out numberValue))                              {                                  numberValue *= (negateNumber ? -1 : 1);                                  // make sure it's between 0 and 255                                  if (numberValue < 0)                                  {                                      tokenText = "0";                                      rgb[ndx] = 0;                                  }                                  else if (numberValue > 255)                                  {                                      tokenText = "255";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(numberValue);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                          else                          {                              // percentage                              float percentageValue;                              if (tokenText.Substring(0' tokenText.Length - 1).TryParseSingleInvariant(out percentageValue))                              {                                  percentageValue *= (negateNumber ? -1 : 1);                                  if (percentageValue < 0)                                  {                                      tokenText = "0%";                                      rgb[ndx] = 0;                                  }                                  else if (percentageValue > 100)                                  {                                      tokenText = "100%";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(percentageValue * 255 / 100);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                      }                        // add the number to the rgb string builder                      sbRGB.Append(tokenText);                        // skip to the next significant                      comments = NextSignificantToken();                      if (comments.Length > 0)                      {                          // add the comments                          sbRGB.Append(comments);                          // and signal that we need to use the RGB function because of them                          useRGB = true;                      }                  }                    if (useRGB)                  {                      // something prevented us from collapsing the rgb function                      // just output the rgb function we've been building up                      Append(sbRGB.ToString());                  }                  else                  {                      // we can collapse it to either #rrggbb or #rgb                      // calculate the full hex string and crunch it                      var fullCode = "#{0:x2}{1:x2}{2:x2}".FormatInvariant(rgb[0]' rgb[1]' rgb[2]);                      var hexString = CrunchHexColor(fullCode' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexString);                        // set the flag so we know we don't want to add the closing paren                      crunchedRGB = true;                  }                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                  {                      if (!crunchedRGB)                      {                          AppendCurrent();                      }                        SkipSpace();                      parsed = Parsed.True;                  }                  else                  {                      ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRgb,The following statement contains a magic number: if (CurrentTokenType == TokenType.Function                  && string.Compare(CurrentTokenText' "rgb("' StringComparison.OrdinalIgnoreCase) == 0)              {                  // rgb function parsing                  var useRGB = false;                  var crunchedRGB = false;                  // converting to #rrggbb or #rgb IF we don't find any significant comments!                  // skip any space or comments                  var rgb = new int[3];                    // we're going to be building up the rgb function just in case we need it                  var sbRGB = new StringBuilder();                  sbRGB.Append(CurrentTokenText.ToLowerInvariant());                    var comments = NextSignificantToken();                  if (comments.Length > 0)                  {                      // add the comments                      sbRGB.Append(comments);                      // and signal that we need to use the RGB function because of them                      useRGB = true;                  }                    for (var ndx = 0; ndx < 3; ++ndx)                  {                      // if this isn't the first number' we better find a comma separator                      if (ndx > 0)                      {                          if (CurrentTokenType == TokenType.Character && CurrentTokenText == "'")                          {                              // add it to the rgb string builder                              sbRGB.Append(''');                          }                          else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                                // closing paren is the end of the function! exit the loop                              useRGB = true;                              break;                          }                          else                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                              sbRGB.Append(CurrentTokenText);                              useRGB = true;                          }                            // skip to the next significant                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // although we ALLOW negative numbers here' we'll trim them                      // later. But in the mean time' save a negation flag.                      var negateNumber = false;                      if (CurrentTokenType == TokenType.Character && CurrentTokenText == "-")                      {                          negateNumber = true;                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // we might adjust the value' so save the token text                      var tokenText = CurrentTokenText;                        if (CurrentTokenType != TokenType.Number && CurrentTokenType != TokenType.Percentage)                      {                          ReportError(0' CssErrorCode.ExpectedRgbNumberOrPercentage' CurrentTokenText);                          useRGB = true;                      }                      else                      {                          if (CurrentTokenType == TokenType.Number)                          {                              // get the number value                              float numberValue;                              if (tokenText.TryParseSingleInvariant(out numberValue))                              {                                  numberValue *= (negateNumber ? -1 : 1);                                  // make sure it's between 0 and 255                                  if (numberValue < 0)                                  {                                      tokenText = "0";                                      rgb[ndx] = 0;                                  }                                  else if (numberValue > 255)                                  {                                      tokenText = "255";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(numberValue);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                          else                          {                              // percentage                              float percentageValue;                              if (tokenText.Substring(0' tokenText.Length - 1).TryParseSingleInvariant(out percentageValue))                              {                                  percentageValue *= (negateNumber ? -1 : 1);                                  if (percentageValue < 0)                                  {                                      tokenText = "0%";                                      rgb[ndx] = 0;                                  }                                  else if (percentageValue > 100)                                  {                                      tokenText = "100%";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(percentageValue * 255 / 100);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                      }                        // add the number to the rgb string builder                      sbRGB.Append(tokenText);                        // skip to the next significant                      comments = NextSignificantToken();                      if (comments.Length > 0)                      {                          // add the comments                          sbRGB.Append(comments);                          // and signal that we need to use the RGB function because of them                          useRGB = true;                      }                  }                    if (useRGB)                  {                      // something prevented us from collapsing the rgb function                      // just output the rgb function we've been building up                      Append(sbRGB.ToString());                  }                  else                  {                      // we can collapse it to either #rrggbb or #rgb                      // calculate the full hex string and crunch it                      var fullCode = "#{0:x2}{1:x2}{2:x2}".FormatInvariant(rgb[0]' rgb[1]' rgb[2]);                      var hexString = CrunchHexColor(fullCode' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexString);                        // set the flag so we know we don't want to add the closing paren                      crunchedRGB = true;                  }                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                  {                      if (!crunchedRGB)                      {                          AppendCurrent();                      }                        SkipSpace();                      parsed = Parsed.True;                  }                  else                  {                      ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRgb,The following statement contains a magic number: if (CurrentTokenType == TokenType.Function                  && string.Compare(CurrentTokenText' "rgb("' StringComparison.OrdinalIgnoreCase) == 0)              {                  // rgb function parsing                  var useRGB = false;                  var crunchedRGB = false;                  // converting to #rrggbb or #rgb IF we don't find any significant comments!                  // skip any space or comments                  var rgb = new int[3];                    // we're going to be building up the rgb function just in case we need it                  var sbRGB = new StringBuilder();                  sbRGB.Append(CurrentTokenText.ToLowerInvariant());                    var comments = NextSignificantToken();                  if (comments.Length > 0)                  {                      // add the comments                      sbRGB.Append(comments);                      // and signal that we need to use the RGB function because of them                      useRGB = true;                  }                    for (var ndx = 0; ndx < 3; ++ndx)                  {                      // if this isn't the first number' we better find a comma separator                      if (ndx > 0)                      {                          if (CurrentTokenType == TokenType.Character && CurrentTokenText == "'")                          {                              // add it to the rgb string builder                              sbRGB.Append(''');                          }                          else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                                // closing paren is the end of the function! exit the loop                              useRGB = true;                              break;                          }                          else                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                              sbRGB.Append(CurrentTokenText);                              useRGB = true;                          }                            // skip to the next significant                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // although we ALLOW negative numbers here' we'll trim them                      // later. But in the mean time' save a negation flag.                      var negateNumber = false;                      if (CurrentTokenType == TokenType.Character && CurrentTokenText == "-")                      {                          negateNumber = true;                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // we might adjust the value' so save the token text                      var tokenText = CurrentTokenText;                        if (CurrentTokenType != TokenType.Number && CurrentTokenType != TokenType.Percentage)                      {                          ReportError(0' CssErrorCode.ExpectedRgbNumberOrPercentage' CurrentTokenText);                          useRGB = true;                      }                      else                      {                          if (CurrentTokenType == TokenType.Number)                          {                              // get the number value                              float numberValue;                              if (tokenText.TryParseSingleInvariant(out numberValue))                              {                                  numberValue *= (negateNumber ? -1 : 1);                                  // make sure it's between 0 and 255                                  if (numberValue < 0)                                  {                                      tokenText = "0";                                      rgb[ndx] = 0;                                  }                                  else if (numberValue > 255)                                  {                                      tokenText = "255";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(numberValue);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                          else                          {                              // percentage                              float percentageValue;                              if (tokenText.Substring(0' tokenText.Length - 1).TryParseSingleInvariant(out percentageValue))                              {                                  percentageValue *= (negateNumber ? -1 : 1);                                  if (percentageValue < 0)                                  {                                      tokenText = "0%";                                      rgb[ndx] = 0;                                  }                                  else if (percentageValue > 100)                                  {                                      tokenText = "100%";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(percentageValue * 255 / 100);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                      }                        // add the number to the rgb string builder                      sbRGB.Append(tokenText);                        // skip to the next significant                      comments = NextSignificantToken();                      if (comments.Length > 0)                      {                          // add the comments                          sbRGB.Append(comments);                          // and signal that we need to use the RGB function because of them                          useRGB = true;                      }                  }                    if (useRGB)                  {                      // something prevented us from collapsing the rgb function                      // just output the rgb function we've been building up                      Append(sbRGB.ToString());                  }                  else                  {                      // we can collapse it to either #rrggbb or #rgb                      // calculate the full hex string and crunch it                      var fullCode = "#{0:x2}{1:x2}{2:x2}".FormatInvariant(rgb[0]' rgb[1]' rgb[2]);                      var hexString = CrunchHexColor(fullCode' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexString);                        // set the flag so we know we don't want to add the closing paren                      crunchedRGB = true;                  }                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                  {                      if (!crunchedRGB)                      {                          AppendCurrent();                      }                        SkipSpace();                      parsed = Parsed.True;                  }                  else                  {                      ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRgb,The following statement contains a magic number: if (CurrentTokenType == TokenType.Function                  && string.Compare(CurrentTokenText' "rgb("' StringComparison.OrdinalIgnoreCase) == 0)              {                  // rgb function parsing                  var useRGB = false;                  var crunchedRGB = false;                  // converting to #rrggbb or #rgb IF we don't find any significant comments!                  // skip any space or comments                  var rgb = new int[3];                    // we're going to be building up the rgb function just in case we need it                  var sbRGB = new StringBuilder();                  sbRGB.Append(CurrentTokenText.ToLowerInvariant());                    var comments = NextSignificantToken();                  if (comments.Length > 0)                  {                      // add the comments                      sbRGB.Append(comments);                      // and signal that we need to use the RGB function because of them                      useRGB = true;                  }                    for (var ndx = 0; ndx < 3; ++ndx)                  {                      // if this isn't the first number' we better find a comma separator                      if (ndx > 0)                      {                          if (CurrentTokenType == TokenType.Character && CurrentTokenText == "'")                          {                              // add it to the rgb string builder                              sbRGB.Append(''');                          }                          else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                                // closing paren is the end of the function! exit the loop                              useRGB = true;                              break;                          }                          else                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                              sbRGB.Append(CurrentTokenText);                              useRGB = true;                          }                            // skip to the next significant                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // although we ALLOW negative numbers here' we'll trim them                      // later. But in the mean time' save a negation flag.                      var negateNumber = false;                      if (CurrentTokenType == TokenType.Character && CurrentTokenText == "-")                      {                          negateNumber = true;                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // we might adjust the value' so save the token text                      var tokenText = CurrentTokenText;                        if (CurrentTokenType != TokenType.Number && CurrentTokenType != TokenType.Percentage)                      {                          ReportError(0' CssErrorCode.ExpectedRgbNumberOrPercentage' CurrentTokenText);                          useRGB = true;                      }                      else                      {                          if (CurrentTokenType == TokenType.Number)                          {                              // get the number value                              float numberValue;                              if (tokenText.TryParseSingleInvariant(out numberValue))                              {                                  numberValue *= (negateNumber ? -1 : 1);                                  // make sure it's between 0 and 255                                  if (numberValue < 0)                                  {                                      tokenText = "0";                                      rgb[ndx] = 0;                                  }                                  else if (numberValue > 255)                                  {                                      tokenText = "255";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(numberValue);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                          else                          {                              // percentage                              float percentageValue;                              if (tokenText.Substring(0' tokenText.Length - 1).TryParseSingleInvariant(out percentageValue))                              {                                  percentageValue *= (negateNumber ? -1 : 1);                                  if (percentageValue < 0)                                  {                                      tokenText = "0%";                                      rgb[ndx] = 0;                                  }                                  else if (percentageValue > 100)                                  {                                      tokenText = "100%";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(percentageValue * 255 / 100);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                      }                        // add the number to the rgb string builder                      sbRGB.Append(tokenText);                        // skip to the next significant                      comments = NextSignificantToken();                      if (comments.Length > 0)                      {                          // add the comments                          sbRGB.Append(comments);                          // and signal that we need to use the RGB function because of them                          useRGB = true;                      }                  }                    if (useRGB)                  {                      // something prevented us from collapsing the rgb function                      // just output the rgb function we've been building up                      Append(sbRGB.ToString());                  }                  else                  {                      // we can collapse it to either #rrggbb or #rgb                      // calculate the full hex string and crunch it                      var fullCode = "#{0:x2}{1:x2}{2:x2}".FormatInvariant(rgb[0]' rgb[1]' rgb[2]);                      var hexString = CrunchHexColor(fullCode' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexString);                        // set the flag so we know we don't want to add the closing paren                      crunchedRGB = true;                  }                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                  {                      if (!crunchedRGB)                      {                          AppendCurrent();                      }                        SkipSpace();                      parsed = Parsed.True;                  }                  else                  {                      ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRgb,The following statement contains a magic number: if (CurrentTokenType == TokenType.Function                  && string.Compare(CurrentTokenText' "rgb("' StringComparison.OrdinalIgnoreCase) == 0)              {                  // rgb function parsing                  var useRGB = false;                  var crunchedRGB = false;                  // converting to #rrggbb or #rgb IF we don't find any significant comments!                  // skip any space or comments                  var rgb = new int[3];                    // we're going to be building up the rgb function just in case we need it                  var sbRGB = new StringBuilder();                  sbRGB.Append(CurrentTokenText.ToLowerInvariant());                    var comments = NextSignificantToken();                  if (comments.Length > 0)                  {                      // add the comments                      sbRGB.Append(comments);                      // and signal that we need to use the RGB function because of them                      useRGB = true;                  }                    for (var ndx = 0; ndx < 3; ++ndx)                  {                      // if this isn't the first number' we better find a comma separator                      if (ndx > 0)                      {                          if (CurrentTokenType == TokenType.Character && CurrentTokenText == "'")                          {                              // add it to the rgb string builder                              sbRGB.Append(''');                          }                          else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                                // closing paren is the end of the function! exit the loop                              useRGB = true;                              break;                          }                          else                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                              sbRGB.Append(CurrentTokenText);                              useRGB = true;                          }                            // skip to the next significant                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // although we ALLOW negative numbers here' we'll trim them                      // later. But in the mean time' save a negation flag.                      var negateNumber = false;                      if (CurrentTokenType == TokenType.Character && CurrentTokenText == "-")                      {                          negateNumber = true;                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // we might adjust the value' so save the token text                      var tokenText = CurrentTokenText;                        if (CurrentTokenType != TokenType.Number && CurrentTokenType != TokenType.Percentage)                      {                          ReportError(0' CssErrorCode.ExpectedRgbNumberOrPercentage' CurrentTokenText);                          useRGB = true;                      }                      else                      {                          if (CurrentTokenType == TokenType.Number)                          {                              // get the number value                              float numberValue;                              if (tokenText.TryParseSingleInvariant(out numberValue))                              {                                  numberValue *= (negateNumber ? -1 : 1);                                  // make sure it's between 0 and 255                                  if (numberValue < 0)                                  {                                      tokenText = "0";                                      rgb[ndx] = 0;                                  }                                  else if (numberValue > 255)                                  {                                      tokenText = "255";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(numberValue);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                          else                          {                              // percentage                              float percentageValue;                              if (tokenText.Substring(0' tokenText.Length - 1).TryParseSingleInvariant(out percentageValue))                              {                                  percentageValue *= (negateNumber ? -1 : 1);                                  if (percentageValue < 0)                                  {                                      tokenText = "0%";                                      rgb[ndx] = 0;                                  }                                  else if (percentageValue > 100)                                  {                                      tokenText = "100%";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(percentageValue * 255 / 100);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                      }                        // add the number to the rgb string builder                      sbRGB.Append(tokenText);                        // skip to the next significant                      comments = NextSignificantToken();                      if (comments.Length > 0)                      {                          // add the comments                          sbRGB.Append(comments);                          // and signal that we need to use the RGB function because of them                          useRGB = true;                      }                  }                    if (useRGB)                  {                      // something prevented us from collapsing the rgb function                      // just output the rgb function we've been building up                      Append(sbRGB.ToString());                  }                  else                  {                      // we can collapse it to either #rrggbb or #rgb                      // calculate the full hex string and crunch it                      var fullCode = "#{0:x2}{1:x2}{2:x2}".FormatInvariant(rgb[0]' rgb[1]' rgb[2]);                      var hexString = CrunchHexColor(fullCode' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexString);                        // set the flag so we know we don't want to add the closing paren                      crunchedRGB = true;                  }                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                  {                      if (!crunchedRGB)                      {                          AppendCurrent();                      }                        SkipSpace();                      parsed = Parsed.True;                  }                  else                  {                      ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseRgb,The following statement contains a magic number: if (CurrentTokenType == TokenType.Function                  && string.Compare(CurrentTokenText' "rgb("' StringComparison.OrdinalIgnoreCase) == 0)              {                  // rgb function parsing                  var useRGB = false;                  var crunchedRGB = false;                  // converting to #rrggbb or #rgb IF we don't find any significant comments!                  // skip any space or comments                  var rgb = new int[3];                    // we're going to be building up the rgb function just in case we need it                  var sbRGB = new StringBuilder();                  sbRGB.Append(CurrentTokenText.ToLowerInvariant());                    var comments = NextSignificantToken();                  if (comments.Length > 0)                  {                      // add the comments                      sbRGB.Append(comments);                      // and signal that we need to use the RGB function because of them                      useRGB = true;                  }                    for (var ndx = 0; ndx < 3; ++ndx)                  {                      // if this isn't the first number' we better find a comma separator                      if (ndx > 0)                      {                          if (CurrentTokenType == TokenType.Character && CurrentTokenText == "'")                          {                              // add it to the rgb string builder                              sbRGB.Append(''');                          }                          else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                                // closing paren is the end of the function! exit the loop                              useRGB = true;                              break;                          }                          else                          {                              ReportError(0' CssErrorCode.ExpectedComma' CurrentTokenText);                              sbRGB.Append(CurrentTokenText);                              useRGB = true;                          }                            // skip to the next significant                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // although we ALLOW negative numbers here' we'll trim them                      // later. But in the mean time' save a negation flag.                      var negateNumber = false;                      if (CurrentTokenType == TokenType.Character && CurrentTokenText == "-")                      {                          negateNumber = true;                          comments = NextSignificantToken();                          if (comments.Length > 0)                          {                              // add the comments                              sbRGB.Append(comments);                              // and signal that we need to use the RGB function because of them                              useRGB = true;                          }                      }                        // we might adjust the value' so save the token text                      var tokenText = CurrentTokenText;                        if (CurrentTokenType != TokenType.Number && CurrentTokenType != TokenType.Percentage)                      {                          ReportError(0' CssErrorCode.ExpectedRgbNumberOrPercentage' CurrentTokenText);                          useRGB = true;                      }                      else                      {                          if (CurrentTokenType == TokenType.Number)                          {                              // get the number value                              float numberValue;                              if (tokenText.TryParseSingleInvariant(out numberValue))                              {                                  numberValue *= (negateNumber ? -1 : 1);                                  // make sure it's between 0 and 255                                  if (numberValue < 0)                                  {                                      tokenText = "0";                                      rgb[ndx] = 0;                                  }                                  else if (numberValue > 255)                                  {                                      tokenText = "255";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(numberValue);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                          else                          {                              // percentage                              float percentageValue;                              if (tokenText.Substring(0' tokenText.Length - 1).TryParseSingleInvariant(out percentageValue))                              {                                  percentageValue *= (negateNumber ? -1 : 1);                                  if (percentageValue < 0)                                  {                                      tokenText = "0%";                                      rgb[ndx] = 0;                                  }                                  else if (percentageValue > 100)                                  {                                      tokenText = "100%";                                      rgb[ndx] = 255;                                  }                                  else                                  {                                      rgb[ndx] = System.Convert.ToInt32(percentageValue * 255 / 100);                                  }                              }                              else                              {                                  // error -- not even a number. Keep the rgb function                                  // (and don't change the token)                                  useRGB = true;                              }                          }                      }                        // add the number to the rgb string builder                      sbRGB.Append(tokenText);                        // skip to the next significant                      comments = NextSignificantToken();                      if (comments.Length > 0)                      {                          // add the comments                          sbRGB.Append(comments);                          // and signal that we need to use the RGB function because of them                          useRGB = true;                      }                  }                    if (useRGB)                  {                      // something prevented us from collapsing the rgb function                      // just output the rgb function we've been building up                      Append(sbRGB.ToString());                  }                  else                  {                      // we can collapse it to either #rrggbb or #rgb                      // calculate the full hex string and crunch it                      var fullCode = "#{0:x2}{1:x2}{2:x2}".FormatInvariant(rgb[0]' rgb[1]' rgb[2]);                      var hexString = CrunchHexColor(fullCode' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexString);                        // set the flag so we know we don't want to add the closing paren                      crunchedRGB = true;                  }                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")                  {                      if (!crunchedRGB)                      {                          AppendCurrent();                      }                        SkipSpace();                      parsed = Parsed.True;                  }                  else                  {                      ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseHexcolor,The following statement contains a magic number: if (CurrentTokenType == TokenType.Hash)              {                  var colorHash = CurrentTokenText;                  var appendEscapedTab = false;                    // valid hash colors are #rgb' #rrggbb' and #aarrggbb.                  // but there is a commonly-used IE hack that puts \9 at the end of properties' so                  // if we have 5' 8' or 10 characters' let's first check to see if the color                  // ends in a tab.                  if ((colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)                      && colorHash.EndsWith("\t"' StringComparison.Ordinal))                  {                      // it is -- strip that last character and set a flag                      colorHash = colorHash.Substring(0' colorHash.Length - 1);                      appendEscapedTab = true;                  }                    if (colorHash.Length == 4 || colorHash.Length == 7 || colorHash.Length == 9)                  {                      parsed = Parsed.True;                        // we won't do any conversion on the #aarrggbb formats to make them smaller.                      string hexColor = CrunchHexColor(colorHash' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexColor);                        if (appendEscapedTab)                      {                          Append("\\9");                      }                        SkipSpace();                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseHexcolor,The following statement contains a magic number: if (CurrentTokenType == TokenType.Hash)              {                  var colorHash = CurrentTokenText;                  var appendEscapedTab = false;                    // valid hash colors are #rgb' #rrggbb' and #aarrggbb.                  // but there is a commonly-used IE hack that puts \9 at the end of properties' so                  // if we have 5' 8' or 10 characters' let's first check to see if the color                  // ends in a tab.                  if ((colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)                      && colorHash.EndsWith("\t"' StringComparison.Ordinal))                  {                      // it is -- strip that last character and set a flag                      colorHash = colorHash.Substring(0' colorHash.Length - 1);                      appendEscapedTab = true;                  }                    if (colorHash.Length == 4 || colorHash.Length == 7 || colorHash.Length == 9)                  {                      parsed = Parsed.True;                        // we won't do any conversion on the #aarrggbb formats to make them smaller.                      string hexColor = CrunchHexColor(colorHash' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexColor);                        if (appendEscapedTab)                      {                          Append("\\9");                      }                        SkipSpace();                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseHexcolor,The following statement contains a magic number: if (CurrentTokenType == TokenType.Hash)              {                  var colorHash = CurrentTokenText;                  var appendEscapedTab = false;                    // valid hash colors are #rgb' #rrggbb' and #aarrggbb.                  // but there is a commonly-used IE hack that puts \9 at the end of properties' so                  // if we have 5' 8' or 10 characters' let's first check to see if the color                  // ends in a tab.                  if ((colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)                      && colorHash.EndsWith("\t"' StringComparison.Ordinal))                  {                      // it is -- strip that last character and set a flag                      colorHash = colorHash.Substring(0' colorHash.Length - 1);                      appendEscapedTab = true;                  }                    if (colorHash.Length == 4 || colorHash.Length == 7 || colorHash.Length == 9)                  {                      parsed = Parsed.True;                        // we won't do any conversion on the #aarrggbb formats to make them smaller.                      string hexColor = CrunchHexColor(colorHash' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexColor);                        if (appendEscapedTab)                      {                          Append("\\9");                      }                        SkipSpace();                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseHexcolor,The following statement contains a magic number: if (CurrentTokenType == TokenType.Hash)              {                  var colorHash = CurrentTokenText;                  var appendEscapedTab = false;                    // valid hash colors are #rgb' #rrggbb' and #aarrggbb.                  // but there is a commonly-used IE hack that puts \9 at the end of properties' so                  // if we have 5' 8' or 10 characters' let's first check to see if the color                  // ends in a tab.                  if ((colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)                      && colorHash.EndsWith("\t"' StringComparison.Ordinal))                  {                      // it is -- strip that last character and set a flag                      colorHash = colorHash.Substring(0' colorHash.Length - 1);                      appendEscapedTab = true;                  }                    if (colorHash.Length == 4 || colorHash.Length == 7 || colorHash.Length == 9)                  {                      parsed = Parsed.True;                        // we won't do any conversion on the #aarrggbb formats to make them smaller.                      string hexColor = CrunchHexColor(colorHash' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexColor);                        if (appendEscapedTab)                      {                          Append("\\9");                      }                        SkipSpace();                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseHexcolor,The following statement contains a magic number: if (CurrentTokenType == TokenType.Hash)              {                  var colorHash = CurrentTokenText;                  var appendEscapedTab = false;                    // valid hash colors are #rgb' #rrggbb' and #aarrggbb.                  // but there is a commonly-used IE hack that puts \9 at the end of properties' so                  // if we have 5' 8' or 10 characters' let's first check to see if the color                  // ends in a tab.                  if ((colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)                      && colorHash.EndsWith("\t"' StringComparison.Ordinal))                  {                      // it is -- strip that last character and set a flag                      colorHash = colorHash.Substring(0' colorHash.Length - 1);                      appendEscapedTab = true;                  }                    if (colorHash.Length == 4 || colorHash.Length == 7 || colorHash.Length == 9)                  {                      parsed = Parsed.True;                        // we won't do any conversion on the #aarrggbb formats to make them smaller.                      string hexColor = CrunchHexColor(colorHash' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexColor);                        if (appendEscapedTab)                      {                          Append("\\9");                      }                        SkipSpace();                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseHexcolor,The following statement contains a magic number: if (CurrentTokenType == TokenType.Hash)              {                  var colorHash = CurrentTokenText;                  var appendEscapedTab = false;                    // valid hash colors are #rgb' #rrggbb' and #aarrggbb.                  // but there is a commonly-used IE hack that puts \9 at the end of properties' so                  // if we have 5' 8' or 10 characters' let's first check to see if the color                  // ends in a tab.                  if ((colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)                      && colorHash.EndsWith("\t"' StringComparison.Ordinal))                  {                      // it is -- strip that last character and set a flag                      colorHash = colorHash.Substring(0' colorHash.Length - 1);                      appendEscapedTab = true;                  }                    if (colorHash.Length == 4 || colorHash.Length == 7 || colorHash.Length == 9)                  {                      parsed = Parsed.True;                        // we won't do any conversion on the #aarrggbb formats to make them smaller.                      string hexColor = CrunchHexColor(colorHash' Settings.ColorNames' m_noColorAbbreviation);                      Append(hexColor);                        if (appendEscapedTab)                      {                          Append("\\9");                      }                        SkipSpace();                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,EscapeCharacter,The following statement contains a magic number: return hex.Length < 7;
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,OnCssError,The following statement contains a magic number: if (CssError != null && exception != null && !Settings.IgnoreAllErrors)              {                  // format our CSS error code                  string errorCode = "CSS{0}".FormatInvariant((exception.Error & (0xffff)));                    // if we have no errors in our error ignore list' or if we do but this error code is not in                  // that list' fire the event to whomever is listening for it.                  if (!Settings.IgnoreErrorCollection.Contains(errorCode))                  {                      CssError(this' new CssErrorEventArgs(exception'                          new MinifierError(                              exception.Severity < 2'                               exception.Severity'                              GetSeverityString(exception.Severity)'                               errorCode'                              null'                              FileContext'                               exception.Line'                               exception.Char'                               0'                               0'                               exception.Message)));                  }              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,GetSeverityString,The following statement contains a magic number: switch (severity)              {                  case 0:                      return CssStrings.Severity0;                    case 1:                      return CssStrings.Severity1;                    case 2:                      return CssStrings.Severity2;                    case 3:                      return CssStrings.Severity3;                    case 4:                      return CssStrings.Severity4;                    default:                      return CssStrings.SeverityUnknown.FormatInvariant(severity);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,GetSeverityString,The following statement contains a magic number: switch (severity)              {                  case 0:                      return CssStrings.Severity0;                    case 1:                      return CssStrings.Severity1;                    case 2:                      return CssStrings.Severity2;                    case 3:                      return CssStrings.Severity3;                    case 4:                      return CssStrings.Severity4;                    default:                      return CssStrings.SeverityUnknown.FormatInvariant(severity);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,GetSeverityString,The following statement contains a magic number: switch (severity)              {                  case 0:                      return CssStrings.Severity0;                    case 1:                      return CssStrings.Severity1;                    case 2:                      return CssStrings.Severity2;                    case 3:                      return CssStrings.Severity3;                    case 4:                      return CssStrings.Severity4;                    default:                      return CssStrings.SeverityUnknown.FormatInvariant(severity);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,NormalizeImportantComment,The following statement contains a magic number: if (CommentContainsText(source))              {                  // first check to see if the comment is in the form /*!/ ...text... /**/                  // if so' then it's probably a part of the Opera5&NS4-only comment hack and we want                  // to make SURE that exclamation point does not get in the output because it would                  // mess up the results.                  if (source[3] == '/' && source.EndsWith("/**/"' StringComparison.Ordinal))                  {                      // it is. output the comment as-is EXCEPT without the exclamation mark                      // (and don't put any line-feeds around it)                      source = "/*" + source.Substring(3);                  }              }              else              {                  // important comment' but it doesn't contain text. So instead' leave it inline                  // (don't add a newline character before it) but take out the exclamation mark.                  source = "/*" + source.Substring(3);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,NormalizeImportantComment,The following statement contains a magic number: if (CommentContainsText(source))              {                  // first check to see if the comment is in the form /*!/ ...text... /**/                  // if so' then it's probably a part of the Opera5&NS4-only comment hack and we want                  // to make SURE that exclamation point does not get in the output because it would                  // mess up the results.                  if (source[3] == '/' && source.EndsWith("/**/"' StringComparison.Ordinal))                  {                      // it is. output the comment as-is EXCEPT without the exclamation mark                      // (and don't put any line-feeds around it)                      source = "/*" + source.Substring(3);                  }              }              else              {                  // important comment' but it doesn't contain text. So instead' leave it inline                  // (don't add a newline character before it) but take out the exclamation mark.                  source = "/*" + source.Substring(3);              }
Magic Number,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,NormalizeImportantComment,The following statement contains a magic number: if (CommentContainsText(source))              {                  // first check to see if the comment is in the form /*!/ ...text... /**/                  // if so' then it's probably a part of the Opera5&NS4-only comment hack and we want                  // to make SURE that exclamation point does not get in the output because it would                  // mess up the results.                  if (source[3] == '/' && source.EndsWith("/**/"' StringComparison.Ordinal))                  {                      // it is. output the comment as-is EXCEPT without the exclamation mark                      // (and don't put any line-feeds around it)                      source = "/*" + source.Substring(3);                  }              }              else              {                  // important comment' but it doesn't contain text. So instead' leave it inline                  // (don't add a newline character before it) but take out the exclamation mark.                  source = "/*" + source.Substring(3);              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanComment,The following statement contains a magic number: if (m_currentChar == '*')              {                  NextChar();                  // everything is a comment until we get to */                  StringBuilder sb = new StringBuilder();                  sb.Append("/*");                    bool terminated = false;                  while (m_currentChar != '\0')                  {                      sb.Append(m_currentChar);                      if (m_currentChar == '*' && PeekChar() == '/')                      {                          sb.Append('/');                          NextChar(); // now points to /                          NextChar(); // now points to following character                            // check for comment-hack 2 -- NS4 sees /*/*//*/ as a single comment                          // while everyone else properly parses that as two comments' which hides everything                          // after this construct until the next comment. So this hack shows the stuff                          // between ONLY to NS4. But we still want to crunch it' so if we just found                          // a comment like /*/*/' check to see if the next characters are /*/. If so'                          // treat it like the single comment NS4 sees.                          // (and don't forget that if we want to keep them' we've turned them both into important comments)                          if (sb.ToString() == "/*!/*/" && ReadString("/*/"))                          {                              // read string will leave the current character after the /*/ string'                              // so add the part we just read to the string builder and we'll break                              // out of the loop                              sb.Append("/*/");                          }                          terminated = true;                          break;                      }                      NextChar();                  }                    if (!terminated)                  {                      ReportError(0' CssErrorCode.UnterminatedComment);                  }                                    var comment = sb.ToString();                  if (string.Compare(comment' 2' "/#SOURCE"' 0' 8' StringComparison.OrdinalIgnoreCase) == 0)                  {                      // found our special comment: /*/#SOURCE line col path */                      var match = s_sourceDirective.Match(comment);                      if (match != null)                      {                          int line' column;                          if (int.TryParse(match.Result("${line}")' out line)                              && int.TryParse(match.Result("${col}")' out column))                          {                              // we got a proper line' column' and non-blank path. reset our context                              // with the new line and column.                              this.OnContextChange(                                  match.Result("${path}")'                                  line'                                  column);                                // now' this is weird. by AjaxMin convention' there should be NOTHING after this comment                              // but whitespace and a single line-terminator. So we will skip EVERYTHING after this comment up                              // to the first line-terminator' and then eat that first line-terminator. So it's possible to                              // completely ignore code by putting it between this multiline comment and the end of its line.                              SkipToNextLineWithoutUpdate();                                // return null so this token gets skipped                              return null;                          }                      }                  }                    token = new CssToken(TokenType.Comment' comment' m_context);              }              else if (m_currentChar == '/')              {                  // we found '//' -- it's a JS-style single-line comment which isn't strictly                  // supported by CSS' but we're going to treat as a valid comment because                   // developers like using them. We're not going to persist them' though -- we're                  // going to eat these comments' since they're not valid CSS.                    // first check for our special ///#source directive.                   // We're on the second slash; see if the NEXT character is a third slash                  if (PeekChar() == '/')                  {                      // found '///'                      NextChar();                        // now w're on the third slash; see if the NEXT character is a pound-sign                      if (PeekChar() == '#')                      {                          // okay' we have ///#' which we are going to reserve for all AjaxMin directive comments.                          // so the source better not have something meaningful for the rest of the line.                          NextChar();                            // now we're on the pound-sign. See if we have the source directive                          if (ReadString("#SOURCE"))                          {                              // we have a source directive: ///#source line col file                              // skip space                              DirectiveSkipSpace();                                // pull the line and column numbers. Must be positive integers greater than zero.                              int line = DirectiveScanInteger();                              if (line > 0)                              {                                  DirectiveSkipSpace();                                  int column = DirectiveScanInteger();                                  if (column > 0)                                  {                                      DirectiveSkipSpace();                                        // the rest of the comment line is the file path.                                      var sb = new StringBuilder();                                      while (m_currentChar != '\n' && m_currentChar != '\r')                                      {                                          sb.Append(m_currentChar);                                          DirectiveNextChar();                                      }                                        var fileContext = sb.ToString().TrimEnd();                                      if (!string.IsNullOrEmpty(fileContext))                                      {                                          // we got a proper line' column' and non-blank path. reset our context                                          // with the new line and column.                                          this.OnContextChange(fileContext' line' column);                                            // START SPECIAL PROCESSING                                          SkipToNextLineWithoutUpdate();                                            // return null here so we don't fall through and return a / character.                                          return null;                                      }                                  }                              }                          }                      }                  }                    // eat the comment up to' but not including' the next line terminator                  while (m_currentChar != '\n' && m_currentChar != '\r' && m_currentChar != '\0')                  {                      NextChar();                  }                    // if we wanted to maintain these comments' we would set the token                  // variable to a new CssToken object of type comment. But we don't' so                  // just return null so that the scanner will go around again.                  return null;              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanComment,The following statement contains a magic number: if (m_currentChar == '*')              {                  NextChar();                  // everything is a comment until we get to */                  StringBuilder sb = new StringBuilder();                  sb.Append("/*");                    bool terminated = false;                  while (m_currentChar != '\0')                  {                      sb.Append(m_currentChar);                      if (m_currentChar == '*' && PeekChar() == '/')                      {                          sb.Append('/');                          NextChar(); // now points to /                          NextChar(); // now points to following character                            // check for comment-hack 2 -- NS4 sees /*/*//*/ as a single comment                          // while everyone else properly parses that as two comments' which hides everything                          // after this construct until the next comment. So this hack shows the stuff                          // between ONLY to NS4. But we still want to crunch it' so if we just found                          // a comment like /*/*/' check to see if the next characters are /*/. If so'                          // treat it like the single comment NS4 sees.                          // (and don't forget that if we want to keep them' we've turned them both into important comments)                          if (sb.ToString() == "/*!/*/" && ReadString("/*/"))                          {                              // read string will leave the current character after the /*/ string'                              // so add the part we just read to the string builder and we'll break                              // out of the loop                              sb.Append("/*/");                          }                          terminated = true;                          break;                      }                      NextChar();                  }                    if (!terminated)                  {                      ReportError(0' CssErrorCode.UnterminatedComment);                  }                                    var comment = sb.ToString();                  if (string.Compare(comment' 2' "/#SOURCE"' 0' 8' StringComparison.OrdinalIgnoreCase) == 0)                  {                      // found our special comment: /*/#SOURCE line col path */                      var match = s_sourceDirective.Match(comment);                      if (match != null)                      {                          int line' column;                          if (int.TryParse(match.Result("${line}")' out line)                              && int.TryParse(match.Result("${col}")' out column))                          {                              // we got a proper line' column' and non-blank path. reset our context                              // with the new line and column.                              this.OnContextChange(                                  match.Result("${path}")'                                  line'                                  column);                                // now' this is weird. by AjaxMin convention' there should be NOTHING after this comment                              // but whitespace and a single line-terminator. So we will skip EVERYTHING after this comment up                              // to the first line-terminator' and then eat that first line-terminator. So it's possible to                              // completely ignore code by putting it between this multiline comment and the end of its line.                              SkipToNextLineWithoutUpdate();                                // return null so this token gets skipped                              return null;                          }                      }                  }                    token = new CssToken(TokenType.Comment' comment' m_context);              }              else if (m_currentChar == '/')              {                  // we found '//' -- it's a JS-style single-line comment which isn't strictly                  // supported by CSS' but we're going to treat as a valid comment because                   // developers like using them. We're not going to persist them' though -- we're                  // going to eat these comments' since they're not valid CSS.                    // first check for our special ///#source directive.                   // We're on the second slash; see if the NEXT character is a third slash                  if (PeekChar() == '/')                  {                      // found '///'                      NextChar();                        // now w're on the third slash; see if the NEXT character is a pound-sign                      if (PeekChar() == '#')                      {                          // okay' we have ///#' which we are going to reserve for all AjaxMin directive comments.                          // so the source better not have something meaningful for the rest of the line.                          NextChar();                            // now we're on the pound-sign. See if we have the source directive                          if (ReadString("#SOURCE"))                          {                              // we have a source directive: ///#source line col file                              // skip space                              DirectiveSkipSpace();                                // pull the line and column numbers. Must be positive integers greater than zero.                              int line = DirectiveScanInteger();                              if (line > 0)                              {                                  DirectiveSkipSpace();                                  int column = DirectiveScanInteger();                                  if (column > 0)                                  {                                      DirectiveSkipSpace();                                        // the rest of the comment line is the file path.                                      var sb = new StringBuilder();                                      while (m_currentChar != '\n' && m_currentChar != '\r')                                      {                                          sb.Append(m_currentChar);                                          DirectiveNextChar();                                      }                                        var fileContext = sb.ToString().TrimEnd();                                      if (!string.IsNullOrEmpty(fileContext))                                      {                                          // we got a proper line' column' and non-blank path. reset our context                                          // with the new line and column.                                          this.OnContextChange(fileContext' line' column);                                            // START SPECIAL PROCESSING                                          SkipToNextLineWithoutUpdate();                                            // return null here so we don't fall through and return a / character.                                          return null;                                      }                                  }                              }                          }                      }                  }                    // eat the comment up to' but not including' the next line terminator                  while (m_currentChar != '\n' && m_currentChar != '\r' && m_currentChar != '\0')                  {                      NextChar();                  }                    // if we wanted to maintain these comments' we would set the token                  // variable to a new CssToken object of type comment. But we don't' so                  // just return null so that the scanner will go around again.                  return null;              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanString,The following statement contains a magic number: bool isValidString = (stringLiteral.Length >= 2                  && stringLiteral[0] == stringLiteral[stringLiteral.Length - 1]);
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,The following statement contains a magic number: while (m_currentChar != '\0'                  && count < 6                  && (m_currentChar == '?' || (!hasQuestions && IsH(m_currentChar))))              {                  // if this isn't a leading zero' reset the flag                  if (leadingZero && m_currentChar != '0')                  {                      leadingZero = false;                  }                    if (m_currentChar == '?')                  {                      hasQuestions = true;                                            // assume the digit is an "F" for maximum value                      firstValue = firstValue*16 + HValue('F');                  }                  else                  {                      firstValue = firstValue*16 + HValue(m_currentChar);                  }                    if (!leadingZero)                  {                      sb.Append(m_currentChar);                  }                    ++count;                  NextChar();              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,The following statement contains a magic number: while (m_currentChar != '\0'                  && count < 6                  && (m_currentChar == '?' || (!hasQuestions && IsH(m_currentChar))))              {                  // if this isn't a leading zero' reset the flag                  if (leadingZero && m_currentChar != '0')                  {                      leadingZero = false;                  }                    if (m_currentChar == '?')                  {                      hasQuestions = true;                                            // assume the digit is an "F" for maximum value                      firstValue = firstValue*16 + HValue('F');                  }                  else                  {                      firstValue = firstValue*16 + HValue(m_currentChar);                  }                    if (!leadingZero)                  {                      sb.Append(m_currentChar);                  }                    ++count;                  NextChar();              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,The following statement contains a magic number: while (m_currentChar != '\0'                  && count < 6                  && (m_currentChar == '?' || (!hasQuestions && IsH(m_currentChar))))              {                  // if this isn't a leading zero' reset the flag                  if (leadingZero && m_currentChar != '0')                  {                      leadingZero = false;                  }                    if (m_currentChar == '?')                  {                      hasQuestions = true;                                            // assume the digit is an "F" for maximum value                      firstValue = firstValue*16 + HValue('F');                  }                  else                  {                      firstValue = firstValue*16 + HValue(m_currentChar);                  }                    if (!leadingZero)                  {                      sb.Append(m_currentChar);                  }                    ++count;                  NextChar();              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,The following statement contains a magic number: if (count > 0)              {                  // if the unicode value is out of range' throw an error                  if (firstValue < 0 || 0x10ffff < firstValue)                  {                      // throw an error                      ReportError(0' CssErrorCode.InvalidUnicodeRange' sb.ToString());                  }                    // if we still have the leading zero flag' then all the numbers were zero                  // and we didn't output any of them.                  if (leadingZero)                  {                      // add one zero to keep it proper                      sb.Append('0');                  }                    if (hasQuestions)                  {                      // if there are question marks' then we're done                      token = new CssToken(                          TokenType.UnicodeRange'                          sb.ToString()'                          m_context);                  }                  else if (m_currentChar == '-')                  {                      sb.Append('-');                      NextChar();                        count = 0;                      leadingZero = true;                      int secondValue = 0;                      while (m_currentChar != '\0' && count < 6 && IsH(m_currentChar))                      {                          // if this isn't a leading zero' reset the flag                          if (leadingZero && m_currentChar != '0')                          {                              leadingZero = false;                          }                            secondValue = secondValue * 16 + HValue(m_currentChar);                            if (!leadingZero)                          {                              sb.Append(m_currentChar);                          }                            ++count;                          NextChar();                      }                        if (count > 0)                      {                          // if we still have the leading zero flag' then all the numbers were zero                          // and we didn't output any of them.                          if (leadingZero)                          {                              // add one zero to keep it proper                              sb.Append('0');                          }                            // check to make sure the second value is within range                          // AND is greater than the first                          if (secondValue < 0 || 0x10ffff < secondValue                              || firstValue >= secondValue)                          {                              // throw an error                              ReportError(0' CssErrorCode.InvalidUnicodeRange' sb.ToString());                          }                            token = new CssToken(                              TokenType.UnicodeRange'                              sb.ToString()'                              m_context);                      }                  }                  else                  {                      // single code-point with at least one character                      token = new CssToken(                          TokenType.UnicodeRange'                          sb.ToString()'                          m_context);                  }              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanUnicodeRange,The following statement contains a magic number: if (count > 0)              {                  // if the unicode value is out of range' throw an error                  if (firstValue < 0 || 0x10ffff < firstValue)                  {                      // throw an error                      ReportError(0' CssErrorCode.InvalidUnicodeRange' sb.ToString());                  }                    // if we still have the leading zero flag' then all the numbers were zero                  // and we didn't output any of them.                  if (leadingZero)                  {                      // add one zero to keep it proper                      sb.Append('0');                  }                    if (hasQuestions)                  {                      // if there are question marks' then we're done                      token = new CssToken(                          TokenType.UnicodeRange'                          sb.ToString()'                          m_context);                  }                  else if (m_currentChar == '-')                  {                      sb.Append('-');                      NextChar();                        count = 0;                      leadingZero = true;                      int secondValue = 0;                      while (m_currentChar != '\0' && count < 6 && IsH(m_currentChar))                      {                          // if this isn't a leading zero' reset the flag                          if (leadingZero && m_currentChar != '0')                          {                              leadingZero = false;                          }                            secondValue = secondValue * 16 + HValue(m_currentChar);                            if (!leadingZero)                          {                              sb.Append(m_currentChar);                          }                            ++count;                          NextChar();                      }                        if (count > 0)                      {                          // if we still have the leading zero flag' then all the numbers were zero                          // and we didn't output any of them.                          if (leadingZero)                          {                              // add one zero to keep it proper                              sb.Append('0');                          }                            // check to make sure the second value is within range                          // AND is greater than the first                          if (secondValue < 0 || 0x10ffff < secondValue                              || firstValue >= secondValue)                          {                              // throw an error                              ReportError(0' CssErrorCode.InvalidUnicodeRange' sb.ToString());                          }                            token = new CssToken(                              TokenType.UnicodeRange'                              sb.ToString()'                              m_context);                      }                  }                  else                  {                      // single code-point with at least one character                      token = new CssToken(                          TokenType.UnicodeRange'                          sb.ToString()'                          m_context);                  }              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,HValue,The following statement contains a magic number: if ('a' <= ch && ch <= 'f')              {                  return (ch - 'a') + 10;              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,HValue,The following statement contains a magic number: if ('A' <= ch && ch <= 'F')              {                  return (ch - 'A') + 10;              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,IsNonAscii,The following statement contains a magic number: return (128 <= ch && ch <= 65535);
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,IsNonAscii,The following statement contains a magic number: return (128 <= ch && ch <= 65535);
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,GetUnicodeEncodingValue,The following statement contains a magic number: while (m_currentChar != '\0' && count++ < 6 && IsH(m_currentChar))              {                  unicodeValue = (unicodeValue * 16) + HValue(m_currentChar);                  NextChar();              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,GetUnicodeEncodingValue,The following statement contains a magic number: while (m_currentChar != '\0' && count++ < 6 && IsH(m_currentChar))              {                  unicodeValue = (unicodeValue * 16) + HValue(m_currentChar);                  NextChar();              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,GetNmStart,The following statement contains a magic number: if (nmStart == null)              {                  if (IsNonAscii(m_currentChar)                    || (m_currentChar == '_')                    || ('a' <= m_currentChar && m_currentChar <= 'z')                    || ('A' <= m_currentChar && m_currentChar <= 'Z'))                  {                      // actually' CSS1 and CSS2 don't allow underscores in                      // identifier names' especially not the first character                      if (m_currentChar == '_')                      {                          ReportError(                            4'                            CssErrorCode.UnderscoreNotValid                            );                      }                        nmStart = char.ToString(m_currentChar);                      NextChar();                  }              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,GetNmChar,The following statement contains a magic number: if (nmChar == null)              {                  if (IsNmChar(m_currentChar))                  {                      // actually' CSS1 and CSS2 don't allow underscores in                      // identifier names.                      if (m_currentChar == '_')                      {                          ReportError(                            4'                            CssErrorCode.UnderscoreNotValid                            );                      }                      nmChar = char.ToString(m_currentChar);                      NextChar();                  }              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,GetNum,The following statement contains a magic number: if (m_currentChar == '.')              {                  if (IsD(PeekChar()))                  {                      hasDecimalPoint = true;                      // move over the decimal point                      NextChar();                        StringBuilder sb = new StringBuilder();                      // check for extra digits                      while (IsD(m_currentChar))                      {                          sb.Append(m_currentChar);                          NextChar();                      }                      fraction = sb.ToString();                  }                  else if (units != null)                  {                      // REVIEW: it looks like there must be at least one digit                      // after a decimal point' but let's let it slack a bit and                      // let decimal point be a part of a number if it starts with                      // digits                      hasDecimalPoint = true;                      ReportError(                        2'                        CssErrorCode.DecimalNoDigit                        );                      fraction = string.Empty;                      NextChar();                  }              }
Magic Number,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,DirectiveScanInteger,The following statement contains a magic number: while ('0' <= m_currentChar && m_currentChar <= '9')              {                  number = number * 10 + (m_currentChar - '0');                  NextChar();              }
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var condCommentCompressor = createCompressorClone();  				var matcher = condCommentPattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						condCommentBlocks.Add(  							match.Groups[1].Value + condCommentCompressor.Minify(match.Groups[2].Value) + match.Groups[3].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' string.Format(tempCondCommentBlock' index++));  						sb.Append(match.Result(string.Format(tempCondCommentBlock' index++)));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var condCommentCompressor = createCompressorClone();  				var matcher = condCommentPattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						condCommentBlocks.Add(  							match.Groups[1].Value + condCommentCompressor.Minify(match.Groups[2].Value) + match.Groups[3].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' string.Format(tempCondCommentBlock' index++));  						sb.Append(match.Result(string.Format(tempCondCommentBlock' index++)));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var condCommentCompressor = createCompressorClone();  				var matcher = condCommentPattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						condCommentBlocks.Add(  							match.Groups[1].Value + condCommentCompressor.Minify(match.Groups[2].Value) + match.Groups[3].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' string.Format(tempCondCommentBlock' index++));  						sb.Append(match.Result(string.Format(tempCondCommentBlock' index++)));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = eventPattern1.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						eventBlocks.Add(match.Groups[2].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' "$1" + string.Format(tempEventBlock' index++) + "$3");  						sb.Append(match.Result("$1" + string.Format(tempEventBlock' index++) + "$3"));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = eventPattern1.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						eventBlocks.Add(match.Groups[2].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' "$1" + string.Format(tempEventBlock' index++) + "$3");  						sb.Append(match.Result("$1" + string.Format(tempEventBlock' index++) + "$3"));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = eventPattern2.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						eventBlocks.Add(match.Groups[2].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' "$1" + string.Format(tempEventBlock' index++) + "$3");  						sb.Append(match.Result( "$1" + string.Format(tempEventBlock' index++) + "$3"));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = eventPattern2.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						eventBlocks.Add(match.Groups[2].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' "$1" + string.Format(tempEventBlock' index++) + "$3");  						sb.Append(match.Result( "$1" + string.Format(tempEventBlock' index++) + "$3"));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = prePattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						preBlocks.Add(match.Groups[2].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' "$1" + string.Format(tempPreBlock' index++) + "$3");  						sb.Append(match.Result("$1" + string.Format(tempPreBlock' index++) + "$3"));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = prePattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						preBlocks.Add(match.Groups[2].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' "$1" + string.Format(tempPreBlock' index++) + "$3");  						sb.Append(match.Result("$1" + string.Format(tempPreBlock' index++) + "$3"));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = scriptPattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					//ignore empty scripts  					if (match.Groups[2].Value.Trim().Length > 0)  					{    						//check type  						string type = "";  						var typeMatcher = typeAttrPattern.Match(match.Groups[1].Value);  						if (typeMatcher.Success)  						{  							type = typeMatcher.Groups[2].Value.ToLowerInvariant();  						}    						if (type.Length == 0 || type.Equals("text/javascript") || type.Equals("application/javascript"))  						{  							//javascript block' preserve and compress with js compressor  							scriptBlocks.Add(match.Groups[2].Value);    							sb.Append(html.Substring(lastValue' match.Index - lastValue));  							//matcher.appendReplacement(sb' "$1" + string.Format(tempScriptBlock' index++) + "$3");  							sb.Append(match.Result("$1" + string.Format(tempScriptBlock' index++) + "$3"));    							lastValue = match.Index + match.Length;  						}  						else if (type.Equals("text/x-jquery-tmpl"))  						{  							//jquery template' ignore so it gets compressed with the rest of html  						}  						else  						{  							//some custom script' preserve it inside "skip blocks" so it won't be compressed with js compressor   							skipBlocks.Add(match.Groups[2].Value);    							sb.Append(html.Substring(lastValue' match.Index - lastValue));  							//matcher.appendReplacement(sb' "$1" + string.Format(tempSkipBlock' skipBlockIndex++) + "$3");  							sb.Append(match.Result("$1" + string.Format(tempSkipBlock' skipBlockIndex++) + "$3"));    							lastValue = match.Index + match.Length;  						}  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = scriptPattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					//ignore empty scripts  					if (match.Groups[2].Value.Trim().Length > 0)  					{    						//check type  						string type = "";  						var typeMatcher = typeAttrPattern.Match(match.Groups[1].Value);  						if (typeMatcher.Success)  						{  							type = typeMatcher.Groups[2].Value.ToLowerInvariant();  						}    						if (type.Length == 0 || type.Equals("text/javascript") || type.Equals("application/javascript"))  						{  							//javascript block' preserve and compress with js compressor  							scriptBlocks.Add(match.Groups[2].Value);    							sb.Append(html.Substring(lastValue' match.Index - lastValue));  							//matcher.appendReplacement(sb' "$1" + string.Format(tempScriptBlock' index++) + "$3");  							sb.Append(match.Result("$1" + string.Format(tempScriptBlock' index++) + "$3"));    							lastValue = match.Index + match.Length;  						}  						else if (type.Equals("text/x-jquery-tmpl"))  						{  							//jquery template' ignore so it gets compressed with the rest of html  						}  						else  						{  							//some custom script' preserve it inside "skip blocks" so it won't be compressed with js compressor   							skipBlocks.Add(match.Groups[2].Value);    							sb.Append(html.Substring(lastValue' match.Index - lastValue));  							//matcher.appendReplacement(sb' "$1" + string.Format(tempSkipBlock' skipBlockIndex++) + "$3");  							sb.Append(match.Result("$1" + string.Format(tempSkipBlock' skipBlockIndex++) + "$3"));    							lastValue = match.Index + match.Length;  						}  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = scriptPattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					//ignore empty scripts  					if (match.Groups[2].Value.Trim().Length > 0)  					{    						//check type  						string type = "";  						var typeMatcher = typeAttrPattern.Match(match.Groups[1].Value);  						if (typeMatcher.Success)  						{  							type = typeMatcher.Groups[2].Value.ToLowerInvariant();  						}    						if (type.Length == 0 || type.Equals("text/javascript") || type.Equals("application/javascript"))  						{  							//javascript block' preserve and compress with js compressor  							scriptBlocks.Add(match.Groups[2].Value);    							sb.Append(html.Substring(lastValue' match.Index - lastValue));  							//matcher.appendReplacement(sb' "$1" + string.Format(tempScriptBlock' index++) + "$3");  							sb.Append(match.Result("$1" + string.Format(tempScriptBlock' index++) + "$3"));    							lastValue = match.Index + match.Length;  						}  						else if (type.Equals("text/x-jquery-tmpl"))  						{  							//jquery template' ignore so it gets compressed with the rest of html  						}  						else  						{  							//some custom script' preserve it inside "skip blocks" so it won't be compressed with js compressor   							skipBlocks.Add(match.Groups[2].Value);    							sb.Append(html.Substring(lastValue' match.Index - lastValue));  							//matcher.appendReplacement(sb' "$1" + string.Format(tempSkipBlock' skipBlockIndex++) + "$3");  							sb.Append(match.Result("$1" + string.Format(tempSkipBlock' skipBlockIndex++) + "$3"));    							lastValue = match.Index + match.Length;  						}  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = scriptPattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					//ignore empty scripts  					if (match.Groups[2].Value.Trim().Length > 0)  					{    						//check type  						string type = "";  						var typeMatcher = typeAttrPattern.Match(match.Groups[1].Value);  						if (typeMatcher.Success)  						{  							type = typeMatcher.Groups[2].Value.ToLowerInvariant();  						}    						if (type.Length == 0 || type.Equals("text/javascript") || type.Equals("application/javascript"))  						{  							//javascript block' preserve and compress with js compressor  							scriptBlocks.Add(match.Groups[2].Value);    							sb.Append(html.Substring(lastValue' match.Index - lastValue));  							//matcher.appendReplacement(sb' "$1" + string.Format(tempScriptBlock' index++) + "$3");  							sb.Append(match.Result("$1" + string.Format(tempScriptBlock' index++) + "$3"));    							lastValue = match.Index + match.Length;  						}  						else if (type.Equals("text/x-jquery-tmpl"))  						{  							//jquery template' ignore so it gets compressed with the rest of html  						}  						else  						{  							//some custom script' preserve it inside "skip blocks" so it won't be compressed with js compressor   							skipBlocks.Add(match.Groups[2].Value);    							sb.Append(html.Substring(lastValue' match.Index - lastValue));  							//matcher.appendReplacement(sb' "$1" + string.Format(tempSkipBlock' skipBlockIndex++) + "$3");  							sb.Append(match.Result("$1" + string.Format(tempSkipBlock' skipBlockIndex++) + "$3"));    							lastValue = match.Index + match.Length;  						}  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = stylePattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						styleBlocks.Add(match.Groups[2].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' "$1" + string.Format(tempStyleBlock' index++) + "$3");  						sb.Append(match.Result("$1" + string.Format(tempStyleBlock' index++) + "$3"));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = stylePattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						styleBlocks.Add(match.Groups[2].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' "$1" + string.Format(tempStyleBlock' index++) + "$3");  						sb.Append(match.Result("$1" + string.Format(tempStyleBlock' index++) + "$3"));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = taPattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						taBlocks.Add(match.Groups[2].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' "$1" + string.Format(tempTextAreaBlock' index++) + "$3");  						sb.Append(match.Result("$1"+ string.Format(tempTextAreaBlock' index++) + "$3"));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The following statement contains a magic number: if (true)  			{  				var matcher = taPattern.Matches(html);  				var index = 0;  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					if (match.Groups[2].Value.Trim().Length > 0)  					{  						taBlocks.Add(match.Groups[2].Value);    						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' "$1" + string.Format(tempTextAreaBlock' index++) + "$3");  						sb.Append(match.Result("$1"+ string.Format(tempTextAreaBlock' index++) + "$3"));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();  			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,removeQuotesInsideTags,The following statement contains a magic number: if (_removeQuotes)  			{  				var matcher = tagQuotePattern.Matches(html);  				var sb = new StringBuilder();  				var lastValue = 0;    				foreach (Match match in matcher)  				{  					//if quoted attribute is followed by "/" add extra space  					if (match.Groups[3].Value.Trim().Length == 0)  					{  						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' "=$2");  						sb.Append(match.Result("=$2"));    						lastValue = match.Index + match.Length;  					}  					else  					{  						sb.Append(html.Substring(lastValue' match.Index - lastValue));  						//matcher.appendReplacement(sb' "=$2 $3");  						sb.Append(match.Result("=$2 $3"));    						lastValue = match.Index + match.Length;  					}  				}    				//matcher.appendTail(sb);  				sb.Append(html.Substring(lastValue));    				html = sb.ToString();    			}
Magic Number,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,removeSpacesInsideTags,The following statement contains a magic number: foreach (Match match in matcher)  			{  				//keep space if attribute value is unquoted before trailing slash  				if (match.Groups[2].Value.StartsWith("/") && tagLastUnquotedValuePattern.IsMatch(match.Groups[1].Value))  				{  					sb.Append(html.Substring(lastValue' match.Index - lastValue));  					//matcher.appendReplacement(sb' "$1 $2");  					sb.Append(match.Result("$1 $2"));    					lastValue = match.Index + match.Length;  				}  				else  				{  					sb.Append(html.Substring(lastValue' match.Index - lastValue));  					//matcher.appendReplacement(sb' "$1$2");  					sb.Append(match.Result("$1$2"));    					lastValue = match.Index + match.Length;  				}  			}
Magic Number,Baker.Text,JsConstantWrapper,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsConstantWrapper.cs,EscapeString,The following statement contains a magic number: if (!string.IsNullOrEmpty(text))              {                  for (int ndx = 0; ndx < text.Length; ++ndx)                  {                      char c = text[ndx];                      switch (c)                      {                          // explicit escape sequences                          // if this is for a string parameter to a RegExp object' then we want to use                          // explicit hex-values' not the escape sequences                          case '\b':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x08" : @"\b"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\t':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x09" : @"\t"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\n':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0a" : @"\n"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\v':                              if (!useW3Strict)                              {                                  goto default;                              }                                AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0b" : @"\v"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\f':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0c" : @"\f"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\r':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0d" : @"\r"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\\':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' @"\\"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\'':                          case '"':                              // whichever character we're using as the delimiter' we need                              // to escape inside the string                              if (delimiter == c)                              {                                  AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\"' ref sb);                                  sb.Append(c);                                  startOfStretch = ndx + 1;                              }                                // otherwise' we're going to output the character as-is' so just keep going                              break;                            case '\x2028':                          case '\x2029':                              // issue #14398 - unescaped' these characters (Unicode LineSeparator and ParagraphSeparator)                              // would introduce a line-break in the string.  they ALWAYS need to be escaped'                               // no matter what output encoding we may use.                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' @"\u"' ref sb);                              sb.Append("{0:x}".FormatInvariant((int)c));                              startOfStretch = ndx + 1;                              break;                            default:                              if (' ' <= c && c <= 0x7e)                              {                                  // regular ascii character                                  break;                              }                                if (c < ' ')                              {                                  // ECMA strict mode can't use octal' either                                  if (isRegularExpression || useStrict)                                  {                                      // for regular expression strings' \1 through \9 are always backreferences'                                       // and \10 through \40 are backreferences if they correspond to existing                                       // backreference groups. So we can't use octal for the characters with values                                      // between 0 and 31. encode with a hexadecimal escape sequence                                      AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\x{0:x2}".FormatInvariant((int)c)' ref sb);                                      startOfStretch = ndx + 1;                                  }                                  else                                  {                                      // we're not a regular expression string. And character with a value between                                       // 0 and 31 can be represented in octal with two to three characters (\0 - \37)'                                      // whereas it would always take four characters to do it in hex: \x00 - \x1f.                                      // so let's go with octal since we aren't in strict mode                                      AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\"' ref sb);                                      int intValue = (int)c;                                      if (intValue < 8)                                      {                                          // single octal digit                                          sb.Append(intValue.ToStringInvariant());                                      }                                      else                                      {                                          // two octal digits                                          sb.Append((intValue / 8).ToStringInvariant());                                          sb.Append((intValue % 8).ToStringInvariant());                                      }                                        startOfStretch = ndx + 1;                                  }                              }                                break;                      }                  }              }
Magic Number,Baker.Text,JsConstantWrapper,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsConstantWrapper.cs,EscapeString,The following statement contains a magic number: if (!string.IsNullOrEmpty(text))              {                  for (int ndx = 0; ndx < text.Length; ++ndx)                  {                      char c = text[ndx];                      switch (c)                      {                          // explicit escape sequences                          // if this is for a string parameter to a RegExp object' then we want to use                          // explicit hex-values' not the escape sequences                          case '\b':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x08" : @"\b"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\t':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x09" : @"\t"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\n':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0a" : @"\n"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\v':                              if (!useW3Strict)                              {                                  goto default;                              }                                AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0b" : @"\v"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\f':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0c" : @"\f"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\r':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0d" : @"\r"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\\':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' @"\\"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\'':                          case '"':                              // whichever character we're using as the delimiter' we need                              // to escape inside the string                              if (delimiter == c)                              {                                  AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\"' ref sb);                                  sb.Append(c);                                  startOfStretch = ndx + 1;                              }                                // otherwise' we're going to output the character as-is' so just keep going                              break;                            case '\x2028':                          case '\x2029':                              // issue #14398 - unescaped' these characters (Unicode LineSeparator and ParagraphSeparator)                              // would introduce a line-break in the string.  they ALWAYS need to be escaped'                               // no matter what output encoding we may use.                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' @"\u"' ref sb);                              sb.Append("{0:x}".FormatInvariant((int)c));                              startOfStretch = ndx + 1;                              break;                            default:                              if (' ' <= c && c <= 0x7e)                              {                                  // regular ascii character                                  break;                              }                                if (c < ' ')                              {                                  // ECMA strict mode can't use octal' either                                  if (isRegularExpression || useStrict)                                  {                                      // for regular expression strings' \1 through \9 are always backreferences'                                       // and \10 through \40 are backreferences if they correspond to existing                                       // backreference groups. So we can't use octal for the characters with values                                      // between 0 and 31. encode with a hexadecimal escape sequence                                      AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\x{0:x2}".FormatInvariant((int)c)' ref sb);                                      startOfStretch = ndx + 1;                                  }                                  else                                  {                                      // we're not a regular expression string. And character with a value between                                       // 0 and 31 can be represented in octal with two to three characters (\0 - \37)'                                      // whereas it would always take four characters to do it in hex: \x00 - \x1f.                                      // so let's go with octal since we aren't in strict mode                                      AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\"' ref sb);                                      int intValue = (int)c;                                      if (intValue < 8)                                      {                                          // single octal digit                                          sb.Append(intValue.ToStringInvariant());                                      }                                      else                                      {                                          // two octal digits                                          sb.Append((intValue / 8).ToStringInvariant());                                          sb.Append((intValue % 8).ToStringInvariant());                                      }                                        startOfStretch = ndx + 1;                                  }                              }                                break;                      }                  }              }
Magic Number,Baker.Text,JsConstantWrapper,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsConstantWrapper.cs,EscapeString,The following statement contains a magic number: if (!string.IsNullOrEmpty(text))              {                  for (int ndx = 0; ndx < text.Length; ++ndx)                  {                      char c = text[ndx];                      switch (c)                      {                          // explicit escape sequences                          // if this is for a string parameter to a RegExp object' then we want to use                          // explicit hex-values' not the escape sequences                          case '\b':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x08" : @"\b"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\t':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x09" : @"\t"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\n':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0a" : @"\n"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\v':                              if (!useW3Strict)                              {                                  goto default;                              }                                AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0b" : @"\v"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\f':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0c" : @"\f"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\r':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' isRegularExpression ? @"\x0d" : @"\r"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\\':                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' @"\\"' ref sb);                              startOfStretch = ndx + 1;                              break;                            case '\'':                          case '"':                              // whichever character we're using as the delimiter' we need                              // to escape inside the string                              if (delimiter == c)                              {                                  AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\"' ref sb);                                  sb.Append(c);                                  startOfStretch = ndx + 1;                              }                                // otherwise' we're going to output the character as-is' so just keep going                              break;                            case '\x2028':                          case '\x2029':                              // issue #14398 - unescaped' these characters (Unicode LineSeparator and ParagraphSeparator)                              // would introduce a line-break in the string.  they ALWAYS need to be escaped'                               // no matter what output encoding we may use.                              AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' @"\u"' ref sb);                              sb.Append("{0:x}".FormatInvariant((int)c));                              startOfStretch = ndx + 1;                              break;                            default:                              if (' ' <= c && c <= 0x7e)                              {                                  // regular ascii character                                  break;                              }                                if (c < ' ')                              {                                  // ECMA strict mode can't use octal' either                                  if (isRegularExpression || useStrict)                                  {                                      // for regular expression strings' \1 through \9 are always backreferences'                                       // and \10 through \40 are backreferences if they correspond to existing                                       // backreference groups. So we can't use octal for the characters with values                                      // between 0 and 31. encode with a hexadecimal escape sequence                                      AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\x{0:x2}".FormatInvariant((int)c)' ref sb);                                      startOfStretch = ndx + 1;                                  }                                  else                                  {                                      // we're not a regular expression string. And character with a value between                                       // 0 and 31 can be represented in octal with two to three characters (\0 - \37)'                                      // whereas it would always take four characters to do it in hex: \x00 - \x1f.                                      // so let's go with octal since we aren't in strict mode                                      AddEscape(text.Substring(startOfStretch' ndx - startOfStretch)' "\\"' ref sb);                                      int intValue = (int)c;                                      if (intValue < 8)                                      {                                          // single octal digit                                          sb.Append(intValue.ToStringInvariant());                                      }                                      else                                      {                                          // two octal digits                                          sb.Append((intValue / 8).ToStringInvariant());                                          sb.Append((intValue % 8).ToStringInvariant());                                      }                                        startOfStretch = ndx + 1;                                  }                              }                                break;                      }                  }              }
Magic Number,Baker.Text,JsConstantWrapper,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsConstantWrapper.cs,ToNumber,The following statement contains a magic number: switch(PrimitiveType)              {                  case JsPrimitiveType.Number:                      // pass-through the double as-is                      return (double)Value;                    case JsPrimitiveType.Null:                      // converting null to a number returns +0                      return 0;                    case JsPrimitiveType.Boolean:                      // converting boolean to number: true is 1' false is +0                      return (bool)Value ? 1 : 0;                    case JsPrimitiveType.Other:                      // don't convert others to numbers                      throw new InvalidCastException("Cannot convert 'other' primitives to number");                    default:                      // otherwise this must be a string                      try                      {                          string stringValue = Value.ToString();                          if (stringValue == null || string.IsNullOrEmpty(stringValue.Trim()))                          {                              // empty string or string of nothing but whitespace returns +0                              return 0;                          }                            // see if this is a hex number representation                          Match match;                          if (MayHaveIssues)                          {                              throw new InvalidCastException("cross-browser conversion issues");                          }                          else if ((match = s_hexNumberFormat.Match(stringValue)).Success)                          {                              // if we matched a sign' then we are in a cross-browser gray area.                              // the ECMA spec says that isn't allowed. IE and Safari correctly return NaN.                              // But Firefox' Opera' and Chrome will apply the sign to the parsed hex value.                              if (!string.IsNullOrEmpty(match.Result("${sign}")))                              {                                  throw new InvalidCastException("Cross-browser error converting signed hex string to number");                              }                                // parse the hexadecimal digits portion                              // can't use NumberStyles.HexNumber in double.Parse' so we need to do the conversion manually                              double doubleValue = 0;                              string hexRep = match.Result("${hex}");                                // loop from the start of the string to the end' converting the hex digits to a binary                              // value. As soon as we hit an overflow condition' we can bail.                              for (int ndx = 0; ndx < hexRep.Length && !double.IsInfinity(doubleValue); ++ndx)                              {                                  // we already know from the regular expression match that the hex rep is ONLY                                  // 0-9' a-f or A-F' so we don't need to test for outside those ranges.                                  char ch = hexRep[ndx];                                  doubleValue = (doubleValue * 16) + (ch <= '9' ? ch & 0xf : (ch & 0xf) + 9);                              }                              return doubleValue;                          }                          else                          {                              // not a hex number -- try doing a regular decimal float conversion                              return double.Parse(stringValue' NumberStyles.Float' CultureInfo.InvariantCulture);                          }                      }                      catch (FormatException)                      {                          // string isn't a number' return NaN                          return double.NaN;                      }                      catch (OverflowException)                      {                          // if the string starts with optional white-space followed by a minus sign'                          // then it's a negative-infinity overflow. Otherwise it's a positive infinity overflow.                          Regex negativeSign = new Regex(@"^\s*-");                          return (negativeSign.IsMatch(Value.ToString()))                              ? double.NegativeInfinity                              : double.PositiveInfinity;                      }              }
Magic Number,Baker.Text,JsConstantWrapper,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsConstantWrapper.cs,ToNumber,The following statement contains a magic number: switch(PrimitiveType)              {                  case JsPrimitiveType.Number:                      // pass-through the double as-is                      return (double)Value;                    case JsPrimitiveType.Null:                      // converting null to a number returns +0                      return 0;                    case JsPrimitiveType.Boolean:                      // converting boolean to number: true is 1' false is +0                      return (bool)Value ? 1 : 0;                    case JsPrimitiveType.Other:                      // don't convert others to numbers                      throw new InvalidCastException("Cannot convert 'other' primitives to number");                    default:                      // otherwise this must be a string                      try                      {                          string stringValue = Value.ToString();                          if (stringValue == null || string.IsNullOrEmpty(stringValue.Trim()))                          {                              // empty string or string of nothing but whitespace returns +0                              return 0;                          }                            // see if this is a hex number representation                          Match match;                          if (MayHaveIssues)                          {                              throw new InvalidCastException("cross-browser conversion issues");                          }                          else if ((match = s_hexNumberFormat.Match(stringValue)).Success)                          {                              // if we matched a sign' then we are in a cross-browser gray area.                              // the ECMA spec says that isn't allowed. IE and Safari correctly return NaN.                              // But Firefox' Opera' and Chrome will apply the sign to the parsed hex value.                              if (!string.IsNullOrEmpty(match.Result("${sign}")))                              {                                  throw new InvalidCastException("Cross-browser error converting signed hex string to number");                              }                                // parse the hexadecimal digits portion                              // can't use NumberStyles.HexNumber in double.Parse' so we need to do the conversion manually                              double doubleValue = 0;                              string hexRep = match.Result("${hex}");                                // loop from the start of the string to the end' converting the hex digits to a binary                              // value. As soon as we hit an overflow condition' we can bail.                              for (int ndx = 0; ndx < hexRep.Length && !double.IsInfinity(doubleValue); ++ndx)                              {                                  // we already know from the regular expression match that the hex rep is ONLY                                  // 0-9' a-f or A-F' so we don't need to test for outside those ranges.                                  char ch = hexRep[ndx];                                  doubleValue = (doubleValue * 16) + (ch <= '9' ? ch & 0xf : (ch & 0xf) + 9);                              }                              return doubleValue;                          }                          else                          {                              // not a hex number -- try doing a regular decimal float conversion                              return double.Parse(stringValue' NumberStyles.Float' CultureInfo.InvariantCulture);                          }                      }                      catch (FormatException)                      {                          // string isn't a number' return NaN                          return double.NaN;                      }                      catch (OverflowException)                      {                          // if the string starts with optional white-space followed by a minus sign'                          // then it's a negative-infinity overflow. Otherwise it's a positive infinity overflow.                          Regex negativeSign = new Regex(@"^\s*-");                          return (negativeSign.IsMatch(Value.ToString()))                              ? double.NegativeInfinity                              : double.PositiveInfinity;                      }              }
Magic Number,Baker.Text,JsContext,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsContext.cs,HandleError,The following statement contains a magic number: if ((errorId != JsError.UndeclaredVariable && errorId != JsError.UndeclaredFunction) || !Document.HasAlreadySeenErrorFor(Code))              {                  var error = new JsException(errorId' this);                    if (forceToError)                  {                      error.IsError = true;                  }                  else                  {                      error.IsError = error.Severity < 2;                  }                    Document.HandleError(error);              }
Magic Number,Baker.Text,JsDirectivePrologue,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsDirectivePrologue.cs,JsDirectivePrologue,The following statement contains a magic number: UseStrict = string.CompareOrdinal(Context.Code' 1' "use strict"' 0' 10) == 0;
Magic Number,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Visit,The following statement contains a magic number: if (node != null)              {                  var commaOperator = node.Parent as JsCommaOperator;                  JsAstNodeList list;                  if (commaOperator != null                      && (list = commaOperator.Operand2 as JsAstNodeList) != null)                  {                      // this list is part of a comma-operator' which is a collection of contiguous                      // expression statements that we combined together. What we want to do is                      // delete all constant elements from the list.                      // if the parent is a block' then this was just a collection of statements and                      // we can delete ALL constant expressions. But if the parent is not a block' then                      // we will want to keep the last one as-is because it is the return value of the                      // overall expression.                      for (var ndx = list.Count - (node.Parent is JsBlock ? 1 : 2); ndx >= 0; --ndx)                      {                          if (list[ndx] is JsConstantWrapper)                          {                              list.RemoveAt(ndx);                          }                      }                    }                    // then normally recurse whatever is left over                  base.Visit(node);              }
Magic Number,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Visit,The following statement contains a magic number: if (node != null)              {                  // depth-first                  base.Visit(node);                    // if this isn't a constructor and it isn't a member-brackets operator                  if (!node.IsConstructor && !node.InBrackets)                  {                      // check to see if this is a call of certain member functions                      var member = node.Function as JsMember;                      if (member != null)                      {                          if (string.CompareOrdinal(member.Name' "join") == 0 && node.Arguments.Count <= 1                              && m_parser.Settings.IsModificationAllowed(JsTreeModifications.EvaluateLiteralJoins))                          {                              // this is a call to join with zero or one argument (no more)                              // see if the root is an array literal that has no issues                              var arrayLiteral = member.Root as JsArrayLiteral;                              if (arrayLiteral != null && !arrayLiteral.MayHaveIssues)                              {                                  // it is -- make sure the separator is either not specified or is a constant                                  JsConstantWrapper separator = null;                                  if (node.Arguments.Count == 0 || (separator = node.Arguments[0] as JsConstantWrapper) != null)                                  {                                      // and the array literal must contain only constant items                                      if (OnlyHasConstantItems(arrayLiteral))                                      {                                          // last test: compute the combined string and only use it if it's actually                                          // shorter than the original code                                          var combinedJoin = ComputeJoin(arrayLiteral' separator);                                          if (combinedJoin.Length + 2 < node.ToCode().Length)                                          {                                              // transform: [c'c'c].join(s) => "cscsc"                                              ReplaceNodeWithLiteral(node'                                                   new JsConstantWrapper(combinedJoin' JsPrimitiveType.String' node.Context' node.Parser));                                          }                                      }                                  }                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsException,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsException.cs,GetSeverity,The following statement contains a magic number: switch (errorCode)              {                  case JsError.AmbiguousCatchVar:                  case JsError.AmbiguousNamedFunctionExpression:                  case JsError.NumericOverflow:                  case JsError.StrictComparisonIsAlwaysTrueOrFalse:                      return 1;                    case JsError.ArrayLiteralTrailingComma:                  case JsError.DuplicateCatch:                  case JsError.DuplicateConstantDeclaration:                  case JsError.DuplicateLexicalDeclaration:                  case JsError.KeywordUsedAsIdentifier:                  case JsError.MisplacedFunctionDeclaration:                  case JsError.ObjectLiteralKeyword:                      return 2;                    case JsError.ArgumentNotReferenced:                  case JsError.DuplicateName:                  case JsError.FunctionNotReferenced:                  case JsError.UndeclaredFunction:                  case JsError.UndeclaredVariable:                  case JsError.VariableDefinedNotReferenced:                      return 3;                    case JsError.StatementBlockExpected:                  case JsError.SuspectAssignment:                  case JsError.SuspectSemicolon:                  case JsError.SuspectEquality:                  case JsError.WithNotRecommended:                  case JsError.ObjectConstructorTakesNoArguments:                  case JsError.NumericMaximum:                  case JsError.NumericMinimum:                  case JsError.OctalLiteralsDeprecated:                  case JsError.FunctionNameMustBeIdentifier:                  case JsError.SemicolonInsertion:                      return 4;                    default:                      // all others                      return 0;              }
Magic Number,Baker.Text,JsException,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsException.cs,GetSeverity,The following statement contains a magic number: switch (errorCode)              {                  case JsError.AmbiguousCatchVar:                  case JsError.AmbiguousNamedFunctionExpression:                  case JsError.NumericOverflow:                  case JsError.StrictComparisonIsAlwaysTrueOrFalse:                      return 1;                    case JsError.ArrayLiteralTrailingComma:                  case JsError.DuplicateCatch:                  case JsError.DuplicateConstantDeclaration:                  case JsError.DuplicateLexicalDeclaration:                  case JsError.KeywordUsedAsIdentifier:                  case JsError.MisplacedFunctionDeclaration:                  case JsError.ObjectLiteralKeyword:                      return 2;                    case JsError.ArgumentNotReferenced:                  case JsError.DuplicateName:                  case JsError.FunctionNotReferenced:                  case JsError.UndeclaredFunction:                  case JsError.UndeclaredVariable:                  case JsError.VariableDefinedNotReferenced:                      return 3;                    case JsError.StatementBlockExpected:                  case JsError.SuspectAssignment:                  case JsError.SuspectSemicolon:                  case JsError.SuspectEquality:                  case JsError.WithNotRecommended:                  case JsError.ObjectConstructorTakesNoArguments:                  case JsError.NumericMaximum:                  case JsError.NumericMinimum:                  case JsError.OctalLiteralsDeprecated:                  case JsError.FunctionNameMustBeIdentifier:                  case JsError.SemicolonInsertion:                      return 4;                    default:                      // all others                      return 0;              }
Magic Number,Baker.Text,JsException,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsException.cs,GetSeverity,The following statement contains a magic number: switch (errorCode)              {                  case JsError.AmbiguousCatchVar:                  case JsError.AmbiguousNamedFunctionExpression:                  case JsError.NumericOverflow:                  case JsError.StrictComparisonIsAlwaysTrueOrFalse:                      return 1;                    case JsError.ArrayLiteralTrailingComma:                  case JsError.DuplicateCatch:                  case JsError.DuplicateConstantDeclaration:                  case JsError.DuplicateLexicalDeclaration:                  case JsError.KeywordUsedAsIdentifier:                  case JsError.MisplacedFunctionDeclaration:                  case JsError.ObjectLiteralKeyword:                      return 2;                    case JsError.ArgumentNotReferenced:                  case JsError.DuplicateName:                  case JsError.FunctionNotReferenced:                  case JsError.UndeclaredFunction:                  case JsError.UndeclaredVariable:                  case JsError.VariableDefinedNotReferenced:                      return 3;                    case JsError.StatementBlockExpected:                  case JsError.SuspectAssignment:                  case JsError.SuspectSemicolon:                  case JsError.SuspectEquality:                  case JsError.WithNotRecommended:                  case JsError.ObjectConstructorTakesNoArguments:                  case JsError.NumericMaximum:                  case JsError.NumericMinimum:                  case JsError.OctalLiteralsDeprecated:                  case JsError.FunctionNameMustBeIdentifier:                  case JsError.SemicolonInsertion:                      return 4;                    default:                      // all others                      return 0;              }
Magic Number,Baker.Text,JsFinalPassVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsFinalPassVisitor.cs,CreateSplitNodeFromEnd,The following statement contains a magic number: if (ndx == nodeList.Count - 1)              {                  // the LAST one can be broken. Pull it off the list and we will just                  // insert it after the current node.                  newNode = nodeList[ndx];                  nodeList.RemoveAt(ndx);              }              else if (ndx == nodeList.Count - 2)              {                  // the PENULTIMATE item can be broken. So create a new comma operator                  // with the just the last two item and we'll insert it after the current node                  var left = nodeList[ndx];                  nodeList.RemoveAt(ndx);                  var right = nodeList[ndx];                  nodeList.RemoveAt(ndx);                    newNode = new JsCommaOperator(null' nodeList.Parser)                      {                          Operand1 = left'                          Operand2 = right                      };              }              else              {                  // at least three items will be pulled off' which means there will                  // be at least two items on the right' so we'll create a new astlist to                  // insert those items into a new comma operator                  var left = nodeList[ndx];                  nodeList.RemoveAt(ndx);                    // if we were passed zero' then just reuse the node list.                  // otherwise we need to create a new one and move the items                  // from the index position over.                  JsAstNodeList right;                  if (ndx == 0)                  {                      right = nodeList;                  }                  else                  {                      right = new JsAstNodeList(null' nodeList.Parser);                      while (ndx < nodeList.Count)                      {                          var temp = nodeList[ndx];                          nodeList.RemoveAt(ndx);                          right.Append(temp);                      }                  }                    newNode = new JsCommaOperator(null' nodeList.Parser)                      {                          Operand1 = left'                          Operand2 = right                      };              }
Magic Number,Baker.Text,JsFinalPassVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsFinalPassVisitor.cs,RotateOpeator,The following statement contains a magic number: if (rightSide.Count == 0)              {                  // the list is empty -- remove the node altogether                  node.Parent.ReplaceChild(node' null);              }              else if (rightSide.Count == 1)              {                  // the list has only one item -- replace the node with the one item                  node.Parent.ReplaceChild(node' rightSide[0]);              }              else if (rightSide.Count == 2)              {                  // there are only two items -- rotate the first to the left-hand side                  // and replace the right-hand side with the second item                  node.Operand1 = rightSide[0];                  node.Operand2 = rightSide[1];              }              else              {                  // there will still be more than one left in the list after we peel off the                  // first one. rotate the first item to the left-hand side                  var temp = rightSide[0];                  rightSide.RemoveAt(0);                  node.Operand1 = temp;              }
Magic Number,Baker.Text,JsKeyword,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsKeyword.cs,InitKeywords,The following statement contains a magic number: JsKeyword[] keywords = new JsKeyword[26];
Magic Number,Baker.Text,JsLogicalNot,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsLogicalNot.cs,MeasureBinaryOperator,The following statement contains a magic number: switch (node.OperatorToken)              {                  case JsToken.Equal:                  case JsToken.NotEqual:                  case JsToken.StrictEqual:                  case JsToken.StrictNotEqual:                      // these operators can be turned into a logical not without any                      // delta in code size. == becomes !=' etc.                      break;                    case JsToken.LessThan:                  case JsToken.GreaterThan:                  // these operators would add another character when turnbed into a not.                  // for example' < becomes >=' etc                  //++m_delta;                  //break;                    case JsToken.LessThanEqual:                  case JsToken.GreaterThanEqual:                  // these operators would subtract another character when turnbed into a not.                  // for example' <= becomes >' etc                  //--m_delta;                  //break;                    case JsToken.Assign:                  case JsToken.PlusAssign:                  case JsToken.MinusAssign:                  case JsToken.MultiplyAssign:                  case JsToken.DivideAssign:                  case JsToken.ModuloAssign:                  case JsToken.BitwiseAndAssign:                  case JsToken.BitwiseOrAssign:                  case JsToken.BitwiseXorAssign:                  case JsToken.LeftShiftAssign:                  case JsToken.RightShiftAssign:                  case JsToken.UnsignedRightShiftAssign:                  case JsToken.BitwiseAnd:                  case JsToken.BitwiseOr:                  case JsToken.BitwiseXor:                  case JsToken.Divide:                  case JsToken.Multiply:                  case JsToken.Modulo:                  case JsToken.Minus:                  case JsToken.Plus:                  case JsToken.LeftShift:                  case JsToken.RightShift:                  case JsToken.UnsignedRightShift:                  case JsToken.In:                  case JsToken.InstanceOf:                      // these operators have no logical not' which means we need to wrap them in                      // a unary logical-not operator. And since they have a lower precedence than                      // the unary logical-not' they'll have to be wrapped in parens. So that means                      // logical-not'ing these guys adds three characters                      m_delta += 3;                      break;                    case JsToken.Comma:                      // to logical-not a comma-operator' we just need to logical-not the                      // right-hand side                      node.Operand2.Accept(this);                      break;                    case JsToken.LogicalAnd:                  case JsToken.LogicalOr:                      if (node.Parent is JsBlock || (node.Parent is JsCommaOperator && node.Parent.Parent is JsBlock))                      {                          // if the parent is a block' then this is a simple expression statement:                          // expr1 || expr2; or expr1 && expr2; If so' then the result isn't                          // used anywhere and we're just using the || or && operator as a                          // shorter if-statement. So we don't need to negate the right-hand                          // side' just the left-hand side.                          if (node.Operand1 != null)                          {                              node.Operand1.Accept(this);                          }                      }                      else                      {                          // the logical-not of a logical-and or logical-or operation is the                           // other operation against the not of each operand. Since the opposite                          // operator is the same length as this operator' then we just need                          // to recurse both operands to find the true delta.                          if (node.Operand1 != null)                          {                              node.Operand1.Accept(this);                          }                            if (node.Operand2 != null)                          {                              node.Operand2.Accept(this);                          }                      }                      break;              }
Magic Number,Baker.Text,JsLogicalNot,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsLogicalNot.cs,Visit,The following statement contains a magic number: if (node != null)              {                  // we have two choices for the conditional. Either:                  //  1. we wrap the whole thing in a logical-not operator' which means we also need to                  //     add parentheses' since conditional is lower-precedence than the logicial not' or                  //  2. apply the logical-not to both the true- and false-branches.                  // The first is guaranteed 3 additional characters. We have to check the delta for                  // each branch and add them together to know how much the second would cost. If it's                   // greater than 3' then we just want to not the whole thing.                  var notTrue = new JsLogicalNot(node.TrueExpression' m_parser);                  var notFalse = new JsLogicalNot(node.FalseExpression' m_parser);                  var costNottingBoth = notTrue.Measure() + notFalse.Measure();                    if (m_measure)                  {                      // we're just measuring -- adjust the delta accordingly                      // (the lesser of the two options)                      m_delta += (costNottingBoth > 3) ? 3 : costNottingBoth;                  }                  else if (costNottingBoth > 3)                  {                      // just wrap the whole thing                      WrapWithLogicalNot(node);                  }                  else                  {                      // less bytes to wrap each branch separately                      node.TrueExpression.Accept(this);                      node.FalseExpression.Accept(this);                  }              }
Magic Number,Baker.Text,JsLogicalNot,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsLogicalNot.cs,Visit,The following statement contains a magic number: if (node != null)              {                  // we have two choices for the conditional. Either:                  //  1. we wrap the whole thing in a logical-not operator' which means we also need to                  //     add parentheses' since conditional is lower-precedence than the logicial not' or                  //  2. apply the logical-not to both the true- and false-branches.                  // The first is guaranteed 3 additional characters. We have to check the delta for                  // each branch and add them together to know how much the second would cost. If it's                   // greater than 3' then we just want to not the whole thing.                  var notTrue = new JsLogicalNot(node.TrueExpression' m_parser);                  var notFalse = new JsLogicalNot(node.FalseExpression' m_parser);                  var costNottingBoth = notTrue.Measure() + notFalse.Measure();                    if (m_measure)                  {                      // we're just measuring -- adjust the delta accordingly                      // (the lesser of the two options)                      m_delta += (costNottingBoth > 3) ? 3 : costNottingBoth;                  }                  else if (costNottingBoth > 3)                  {                      // just wrap the whole thing                      WrapWithLogicalNot(node);                  }                  else                  {                      // less bytes to wrap each branch separately                      node.TrueExpression.Accept(this);                      node.FalseExpression.Accept(this);                  }              }
Magic Number,Baker.Text,JsLogicalNot,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsLogicalNot.cs,Visit,The following statement contains a magic number: if (node != null)              {                  // we have two choices for the conditional. Either:                  //  1. we wrap the whole thing in a logical-not operator' which means we also need to                  //     add parentheses' since conditional is lower-precedence than the logicial not' or                  //  2. apply the logical-not to both the true- and false-branches.                  // The first is guaranteed 3 additional characters. We have to check the delta for                  // each branch and add them together to know how much the second would cost. If it's                   // greater than 3' then we just want to not the whole thing.                  var notTrue = new JsLogicalNot(node.TrueExpression' m_parser);                  var notFalse = new JsLogicalNot(node.FalseExpression' m_parser);                  var costNottingBoth = notTrue.Measure() + notFalse.Measure();                    if (m_measure)                  {                      // we're just measuring -- adjust the delta accordingly                      // (the lesser of the two options)                      m_delta += (costNottingBoth > 3) ? 3 : costNottingBoth;                  }                  else if (costNottingBoth > 3)                  {                      // just wrap the whole thing                      WrapWithLogicalNot(node);                  }                  else                  {                      // less bytes to wrap each branch separately                      node.TrueExpression.Accept(this);                      node.FalseExpression.Accept(this);                  }              }
Magic Number,Baker.Text,JsLogicalNot,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsLogicalNot.cs,Visit,The following statement contains a magic number: if (node != null && !node.OperatorInConditionalCompilationComment)              {                  // if this is a unary logical-not operator' then we will just remove the                  // logical-not operation                  if (node.OperatorToken == JsToken.LogicalNot)                  {                      if (m_measure)                      {                          // measure                          // removes the not operator character' but also might remove parens that we would                          // no longer need.                          --m_delta;                          if (node.Operand is JsBinaryOperator || node.Operand is JsConditional || node.Operand is JsGroupingOperator)                          {                              // those operators are lesser-precedence than the logical-not coperator and would've                              // added parens that we now don't need                              m_delta -= 2;                          }                      }                      else                      {                          // convert                          // just replace the not with its own operand' unless the child                          // itself is a grouping operator' in which case we will replace it                          // with the grouping operand to get rid of the parens                          var grouping = node.Operand as JsGroupingOperator;                          if (grouping != null)                          {                              node.Parent.ReplaceChild(node' grouping.Operand);                          }                          else                          {                              node.Parent.ReplaceChild(node' node.Operand);                          }                      }                  }                  else                  {                      // same logic as most nodes for the other operators                      TypicalHandler(node);                  }              }
Magic Number,Baker.Text,JsonOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsonOutputVisitor.cs,GetSmallestRep,The following statement contains a magic number: if (match.Success)              {                  string mantissa = match.Result("${man}");                  if (string.IsNullOrEmpty(match.Result("${exp}")))                  {                      if (string.IsNullOrEmpty(mantissa))                      {                          // no decimal portion                          if (string.IsNullOrEmpty(match.Result("${sig}")))                          {                              // no non-zero digits in the magnitude either -- must be a zero                              number = match.Result("${neg}") + "0";                          }                          else                          {                              // see if there are trailing zeros                              // that we can use e-notation to make smaller                              int numZeros = match.Result("${zer}").Length;                              if (numZeros > 2)                              {                                  number = match.Result("${neg}") + match.Result("${sig}")                                      + 'e' + numZeros.ToString(CultureInfo.InvariantCulture);                              }                          }                      }                      else                      {                          // there is a decimal portion. Put it back together                          // with the bare-minimum stuff -- no plus-sign' no leading magnitude zeros'                          // no trailing mantissa zeros. A zero magnitude won't show up' either.                          number = match.Result("${neg}") + match.Result("${mag}") + '.' + mantissa;                      }                  }                  else if (string.IsNullOrEmpty(mantissa))                  {                      // there is an exponent' but no significant mantissa                      number = match.Result("${neg}") + match.Result("${mag}")                          + "e" + match.Result("${eng}") + match.Result("${pow}");                  }                  else                  {                      // there is an exponent and a significant mantissa                      // we want to see if we can eliminate it and save some bytes                        // get the integer value of the exponent                      int exponent;                      if (int.TryParse(match.Result("${eng}") + match.Result("${pow}")' NumberStyles.Integer' CultureInfo.InvariantCulture' out exponent))                      {                          // slap the mantissa directly to the magnitude without a decimal point.                          // we'll subtract the number of characters we just added to the magnitude from                          // the exponent                          number = match.Result("${neg}") + match.Result("${mag}") + mantissa                              + 'e' + (exponent - mantissa.Length).ToString(CultureInfo.InvariantCulture);                      }                      else                      {                          // should n't get here' but it we do' go with what we have                          number = match.Result("${neg}") + match.Result("${mag}") + '.' + mantissa                              + 'e' + match.Result("${eng}") + match.Result("${pow}");                      }                  }              }
Magic Number,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The following statement contains a magic number: if (node != null)              {                  var symbol = StartSymbol(node);                    // make sure we force the important comments to start on a new line' regardless                  // of whether or not we are in multi- or single-line mode' and the statement after                  // should also be on a new line.                  BreakLine(true);                  node.Context.OutputLine = m_lineCount;                    // the output method assumes any text we send it's way doesn't contain any line feed                  // characters. The important comment' however' may contain some. We don't want to count                  // the entire comment as a single line' AND we want to normalize the line-feed characters'                  // so lets process the comment line-by-line                  var lineFeedChars = new[] { '\n'' '\r'' '\u2028'' '\u2029' };                  var startIndex = 0;                  var firstLF = node.Comment.IndexOfAny(lineFeedChars' startIndex);                  if (firstLF < 0)                  {                      // no line-breaks at all!                      Output(node.Comment);                  }                  else                  {                      // output the first segment -- from start to first line break                      Output(node.Comment.Substring(0' firstLF));                      while (true)                      {                          // advance the next segment pointer                          if (node.Comment[firstLF] == '\r'                              && firstLF < node.Comment.Length - 1                              && node.Comment[firstLF + 1] == '\n')                          {                              startIndex = firstLF + 2;                          }                          else                          {                              startIndex = firstLF + 1;                          }                            // force the line-break in the output                          BreakLine(true);                            // look for the next line break                          firstLF = node.Comment.IndexOfAny(lineFeedChars' startIndex);                            if (firstLF > startIndex)                          {                              // only output something if there was something before the next line break                              Output(node.Comment.Substring(startIndex' firstLF - startIndex));                          }                          else if (firstLF < 0)                          {                              // no more line-breaks -- output the last segment and break out of the loop                              Output(node.Comment.Substring(startIndex));                              break;                          }                      }                  }                    // force a line-break AFTER teh important comment as well                  BreakLine(true);                  EndSymbol(symbol);              }
Magic Number,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,SetLastCharState,The following statement contains a magic number: if (!string.IsNullOrEmpty(text))              {                  // get the last character                  char lastChar = text[text.Length - 1];                    // if it's not a plus or a minus' we don't care                  if (lastChar == '+' || lastChar == '-')                  {                      // see HOW MANY of those characters were at the end of the string                      var ndxDifferent = text.Length - 1;                      while (--ndxDifferent >= 0)                      {                          if (text[ndxDifferent] != lastChar)                          {                              break;                          }                      }                        // if the first diff index is less than zero' then the whole string is one of                      // these two special characters                      if (ndxDifferent < 0 && m_lastCharacter == lastChar)                      {                          // the whole string is the same character' AND it's the same character                           // at the end of the last time we output stuff. We need to take into                           // account the previous state when we set the current state.                          // it's a logical XOR -- if the two values are the same' m_lastCountOdd is false;                          // it they are different' m_lastCountOdd is true.                          m_lastCountOdd = (text.Length % 2 == 1) ^ m_lastCountOdd;                      }                      else                      {                          // either the whole string wasn't the same character' OR the previous ending                          // wasn't the same character. Either way' the current state is determined                           // exclusively by the number of characters we found at the end of this string                          // get the number of same characters ending this string' mod by 2' and if the                          // result is 1' it's an odd number of characters.                          m_lastCountOdd = (text.Length - 1 - ndxDifferent) % 2 == 1;                      }                  }                  else                  {                      // say we weren't odd                      m_lastCountOdd = false;                  }                    // save the last character for next time                  m_lastCharacter = lastChar;              }
Magic Number,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,SetLastCharState,The following statement contains a magic number: if (!string.IsNullOrEmpty(text))              {                  // get the last character                  char lastChar = text[text.Length - 1];                    // if it's not a plus or a minus' we don't care                  if (lastChar == '+' || lastChar == '-')                  {                      // see HOW MANY of those characters were at the end of the string                      var ndxDifferent = text.Length - 1;                      while (--ndxDifferent >= 0)                      {                          if (text[ndxDifferent] != lastChar)                          {                              break;                          }                      }                        // if the first diff index is less than zero' then the whole string is one of                      // these two special characters                      if (ndxDifferent < 0 && m_lastCharacter == lastChar)                      {                          // the whole string is the same character' AND it's the same character                           // at the end of the last time we output stuff. We need to take into                           // account the previous state when we set the current state.                          // it's a logical XOR -- if the two values are the same' m_lastCountOdd is false;                          // it they are different' m_lastCountOdd is true.                          m_lastCountOdd = (text.Length % 2 == 1) ^ m_lastCountOdd;                      }                      else                      {                          // either the whole string wasn't the same character' OR the previous ending                          // wasn't the same character. Either way' the current state is determined                           // exclusively by the number of characters we found at the end of this string                          // get the number of same characters ending this string' mod by 2' and if the                          // result is 1' it's an odd number of characters.                          m_lastCountOdd = (text.Length - 1 - ndxDifferent) % 2 == 1;                      }                  }                  else                  {                      // say we weren't odd                      m_lastCountOdd = false;                  }                    // save the last character for next time                  m_lastCharacter = lastChar;              }
Magic Number,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,WriteToStream,The following statement contains a magic number: if (m_settings.AlwaysEscapeNonAscii && ch > '\u007f')              {                  // expand it to the \uXXXX format' which is six characters                  m_outputStream.Write("\\u{0:x4}"' (int)ch);                  return 6;              }              else              {                  m_outputStream.Write(ch);                  return 1;              }
Magic Number,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,GetSmallestRep,The following statement contains a magic number: if (match.Success)              {                  string mantissa = match.Result("${man}");                  if (string.IsNullOrEmpty(match.Result("${exp}")))                  {                      if (string.IsNullOrEmpty(mantissa))                      {                          // no decimal portion                          if (string.IsNullOrEmpty(match.Result("${sig}")))                          {                              // no non-zero digits in the magnitude either -- must be a zero                              number = match.Result("${neg}") + "0";                          }                          else                          {                              // see if there are trailing zeros                              // that we can use e-notation to make smaller                              int numZeros = match.Result("${zer}").Length;                              if (numZeros > 2)                              {                                  number = match.Result("${neg}") + match.Result("${sig}")                                      + 'e' + numZeros.ToStringInvariant();                              }                          }                      }                      else                      {                          // there is a decimal portion. Put it back together                          // with the bare-minimum stuff -- no plus-sign' no leading magnitude zeros'                          // no trailing mantissa zeros. A zero magnitude won't show up' either.                          number = match.Result("${neg}") + match.Result("${mag}") + '.' + mantissa;                      }                  }                  else if (string.IsNullOrEmpty(mantissa))                  {                      // there is an exponent' but no significant mantissa                      number = match.Result("${neg}") + match.Result("${mag}")                          + "e" + match.Result("${eng}") + match.Result("${pow}");                  }                  else                  {                      // there is an exponent and a significant mantissa                      // we want to see if we can eliminate it and save some bytes                        // get the integer value of the exponent                      int exponent;                      if ((match.Result("${eng}") + match.Result("${pow}")).TryParseIntInvariant(NumberStyles.Integer' out exponent))                      {                          // slap the mantissa directly to the magnitude without a decimal point.                          // we'll subtract the number of characters we just added to the magnitude from                          // the exponent                          number = match.Result("${neg}") + match.Result("${mag}") + mantissa                              + 'e' + (exponent - mantissa.Length).ToStringInvariant();                      }                      else                      {                          // should n't get here' but it we do' go with what we have                          number = match.Result("${neg}") + match.Result("${mag}") + '.' + mantissa                              + 'e' + match.Result("${eng}") + match.Result("${pow}");                      }                  }              }
Magic Number,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,NormalOrHexIfSmaller,The following statement contains a magic number: int maxValue = normal.Length - 2;
Magic Number,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,NormalOrHexIfSmaller,The following statement contains a magic number: while (maxValue > 0 && doubleValue > 0)              {                  // get the right-most hex character                  int digit = (int)(doubleValue % 16);                    // if the digit is less than ten' then we want to add it to '0' to get the decimal character.                  // otherwise we want to add (digit - 10) to 'a' to get the alphabetic hex digit                  charArray[--position] = (char)((digit < 10 ? '0' : 'a' - 10) + digit);                    // next character                  doubleValue = Math.Floor(doubleValue / 16);                  --maxValue;              }
Magic Number,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,NormalOrHexIfSmaller,The following statement contains a magic number: while (maxValue > 0 && doubleValue > 0)              {                  // get the right-most hex character                  int digit = (int)(doubleValue % 16);                    // if the digit is less than ten' then we want to add it to '0' to get the decimal character.                  // otherwise we want to add (digit - 10) to 'a' to get the alphabetic hex digit                  charArray[--position] = (char)((digit < 10 ? '0' : 'a' - 10) + digit);                    // next character                  doubleValue = Math.Floor(doubleValue / 16);                  --maxValue;              }
Magic Number,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,NormalOrHexIfSmaller,The following statement contains a magic number: while (maxValue > 0 && doubleValue > 0)              {                  // get the right-most hex character                  int digit = (int)(doubleValue % 16);                    // if the digit is less than ten' then we want to add it to '0' to get the decimal character.                  // otherwise we want to add (digit - 10) to 'a' to get the alphabetic hex digit                  charArray[--position] = (char)((digit < 10 ? '0' : 'a' - 10) + digit);                    // next character                  doubleValue = Math.Floor(doubleValue / 16);                  --maxValue;              }
Magic Number,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,NormalOrHexIfSmaller,The following statement contains a magic number: while (maxValue > 0 && doubleValue > 0)              {                  // get the right-most hex character                  int digit = (int)(doubleValue % 16);                    // if the digit is less than ten' then we want to add it to '0' to get the decimal character.                  // otherwise we want to add (digit - 10) to 'a' to get the alphabetic hex digit                  charArray[--position] = (char)((digit < 10 ? '0' : 'a' - 10) + digit);                    // next character                  doubleValue = Math.Floor(doubleValue / 16);                  --maxValue;              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,GetSeverityString,The following statement contains a magic number: switch (severity)              {                  case 0:                      return JScript.Severity0;                    case 1:                      return JScript.Severity1;                    case 2:                      return JScript.Severity2;                    case 3:                      return JScript.Severity3;                    case 4:                      return JScript.Severity4;                    default:                      return JScript.SeverityUnknown.FormatInvariant(severity);              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,GetSeverityString,The following statement contains a magic number: switch (severity)              {                  case 0:                      return JScript.Severity0;                    case 1:                      return JScript.Severity1;                    case 2:                      return JScript.Severity2;                    case 3:                      return JScript.Severity3;                    case 4:                      return JScript.Severity4;                    default:                      return JScript.SeverityUnknown.FormatInvariant(severity);              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,GetSeverityString,The following statement contains a magic number: switch (severity)              {                  case 0:                      return JScript.Severity0;                    case 1:                      return JScript.Severity1;                    case 2:                      return JScript.Severity2;                    case 3:                      return JScript.Severity3;                    case 4:                      return JScript.Severity4;                    default:                      return JScript.SeverityUnknown.FormatInvariant(severity);              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,JsParser,The following statement contains a magic number: m_severity = 5;
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,JsParser,The following statement contains a magic number: m_blockType = new List<BlockType>(16);
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,Parse,The following statement contains a magic number: var timePoints = m_timingPoints = new long[9];
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseFunction,The following statement contains a magic number: m_blockType = new List<BlockType>(16);
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseLeftHandSideExpression,The following statement contains a magic number: TryItAgain:                // new expression              while (JsToken.New == m_currentToken.Token)              {                  if (null == newContexts)                      newContexts = new List<JsContext>(4);                  newContexts.Add(m_currentToken.Clone());                  GetNextToken();              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The following statement contains a magic number: try              {                  if (isInteger)                  {                      if (str[0] == '0' && str.Length > 1)                      {                          if (str[1] == 'x' || str[1] == 'X')                          {                              if (str.Length == 2)                              {                                  // 0x???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a hex integer' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str' 16);                          }                          else if (str[1] == 'o' || str[1] == 'O')                          {                              if (str.Length == 2)                              {                                  // 0o???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as an octal integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 8);                          }                          else if (str[1] == 'b' || str[1] == 'B')                          {                              if (str.Length == 2)                              {                                  // 0b???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a binary integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 2);                          }                          else                          {                              // might be an octal value... try converting to octal                              // and if it fails' just convert to decimal                              try                              {                                  doubleValue = (double)System.Convert.ToInt64(str' 8);                                    // if we got here' we successfully converted it to octal.                                  // now' octal literals are deprecated -- not all JS implementations will                                  // decode them. If this decoded as an octal' it can also be a decimal. Check                                  // the decimal value' and if it's the same' then we'll just treat it                                  // as a normal decimal value. Otherwise we'll throw a warning and treat it                                  // as a special no-convert literal.                                  double decimalValue = (double)System.Convert.ToInt64(str' 10);                                  if (decimalValue != doubleValue)                                  {                                      // throw a warning!                                      ReportError(JsError.OctalLiteralsDeprecated' m_currentToken.Clone()' true);                                        // return false because octals are deprecated and might have                                      // cross-browser issues                                      return false;                                  }                              }                              catch (FormatException)                              {                                  // ignore the format exception and fall through to parsing                                  // the value as a base-10 decimal value                                  doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                              }                          }                      }                      else                      {                          // just parse the integer as a decimal value                          doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                      }                        // check for out-of-bounds integer values -- if the integer can't EXACTLY be represented                      // as a double' then we don't want to consider it "successful"                      if (doubleValue < -0x20000000000000 || 0x20000000000000 < doubleValue)                      {                          return false;                      }                  }                  else                  {                      // use the system to convert the string to a double                      doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                  }                    // if we got here' we should have an appropriate value in doubleValue                  return true;              }              catch (OverflowException)              {                  // overflow mean just return one of the infinity values                  doubleValue = (str[0] == '-'                    ? Double.NegativeInfinity                    : Double.PositiveInfinity                    );                    // and it wasn't "successful"                  return false;              }              catch (FormatException)              {                  // format exception converts to NaN                  doubleValue = double.NaN;                    // not successful                  return false;              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The following statement contains a magic number: try              {                  if (isInteger)                  {                      if (str[0] == '0' && str.Length > 1)                      {                          if (str[1] == 'x' || str[1] == 'X')                          {                              if (str.Length == 2)                              {                                  // 0x???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a hex integer' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str' 16);                          }                          else if (str[1] == 'o' || str[1] == 'O')                          {                              if (str.Length == 2)                              {                                  // 0o???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as an octal integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 8);                          }                          else if (str[1] == 'b' || str[1] == 'B')                          {                              if (str.Length == 2)                              {                                  // 0b???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a binary integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 2);                          }                          else                          {                              // might be an octal value... try converting to octal                              // and if it fails' just convert to decimal                              try                              {                                  doubleValue = (double)System.Convert.ToInt64(str' 8);                                    // if we got here' we successfully converted it to octal.                                  // now' octal literals are deprecated -- not all JS implementations will                                  // decode them. If this decoded as an octal' it can also be a decimal. Check                                  // the decimal value' and if it's the same' then we'll just treat it                                  // as a normal decimal value. Otherwise we'll throw a warning and treat it                                  // as a special no-convert literal.                                  double decimalValue = (double)System.Convert.ToInt64(str' 10);                                  if (decimalValue != doubleValue)                                  {                                      // throw a warning!                                      ReportError(JsError.OctalLiteralsDeprecated' m_currentToken.Clone()' true);                                        // return false because octals are deprecated and might have                                      // cross-browser issues                                      return false;                                  }                              }                              catch (FormatException)                              {                                  // ignore the format exception and fall through to parsing                                  // the value as a base-10 decimal value                                  doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                              }                          }                      }                      else                      {                          // just parse the integer as a decimal value                          doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                      }                        // check for out-of-bounds integer values -- if the integer can't EXACTLY be represented                      // as a double' then we don't want to consider it "successful"                      if (doubleValue < -0x20000000000000 || 0x20000000000000 < doubleValue)                      {                          return false;                      }                  }                  else                  {                      // use the system to convert the string to a double                      doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                  }                    // if we got here' we should have an appropriate value in doubleValue                  return true;              }              catch (OverflowException)              {                  // overflow mean just return one of the infinity values                  doubleValue = (str[0] == '-'                    ? Double.NegativeInfinity                    : Double.PositiveInfinity                    );                    // and it wasn't "successful"                  return false;              }              catch (FormatException)              {                  // format exception converts to NaN                  doubleValue = double.NaN;                    // not successful                  return false;              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The following statement contains a magic number: try              {                  if (isInteger)                  {                      if (str[0] == '0' && str.Length > 1)                      {                          if (str[1] == 'x' || str[1] == 'X')                          {                              if (str.Length == 2)                              {                                  // 0x???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a hex integer' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str' 16);                          }                          else if (str[1] == 'o' || str[1] == 'O')                          {                              if (str.Length == 2)                              {                                  // 0o???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as an octal integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 8);                          }                          else if (str[1] == 'b' || str[1] == 'B')                          {                              if (str.Length == 2)                              {                                  // 0b???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a binary integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 2);                          }                          else                          {                              // might be an octal value... try converting to octal                              // and if it fails' just convert to decimal                              try                              {                                  doubleValue = (double)System.Convert.ToInt64(str' 8);                                    // if we got here' we successfully converted it to octal.                                  // now' octal literals are deprecated -- not all JS implementations will                                  // decode them. If this decoded as an octal' it can also be a decimal. Check                                  // the decimal value' and if it's the same' then we'll just treat it                                  // as a normal decimal value. Otherwise we'll throw a warning and treat it                                  // as a special no-convert literal.                                  double decimalValue = (double)System.Convert.ToInt64(str' 10);                                  if (decimalValue != doubleValue)                                  {                                      // throw a warning!                                      ReportError(JsError.OctalLiteralsDeprecated' m_currentToken.Clone()' true);                                        // return false because octals are deprecated and might have                                      // cross-browser issues                                      return false;                                  }                              }                              catch (FormatException)                              {                                  // ignore the format exception and fall through to parsing                                  // the value as a base-10 decimal value                                  doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                              }                          }                      }                      else                      {                          // just parse the integer as a decimal value                          doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                      }                        // check for out-of-bounds integer values -- if the integer can't EXACTLY be represented                      // as a double' then we don't want to consider it "successful"                      if (doubleValue < -0x20000000000000 || 0x20000000000000 < doubleValue)                      {                          return false;                      }                  }                  else                  {                      // use the system to convert the string to a double                      doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                  }                    // if we got here' we should have an appropriate value in doubleValue                  return true;              }              catch (OverflowException)              {                  // overflow mean just return one of the infinity values                  doubleValue = (str[0] == '-'                    ? Double.NegativeInfinity                    : Double.PositiveInfinity                    );                    // and it wasn't "successful"                  return false;              }              catch (FormatException)              {                  // format exception converts to NaN                  doubleValue = double.NaN;                    // not successful                  return false;              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The following statement contains a magic number: try              {                  if (isInteger)                  {                      if (str[0] == '0' && str.Length > 1)                      {                          if (str[1] == 'x' || str[1] == 'X')                          {                              if (str.Length == 2)                              {                                  // 0x???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a hex integer' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str' 16);                          }                          else if (str[1] == 'o' || str[1] == 'O')                          {                              if (str.Length == 2)                              {                                  // 0o???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as an octal integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 8);                          }                          else if (str[1] == 'b' || str[1] == 'B')                          {                              if (str.Length == 2)                              {                                  // 0b???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a binary integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 2);                          }                          else                          {                              // might be an octal value... try converting to octal                              // and if it fails' just convert to decimal                              try                              {                                  doubleValue = (double)System.Convert.ToInt64(str' 8);                                    // if we got here' we successfully converted it to octal.                                  // now' octal literals are deprecated -- not all JS implementations will                                  // decode them. If this decoded as an octal' it can also be a decimal. Check                                  // the decimal value' and if it's the same' then we'll just treat it                                  // as a normal decimal value. Otherwise we'll throw a warning and treat it                                  // as a special no-convert literal.                                  double decimalValue = (double)System.Convert.ToInt64(str' 10);                                  if (decimalValue != doubleValue)                                  {                                      // throw a warning!                                      ReportError(JsError.OctalLiteralsDeprecated' m_currentToken.Clone()' true);                                        // return false because octals are deprecated and might have                                      // cross-browser issues                                      return false;                                  }                              }                              catch (FormatException)                              {                                  // ignore the format exception and fall through to parsing                                  // the value as a base-10 decimal value                                  doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                              }                          }                      }                      else                      {                          // just parse the integer as a decimal value                          doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                      }                        // check for out-of-bounds integer values -- if the integer can't EXACTLY be represented                      // as a double' then we don't want to consider it "successful"                      if (doubleValue < -0x20000000000000 || 0x20000000000000 < doubleValue)                      {                          return false;                      }                  }                  else                  {                      // use the system to convert the string to a double                      doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                  }                    // if we got here' we should have an appropriate value in doubleValue                  return true;              }              catch (OverflowException)              {                  // overflow mean just return one of the infinity values                  doubleValue = (str[0] == '-'                    ? Double.NegativeInfinity                    : Double.PositiveInfinity                    );                    // and it wasn't "successful"                  return false;              }              catch (FormatException)              {                  // format exception converts to NaN                  doubleValue = double.NaN;                    // not successful                  return false;              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The following statement contains a magic number: try              {                  if (isInteger)                  {                      if (str[0] == '0' && str.Length > 1)                      {                          if (str[1] == 'x' || str[1] == 'X')                          {                              if (str.Length == 2)                              {                                  // 0x???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a hex integer' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str' 16);                          }                          else if (str[1] == 'o' || str[1] == 'O')                          {                              if (str.Length == 2)                              {                                  // 0o???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as an octal integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 8);                          }                          else if (str[1] == 'b' || str[1] == 'B')                          {                              if (str.Length == 2)                              {                                  // 0b???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a binary integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 2);                          }                          else                          {                              // might be an octal value... try converting to octal                              // and if it fails' just convert to decimal                              try                              {                                  doubleValue = (double)System.Convert.ToInt64(str' 8);                                    // if we got here' we successfully converted it to octal.                                  // now' octal literals are deprecated -- not all JS implementations will                                  // decode them. If this decoded as an octal' it can also be a decimal. Check                                  // the decimal value' and if it's the same' then we'll just treat it                                  // as a normal decimal value. Otherwise we'll throw a warning and treat it                                  // as a special no-convert literal.                                  double decimalValue = (double)System.Convert.ToInt64(str' 10);                                  if (decimalValue != doubleValue)                                  {                                      // throw a warning!                                      ReportError(JsError.OctalLiteralsDeprecated' m_currentToken.Clone()' true);                                        // return false because octals are deprecated and might have                                      // cross-browser issues                                      return false;                                  }                              }                              catch (FormatException)                              {                                  // ignore the format exception and fall through to parsing                                  // the value as a base-10 decimal value                                  doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                              }                          }                      }                      else                      {                          // just parse the integer as a decimal value                          doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                      }                        // check for out-of-bounds integer values -- if the integer can't EXACTLY be represented                      // as a double' then we don't want to consider it "successful"                      if (doubleValue < -0x20000000000000 || 0x20000000000000 < doubleValue)                      {                          return false;                      }                  }                  else                  {                      // use the system to convert the string to a double                      doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                  }                    // if we got here' we should have an appropriate value in doubleValue                  return true;              }              catch (OverflowException)              {                  // overflow mean just return one of the infinity values                  doubleValue = (str[0] == '-'                    ? Double.NegativeInfinity                    : Double.PositiveInfinity                    );                    // and it wasn't "successful"                  return false;              }              catch (FormatException)              {                  // format exception converts to NaN                  doubleValue = double.NaN;                    // not successful                  return false;              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The following statement contains a magic number: try              {                  if (isInteger)                  {                      if (str[0] == '0' && str.Length > 1)                      {                          if (str[1] == 'x' || str[1] == 'X')                          {                              if (str.Length == 2)                              {                                  // 0x???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a hex integer' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str' 16);                          }                          else if (str[1] == 'o' || str[1] == 'O')                          {                              if (str.Length == 2)                              {                                  // 0o???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as an octal integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 8);                          }                          else if (str[1] == 'b' || str[1] == 'B')                          {                              if (str.Length == 2)                              {                                  // 0b???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a binary integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 2);                          }                          else                          {                              // might be an octal value... try converting to octal                              // and if it fails' just convert to decimal                              try                              {                                  doubleValue = (double)System.Convert.ToInt64(str' 8);                                    // if we got here' we successfully converted it to octal.                                  // now' octal literals are deprecated -- not all JS implementations will                                  // decode them. If this decoded as an octal' it can also be a decimal. Check                                  // the decimal value' and if it's the same' then we'll just treat it                                  // as a normal decimal value. Otherwise we'll throw a warning and treat it                                  // as a special no-convert literal.                                  double decimalValue = (double)System.Convert.ToInt64(str' 10);                                  if (decimalValue != doubleValue)                                  {                                      // throw a warning!                                      ReportError(JsError.OctalLiteralsDeprecated' m_currentToken.Clone()' true);                                        // return false because octals are deprecated and might have                                      // cross-browser issues                                      return false;                                  }                              }                              catch (FormatException)                              {                                  // ignore the format exception and fall through to parsing                                  // the value as a base-10 decimal value                                  doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                              }                          }                      }                      else                      {                          // just parse the integer as a decimal value                          doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                      }                        // check for out-of-bounds integer values -- if the integer can't EXACTLY be represented                      // as a double' then we don't want to consider it "successful"                      if (doubleValue < -0x20000000000000 || 0x20000000000000 < doubleValue)                      {                          return false;                      }                  }                  else                  {                      // use the system to convert the string to a double                      doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                  }                    // if we got here' we should have an appropriate value in doubleValue                  return true;              }              catch (OverflowException)              {                  // overflow mean just return one of the infinity values                  doubleValue = (str[0] == '-'                    ? Double.NegativeInfinity                    : Double.PositiveInfinity                    );                    // and it wasn't "successful"                  return false;              }              catch (FormatException)              {                  // format exception converts to NaN                  doubleValue = double.NaN;                    // not successful                  return false;              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The following statement contains a magic number: try              {                  if (isInteger)                  {                      if (str[0] == '0' && str.Length > 1)                      {                          if (str[1] == 'x' || str[1] == 'X')                          {                              if (str.Length == 2)                              {                                  // 0x???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a hex integer' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str' 16);                          }                          else if (str[1] == 'o' || str[1] == 'O')                          {                              if (str.Length == 2)                              {                                  // 0o???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as an octal integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 8);                          }                          else if (str[1] == 'b' || str[1] == 'B')                          {                              if (str.Length == 2)                              {                                  // 0b???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a binary integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 2);                          }                          else                          {                              // might be an octal value... try converting to octal                              // and if it fails' just convert to decimal                              try                              {                                  doubleValue = (double)System.Convert.ToInt64(str' 8);                                    // if we got here' we successfully converted it to octal.                                  // now' octal literals are deprecated -- not all JS implementations will                                  // decode them. If this decoded as an octal' it can also be a decimal. Check                                  // the decimal value' and if it's the same' then we'll just treat it                                  // as a normal decimal value. Otherwise we'll throw a warning and treat it                                  // as a special no-convert literal.                                  double decimalValue = (double)System.Convert.ToInt64(str' 10);                                  if (decimalValue != doubleValue)                                  {                                      // throw a warning!                                      ReportError(JsError.OctalLiteralsDeprecated' m_currentToken.Clone()' true);                                        // return false because octals are deprecated and might have                                      // cross-browser issues                                      return false;                                  }                              }                              catch (FormatException)                              {                                  // ignore the format exception and fall through to parsing                                  // the value as a base-10 decimal value                                  doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                              }                          }                      }                      else                      {                          // just parse the integer as a decimal value                          doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                      }                        // check for out-of-bounds integer values -- if the integer can't EXACTLY be represented                      // as a double' then we don't want to consider it "successful"                      if (doubleValue < -0x20000000000000 || 0x20000000000000 < doubleValue)                      {                          return false;                      }                  }                  else                  {                      // use the system to convert the string to a double                      doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                  }                    // if we got here' we should have an appropriate value in doubleValue                  return true;              }              catch (OverflowException)              {                  // overflow mean just return one of the infinity values                  doubleValue = (str[0] == '-'                    ? Double.NegativeInfinity                    : Double.PositiveInfinity                    );                    // and it wasn't "successful"                  return false;              }              catch (FormatException)              {                  // format exception converts to NaN                  doubleValue = double.NaN;                    // not successful                  return false;              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The following statement contains a magic number: try              {                  if (isInteger)                  {                      if (str[0] == '0' && str.Length > 1)                      {                          if (str[1] == 'x' || str[1] == 'X')                          {                              if (str.Length == 2)                              {                                  // 0x???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a hex integer' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str' 16);                          }                          else if (str[1] == 'o' || str[1] == 'O')                          {                              if (str.Length == 2)                              {                                  // 0o???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as an octal integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 8);                          }                          else if (str[1] == 'b' || str[1] == 'B')                          {                              if (str.Length == 2)                              {                                  // 0b???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a binary integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 2);                          }                          else                          {                              // might be an octal value... try converting to octal                              // and if it fails' just convert to decimal                              try                              {                                  doubleValue = (double)System.Convert.ToInt64(str' 8);                                    // if we got here' we successfully converted it to octal.                                  // now' octal literals are deprecated -- not all JS implementations will                                  // decode them. If this decoded as an octal' it can also be a decimal. Check                                  // the decimal value' and if it's the same' then we'll just treat it                                  // as a normal decimal value. Otherwise we'll throw a warning and treat it                                  // as a special no-convert literal.                                  double decimalValue = (double)System.Convert.ToInt64(str' 10);                                  if (decimalValue != doubleValue)                                  {                                      // throw a warning!                                      ReportError(JsError.OctalLiteralsDeprecated' m_currentToken.Clone()' true);                                        // return false because octals are deprecated and might have                                      // cross-browser issues                                      return false;                                  }                              }                              catch (FormatException)                              {                                  // ignore the format exception and fall through to parsing                                  // the value as a base-10 decimal value                                  doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                              }                          }                      }                      else                      {                          // just parse the integer as a decimal value                          doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                      }                        // check for out-of-bounds integer values -- if the integer can't EXACTLY be represented                      // as a double' then we don't want to consider it "successful"                      if (doubleValue < -0x20000000000000 || 0x20000000000000 < doubleValue)                      {                          return false;                      }                  }                  else                  {                      // use the system to convert the string to a double                      doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                  }                    // if we got here' we should have an appropriate value in doubleValue                  return true;              }              catch (OverflowException)              {                  // overflow mean just return one of the infinity values                  doubleValue = (str[0] == '-'                    ? Double.NegativeInfinity                    : Double.PositiveInfinity                    );                    // and it wasn't "successful"                  return false;              }              catch (FormatException)              {                  // format exception converts to NaN                  doubleValue = double.NaN;                    // not successful                  return false;              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The following statement contains a magic number: try              {                  if (isInteger)                  {                      if (str[0] == '0' && str.Length > 1)                      {                          if (str[1] == 'x' || str[1] == 'X')                          {                              if (str.Length == 2)                              {                                  // 0x???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a hex integer' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str' 16);                          }                          else if (str[1] == 'o' || str[1] == 'O')                          {                              if (str.Length == 2)                              {                                  // 0o???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as an octal integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 8);                          }                          else if (str[1] == 'b' || str[1] == 'B')                          {                              if (str.Length == 2)                              {                                  // 0b???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a binary integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 2);                          }                          else                          {                              // might be an octal value... try converting to octal                              // and if it fails' just convert to decimal                              try                              {                                  doubleValue = (double)System.Convert.ToInt64(str' 8);                                    // if we got here' we successfully converted it to octal.                                  // now' octal literals are deprecated -- not all JS implementations will                                  // decode them. If this decoded as an octal' it can also be a decimal. Check                                  // the decimal value' and if it's the same' then we'll just treat it                                  // as a normal decimal value. Otherwise we'll throw a warning and treat it                                  // as a special no-convert literal.                                  double decimalValue = (double)System.Convert.ToInt64(str' 10);                                  if (decimalValue != doubleValue)                                  {                                      // throw a warning!                                      ReportError(JsError.OctalLiteralsDeprecated' m_currentToken.Clone()' true);                                        // return false because octals are deprecated and might have                                      // cross-browser issues                                      return false;                                  }                              }                              catch (FormatException)                              {                                  // ignore the format exception and fall through to parsing                                  // the value as a base-10 decimal value                                  doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                              }                          }                      }                      else                      {                          // just parse the integer as a decimal value                          doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                      }                        // check for out-of-bounds integer values -- if the integer can't EXACTLY be represented                      // as a double' then we don't want to consider it "successful"                      if (doubleValue < -0x20000000000000 || 0x20000000000000 < doubleValue)                      {                          return false;                      }                  }                  else                  {                      // use the system to convert the string to a double                      doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                  }                    // if we got here' we should have an appropriate value in doubleValue                  return true;              }              catch (OverflowException)              {                  // overflow mean just return one of the infinity values                  doubleValue = (str[0] == '-'                    ? Double.NegativeInfinity                    : Double.PositiveInfinity                    );                    // and it wasn't "successful"                  return false;              }              catch (FormatException)              {                  // format exception converts to NaN                  doubleValue = double.NaN;                    // not successful                  return false;              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ConvertNumericLiteralToDouble,The following statement contains a magic number: try              {                  if (isInteger)                  {                      if (str[0] == '0' && str.Length > 1)                      {                          if (str[1] == 'x' || str[1] == 'X')                          {                              if (str.Length == 2)                              {                                  // 0x???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a hex integer' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str' 16);                          }                          else if (str[1] == 'o' || str[1] == 'O')                          {                              if (str.Length == 2)                              {                                  // 0o???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as an octal integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 8);                          }                          else if (str[1] == 'b' || str[1] == 'B')                          {                              if (str.Length == 2)                              {                                  // 0b???? must be a parse error. Just return zero                                  doubleValue = 0;                                  return false;                              }                                // parse the number as a binary integer without the prefix' converted to a double                              doubleValue = (double)System.Convert.ToInt64(str.Substring(2)' 2);                          }                          else                          {                              // might be an octal value... try converting to octal                              // and if it fails' just convert to decimal                              try                              {                                  doubleValue = (double)System.Convert.ToInt64(str' 8);                                    // if we got here' we successfully converted it to octal.                                  // now' octal literals are deprecated -- not all JS implementations will                                  // decode them. If this decoded as an octal' it can also be a decimal. Check                                  // the decimal value' and if it's the same' then we'll just treat it                                  // as a normal decimal value. Otherwise we'll throw a warning and treat it                                  // as a special no-convert literal.                                  double decimalValue = (double)System.Convert.ToInt64(str' 10);                                  if (decimalValue != doubleValue)                                  {                                      // throw a warning!                                      ReportError(JsError.OctalLiteralsDeprecated' m_currentToken.Clone()' true);                                        // return false because octals are deprecated and might have                                      // cross-browser issues                                      return false;                                  }                              }                              catch (FormatException)                              {                                  // ignore the format exception and fall through to parsing                                  // the value as a base-10 decimal value                                  doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                              }                          }                      }                      else                      {                          // just parse the integer as a decimal value                          doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                      }                        // check for out-of-bounds integer values -- if the integer can't EXACTLY be represented                      // as a double' then we don't want to consider it "successful"                      if (doubleValue < -0x20000000000000 || 0x20000000000000 < doubleValue)                      {                          return false;                      }                  }                  else                  {                      // use the system to convert the string to a double                      doubleValue = Convert.ToDouble(str' CultureInfo.InvariantCulture);                  }                    // if we got here' we should have an appropriate value in doubleValue                  return true;              }              catch (OverflowException)              {                  // overflow mean just return one of the infinity values                  doubleValue = (str[0] == '-'                    ? Double.NegativeInfinity                    : Double.PositiveInfinity                    );                    // and it wasn't "successful"                  return false;              }              catch (FormatException)              {                  // format exception converts to NaN                  doubleValue = double.NaN;                    // not successful                  return false;              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,GetNextToken,The following statement contains a magic number: if (m_useCurrentForNext)              {                  // we just want to keep using the current token.                  // but don't get into an infinite loop -- after a while'                  // give up and grab the next token from the scanner anyway                  m_useCurrentForNext = false;                  if (m_breakRecursion++ > 10)                  {                      m_currentToken = ScanNextToken();                  }              }              else              {                  m_goodTokensProcessed++;                  m_breakRecursion = 0;                    // the scanner reuses the same context object for performance'                  // so if we ever mean to hold onto it later' we need to clone it.                  m_currentToken = ScanNextToken();              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ScanNextToken,The following statement contains a magic number: while (nextToken.Token == JsToken.WhiteSpace                  || nextToken.Token == JsToken.EndOfLine                  || nextToken.Token == JsToken.SingleLineComment                  || nextToken.Token == JsToken.MultipleLineComment                  || nextToken.Token == JsToken.Error                  || nextToken.Token == JsToken.PreprocessorDirective)              {                  if (nextToken.Token == JsToken.EndOfLine)                  {                      m_foundEndOfLine = true;                  }                  else if (nextToken.Token == JsToken.MultipleLineComment || nextToken.Token == JsToken.SingleLineComment)                  {                      if (nextToken.HasCode                           && ((nextToken.Code.Length > 2 && nextToken.Code[2] == '!')                           || (nextToken.Code.IndexOf("@preserve"' StringComparison.OrdinalIgnoreCase) >= 0)                          || (nextToken.Code.IndexOf("@license"' StringComparison.OrdinalIgnoreCase) >= 0)))                      {                          // this is an important comment -- save it for later                          m_importantComments.Add(nextToken.Clone());                      }                  }                    // if we are preprocess-only' then don't output any preprocessor directive tokens                  EchoWriter.IfNotNull(w => { if (!Settings.PreprocessOnly || nextToken.Token != JsToken.PreprocessorDirective) w.Write(nextToken.Code); });                  nextToken = m_scanner.ScanNextToken(false);              }
Magic Number,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ScanNextToken,The following statement contains a magic number: while (nextToken.Token == JsToken.WhiteSpace                  || nextToken.Token == JsToken.EndOfLine                  || nextToken.Token == JsToken.SingleLineComment                  || nextToken.Token == JsToken.MultipleLineComment                  || nextToken.Token == JsToken.Error                  || nextToken.Token == JsToken.PreprocessorDirective)              {                  if (nextToken.Token == JsToken.EndOfLine)                  {                      m_foundEndOfLine = true;                  }                  else if (nextToken.Token == JsToken.MultipleLineComment || nextToken.Token == JsToken.SingleLineComment)                  {                      if (nextToken.HasCode                           && ((nextToken.Code.Length > 2 && nextToken.Code[2] == '!')                           || (nextToken.Code.IndexOf("@preserve"' StringComparison.OrdinalIgnoreCase) >= 0)                          || (nextToken.Code.IndexOf("@license"' StringComparison.OrdinalIgnoreCase) >= 0)))                      {                          // this is an important comment -- save it for later                          m_importantComments.Add(nextToken.Clone());                      }                  }                    // if we are preprocess-only' then don't output any preprocessor directive tokens                  EchoWriter.IfNotNull(w => { if (!Settings.PreprocessOnly || nextToken.Token != JsToken.PreprocessorDirective) w.Write(nextToken.Code); });                  nextToken = m_scanner.ScanNextToken(false);              }
Magic Number,Baker.Text,JsReorderScopeVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsReorderScopeVisitor.cs,RelocateVar,The following statement contains a magic number: if (block[insertAt] != varStatement)              {                  // check to see if the current position is a var and we are the NEXT statement.                  // if that's the case' we don't need to break out the initializer' just append all the                  // vardecls as-is to the current position.                  var existingVar = block[insertAt] as JsVar;                  if (existingVar != null && block[insertAt + 1] == varStatement)                  {                      // just append our vardecls to the insertion point' then delete our statement                      existingVar.Append(varStatement);                      block.RemoveAt(insertAt + 1);                  }                  else                  {                      // iterate through the decls and count how many have initializers                      var initializerCount = 0;                      for (var ndx = 0; ndx < varStatement.Count; ++ndx)                      {                          if (varStatement[ndx].Initializer != null)                          {                              ++initializerCount;                          }                      }                        // if there are more than two decls with initializers' then we won't actually                      // be gaining anything by moving the var to the top. We'll get rid of the four                      // bytes for the "var "' but we'll be adding two bytes for the name and comma                      // because name=init will still need to remain behind.                      if (initializerCount <= 2)                      {                          // first iterate through all the declarations in the var statement'                          // constructing an expression statement that is made up of assignment                          // operators for each of the declarations that have initializers (if any)                          // and removing all the initializers                          var assignments = new List<JsAstNode>();                          for (var ndx = 0; ndx < varStatement.Count; ++ndx)                          {                              var varDecl = varStatement[ndx];                              if (varDecl.Initializer != null)                              {                                  if (varDecl.IsCCSpecialCase)                                  {                                      // create a vardecl with the same name and no initializer                                      var copyDecl = new JsVariableDeclaration(varDecl.Context' varDecl.Parser)                                          {                                              Identifier = varDecl.Identifier'                                              NameContext = varDecl.VariableField.OriginalContext'                                              VariableField = varDecl.VariableField                                          };                                        // replace the special vardecl with the copy                                      varStatement[ndx] = copyDecl;                                        // add the original vardecl to the list of "assignments"                                      assignments.Add(varDecl);                                        // add the new decl to the field's declaration list' and remove the old one                                      // because we're going to change that to an assignment.                                      varDecl.VariableField.Declarations.Add(copyDecl);                                      varDecl.VariableField.Declarations.Remove(varDecl);                                  }                                  else                                  {                                      // hold on to the object so we don't lose it to the GC                                      var initializer = varDecl.Initializer;                                        // remove it from the vardecl                                      varDecl.Initializer = null;                                        // create an assignment operator for a lookup to the name                                      // as the left' and the initializer as the right' and add it to the list                                      var lookup = new JsLookup(varDecl.VariableField.OriginalContext' varDecl.Parser)                                          {                                              Name = varDecl.Identifier'                                              VariableField = varDecl.VariableField'                                          };                                      assignments.Add(new JsBinaryOperator(varDecl.Context' varDecl.Parser)                                          {                                              Operand1 = lookup'                                              Operand2 = initializer'                                              OperatorToken = JsToken.Assign'                                              OperatorContext = varDecl.AssignContext                                          });                                        // add the new lookup to the field's references                                      varDecl.VariableField.References.Add(lookup);                                  }                              }                          }                            // now if there were any initializers...                          if (assignments.Count > 0)                          {                              // we want to create one big expression from all the assignments and replace the                              // var statement with the assignment(s) expression. Start at position n=1 and create                              // a binary operator of n-1 as the left' n as the right' and using a comma operator.                              var expression = assignments[0];                              for (var ndx = 1; ndx < assignments.Count; ++ndx)                              {                                  expression = JsCommaOperator.CombineWithComma(null' expression.Parser' expression' assignments[ndx]);                              }                                // replace the var with the expression.                              // we still have a pointer to the var' so we can insert it back into the proper                              // place next.                              varStatement.Parent.ReplaceChild(varStatement' expression);                          }                          else                          {                              // no initializers.                              // if the parent is a for-in statement...                              var forInParent = varStatement.Parent as JsForIn;                              if (forInParent != null)                              {                                  // we want to replace the var statement with a lookup for the var                                  // there should be only one vardecl                                  var varDecl = varStatement[0];                                  var lookup = new JsLookup(varDecl.VariableField.OriginalContext' varStatement.Parser)                                      {                                          Name = varDecl.Identifier'                                          VariableField = varDecl.VariableField                                      };                                  varStatement.Parent.ReplaceChild(varStatement' lookup);                                  varDecl.VariableField.References.Add(lookup);                              }                              else                              {                                  // just remove the var statement altogether                                  varStatement.Parent.ReplaceChild(varStatement' null);                              }                          }                            // if the statement at the insertion point is a var-statement already'                          // then we just need to append our vardecls to it. Otherwise we'll insert our                          // var statement at the right point                          if (existingVar != null)                          {                              // append the varstatement we want to move to the existing var' which will                              // transfer all the vardecls to it.                              existingVar.Append(varStatement);                          }                          else                          {                              // move the var to the insert point' incrementing the position or next time                              block.Insert(insertAt' varStatement);                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,JsScanner,The following statement contains a magic number: m_identifier = new StringBuilder(128);
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,JsScanner,The following statement contains a magic number: m_identifier = new StringBuilder(128);
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The following statement contains a magic number: switch (c)              {                  case '\n':                  case '\r':                      token = ScanLineTerminator(c);                      break;                    case '\t':                  case '\v':                  case '\f':                  case ' ':                      // we are asking for raw tokens' and this is the start of a stretch of whitespace.                      // advance to the end of the whitespace' and return that as the token                      token = JsToken.WhiteSpace;                      while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                      {                          ++m_currentPosition;                      }                        break;                    case '!':                      token = JsToken.LogicalNot;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.NotEqual;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictNotEqual;                          }                      }                        break;                    case '"':                  case '\'':                      token = JsToken.StringLiteral;                      ScanString(c);                      break;                    case '$':                  case '_':                      ScanIdentifier();                      token = JsToken.Identifier;                      break;                    case '%':                      token = JsToken.Modulo;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.ModuloAssign;                      }                        break;                    case '&':                      token = JsToken.BitwiseAnd;                      c = GetChar(m_currentPosition);                      if ('&' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalAnd;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseAndAssign;                      }                        break;                    case '(':                      token = JsToken.LeftParenthesis;                      break;                    case ')':                      token = JsToken.RightParenthesis;                      break;                    case '*':                      token = JsToken.Multiply;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.MultiplyAssign;                      }                        break;                    case '+':                      token = JsToken.Plus;                      c = GetChar(m_currentPosition);                      if ('+' == c)                      {                          m_currentPosition++;                          token = JsToken.Increment;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.PlusAssign;                      }                        break;                    case ''':                      token = JsToken.Comma;                      break;                    case '-':                      token = JsToken.Minus;                      c = GetChar(m_currentPosition);                      if ('-' == c)                      {                          m_currentPosition++;                          token = JsToken.Decrement;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.MinusAssign;                      }                        break;                    case '.':                      token = JsToken.AccessField;                      c = GetChar(m_currentPosition);                      if (JsScanner.IsDigit(c))                      {                          token = ScanNumber('.');                      }                        break;                    case '/':                      token = JsToken.Divide;                      c = GetChar(m_currentPosition);                      switch (c)                      {                          case '/':                              token = JsToken.SingleLineComment;                              m_inSingleLineComment = true;                              c = GetChar(++m_currentPosition);                                // see if there is a THIRD slash character                              if (c == '/')                              {                                  // advance past the slash and see if we have one of our special preprocessing directives                                  ++m_currentPosition;                                  if (GetChar(m_currentPosition) == '#')                                  {                                      // scan preprocessing directives                                      token = JsToken.PreprocessorDirective;                                        if (!ScanPreprocessingDirective())                                      {                                          // if it returns false' we don't want to skip the rest of                                          // the comment line; just exit                                          break;                                      }                                  }                              }                              else if (c == '@' && !IgnoreConditionalCompilation)                              {                                  // we got //@                                  // if we have not turned on conditional-compilation yet' then check to see if that's                                  // what we're trying to do now.                                  // we are currently on the @ -- start peeking from there                                  if (m_conditionalCompilationOn                                      || CheckSubstring(m_currentPosition + 1' "cc_on"))                                  {                                      // if the NEXT character is not an identifier character' then we need to skip                                      // the @ character -- otherwise leave it there                                      if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                      {                                          ++m_currentPosition;                                      }                                        // we are now in a conditional comment                                      m_inConditionalComment = true;                                      token = JsToken.ConditionalCommentStart;                                      break;                                  }                              }                                SkipSingleLineComment();                                // if we're still in a multiple-line comment' then we must've been in                              // a multi-line CONDITIONAL comment' in which case this normal one-line comment                              // won't turn off conditional comments just because we hit the end of line.                              if (!m_inMultipleLineComment && m_inConditionalComment)                              {                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                              }                                break;                            case '*':                              m_inMultipleLineComment = true;                              if (GetChar(++m_currentPosition) == '@' && !IgnoreConditionalCompilation)                              {                                  // we have /*@                                  // if we have not turned on conditional-compilation yet' then let's peek to see if the next                                  // few characters are cc_on -- if so' turn it on.                                  if (!m_conditionalCompilationOn)                                  {                                      // we are currently on the @ -- start peeking from there                                      if (!CheckSubstring(m_currentPosition + 1' "cc_on"))                                      {                                          // we aren't turning on conditional comments. We need to ignore this comment                                          // as just another multi-line comment                                          SkipMultilineComment();                                          token = JsToken.MultipleLineComment;                                          break;                                      }                                  }                                    // if the NEXT character is not an identifier character' then we need to skip                                  // the @ character -- otherwise leave it there                                  if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                  {                                      ++m_currentPosition;                                  }                                    // we are now in a conditional comment                                  m_inConditionalComment = true;                                  token = JsToken.ConditionalCommentStart;                                  break;                              }                                SkipMultilineComment();                              token = JsToken.MultipleLineComment;                              break;                            default:                              // if we were passed the hint that we prefer regular expressions                              // over divide operators' then try parsing one now.                              if (scanForRegularExpressionLiterals)                              {                                  // we think this is probably a regular expression.                                  // if it is...                                  if (ScanRegExp() != null)                                  {                                      // also scan the flags (if any)                                      ScanRegExpFlags();                                      token = JsToken.RegularExpression;                                  }                                  else if (c == '=')                                  {                                      m_currentPosition++;                                      token = JsToken.DivideAssign;                                  }                              }                              else if (c == '=')                              {                                  m_currentPosition++;                                  token = JsToken.DivideAssign;                              }                              break;                      }                        break;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      token = ScanNumber(c);                      break;                    case ':':                      token = JsToken.Colon;                      break;                    case ';':                      token = JsToken.Semicolon;                      break;                    case '<':                      if (AllowEmbeddedAspNetBlocks &&                          '%' == GetChar(m_currentPosition))                      {                          token = ScanAspNetBlock();                      }                      else                      {                          token = JsToken.LessThan;                          if ('<' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.LeftShift;                          }                            if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              if (token == JsToken.LessThan)                              {                                  token = JsToken.LessThanEqual;                              }                              else                              {                                  token = JsToken.LeftShiftAssign;                              }                          }                      }                        break;                    case '=':                      token = JsToken.Assign;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.Equal;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictEqual;                          }                      }                        break;                    case '>':                      token = JsToken.GreaterThan;                      if ('>' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.RightShift;                          if ('>' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.UnsignedRightShift;                          }                      }                        if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = token == JsToken.GreaterThan ? JsToken.GreaterThanEqual                              : token == JsToken.RightShift ? JsToken.RightShiftAssign                              : token == JsToken.UnsignedRightShift ? JsToken.UnsignedRightShiftAssign                              : JsToken.Error;                      }                        break;                    case '?':                      token = JsToken.ConditionalIf;                      break;                    case '@':                      if (IgnoreConditionalCompilation)                      {                          // if the switch to ignore conditional compilation is on' then we don't know                          // anything about conditional-compilation statements' and the @-sign character                          // is illegal at this spot.                          token = IllegalCharacter();                          break;                      }                        // see if the @-sign is immediately followed by an identifier. If it is'                      // we'll see which one so we can tell if it's a conditional-compilation statement                      // need to make sure the context INCLUDES the @ sign                      int startPosition = m_currentPosition;                      m_currentToken.StartPosition = startPosition - 1;                      m_currentToken.StartLineNumber = m_currentLine;                      m_currentToken.StartLinePosition = m_startLinePosition;                      ScanIdentifier();                      switch (m_currentPosition - startPosition)                      {                          case 0:                              // look for '@*/'.                              if ('*' == GetChar(m_currentPosition) && '/' == GetChar(++m_currentPosition))                              {                                  m_currentPosition++;                                  m_inMultipleLineComment = false;                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                                  break;                              }                                // otherwise we just have a @ sitting by itself!                              // throw an error and loop back to the next token.                              token = IllegalCharacter();                              break;                            case 2:                              if (CheckSubstring(startPosition' "if"))                              {                                  token = JsToken.ConditionalCompilationIf;                                    // increment the if-level                                  ++m_conditionalCompilationIfLevel;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @if statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 3:                              if (CheckSubstring(startPosition' "set"))                              {                                  token = JsToken.ConditionalCompilationSet;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @set statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "end"))                              {                                  token = JsToken.ConditionalCompilationEnd;                                  if (m_conditionalCompilationIfLevel > 0)                                  {                                      // down one more @if level                                      m_conditionalCompilationIfLevel--;                                  }                                  else                                  {                                      // not corresponding @if -- invalid @end statement                                      HandleError(JsError.CCInvalidEnd);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 4:                              if (CheckSubstring(startPosition' "else"))                              {                                  token = JsToken.ConditionalCompilationElse;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElse);                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "elif"))                              {                                  token = JsToken.ConditionalCompilationElseIf;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElseIf);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 5:                              if (CheckSubstring(startPosition' "cc_on"))                              {                                  // turn it on and return the @cc_on token                                  m_conditionalCompilationOn = true;                                  token = JsToken.ConditionalCompilationOn;                                  break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            default:                              // we have @[id]' where [id] is a valid identifier.                              // if we haven't explicitly turned on conditional compilation'                              // we'll keep processing' but we need to fire an error to indicate                              // that the code should turn it on first.                              if (!m_conditionalCompilationOn)                              {                                  HandleError(JsError.CCOff);                              }                                token = JsToken.ConditionalCompilationVariable;                              break;                      }                        break;                    case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                  case 'G':                  case 'H':                  case 'I':                  case 'J':                  case 'K':                  case 'L':                  case 'M':                  case 'N':                  case 'O':                  case 'P':                  case 'Q':                  case 'R':                  case 'S':                  case 'T':                  case 'U':                  case 'V':                  case 'W':                  case 'X':                  case 'Y':                  case 'Z':                      token = JsToken.Identifier;                      ScanIdentifier();                      break;                    case '[':                      token = JsToken.LeftBracket;                      break;                    case '\\':                      // try decoding a unicode escape sequence. We read the backslash and                      // now the "current" character is the "u"                      if (PeekUnicodeEscape(m_currentPosition' ref c))                      {                          // advance past the escape characters                          m_currentPosition += 5;                            // valid unicode escape sequence                          if (IsValidIdentifierStart(c))                          {                              // use the unescaped character as the first character of the                              // decoded identifier' and current character is now the last position                              // on the builder                              m_identifier.Append(c);                              m_lastPosOnBuilder = m_currentPosition;                                // scan the rest of the identifier                              ScanIdentifier();                                // because it STARTS with an escaped character it cannot be a keyword                              token = JsToken.Identifier;                              break;                          }                      }                      else                      {                          // not a valid unicode escape sequence                          // see if the next character is a valid identifier character                          if (IsValidIdentifierStart(GetChar(m_currentPosition)))                          {                              // we're going to just assume this is an escaped identifier character                              // because some older browsers allow things like \foo ("foo") and                               // \while to be an identifer "while" and not the reserved word                              ScanIdentifier();                              token = JsToken.Identifier;                              break;                          }                      }                        HandleError(JsError.IllegalChar);                      break;                    case ']':                      token = JsToken.RightBracket;                      break;                    case '^':                      token = JsToken.BitwiseXor;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.BitwiseXorAssign;                      }                        break;                    case '#':                  case '`':                      token = IllegalCharacter();                      break;                    case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                  case 'g':                  case 'h':                  case 'i':                  case 'j':                  case 'k':                  case 'l':                  case 'm':                  case 'n':                  case 'o':                  case 'p':                  case 'q':                  case 'r':                  case 's':                  case 't':                  case 'u':                  case 'v':                  case 'w':                  case 'x':                  case 'y':                  case 'z':                      JsKeyword keyword = s_Keywords[c - 'a'];                      if (null != keyword)                      {                          token = ScanKeyword(keyword);                      }                      else                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      break;                    case '{':                      token = JsToken.LeftCurly;                      break;                    case '|':                      token = JsToken.BitwiseOr;                      c = GetChar(m_currentPosition);                      if ('|' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalOr;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseOrAssign;                      }                        break;                    case '}':                      token = JsToken.RightCurly;                      break;                    case '~':                      token = JsToken.BitwiseNot;                      break;                    default:                      if (c == '\0')                      {                          if (IsEndOfFile)                          {                              token = JsToken.EndOfFile;                              m_currentPosition--;                              if (m_conditionalCompilationIfLevel > 0)                              {                                  m_currentToken.EndLineNumber = m_currentLine;                                  m_currentToken.EndLinePosition = m_startLinePosition;                                  m_currentToken.EndPosition = m_currentPosition;                                  HandleError(JsError.NoCCEnd);                              }                          }                          else                          {                              token = IllegalCharacter();                          }                      }                      else if (c == '\u2028' || c == '\u2029')                      {                          // more line terminator                          token = ScanLineTerminator(c);                      }                      else if (IsValidIdentifierStart(c))                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      else if (IsBlankSpace(c))                      {                          // we are asking for raw tokens' and this is the start of a stretch of whitespace.                          // advance to the end of the whitespace' and return that as the token                          while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                          {                              ++m_currentPosition;                          }                          token = JsToken.WhiteSpace;                      }                      else                      {                          token = IllegalCharacter();                      }                        break;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The following statement contains a magic number: switch (c)              {                  case '\n':                  case '\r':                      token = ScanLineTerminator(c);                      break;                    case '\t':                  case '\v':                  case '\f':                  case ' ':                      // we are asking for raw tokens' and this is the start of a stretch of whitespace.                      // advance to the end of the whitespace' and return that as the token                      token = JsToken.WhiteSpace;                      while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                      {                          ++m_currentPosition;                      }                        break;                    case '!':                      token = JsToken.LogicalNot;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.NotEqual;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictNotEqual;                          }                      }                        break;                    case '"':                  case '\'':                      token = JsToken.StringLiteral;                      ScanString(c);                      break;                    case '$':                  case '_':                      ScanIdentifier();                      token = JsToken.Identifier;                      break;                    case '%':                      token = JsToken.Modulo;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.ModuloAssign;                      }                        break;                    case '&':                      token = JsToken.BitwiseAnd;                      c = GetChar(m_currentPosition);                      if ('&' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalAnd;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseAndAssign;                      }                        break;                    case '(':                      token = JsToken.LeftParenthesis;                      break;                    case ')':                      token = JsToken.RightParenthesis;                      break;                    case '*':                      token = JsToken.Multiply;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.MultiplyAssign;                      }                        break;                    case '+':                      token = JsToken.Plus;                      c = GetChar(m_currentPosition);                      if ('+' == c)                      {                          m_currentPosition++;                          token = JsToken.Increment;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.PlusAssign;                      }                        break;                    case ''':                      token = JsToken.Comma;                      break;                    case '-':                      token = JsToken.Minus;                      c = GetChar(m_currentPosition);                      if ('-' == c)                      {                          m_currentPosition++;                          token = JsToken.Decrement;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.MinusAssign;                      }                        break;                    case '.':                      token = JsToken.AccessField;                      c = GetChar(m_currentPosition);                      if (JsScanner.IsDigit(c))                      {                          token = ScanNumber('.');                      }                        break;                    case '/':                      token = JsToken.Divide;                      c = GetChar(m_currentPosition);                      switch (c)                      {                          case '/':                              token = JsToken.SingleLineComment;                              m_inSingleLineComment = true;                              c = GetChar(++m_currentPosition);                                // see if there is a THIRD slash character                              if (c == '/')                              {                                  // advance past the slash and see if we have one of our special preprocessing directives                                  ++m_currentPosition;                                  if (GetChar(m_currentPosition) == '#')                                  {                                      // scan preprocessing directives                                      token = JsToken.PreprocessorDirective;                                        if (!ScanPreprocessingDirective())                                      {                                          // if it returns false' we don't want to skip the rest of                                          // the comment line; just exit                                          break;                                      }                                  }                              }                              else if (c == '@' && !IgnoreConditionalCompilation)                              {                                  // we got //@                                  // if we have not turned on conditional-compilation yet' then check to see if that's                                  // what we're trying to do now.                                  // we are currently on the @ -- start peeking from there                                  if (m_conditionalCompilationOn                                      || CheckSubstring(m_currentPosition + 1' "cc_on"))                                  {                                      // if the NEXT character is not an identifier character' then we need to skip                                      // the @ character -- otherwise leave it there                                      if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                      {                                          ++m_currentPosition;                                      }                                        // we are now in a conditional comment                                      m_inConditionalComment = true;                                      token = JsToken.ConditionalCommentStart;                                      break;                                  }                              }                                SkipSingleLineComment();                                // if we're still in a multiple-line comment' then we must've been in                              // a multi-line CONDITIONAL comment' in which case this normal one-line comment                              // won't turn off conditional comments just because we hit the end of line.                              if (!m_inMultipleLineComment && m_inConditionalComment)                              {                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                              }                                break;                            case '*':                              m_inMultipleLineComment = true;                              if (GetChar(++m_currentPosition) == '@' && !IgnoreConditionalCompilation)                              {                                  // we have /*@                                  // if we have not turned on conditional-compilation yet' then let's peek to see if the next                                  // few characters are cc_on -- if so' turn it on.                                  if (!m_conditionalCompilationOn)                                  {                                      // we are currently on the @ -- start peeking from there                                      if (!CheckSubstring(m_currentPosition + 1' "cc_on"))                                      {                                          // we aren't turning on conditional comments. We need to ignore this comment                                          // as just another multi-line comment                                          SkipMultilineComment();                                          token = JsToken.MultipleLineComment;                                          break;                                      }                                  }                                    // if the NEXT character is not an identifier character' then we need to skip                                  // the @ character -- otherwise leave it there                                  if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                  {                                      ++m_currentPosition;                                  }                                    // we are now in a conditional comment                                  m_inConditionalComment = true;                                  token = JsToken.ConditionalCommentStart;                                  break;                              }                                SkipMultilineComment();                              token = JsToken.MultipleLineComment;                              break;                            default:                              // if we were passed the hint that we prefer regular expressions                              // over divide operators' then try parsing one now.                              if (scanForRegularExpressionLiterals)                              {                                  // we think this is probably a regular expression.                                  // if it is...                                  if (ScanRegExp() != null)                                  {                                      // also scan the flags (if any)                                      ScanRegExpFlags();                                      token = JsToken.RegularExpression;                                  }                                  else if (c == '=')                                  {                                      m_currentPosition++;                                      token = JsToken.DivideAssign;                                  }                              }                              else if (c == '=')                              {                                  m_currentPosition++;                                  token = JsToken.DivideAssign;                              }                              break;                      }                        break;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      token = ScanNumber(c);                      break;                    case ':':                      token = JsToken.Colon;                      break;                    case ';':                      token = JsToken.Semicolon;                      break;                    case '<':                      if (AllowEmbeddedAspNetBlocks &&                          '%' == GetChar(m_currentPosition))                      {                          token = ScanAspNetBlock();                      }                      else                      {                          token = JsToken.LessThan;                          if ('<' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.LeftShift;                          }                            if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              if (token == JsToken.LessThan)                              {                                  token = JsToken.LessThanEqual;                              }                              else                              {                                  token = JsToken.LeftShiftAssign;                              }                          }                      }                        break;                    case '=':                      token = JsToken.Assign;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.Equal;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictEqual;                          }                      }                        break;                    case '>':                      token = JsToken.GreaterThan;                      if ('>' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.RightShift;                          if ('>' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.UnsignedRightShift;                          }                      }                        if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = token == JsToken.GreaterThan ? JsToken.GreaterThanEqual                              : token == JsToken.RightShift ? JsToken.RightShiftAssign                              : token == JsToken.UnsignedRightShift ? JsToken.UnsignedRightShiftAssign                              : JsToken.Error;                      }                        break;                    case '?':                      token = JsToken.ConditionalIf;                      break;                    case '@':                      if (IgnoreConditionalCompilation)                      {                          // if the switch to ignore conditional compilation is on' then we don't know                          // anything about conditional-compilation statements' and the @-sign character                          // is illegal at this spot.                          token = IllegalCharacter();                          break;                      }                        // see if the @-sign is immediately followed by an identifier. If it is'                      // we'll see which one so we can tell if it's a conditional-compilation statement                      // need to make sure the context INCLUDES the @ sign                      int startPosition = m_currentPosition;                      m_currentToken.StartPosition = startPosition - 1;                      m_currentToken.StartLineNumber = m_currentLine;                      m_currentToken.StartLinePosition = m_startLinePosition;                      ScanIdentifier();                      switch (m_currentPosition - startPosition)                      {                          case 0:                              // look for '@*/'.                              if ('*' == GetChar(m_currentPosition) && '/' == GetChar(++m_currentPosition))                              {                                  m_currentPosition++;                                  m_inMultipleLineComment = false;                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                                  break;                              }                                // otherwise we just have a @ sitting by itself!                              // throw an error and loop back to the next token.                              token = IllegalCharacter();                              break;                            case 2:                              if (CheckSubstring(startPosition' "if"))                              {                                  token = JsToken.ConditionalCompilationIf;                                    // increment the if-level                                  ++m_conditionalCompilationIfLevel;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @if statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 3:                              if (CheckSubstring(startPosition' "set"))                              {                                  token = JsToken.ConditionalCompilationSet;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @set statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "end"))                              {                                  token = JsToken.ConditionalCompilationEnd;                                  if (m_conditionalCompilationIfLevel > 0)                                  {                                      // down one more @if level                                      m_conditionalCompilationIfLevel--;                                  }                                  else                                  {                                      // not corresponding @if -- invalid @end statement                                      HandleError(JsError.CCInvalidEnd);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 4:                              if (CheckSubstring(startPosition' "else"))                              {                                  token = JsToken.ConditionalCompilationElse;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElse);                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "elif"))                              {                                  token = JsToken.ConditionalCompilationElseIf;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElseIf);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 5:                              if (CheckSubstring(startPosition' "cc_on"))                              {                                  // turn it on and return the @cc_on token                                  m_conditionalCompilationOn = true;                                  token = JsToken.ConditionalCompilationOn;                                  break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            default:                              // we have @[id]' where [id] is a valid identifier.                              // if we haven't explicitly turned on conditional compilation'                              // we'll keep processing' but we need to fire an error to indicate                              // that the code should turn it on first.                              if (!m_conditionalCompilationOn)                              {                                  HandleError(JsError.CCOff);                              }                                token = JsToken.ConditionalCompilationVariable;                              break;                      }                        break;                    case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                  case 'G':                  case 'H':                  case 'I':                  case 'J':                  case 'K':                  case 'L':                  case 'M':                  case 'N':                  case 'O':                  case 'P':                  case 'Q':                  case 'R':                  case 'S':                  case 'T':                  case 'U':                  case 'V':                  case 'W':                  case 'X':                  case 'Y':                  case 'Z':                      token = JsToken.Identifier;                      ScanIdentifier();                      break;                    case '[':                      token = JsToken.LeftBracket;                      break;                    case '\\':                      // try decoding a unicode escape sequence. We read the backslash and                      // now the "current" character is the "u"                      if (PeekUnicodeEscape(m_currentPosition' ref c))                      {                          // advance past the escape characters                          m_currentPosition += 5;                            // valid unicode escape sequence                          if (IsValidIdentifierStart(c))                          {                              // use the unescaped character as the first character of the                              // decoded identifier' and current character is now the last position                              // on the builder                              m_identifier.Append(c);                              m_lastPosOnBuilder = m_currentPosition;                                // scan the rest of the identifier                              ScanIdentifier();                                // because it STARTS with an escaped character it cannot be a keyword                              token = JsToken.Identifier;                              break;                          }                      }                      else                      {                          // not a valid unicode escape sequence                          // see if the next character is a valid identifier character                          if (IsValidIdentifierStart(GetChar(m_currentPosition)))                          {                              // we're going to just assume this is an escaped identifier character                              // because some older browsers allow things like \foo ("foo") and                               // \while to be an identifer "while" and not the reserved word                              ScanIdentifier();                              token = JsToken.Identifier;                              break;                          }                      }                        HandleError(JsError.IllegalChar);                      break;                    case ']':                      token = JsToken.RightBracket;                      break;                    case '^':                      token = JsToken.BitwiseXor;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.BitwiseXorAssign;                      }                        break;                    case '#':                  case '`':                      token = IllegalCharacter();                      break;                    case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                  case 'g':                  case 'h':                  case 'i':                  case 'j':                  case 'k':                  case 'l':                  case 'm':                  case 'n':                  case 'o':                  case 'p':                  case 'q':                  case 'r':                  case 's':                  case 't':                  case 'u':                  case 'v':                  case 'w':                  case 'x':                  case 'y':                  case 'z':                      JsKeyword keyword = s_Keywords[c - 'a'];                      if (null != keyword)                      {                          token = ScanKeyword(keyword);                      }                      else                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      break;                    case '{':                      token = JsToken.LeftCurly;                      break;                    case '|':                      token = JsToken.BitwiseOr;                      c = GetChar(m_currentPosition);                      if ('|' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalOr;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseOrAssign;                      }                        break;                    case '}':                      token = JsToken.RightCurly;                      break;                    case '~':                      token = JsToken.BitwiseNot;                      break;                    default:                      if (c == '\0')                      {                          if (IsEndOfFile)                          {                              token = JsToken.EndOfFile;                              m_currentPosition--;                              if (m_conditionalCompilationIfLevel > 0)                              {                                  m_currentToken.EndLineNumber = m_currentLine;                                  m_currentToken.EndLinePosition = m_startLinePosition;                                  m_currentToken.EndPosition = m_currentPosition;                                  HandleError(JsError.NoCCEnd);                              }                          }                          else                          {                              token = IllegalCharacter();                          }                      }                      else if (c == '\u2028' || c == '\u2029')                      {                          // more line terminator                          token = ScanLineTerminator(c);                      }                      else if (IsValidIdentifierStart(c))                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      else if (IsBlankSpace(c))                      {                          // we are asking for raw tokens' and this is the start of a stretch of whitespace.                          // advance to the end of the whitespace' and return that as the token                          while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                          {                              ++m_currentPosition;                          }                          token = JsToken.WhiteSpace;                      }                      else                      {                          token = IllegalCharacter();                      }                        break;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The following statement contains a magic number: switch (c)              {                  case '\n':                  case '\r':                      token = ScanLineTerminator(c);                      break;                    case '\t':                  case '\v':                  case '\f':                  case ' ':                      // we are asking for raw tokens' and this is the start of a stretch of whitespace.                      // advance to the end of the whitespace' and return that as the token                      token = JsToken.WhiteSpace;                      while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                      {                          ++m_currentPosition;                      }                        break;                    case '!':                      token = JsToken.LogicalNot;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.NotEqual;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictNotEqual;                          }                      }                        break;                    case '"':                  case '\'':                      token = JsToken.StringLiteral;                      ScanString(c);                      break;                    case '$':                  case '_':                      ScanIdentifier();                      token = JsToken.Identifier;                      break;                    case '%':                      token = JsToken.Modulo;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.ModuloAssign;                      }                        break;                    case '&':                      token = JsToken.BitwiseAnd;                      c = GetChar(m_currentPosition);                      if ('&' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalAnd;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseAndAssign;                      }                        break;                    case '(':                      token = JsToken.LeftParenthesis;                      break;                    case ')':                      token = JsToken.RightParenthesis;                      break;                    case '*':                      token = JsToken.Multiply;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.MultiplyAssign;                      }                        break;                    case '+':                      token = JsToken.Plus;                      c = GetChar(m_currentPosition);                      if ('+' == c)                      {                          m_currentPosition++;                          token = JsToken.Increment;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.PlusAssign;                      }                        break;                    case ''':                      token = JsToken.Comma;                      break;                    case '-':                      token = JsToken.Minus;                      c = GetChar(m_currentPosition);                      if ('-' == c)                      {                          m_currentPosition++;                          token = JsToken.Decrement;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.MinusAssign;                      }                        break;                    case '.':                      token = JsToken.AccessField;                      c = GetChar(m_currentPosition);                      if (JsScanner.IsDigit(c))                      {                          token = ScanNumber('.');                      }                        break;                    case '/':                      token = JsToken.Divide;                      c = GetChar(m_currentPosition);                      switch (c)                      {                          case '/':                              token = JsToken.SingleLineComment;                              m_inSingleLineComment = true;                              c = GetChar(++m_currentPosition);                                // see if there is a THIRD slash character                              if (c == '/')                              {                                  // advance past the slash and see if we have one of our special preprocessing directives                                  ++m_currentPosition;                                  if (GetChar(m_currentPosition) == '#')                                  {                                      // scan preprocessing directives                                      token = JsToken.PreprocessorDirective;                                        if (!ScanPreprocessingDirective())                                      {                                          // if it returns false' we don't want to skip the rest of                                          // the comment line; just exit                                          break;                                      }                                  }                              }                              else if (c == '@' && !IgnoreConditionalCompilation)                              {                                  // we got //@                                  // if we have not turned on conditional-compilation yet' then check to see if that's                                  // what we're trying to do now.                                  // we are currently on the @ -- start peeking from there                                  if (m_conditionalCompilationOn                                      || CheckSubstring(m_currentPosition + 1' "cc_on"))                                  {                                      // if the NEXT character is not an identifier character' then we need to skip                                      // the @ character -- otherwise leave it there                                      if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                      {                                          ++m_currentPosition;                                      }                                        // we are now in a conditional comment                                      m_inConditionalComment = true;                                      token = JsToken.ConditionalCommentStart;                                      break;                                  }                              }                                SkipSingleLineComment();                                // if we're still in a multiple-line comment' then we must've been in                              // a multi-line CONDITIONAL comment' in which case this normal one-line comment                              // won't turn off conditional comments just because we hit the end of line.                              if (!m_inMultipleLineComment && m_inConditionalComment)                              {                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                              }                                break;                            case '*':                              m_inMultipleLineComment = true;                              if (GetChar(++m_currentPosition) == '@' && !IgnoreConditionalCompilation)                              {                                  // we have /*@                                  // if we have not turned on conditional-compilation yet' then let's peek to see if the next                                  // few characters are cc_on -- if so' turn it on.                                  if (!m_conditionalCompilationOn)                                  {                                      // we are currently on the @ -- start peeking from there                                      if (!CheckSubstring(m_currentPosition + 1' "cc_on"))                                      {                                          // we aren't turning on conditional comments. We need to ignore this comment                                          // as just another multi-line comment                                          SkipMultilineComment();                                          token = JsToken.MultipleLineComment;                                          break;                                      }                                  }                                    // if the NEXT character is not an identifier character' then we need to skip                                  // the @ character -- otherwise leave it there                                  if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                  {                                      ++m_currentPosition;                                  }                                    // we are now in a conditional comment                                  m_inConditionalComment = true;                                  token = JsToken.ConditionalCommentStart;                                  break;                              }                                SkipMultilineComment();                              token = JsToken.MultipleLineComment;                              break;                            default:                              // if we were passed the hint that we prefer regular expressions                              // over divide operators' then try parsing one now.                              if (scanForRegularExpressionLiterals)                              {                                  // we think this is probably a regular expression.                                  // if it is...                                  if (ScanRegExp() != null)                                  {                                      // also scan the flags (if any)                                      ScanRegExpFlags();                                      token = JsToken.RegularExpression;                                  }                                  else if (c == '=')                                  {                                      m_currentPosition++;                                      token = JsToken.DivideAssign;                                  }                              }                              else if (c == '=')                              {                                  m_currentPosition++;                                  token = JsToken.DivideAssign;                              }                              break;                      }                        break;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      token = ScanNumber(c);                      break;                    case ':':                      token = JsToken.Colon;                      break;                    case ';':                      token = JsToken.Semicolon;                      break;                    case '<':                      if (AllowEmbeddedAspNetBlocks &&                          '%' == GetChar(m_currentPosition))                      {                          token = ScanAspNetBlock();                      }                      else                      {                          token = JsToken.LessThan;                          if ('<' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.LeftShift;                          }                            if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              if (token == JsToken.LessThan)                              {                                  token = JsToken.LessThanEqual;                              }                              else                              {                                  token = JsToken.LeftShiftAssign;                              }                          }                      }                        break;                    case '=':                      token = JsToken.Assign;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.Equal;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictEqual;                          }                      }                        break;                    case '>':                      token = JsToken.GreaterThan;                      if ('>' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.RightShift;                          if ('>' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.UnsignedRightShift;                          }                      }                        if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = token == JsToken.GreaterThan ? JsToken.GreaterThanEqual                              : token == JsToken.RightShift ? JsToken.RightShiftAssign                              : token == JsToken.UnsignedRightShift ? JsToken.UnsignedRightShiftAssign                              : JsToken.Error;                      }                        break;                    case '?':                      token = JsToken.ConditionalIf;                      break;                    case '@':                      if (IgnoreConditionalCompilation)                      {                          // if the switch to ignore conditional compilation is on' then we don't know                          // anything about conditional-compilation statements' and the @-sign character                          // is illegal at this spot.                          token = IllegalCharacter();                          break;                      }                        // see if the @-sign is immediately followed by an identifier. If it is'                      // we'll see which one so we can tell if it's a conditional-compilation statement                      // need to make sure the context INCLUDES the @ sign                      int startPosition = m_currentPosition;                      m_currentToken.StartPosition = startPosition - 1;                      m_currentToken.StartLineNumber = m_currentLine;                      m_currentToken.StartLinePosition = m_startLinePosition;                      ScanIdentifier();                      switch (m_currentPosition - startPosition)                      {                          case 0:                              // look for '@*/'.                              if ('*' == GetChar(m_currentPosition) && '/' == GetChar(++m_currentPosition))                              {                                  m_currentPosition++;                                  m_inMultipleLineComment = false;                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                                  break;                              }                                // otherwise we just have a @ sitting by itself!                              // throw an error and loop back to the next token.                              token = IllegalCharacter();                              break;                            case 2:                              if (CheckSubstring(startPosition' "if"))                              {                                  token = JsToken.ConditionalCompilationIf;                                    // increment the if-level                                  ++m_conditionalCompilationIfLevel;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @if statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 3:                              if (CheckSubstring(startPosition' "set"))                              {                                  token = JsToken.ConditionalCompilationSet;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @set statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "end"))                              {                                  token = JsToken.ConditionalCompilationEnd;                                  if (m_conditionalCompilationIfLevel > 0)                                  {                                      // down one more @if level                                      m_conditionalCompilationIfLevel--;                                  }                                  else                                  {                                      // not corresponding @if -- invalid @end statement                                      HandleError(JsError.CCInvalidEnd);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 4:                              if (CheckSubstring(startPosition' "else"))                              {                                  token = JsToken.ConditionalCompilationElse;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElse);                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "elif"))                              {                                  token = JsToken.ConditionalCompilationElseIf;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElseIf);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 5:                              if (CheckSubstring(startPosition' "cc_on"))                              {                                  // turn it on and return the @cc_on token                                  m_conditionalCompilationOn = true;                                  token = JsToken.ConditionalCompilationOn;                                  break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            default:                              // we have @[id]' where [id] is a valid identifier.                              // if we haven't explicitly turned on conditional compilation'                              // we'll keep processing' but we need to fire an error to indicate                              // that the code should turn it on first.                              if (!m_conditionalCompilationOn)                              {                                  HandleError(JsError.CCOff);                              }                                token = JsToken.ConditionalCompilationVariable;                              break;                      }                        break;                    case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                  case 'G':                  case 'H':                  case 'I':                  case 'J':                  case 'K':                  case 'L':                  case 'M':                  case 'N':                  case 'O':                  case 'P':                  case 'Q':                  case 'R':                  case 'S':                  case 'T':                  case 'U':                  case 'V':                  case 'W':                  case 'X':                  case 'Y':                  case 'Z':                      token = JsToken.Identifier;                      ScanIdentifier();                      break;                    case '[':                      token = JsToken.LeftBracket;                      break;                    case '\\':                      // try decoding a unicode escape sequence. We read the backslash and                      // now the "current" character is the "u"                      if (PeekUnicodeEscape(m_currentPosition' ref c))                      {                          // advance past the escape characters                          m_currentPosition += 5;                            // valid unicode escape sequence                          if (IsValidIdentifierStart(c))                          {                              // use the unescaped character as the first character of the                              // decoded identifier' and current character is now the last position                              // on the builder                              m_identifier.Append(c);                              m_lastPosOnBuilder = m_currentPosition;                                // scan the rest of the identifier                              ScanIdentifier();                                // because it STARTS with an escaped character it cannot be a keyword                              token = JsToken.Identifier;                              break;                          }                      }                      else                      {                          // not a valid unicode escape sequence                          // see if the next character is a valid identifier character                          if (IsValidIdentifierStart(GetChar(m_currentPosition)))                          {                              // we're going to just assume this is an escaped identifier character                              // because some older browsers allow things like \foo ("foo") and                               // \while to be an identifer "while" and not the reserved word                              ScanIdentifier();                              token = JsToken.Identifier;                              break;                          }                      }                        HandleError(JsError.IllegalChar);                      break;                    case ']':                      token = JsToken.RightBracket;                      break;                    case '^':                      token = JsToken.BitwiseXor;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.BitwiseXorAssign;                      }                        break;                    case '#':                  case '`':                      token = IllegalCharacter();                      break;                    case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                  case 'g':                  case 'h':                  case 'i':                  case 'j':                  case 'k':                  case 'l':                  case 'm':                  case 'n':                  case 'o':                  case 'p':                  case 'q':                  case 'r':                  case 's':                  case 't':                  case 'u':                  case 'v':                  case 'w':                  case 'x':                  case 'y':                  case 'z':                      JsKeyword keyword = s_Keywords[c - 'a'];                      if (null != keyword)                      {                          token = ScanKeyword(keyword);                      }                      else                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      break;                    case '{':                      token = JsToken.LeftCurly;                      break;                    case '|':                      token = JsToken.BitwiseOr;                      c = GetChar(m_currentPosition);                      if ('|' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalOr;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseOrAssign;                      }                        break;                    case '}':                      token = JsToken.RightCurly;                      break;                    case '~':                      token = JsToken.BitwiseNot;                      break;                    default:                      if (c == '\0')                      {                          if (IsEndOfFile)                          {                              token = JsToken.EndOfFile;                              m_currentPosition--;                              if (m_conditionalCompilationIfLevel > 0)                              {                                  m_currentToken.EndLineNumber = m_currentLine;                                  m_currentToken.EndLinePosition = m_startLinePosition;                                  m_currentToken.EndPosition = m_currentPosition;                                  HandleError(JsError.NoCCEnd);                              }                          }                          else                          {                              token = IllegalCharacter();                          }                      }                      else if (c == '\u2028' || c == '\u2029')                      {                          // more line terminator                          token = ScanLineTerminator(c);                      }                      else if (IsValidIdentifierStart(c))                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      else if (IsBlankSpace(c))                      {                          // we are asking for raw tokens' and this is the start of a stretch of whitespace.                          // advance to the end of the whitespace' and return that as the token                          while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                          {                              ++m_currentPosition;                          }                          token = JsToken.WhiteSpace;                      }                      else                      {                          token = IllegalCharacter();                      }                        break;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The following statement contains a magic number: switch (c)              {                  case '\n':                  case '\r':                      token = ScanLineTerminator(c);                      break;                    case '\t':                  case '\v':                  case '\f':                  case ' ':                      // we are asking for raw tokens' and this is the start of a stretch of whitespace.                      // advance to the end of the whitespace' and return that as the token                      token = JsToken.WhiteSpace;                      while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                      {                          ++m_currentPosition;                      }                        break;                    case '!':                      token = JsToken.LogicalNot;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.NotEqual;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictNotEqual;                          }                      }                        break;                    case '"':                  case '\'':                      token = JsToken.StringLiteral;                      ScanString(c);                      break;                    case '$':                  case '_':                      ScanIdentifier();                      token = JsToken.Identifier;                      break;                    case '%':                      token = JsToken.Modulo;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.ModuloAssign;                      }                        break;                    case '&':                      token = JsToken.BitwiseAnd;                      c = GetChar(m_currentPosition);                      if ('&' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalAnd;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseAndAssign;                      }                        break;                    case '(':                      token = JsToken.LeftParenthesis;                      break;                    case ')':                      token = JsToken.RightParenthesis;                      break;                    case '*':                      token = JsToken.Multiply;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.MultiplyAssign;                      }                        break;                    case '+':                      token = JsToken.Plus;                      c = GetChar(m_currentPosition);                      if ('+' == c)                      {                          m_currentPosition++;                          token = JsToken.Increment;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.PlusAssign;                      }                        break;                    case ''':                      token = JsToken.Comma;                      break;                    case '-':                      token = JsToken.Minus;                      c = GetChar(m_currentPosition);                      if ('-' == c)                      {                          m_currentPosition++;                          token = JsToken.Decrement;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.MinusAssign;                      }                        break;                    case '.':                      token = JsToken.AccessField;                      c = GetChar(m_currentPosition);                      if (JsScanner.IsDigit(c))                      {                          token = ScanNumber('.');                      }                        break;                    case '/':                      token = JsToken.Divide;                      c = GetChar(m_currentPosition);                      switch (c)                      {                          case '/':                              token = JsToken.SingleLineComment;                              m_inSingleLineComment = true;                              c = GetChar(++m_currentPosition);                                // see if there is a THIRD slash character                              if (c == '/')                              {                                  // advance past the slash and see if we have one of our special preprocessing directives                                  ++m_currentPosition;                                  if (GetChar(m_currentPosition) == '#')                                  {                                      // scan preprocessing directives                                      token = JsToken.PreprocessorDirective;                                        if (!ScanPreprocessingDirective())                                      {                                          // if it returns false' we don't want to skip the rest of                                          // the comment line; just exit                                          break;                                      }                                  }                              }                              else if (c == '@' && !IgnoreConditionalCompilation)                              {                                  // we got //@                                  // if we have not turned on conditional-compilation yet' then check to see if that's                                  // what we're trying to do now.                                  // we are currently on the @ -- start peeking from there                                  if (m_conditionalCompilationOn                                      || CheckSubstring(m_currentPosition + 1' "cc_on"))                                  {                                      // if the NEXT character is not an identifier character' then we need to skip                                      // the @ character -- otherwise leave it there                                      if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                      {                                          ++m_currentPosition;                                      }                                        // we are now in a conditional comment                                      m_inConditionalComment = true;                                      token = JsToken.ConditionalCommentStart;                                      break;                                  }                              }                                SkipSingleLineComment();                                // if we're still in a multiple-line comment' then we must've been in                              // a multi-line CONDITIONAL comment' in which case this normal one-line comment                              // won't turn off conditional comments just because we hit the end of line.                              if (!m_inMultipleLineComment && m_inConditionalComment)                              {                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                              }                                break;                            case '*':                              m_inMultipleLineComment = true;                              if (GetChar(++m_currentPosition) == '@' && !IgnoreConditionalCompilation)                              {                                  // we have /*@                                  // if we have not turned on conditional-compilation yet' then let's peek to see if the next                                  // few characters are cc_on -- if so' turn it on.                                  if (!m_conditionalCompilationOn)                                  {                                      // we are currently on the @ -- start peeking from there                                      if (!CheckSubstring(m_currentPosition + 1' "cc_on"))                                      {                                          // we aren't turning on conditional comments. We need to ignore this comment                                          // as just another multi-line comment                                          SkipMultilineComment();                                          token = JsToken.MultipleLineComment;                                          break;                                      }                                  }                                    // if the NEXT character is not an identifier character' then we need to skip                                  // the @ character -- otherwise leave it there                                  if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                  {                                      ++m_currentPosition;                                  }                                    // we are now in a conditional comment                                  m_inConditionalComment = true;                                  token = JsToken.ConditionalCommentStart;                                  break;                              }                                SkipMultilineComment();                              token = JsToken.MultipleLineComment;                              break;                            default:                              // if we were passed the hint that we prefer regular expressions                              // over divide operators' then try parsing one now.                              if (scanForRegularExpressionLiterals)                              {                                  // we think this is probably a regular expression.                                  // if it is...                                  if (ScanRegExp() != null)                                  {                                      // also scan the flags (if any)                                      ScanRegExpFlags();                                      token = JsToken.RegularExpression;                                  }                                  else if (c == '=')                                  {                                      m_currentPosition++;                                      token = JsToken.DivideAssign;                                  }                              }                              else if (c == '=')                              {                                  m_currentPosition++;                                  token = JsToken.DivideAssign;                              }                              break;                      }                        break;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      token = ScanNumber(c);                      break;                    case ':':                      token = JsToken.Colon;                      break;                    case ';':                      token = JsToken.Semicolon;                      break;                    case '<':                      if (AllowEmbeddedAspNetBlocks &&                          '%' == GetChar(m_currentPosition))                      {                          token = ScanAspNetBlock();                      }                      else                      {                          token = JsToken.LessThan;                          if ('<' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.LeftShift;                          }                            if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              if (token == JsToken.LessThan)                              {                                  token = JsToken.LessThanEqual;                              }                              else                              {                                  token = JsToken.LeftShiftAssign;                              }                          }                      }                        break;                    case '=':                      token = JsToken.Assign;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.Equal;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictEqual;                          }                      }                        break;                    case '>':                      token = JsToken.GreaterThan;                      if ('>' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.RightShift;                          if ('>' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.UnsignedRightShift;                          }                      }                        if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = token == JsToken.GreaterThan ? JsToken.GreaterThanEqual                              : token == JsToken.RightShift ? JsToken.RightShiftAssign                              : token == JsToken.UnsignedRightShift ? JsToken.UnsignedRightShiftAssign                              : JsToken.Error;                      }                        break;                    case '?':                      token = JsToken.ConditionalIf;                      break;                    case '@':                      if (IgnoreConditionalCompilation)                      {                          // if the switch to ignore conditional compilation is on' then we don't know                          // anything about conditional-compilation statements' and the @-sign character                          // is illegal at this spot.                          token = IllegalCharacter();                          break;                      }                        // see if the @-sign is immediately followed by an identifier. If it is'                      // we'll see which one so we can tell if it's a conditional-compilation statement                      // need to make sure the context INCLUDES the @ sign                      int startPosition = m_currentPosition;                      m_currentToken.StartPosition = startPosition - 1;                      m_currentToken.StartLineNumber = m_currentLine;                      m_currentToken.StartLinePosition = m_startLinePosition;                      ScanIdentifier();                      switch (m_currentPosition - startPosition)                      {                          case 0:                              // look for '@*/'.                              if ('*' == GetChar(m_currentPosition) && '/' == GetChar(++m_currentPosition))                              {                                  m_currentPosition++;                                  m_inMultipleLineComment = false;                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                                  break;                              }                                // otherwise we just have a @ sitting by itself!                              // throw an error and loop back to the next token.                              token = IllegalCharacter();                              break;                            case 2:                              if (CheckSubstring(startPosition' "if"))                              {                                  token = JsToken.ConditionalCompilationIf;                                    // increment the if-level                                  ++m_conditionalCompilationIfLevel;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @if statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 3:                              if (CheckSubstring(startPosition' "set"))                              {                                  token = JsToken.ConditionalCompilationSet;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @set statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "end"))                              {                                  token = JsToken.ConditionalCompilationEnd;                                  if (m_conditionalCompilationIfLevel > 0)                                  {                                      // down one more @if level                                      m_conditionalCompilationIfLevel--;                                  }                                  else                                  {                                      // not corresponding @if -- invalid @end statement                                      HandleError(JsError.CCInvalidEnd);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 4:                              if (CheckSubstring(startPosition' "else"))                              {                                  token = JsToken.ConditionalCompilationElse;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElse);                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "elif"))                              {                                  token = JsToken.ConditionalCompilationElseIf;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElseIf);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 5:                              if (CheckSubstring(startPosition' "cc_on"))                              {                                  // turn it on and return the @cc_on token                                  m_conditionalCompilationOn = true;                                  token = JsToken.ConditionalCompilationOn;                                  break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            default:                              // we have @[id]' where [id] is a valid identifier.                              // if we haven't explicitly turned on conditional compilation'                              // we'll keep processing' but we need to fire an error to indicate                              // that the code should turn it on first.                              if (!m_conditionalCompilationOn)                              {                                  HandleError(JsError.CCOff);                              }                                token = JsToken.ConditionalCompilationVariable;                              break;                      }                        break;                    case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                  case 'G':                  case 'H':                  case 'I':                  case 'J':                  case 'K':                  case 'L':                  case 'M':                  case 'N':                  case 'O':                  case 'P':                  case 'Q':                  case 'R':                  case 'S':                  case 'T':                  case 'U':                  case 'V':                  case 'W':                  case 'X':                  case 'Y':                  case 'Z':                      token = JsToken.Identifier;                      ScanIdentifier();                      break;                    case '[':                      token = JsToken.LeftBracket;                      break;                    case '\\':                      // try decoding a unicode escape sequence. We read the backslash and                      // now the "current" character is the "u"                      if (PeekUnicodeEscape(m_currentPosition' ref c))                      {                          // advance past the escape characters                          m_currentPosition += 5;                            // valid unicode escape sequence                          if (IsValidIdentifierStart(c))                          {                              // use the unescaped character as the first character of the                              // decoded identifier' and current character is now the last position                              // on the builder                              m_identifier.Append(c);                              m_lastPosOnBuilder = m_currentPosition;                                // scan the rest of the identifier                              ScanIdentifier();                                // because it STARTS with an escaped character it cannot be a keyword                              token = JsToken.Identifier;                              break;                          }                      }                      else                      {                          // not a valid unicode escape sequence                          // see if the next character is a valid identifier character                          if (IsValidIdentifierStart(GetChar(m_currentPosition)))                          {                              // we're going to just assume this is an escaped identifier character                              // because some older browsers allow things like \foo ("foo") and                               // \while to be an identifer "while" and not the reserved word                              ScanIdentifier();                              token = JsToken.Identifier;                              break;                          }                      }                        HandleError(JsError.IllegalChar);                      break;                    case ']':                      token = JsToken.RightBracket;                      break;                    case '^':                      token = JsToken.BitwiseXor;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.BitwiseXorAssign;                      }                        break;                    case '#':                  case '`':                      token = IllegalCharacter();                      break;                    case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                  case 'g':                  case 'h':                  case 'i':                  case 'j':                  case 'k':                  case 'l':                  case 'm':                  case 'n':                  case 'o':                  case 'p':                  case 'q':                  case 'r':                  case 's':                  case 't':                  case 'u':                  case 'v':                  case 'w':                  case 'x':                  case 'y':                  case 'z':                      JsKeyword keyword = s_Keywords[c - 'a'];                      if (null != keyword)                      {                          token = ScanKeyword(keyword);                      }                      else                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      break;                    case '{':                      token = JsToken.LeftCurly;                      break;                    case '|':                      token = JsToken.BitwiseOr;                      c = GetChar(m_currentPosition);                      if ('|' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalOr;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseOrAssign;                      }                        break;                    case '}':                      token = JsToken.RightCurly;                      break;                    case '~':                      token = JsToken.BitwiseNot;                      break;                    default:                      if (c == '\0')                      {                          if (IsEndOfFile)                          {                              token = JsToken.EndOfFile;                              m_currentPosition--;                              if (m_conditionalCompilationIfLevel > 0)                              {                                  m_currentToken.EndLineNumber = m_currentLine;                                  m_currentToken.EndLinePosition = m_startLinePosition;                                  m_currentToken.EndPosition = m_currentPosition;                                  HandleError(JsError.NoCCEnd);                              }                          }                          else                          {                              token = IllegalCharacter();                          }                      }                      else if (c == '\u2028' || c == '\u2029')                      {                          // more line terminator                          token = ScanLineTerminator(c);                      }                      else if (IsValidIdentifierStart(c))                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      else if (IsBlankSpace(c))                      {                          // we are asking for raw tokens' and this is the start of a stretch of whitespace.                          // advance to the end of the whitespace' and return that as the token                          while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                          {                              ++m_currentPosition;                          }                          token = JsToken.WhiteSpace;                      }                      else                      {                          token = IllegalCharacter();                      }                        break;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanNextToken,The following statement contains a magic number: switch (c)              {                  case '\n':                  case '\r':                      token = ScanLineTerminator(c);                      break;                    case '\t':                  case '\v':                  case '\f':                  case ' ':                      // we are asking for raw tokens' and this is the start of a stretch of whitespace.                      // advance to the end of the whitespace' and return that as the token                      token = JsToken.WhiteSpace;                      while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                      {                          ++m_currentPosition;                      }                        break;                    case '!':                      token = JsToken.LogicalNot;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.NotEqual;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictNotEqual;                          }                      }                        break;                    case '"':                  case '\'':                      token = JsToken.StringLiteral;                      ScanString(c);                      break;                    case '$':                  case '_':                      ScanIdentifier();                      token = JsToken.Identifier;                      break;                    case '%':                      token = JsToken.Modulo;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.ModuloAssign;                      }                        break;                    case '&':                      token = JsToken.BitwiseAnd;                      c = GetChar(m_currentPosition);                      if ('&' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalAnd;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseAndAssign;                      }                        break;                    case '(':                      token = JsToken.LeftParenthesis;                      break;                    case ')':                      token = JsToken.RightParenthesis;                      break;                    case '*':                      token = JsToken.Multiply;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.MultiplyAssign;                      }                        break;                    case '+':                      token = JsToken.Plus;                      c = GetChar(m_currentPosition);                      if ('+' == c)                      {                          m_currentPosition++;                          token = JsToken.Increment;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.PlusAssign;                      }                        break;                    case ''':                      token = JsToken.Comma;                      break;                    case '-':                      token = JsToken.Minus;                      c = GetChar(m_currentPosition);                      if ('-' == c)                      {                          m_currentPosition++;                          token = JsToken.Decrement;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.MinusAssign;                      }                        break;                    case '.':                      token = JsToken.AccessField;                      c = GetChar(m_currentPosition);                      if (JsScanner.IsDigit(c))                      {                          token = ScanNumber('.');                      }                        break;                    case '/':                      token = JsToken.Divide;                      c = GetChar(m_currentPosition);                      switch (c)                      {                          case '/':                              token = JsToken.SingleLineComment;                              m_inSingleLineComment = true;                              c = GetChar(++m_currentPosition);                                // see if there is a THIRD slash character                              if (c == '/')                              {                                  // advance past the slash and see if we have one of our special preprocessing directives                                  ++m_currentPosition;                                  if (GetChar(m_currentPosition) == '#')                                  {                                      // scan preprocessing directives                                      token = JsToken.PreprocessorDirective;                                        if (!ScanPreprocessingDirective())                                      {                                          // if it returns false' we don't want to skip the rest of                                          // the comment line; just exit                                          break;                                      }                                  }                              }                              else if (c == '@' && !IgnoreConditionalCompilation)                              {                                  // we got //@                                  // if we have not turned on conditional-compilation yet' then check to see if that's                                  // what we're trying to do now.                                  // we are currently on the @ -- start peeking from there                                  if (m_conditionalCompilationOn                                      || CheckSubstring(m_currentPosition + 1' "cc_on"))                                  {                                      // if the NEXT character is not an identifier character' then we need to skip                                      // the @ character -- otherwise leave it there                                      if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                      {                                          ++m_currentPosition;                                      }                                        // we are now in a conditional comment                                      m_inConditionalComment = true;                                      token = JsToken.ConditionalCommentStart;                                      break;                                  }                              }                                SkipSingleLineComment();                                // if we're still in a multiple-line comment' then we must've been in                              // a multi-line CONDITIONAL comment' in which case this normal one-line comment                              // won't turn off conditional comments just because we hit the end of line.                              if (!m_inMultipleLineComment && m_inConditionalComment)                              {                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                              }                                break;                            case '*':                              m_inMultipleLineComment = true;                              if (GetChar(++m_currentPosition) == '@' && !IgnoreConditionalCompilation)                              {                                  // we have /*@                                  // if we have not turned on conditional-compilation yet' then let's peek to see if the next                                  // few characters are cc_on -- if so' turn it on.                                  if (!m_conditionalCompilationOn)                                  {                                      // we are currently on the @ -- start peeking from there                                      if (!CheckSubstring(m_currentPosition + 1' "cc_on"))                                      {                                          // we aren't turning on conditional comments. We need to ignore this comment                                          // as just another multi-line comment                                          SkipMultilineComment();                                          token = JsToken.MultipleLineComment;                                          break;                                      }                                  }                                    // if the NEXT character is not an identifier character' then we need to skip                                  // the @ character -- otherwise leave it there                                  if (!IsValidIdentifierStart(GetChar(m_currentPosition + 1)))                                  {                                      ++m_currentPosition;                                  }                                    // we are now in a conditional comment                                  m_inConditionalComment = true;                                  token = JsToken.ConditionalCommentStart;                                  break;                              }                                SkipMultilineComment();                              token = JsToken.MultipleLineComment;                              break;                            default:                              // if we were passed the hint that we prefer regular expressions                              // over divide operators' then try parsing one now.                              if (scanForRegularExpressionLiterals)                              {                                  // we think this is probably a regular expression.                                  // if it is...                                  if (ScanRegExp() != null)                                  {                                      // also scan the flags (if any)                                      ScanRegExpFlags();                                      token = JsToken.RegularExpression;                                  }                                  else if (c == '=')                                  {                                      m_currentPosition++;                                      token = JsToken.DivideAssign;                                  }                              }                              else if (c == '=')                              {                                  m_currentPosition++;                                  token = JsToken.DivideAssign;                              }                              break;                      }                        break;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      token = ScanNumber(c);                      break;                    case ':':                      token = JsToken.Colon;                      break;                    case ';':                      token = JsToken.Semicolon;                      break;                    case '<':                      if (AllowEmbeddedAspNetBlocks &&                          '%' == GetChar(m_currentPosition))                      {                          token = ScanAspNetBlock();                      }                      else                      {                          token = JsToken.LessThan;                          if ('<' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.LeftShift;                          }                            if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              if (token == JsToken.LessThan)                              {                                  token = JsToken.LessThanEqual;                              }                              else                              {                                  token = JsToken.LeftShiftAssign;                              }                          }                      }                        break;                    case '=':                      token = JsToken.Assign;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.Equal;                          if ('=' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.StrictEqual;                          }                      }                        break;                    case '>':                      token = JsToken.GreaterThan;                      if ('>' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.RightShift;                          if ('>' == GetChar(m_currentPosition))                          {                              m_currentPosition++;                              token = JsToken.UnsignedRightShift;                          }                      }                        if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = token == JsToken.GreaterThan ? JsToken.GreaterThanEqual                              : token == JsToken.RightShift ? JsToken.RightShiftAssign                              : token == JsToken.UnsignedRightShift ? JsToken.UnsignedRightShiftAssign                              : JsToken.Error;                      }                        break;                    case '?':                      token = JsToken.ConditionalIf;                      break;                    case '@':                      if (IgnoreConditionalCompilation)                      {                          // if the switch to ignore conditional compilation is on' then we don't know                          // anything about conditional-compilation statements' and the @-sign character                          // is illegal at this spot.                          token = IllegalCharacter();                          break;                      }                        // see if the @-sign is immediately followed by an identifier. If it is'                      // we'll see which one so we can tell if it's a conditional-compilation statement                      // need to make sure the context INCLUDES the @ sign                      int startPosition = m_currentPosition;                      m_currentToken.StartPosition = startPosition - 1;                      m_currentToken.StartLineNumber = m_currentLine;                      m_currentToken.StartLinePosition = m_startLinePosition;                      ScanIdentifier();                      switch (m_currentPosition - startPosition)                      {                          case 0:                              // look for '@*/'.                              if ('*' == GetChar(m_currentPosition) && '/' == GetChar(++m_currentPosition))                              {                                  m_currentPosition++;                                  m_inMultipleLineComment = false;                                  m_inConditionalComment = false;                                  token = JsToken.ConditionalCommentEnd;                                  break;                              }                                // otherwise we just have a @ sitting by itself!                              // throw an error and loop back to the next token.                              token = IllegalCharacter();                              break;                            case 2:                              if (CheckSubstring(startPosition' "if"))                              {                                  token = JsToken.ConditionalCompilationIf;                                    // increment the if-level                                  ++m_conditionalCompilationIfLevel;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @if statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 3:                              if (CheckSubstring(startPosition' "set"))                              {                                  token = JsToken.ConditionalCompilationSet;                                    // if we're not in a conditional comment and we haven't explicitly                                  // turned on conditional compilation when we encounter                                  // a @set statement' then we can implicitly turn it on.                                  if (!m_inConditionalComment && !m_conditionalCompilationOn)                                  {                                      m_conditionalCompilationOn = true;                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "end"))                              {                                  token = JsToken.ConditionalCompilationEnd;                                  if (m_conditionalCompilationIfLevel > 0)                                  {                                      // down one more @if level                                      m_conditionalCompilationIfLevel--;                                  }                                  else                                  {                                      // not corresponding @if -- invalid @end statement                                      HandleError(JsError.CCInvalidEnd);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 4:                              if (CheckSubstring(startPosition' "else"))                              {                                  token = JsToken.ConditionalCompilationElse;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElse);                                  }                                    break;                              }                                if (CheckSubstring(startPosition' "elif"))                              {                                  token = JsToken.ConditionalCompilationElseIf;                                    // if we don't have a corresponding @if statement' then throw and error                                  // (but keep processing)                                  if (m_conditionalCompilationIfLevel <= 0)                                  {                                      HandleError(JsError.CCInvalidElseIf);                                  }                                    break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            case 5:                              if (CheckSubstring(startPosition' "cc_on"))                              {                                  // turn it on and return the @cc_on token                                  m_conditionalCompilationOn = true;                                  token = JsToken.ConditionalCompilationOn;                                  break;                              }                                // the string isn't a known preprocessor command' so                               // fall into the default processing to handle it as a variable name                              goto default;                            default:                              // we have @[id]' where [id] is a valid identifier.                              // if we haven't explicitly turned on conditional compilation'                              // we'll keep processing' but we need to fire an error to indicate                              // that the code should turn it on first.                              if (!m_conditionalCompilationOn)                              {                                  HandleError(JsError.CCOff);                              }                                token = JsToken.ConditionalCompilationVariable;                              break;                      }                        break;                    case 'A':                  case 'B':                  case 'C':                  case 'D':                  case 'E':                  case 'F':                  case 'G':                  case 'H':                  case 'I':                  case 'J':                  case 'K':                  case 'L':                  case 'M':                  case 'N':                  case 'O':                  case 'P':                  case 'Q':                  case 'R':                  case 'S':                  case 'T':                  case 'U':                  case 'V':                  case 'W':                  case 'X':                  case 'Y':                  case 'Z':                      token = JsToken.Identifier;                      ScanIdentifier();                      break;                    case '[':                      token = JsToken.LeftBracket;                      break;                    case '\\':                      // try decoding a unicode escape sequence. We read the backslash and                      // now the "current" character is the "u"                      if (PeekUnicodeEscape(m_currentPosition' ref c))                      {                          // advance past the escape characters                          m_currentPosition += 5;                            // valid unicode escape sequence                          if (IsValidIdentifierStart(c))                          {                              // use the unescaped character as the first character of the                              // decoded identifier' and current character is now the last position                              // on the builder                              m_identifier.Append(c);                              m_lastPosOnBuilder = m_currentPosition;                                // scan the rest of the identifier                              ScanIdentifier();                                // because it STARTS with an escaped character it cannot be a keyword                              token = JsToken.Identifier;                              break;                          }                      }                      else                      {                          // not a valid unicode escape sequence                          // see if the next character is a valid identifier character                          if (IsValidIdentifierStart(GetChar(m_currentPosition)))                          {                              // we're going to just assume this is an escaped identifier character                              // because some older browsers allow things like \foo ("foo") and                               // \while to be an identifer "while" and not the reserved word                              ScanIdentifier();                              token = JsToken.Identifier;                              break;                          }                      }                        HandleError(JsError.IllegalChar);                      break;                    case ']':                      token = JsToken.RightBracket;                      break;                    case '^':                      token = JsToken.BitwiseXor;                      if ('=' == GetChar(m_currentPosition))                      {                          m_currentPosition++;                          token = JsToken.BitwiseXorAssign;                      }                        break;                    case '#':                  case '`':                      token = IllegalCharacter();                      break;                    case 'a':                  case 'b':                  case 'c':                  case 'd':                  case 'e':                  case 'f':                  case 'g':                  case 'h':                  case 'i':                  case 'j':                  case 'k':                  case 'l':                  case 'm':                  case 'n':                  case 'o':                  case 'p':                  case 'q':                  case 'r':                  case 's':                  case 't':                  case 'u':                  case 'v':                  case 'w':                  case 'x':                  case 'y':                  case 'z':                      JsKeyword keyword = s_Keywords[c - 'a'];                      if (null != keyword)                      {                          token = ScanKeyword(keyword);                      }                      else                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      break;                    case '{':                      token = JsToken.LeftCurly;                      break;                    case '|':                      token = JsToken.BitwiseOr;                      c = GetChar(m_currentPosition);                      if ('|' == c)                      {                          m_currentPosition++;                          token = JsToken.LogicalOr;                      }                      else if ('=' == c)                      {                          m_currentPosition++;                          token = JsToken.BitwiseOrAssign;                      }                        break;                    case '}':                      token = JsToken.RightCurly;                      break;                    case '~':                      token = JsToken.BitwiseNot;                      break;                    default:                      if (c == '\0')                      {                          if (IsEndOfFile)                          {                              token = JsToken.EndOfFile;                              m_currentPosition--;                              if (m_conditionalCompilationIfLevel > 0)                              {                                  m_currentToken.EndLineNumber = m_currentLine;                                  m_currentToken.EndLinePosition = m_startLinePosition;                                  m_currentToken.EndPosition = m_currentPosition;                                  HandleError(JsError.NoCCEnd);                              }                          }                          else                          {                              token = IllegalCharacter();                          }                      }                      else if (c == '\u2028' || c == '\u2029')                      {                          // more line terminator                          token = ScanLineTerminator(c);                      }                      else if (IsValidIdentifierStart(c))                      {                          token = JsToken.Identifier;                          ScanIdentifier();                      }                      else if (IsBlankSpace(c))                      {                          // we are asking for raw tokens' and this is the start of a stretch of whitespace.                          // advance to the end of the whitespace' and return that as the token                          while (JsScanner.IsBlankSpace(GetChar(m_currentPosition)))                          {                              ++m_currentPosition;                          }                          token = JsToken.WhiteSpace;                      }                      else                      {                          token = IllegalCharacter();                      }                        break;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanRegExp,The following statement contains a magic number: while (!IsEndLineOrEOF(c = GetChar(m_currentPosition++)' 0))              {                  if (isEscape)                  {                      isEscape = false;                  }                  else if (c == '[')                  {                      isInSet = true;                  }                  else if (isInSet)                  {                      if (c == ']')                      {                          isInSet = false;                      }                  }                  else if (c == '/')                  {                      if (pos == m_currentPosition)                      {                          return null;                      }                        m_currentToken.EndPosition = m_currentPosition;                      m_currentToken.EndLinePosition = m_startLinePosition;                      m_currentToken.EndLineNumber = m_currentLine;                      return m_strSourceCode.Substring(                          m_currentToken.StartPosition + 1'                          m_currentToken.EndPosition - m_currentToken.StartPosition - 2);                  }                  else if (c == '\\')                  {                      isEscape = true;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanAspNetBlock,The following statement contains a magic number: if (IsEndOfFile)              {                  HandleError(JsError.UnterminatedAspNetBlock);              }              else              {                  // Eat the last >.                  this.m_currentPosition++;                    if (thirdChar == '=')                  {                      // this is a <%= ... %> token.                      // we're going to treat this like an identifier                      tokenType = JsToken.Identifier;                        // now' if the next character is an identifier part                      // then skip to the end of the identifier. And if this is                      // another <%= then skip to the end (%>)                      if (IsValidIdentifierPart(GetChar(m_currentPosition))                          || CheckSubstring(m_currentPosition' "<%="))                      {                          // and do it however many times we need                          while (true)                          {                              if (IsValidIdentifierPart(GetChar(m_currentPosition)))                              {                                  // skip to the end of the identifier part                                  while (IsValidIdentifierPart(GetChar(++m_currentPosition)))                                  {                                      // loop                                  }                                    // when we get here' the current position is the first                                  // character that ISN"T an identifier-part. That means everything                                   // UP TO this point must have been on the                                   // same line' so we only need to update the position                                  m_currentToken.EndPosition = m_currentPosition;                              }                              else if (CheckSubstring(m_currentPosition' "<%="))                              {                                  // skip forward four characters -- the minimum position                                  // for the closing %>                                  m_currentPosition += 4;                                    // and keep looping until we find it                                  while (!(this.GetChar(this.m_currentPosition - 1) == '%' &&                                           this.GetChar(this.m_currentPosition) == '>') ||                                           IsEndOfFile)                                  {                                      this.m_currentPosition++;                                  }                                    // update the end of the token                                  m_currentToken.EndPosition = m_currentPosition + 1;                                  m_currentToken.EndLineNumber = m_currentLine;                                  m_currentToken.EndLinePosition = m_startLinePosition;                                    // we should be at the > of the %> right now.                                  // see if we found an unterminated asp.net block                                  if (IsEndOfFile)                                  {                                      HandleError(JsError.UnterminatedAspNetBlock);                                  }                                  else                                  {                                      // skip the > and go around another time                                      ++m_currentPosition;                                  }                              }                              else                              {                                  // neither an identifer part nor another <%= sequence'                                  // so we're done here                                  break;                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: while((ch = GetChar(m_currentPosition++)) != delimiter)              {                  if (ch != '\\')                  {                      // this is the common non escape case                      if (IsLineTerminator(ch' 0))                      {                          // TODO: we want to flag this string as unterminated *and having issues*'                          // and then somehow output a line-break in the output to duplicate the                          // source. However' we will need to figure out how to NOT combine the statement                          // with the next statement. For instance:                          //      var x = "unterminated                          //      var y = 42;                          // should NOT get combined to: var x="unterminated'y=42;                          // (same for moving it inside for-statements' combining expression statements' etc.)                          //m_literalIssues = true;                          HandleError(JsError.UnterminatedString);                            // back up to the start of the line terminator                          --m_currentPosition;                          if (GetChar(m_currentPosition - 1) == '\r')                          {                              --m_currentPosition;                          }                            break;                      }                        if ('\0' == ch)                      {                          // whether it's a null literal character within the string or an                          // actual end of file' this string literal has issues....                          m_literalIssues = true;                            if (IsEndOfFile)                          {                              m_currentPosition--;                              HandleError(JsError.UnterminatedString);                              break;                          }                        }                        if (AllowEmbeddedAspNetBlocks                          && ch == '<'                          && GetChar(m_currentPosition) == '%')                      {                          // start of an ASP.NET block INSIDE a string literal.                          // just skip the entire ASP.NET block -- move forward until                          // we find the closing %> delimiter' then we'll continue on                          // with the next character.                          SkipAspNetReplacement();                            // asp.net blocks insides strings can cause issues                          m_literalIssues = true;                      }                  }                  else                  {                      // ESCAPE CASE                        // got an escape of some sort. Have to use the StringBuilder                      if (null == result)                      {                          result = new StringBuilder(128);                      }                        // start points to the first position that has not been written to the StringBuilder.                      // The first time we get in here that position is the beginning of the string' after that                      // is the character immediately following the escape sequence                      if (m_currentPosition - start - 1 > 0)                      {                          // append all the non escape chars to the string builder                          result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                      }                        // state variable to be reset                      bool seqOfThree = false;                      bool isValidHex;                      int escapeStart;                      int esc = 0;                        ch = GetChar(m_currentPosition++);                      switch (ch)                      {                          // line terminator crap                          case '\r':                              if ('\n' == GetChar(m_currentPosition))                              {                                  m_currentPosition++;                              }                                goto case '\n';                            case '\n':                          case '\u2028':                          case '\u2029':                              m_currentLine++;                              m_startLinePosition = m_currentPosition;                              break;                            // classic single char escape sequences                          case 'b':                              result.Append((char)8);                              break;                            case 't':                              result.Append((char)9);                              break;                            case 'n':                              result.Append((char)10);                              break;                            case 'v':                              // \v inside strings can cause issues                              m_literalIssues = true;                              result.Append((char)11);                              break;                            case 'f':                              result.Append((char)12);                              break;                            case 'r':                              result.Append((char)13);                              break;                            case '"':                              result.Append('"');                              break;                            case '\'':                              result.Append('\'');                              break;                            case '\\':                              result.Append('\\');                              break;                            // hexadecimal escape sequence /xHH                          case 'x':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original and flag this                                   // as having issues                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            // unicode escape sequence /uHHHH                          case 'u':                              // save the start of the escape in case we fail                              escapeStart = m_currentPosition - 2;                              isValidHex = true;                              if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (!ScanHexDigit(ref esc))                              {                                  isValidHex = false;                                                                    // if that invalid character (which the scan function skipped over)                                  // was a delimiter' back up!                                  if (GetChar(m_currentPosition - 1) == delimiter)                                  {                                      --m_currentPosition;                                  }                              }                                if (isValidHex)                              {                                  // valid; use the unescaped character                                  result.Append((char)esc);                              }                              else                              {                                  // wasn't valid -- keep the original                                  result.Append(m_strSourceCode.Substring(escapeStart' m_currentPosition - escapeStart));                                  m_literalIssues = true;                                  HandleError(JsError.BadHexEscapeSequence);                              }                              break;                            case '0':                          case '1':                          case '2':                          case '3':                              seqOfThree = true;                              esc = (ch - '0') << 6;                              goto case '4';                            case '4':                          case '5':                          case '6':                          case '7':                              // octal literals inside strings can cause issues                              m_literalIssues = true;                                // esc is reset at the beginning of the loop and it is used to check that we did not go through the cases 1' 2 or 3                              if (!seqOfThree)                              {                                  esc = (ch - '0') << 3;                              }                                ch = GetChar(m_currentPosition++);                              if ('0' <= ch && ch <= '7')                              {                                  if (seqOfThree)                                  {                                      esc |= (ch - '0') << 3;                                      ch = GetChar(m_currentPosition++);                                      if ('0' <= ch && ch <= '7')                                      {                                          esc |= ch - '0';                                          result.Append((char)esc);                                      }                                      else                                      {                                          result.Append((char)(esc >> 3));                                            // do not skip over this char we have to read it back                                          --m_currentPosition;                                      }                                  }                                  else                                  {                                      esc |= ch - '0';                                      result.Append((char)esc);                                  }                              }                              else                              {                                  if (seqOfThree)                                  {                                      result.Append((char)(esc >> 6));                                  }                                  else                                  {                                      result.Append((char)(esc >> 3));                                  }                                    // do not skip over this char we have to read it back                                  --m_currentPosition;                              }                                HandleError(JsError.OctalLiteralsDeprecated);                              break;                            default:                              // not an octal number' ignore the escape '/' and simply append the current char                              result.Append(ch);                              break;                      }                        start = m_currentPosition;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The following statement contains a magic number: if (null != result)              {                  if (m_currentPosition - start - 1 > 0)                  {                      // append all the non escape chars to the string builder                      result.Append(m_strSourceCode' start' m_currentPosition - start - 1);                  }                  m_decodedString = result.ToString();              }              else if (m_currentPosition == m_currentToken.StartPosition + 1)              {                  // empty unterminated string!                  m_decodedString = string.Empty;              }              else              {                  // might be an unterminated string' so make sure that last character is the terminator                  int numDelimiters = (GetChar(m_currentPosition - 1) == delimiter ? 2 : 1);                  m_decodedString = m_strSourceCode.Substring(m_currentToken.StartPosition + 1' m_currentPosition - m_currentToken.StartPosition - numDelimiters);              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanHexDigit,The following statement contains a magic number: if (char.IsDigit(ch))              {                  esc = esc << 4 | (ch - '0');              }              else if ('A' <= ch && ch <= 'F')              {                  esc = esc << 4 | (ch - 'A' + 10);              }              else if ('a' <= ch && ch <= 'f')              {                  esc = esc << 4 | (ch - 'a' + 10);              }              else              {                  // not a valid hex character!                  isGoodValue = false;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanHexDigit,The following statement contains a magic number: if (char.IsDigit(ch))              {                  esc = esc << 4 | (ch - '0');              }              else if ('A' <= ch && ch <= 'F')              {                  esc = esc << 4 | (ch - 'A' + 10);              }              else if ('a' <= ch && ch <= 'f')              {                  esc = esc << 4 | (ch - 'a' + 10);              }              else              {                  // not a valid hex character!                  isGoodValue = false;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanHexDigit,The following statement contains a magic number: if (char.IsDigit(ch))              {                  esc = esc << 4 | (ch - '0');              }              else if ('A' <= ch && ch <= 'F')              {                  esc = esc << 4 | (ch - 'A' + 10);              }              else if ('a' <= ch && ch <= 'f')              {                  esc = esc << 4 | (ch - 'a' + 10);              }              else              {                  // not a valid hex character!                  isGoodValue = false;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanHexDigit,The following statement contains a magic number: if (char.IsDigit(ch))              {                  esc = esc << 4 | (ch - '0');              }              else if ('A' <= ch && ch <= 'F')              {                  esc = esc << 4 | (ch - 'A' + 10);              }              else if ('a' <= ch && ch <= 'f')              {                  esc = esc << 4 | (ch - 'a' + 10);              }              else              {                  // not a valid hex character!                  isGoodValue = false;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanHexDigit,The following statement contains a magic number: if (char.IsDigit(ch))              {                  esc = esc << 4 | (ch - '0');              }              else if ('A' <= ch && ch <= 'F')              {                  esc = esc << 4 | (ch - 'A' + 10);              }              else if ('a' <= ch && ch <= 'f')              {                  esc = esc << 4 | (ch - 'a' + 10);              }              else              {                  // not a valid hex character!                  isGoodValue = false;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsBlankSpace,The following statement contains a magic number: switch (c)              {                  case '\u0009':                  case '\u000b':                  case '\u000c':                  case '\u0020':                  case '\u00a0':                  case '\ufeff': // BOM - byte order mark                      return true;                    default:                      return (c < 128) ? false : char.GetUnicodeCategory(c) == UnicodeCategory.SpaceSeparator;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,GetHexValue,The following statement contains a magic number: if ('0' <= hex && hex <= '9')              {                  hexValue = hex - '0';              }              else if ('a' <= hex && hex <= 'f')              {                  hexValue = hex - 'a' + 10;              }              else              {                  hexValue = hex - 'A' + 10;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,GetHexValue,The following statement contains a magic number: if ('0' <= hex && hex <= '9')              {                  hexValue = hex - '0';              }              else if ('a' <= hex && hex <= 'f')              {                  hexValue = hex - 'a' + 10;              }              else              {                  hexValue = hex - 'A' + 10;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsValidIdentifierStart,The following statement contains a magic number: if (letter >= 128)              {                  // check the unicode category                  UnicodeCategory cat = char.GetUnicodeCategory(letter);                  switch (cat)                  {                      case UnicodeCategory.UppercaseLetter:                      case UnicodeCategory.LowercaseLetter:                      case UnicodeCategory.TitlecaseLetter:                      case UnicodeCategory.ModifierLetter:                      case UnicodeCategory.OtherLetter:                      case UnicodeCategory.LetterNumber:                          // okay                          return true;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsValidIdentifierPart,The following statement contains a magic number: if (letter >= 128)              {                  UnicodeCategory unicodeCategory = Char.GetUnicodeCategory(letter);                  switch (unicodeCategory)                  {                      case UnicodeCategory.UppercaseLetter:                      case UnicodeCategory.LowercaseLetter:                      case UnicodeCategory.TitlecaseLetter:                      case UnicodeCategory.ModifierLetter:                      case UnicodeCategory.OtherLetter:                      case UnicodeCategory.LetterNumber:                      case UnicodeCategory.NonSpacingMark:                      case UnicodeCategory.SpacingCombiningMark:                      case UnicodeCategory.DecimalDigitNumber:                      case UnicodeCategory.ConnectorPunctuation:                          return true;                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if (!string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6)              {                  if (str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5]))                  {                      ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if (!string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6)              {                  if (str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5]))                  {                      ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if (!string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6)              {                  if (str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5]))                  {                      ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if (!string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6)              {                  if (str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5]))                  {                      ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if (!string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6)              {                  if (str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5]))                  {                      ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if (!string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6)              {                  if (str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5]))                  {                      ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if (!string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6)              {                  if (str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5]))                  {                      ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if (!string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6)              {                  if (str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5]))                  {                      ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if (!string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6)              {                  if (str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5]))                  {                      ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if (!string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6)              {                  if (str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5]))                  {                      ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if (!string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6)              {                  if (str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5]))                  {                      ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if (!string.IsNullOrEmpty(str) && ch == '\\' && str.Length >= 6)              {                  if (str[1] == 'u'                       && IsHexDigit(str[2])                      && IsHexDigit(str[3])                      && IsHexDigit(str[4])                      && IsHexDigit(str[5]))                  {                      ch = (char)(GetHexValue(str[2]) << 12 | GetHexValue(str[3]) << 8 | GetHexValue(str[4]) << 4 | GetHexValue(str[5]));                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if ('u' == GetChar(index))              {                  char h1 = GetChar(index + 1);                  if (IsHexDigit(h1))                  {                      char h2 = GetChar(index + 2);                      if (IsHexDigit(h2))                      {                          char h3 = GetChar(index + 3);                          if (IsHexDigit(h3))                          {                              char h4 = GetChar(index + 4);                              if (IsHexDigit(h4))                              {                                  // this IS a unicode escape' so compute the new character value                                  // and adjust the current position                                  isEscapeChar = true;                                  ch = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if ('u' == GetChar(index))              {                  char h1 = GetChar(index + 1);                  if (IsHexDigit(h1))                  {                      char h2 = GetChar(index + 2);                      if (IsHexDigit(h2))                      {                          char h3 = GetChar(index + 3);                          if (IsHexDigit(h3))                          {                              char h4 = GetChar(index + 4);                              if (IsHexDigit(h4))                              {                                  // this IS a unicode escape' so compute the new character value                                  // and adjust the current position                                  isEscapeChar = true;                                  ch = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if ('u' == GetChar(index))              {                  char h1 = GetChar(index + 1);                  if (IsHexDigit(h1))                  {                      char h2 = GetChar(index + 2);                      if (IsHexDigit(h2))                      {                          char h3 = GetChar(index + 3);                          if (IsHexDigit(h3))                          {                              char h4 = GetChar(index + 4);                              if (IsHexDigit(h4))                              {                                  // this IS a unicode escape' so compute the new character value                                  // and adjust the current position                                  isEscapeChar = true;                                  ch = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if ('u' == GetChar(index))              {                  char h1 = GetChar(index + 1);                  if (IsHexDigit(h1))                  {                      char h2 = GetChar(index + 2);                      if (IsHexDigit(h2))                      {                          char h3 = GetChar(index + 3);                          if (IsHexDigit(h3))                          {                              char h4 = GetChar(index + 4);                              if (IsHexDigit(h4))                              {                                  // this IS a unicode escape' so compute the new character value                                  // and adjust the current position                                  isEscapeChar = true;                                  ch = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if ('u' == GetChar(index))              {                  char h1 = GetChar(index + 1);                  if (IsHexDigit(h1))                  {                      char h2 = GetChar(index + 2);                      if (IsHexDigit(h2))                      {                          char h3 = GetChar(index + 3);                          if (IsHexDigit(h3))                          {                              char h4 = GetChar(index + 4);                              if (IsHexDigit(h4))                              {                                  // this IS a unicode escape' so compute the new character value                                  // and adjust the current position                                  isEscapeChar = true;                                  ch = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PeekUnicodeEscape,The following statement contains a magic number: if ('u' == GetChar(index))              {                  char h1 = GetChar(index + 1);                  if (IsHexDigit(h1))                  {                      char h2 = GetChar(index + 2);                      if (IsHexDigit(h2))                      {                          char h3 = GetChar(index + 3);                          if (IsHexDigit(h3))                          {                              char h4 = GetChar(index + 4);                              if (IsHexDigit(h4))                              {                                  // this IS a unicode escape' so compute the new character value                                  // and adjust the current position                                  isEscapeChar = true;                                  ch = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: if ('\\' == c)              {                  if ('u' == GetChar(m_currentPosition + 1))                  {                      char h1 = GetChar(m_currentPosition + 2);                      if (IsHexDigit(h1))                      {                          char h2 = GetChar(m_currentPosition + 3);                          if (IsHexDigit(h2))                          {                              char h3 = GetChar(m_currentPosition + 4);                              if (IsHexDigit(h3))                              {                                  char h4 = GetChar(m_currentPosition + 5);                                  if (IsHexDigit(h4))                                  {                                      isEscapeChar = true;                                      c = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                                  }                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: if ('\\' == c)              {                  if ('u' == GetChar(m_currentPosition + 1))                  {                      char h1 = GetChar(m_currentPosition + 2);                      if (IsHexDigit(h1))                      {                          char h2 = GetChar(m_currentPosition + 3);                          if (IsHexDigit(h2))                          {                              char h3 = GetChar(m_currentPosition + 4);                              if (IsHexDigit(h3))                              {                                  char h4 = GetChar(m_currentPosition + 5);                                  if (IsHexDigit(h4))                                  {                                      isEscapeChar = true;                                      c = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                                  }                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: if ('\\' == c)              {                  if ('u' == GetChar(m_currentPosition + 1))                  {                      char h1 = GetChar(m_currentPosition + 2);                      if (IsHexDigit(h1))                      {                          char h2 = GetChar(m_currentPosition + 3);                          if (IsHexDigit(h2))                          {                              char h3 = GetChar(m_currentPosition + 4);                              if (IsHexDigit(h3))                              {                                  char h4 = GetChar(m_currentPosition + 5);                                  if (IsHexDigit(h4))                                  {                                      isEscapeChar = true;                                      c = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                                  }                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: if ('\\' == c)              {                  if ('u' == GetChar(m_currentPosition + 1))                  {                      char h1 = GetChar(m_currentPosition + 2);                      if (IsHexDigit(h1))                      {                          char h2 = GetChar(m_currentPosition + 3);                          if (IsHexDigit(h2))                          {                              char h3 = GetChar(m_currentPosition + 4);                              if (IsHexDigit(h3))                              {                                  char h4 = GetChar(m_currentPosition + 5);                                  if (IsHexDigit(h4))                                  {                                      isEscapeChar = true;                                      c = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                                  }                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: if ('\\' == c)              {                  if ('u' == GetChar(m_currentPosition + 1))                  {                      char h1 = GetChar(m_currentPosition + 2);                      if (IsHexDigit(h1))                      {                          char h2 = GetChar(m_currentPosition + 3);                          if (IsHexDigit(h2))                          {                              char h3 = GetChar(m_currentPosition + 4);                              if (IsHexDigit(h3))                              {                                  char h4 = GetChar(m_currentPosition + 5);                                  if (IsHexDigit(h4))                                  {                                      isEscapeChar = true;                                      c = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                                  }                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: if ('\\' == c)              {                  if ('u' == GetChar(m_currentPosition + 1))                  {                      char h1 = GetChar(m_currentPosition + 2);                      if (IsHexDigit(h1))                      {                          char h2 = GetChar(m_currentPosition + 3);                          if (IsHexDigit(h2))                          {                              char h3 = GetChar(m_currentPosition + 4);                              if (IsHexDigit(h3))                              {                                  char h4 = GetChar(m_currentPosition + 5);                                  if (IsHexDigit(h4))                                  {                                      isEscapeChar = true;                                      c = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                                  }                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: if ('\\' == c)              {                  if ('u' == GetChar(m_currentPosition + 1))                  {                      char h1 = GetChar(m_currentPosition + 2);                      if (IsHexDigit(h1))                      {                          char h2 = GetChar(m_currentPosition + 3);                          if (IsHexDigit(h2))                          {                              char h3 = GetChar(m_currentPosition + 4);                              if (IsHexDigit(h3))                              {                                  char h4 = GetChar(m_currentPosition + 5);                                  if (IsHexDigit(h4))                                  {                                      isEscapeChar = true;                                      c = (char)(GetHexValue(h1) << 12 | GetHexValue(h2) << 8 | GetHexValue(h3) << 4 | GetHexValue(h4));                                  }                              }                          }                      }                  }              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsIdentifierStartChar,The following statement contains a magic number: if (isEscapeChar)              {                  int startPosition = (m_lastPosOnBuilder > 0) ? m_lastPosOnBuilder : m_currentToken.StartPosition;                  if (m_currentPosition - startPosition > 0)                  {                      m_identifier.Append(m_strSourceCode.Substring(startPosition' m_currentPosition - startPosition));                  }                    m_identifier.Append(c);                  m_currentPosition += 5;                  m_lastPosOnBuilder = m_currentPosition + 1;              }
Magic Number,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PPSkipToDirective,The following statement contains a magic number: while (true)              {                  char c = GetChar(m_currentPosition++);                  switch (c)                  {                      // EOF                      case '\0':                          if (IsEndOfFile)                          {                              // adjust the scanner state                              m_currentPosition--;                              m_currentToken.EndPosition = m_currentPosition;                              m_currentToken.EndLineNumber = m_currentLine;                              m_currentToken.EndLinePosition = m_startLinePosition;                                // create a clone of the current token and set the ending to be the end of the                              // directive for which we're trying to find an end. Use THAT context for the                               // error context. Then throw an exception so we can bail.                              var contextError = m_currentToken.Clone();                              contextError.EndPosition = endPosition;                              contextError.EndLineNumber = endLineNum;                              contextError.EndLinePosition = endLinePos;                              contextError.HandleError(string.CompareOrdinal(endStrings[0]' "#ENDDEBUG") == 0                                   ? JsError.NoEndDebugDirective                                   : JsError.NoEndIfDirective);                              throw new EndOfStreamException();                          }                            break;                        // line terminator crap                      case '\r':                          if (GetChar(m_currentPosition) == '\n')                          {                              m_currentPosition++;                          }                            m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                      case '\n':                          m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                      case '\u2028':                          m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                      case '\u2029':                          m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                        // check for /// (and then followed by any one of the substrings passed to us)                      case '/':                          if (CheckSubstring(m_currentPosition' "//"))                          {                              // skip it                              m_currentPosition += 2;                                // check to see if this is the start of ANOTHER preprocessor construct. If it                              // is' then it's a NESTED statement and we'll need to recursively skip the                               // whole thing so everything stays on track                              if (CheckCaseInsensitiveSubstring("#IFDEF")                                  || CheckCaseInsensitiveSubstring("#IFNDEF")                                  || CheckCaseInsensitiveSubstring("#IF"))                              {                                  PPSkipToDirective("#ENDIF");                              }                              else                              {                                  // now check each of the ending strings that were passed to us to see if one of                                  // them is a match                                  for (var ndx = 0; ndx < endStrings.Length; ++ndx)                                  {                                      if (CheckCaseInsensitiveSubstring(endStrings[ndx]))                                      {                                          // found the ending string                                          return ndx;                                      }                                  }                                    // not something we're looking for -- but is it a simple ///#END?                                  if (CheckCaseInsensitiveSubstring("#END"))                                  {                                      // if the current character is not whitespace' then it's not a simple "#END"                                      c = GetChar(m_currentPosition);                                      if (IsBlankSpace(c) || IsAtEndOfLine)                                      {                                          // it is! Well' we were expecting either #ENDIF or #ENDDEBUG' but we found just an #END.                                          // that's not how the syntax is SUPPOSED to go. But let's let it fly.                                          // the ending token is always the first one.                                          return 0;                                      }                                  }                              }                          }                            break;                  }              }
Magic Number,Baker.Text,JsV3SourceMap,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsV3SourceMap.cs,Dispose,The following statement contains a magic number: if (m_writer != null)              {                  // if we want to add the cross-site script injection protection string'                  // do it now at the top of the file as it's own line                  if (SafeHeader)                  {                      m_writer.WriteLine(")]}'");                  }                    // start the JSON object                  m_writer.WriteLine("{");                    WriteProperty("version"' 3);                  WriteProperty("file"' MakeRelative(m_minifiedPath' m_mapPath));                    // line number comes in zero-based' so add one to get the line count                  WriteProperty("lineCount"' m_maxMinifiedLine + 1);                    WriteProperty("mappings"' GenerateMappings(m_sourceFileList' m_nameList));                    // if we have a source root' add the property now                  if (!SourceRoot.IsNullOrWhiteSpace())                  {                      WriteProperty("sourceRoot"' SourceRoot);                  }                    WriteProperty("sources"' m_sourceFileList);                  WriteProperty("names"' m_nameList);                    // close the JSON object                  m_writer.WriteLine();                  m_writer.WriteLine("}");                    m_writer.Close();                  m_writer = null;              }
Magic Number,Baker.Text,JsV3SourceMap,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsV3SourceMap.cs,EncodeNumber,The following statement contains a magic number: do              {                  // pull off the last 5 bits of the value. Because value is guaranteed to be                  // positive at this point' we don't have to worry about the int's sign bit                  // filling in the places as we shift right.                  var digit = value & 0x1f;                  value >>= 5;                    // if there is still something left' then we need to set the                  // continuation bit (bit6) to a 1                  if (value > 0)                  {                      digit |= 0x20;                  }                    // this leaves us with a 6-bit value (between 0 and 63)                  // which we then BASE64 encode and add to the string builder.                  // and if there's anything left' loop around again.                  sb.Append(s_base64[digit]);              }              while (value > 0);
Magic Number,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: if (args != null)              {                  var levelSpecified = false;                  var renamingSpecified = false;                  var killSpecified = false;                  var minifySpecified = false;                  bool parameterFlag;                  for (var ndx = 0; ndx < args.Length; ++ndx)                  {                      // parameter switch                      var thisArg = args[ndx];                        // don't use the forward-slash for switches if this is running under the Mono runtime.                       // Mono is a .NET for UNIX implementation' and the UNIX OS uses forward slashes as the directory separator.                      if (thisArg.Length > 1                        && (thisArg.StartsWith("-"' StringComparison.Ordinal) // this is a normal hyphen (minus character)                        || thisArg.StartsWith(""' StringComparison.Ordinal) // this character is what Word will convert a hyphen to                        || (!m_isMono && thisArg.StartsWith("/"' StringComparison.Ordinal))))                      {                          // general switch syntax is -switch:param                          var parts = thisArg.Substring(1).Split(':');                          var switchPart = parts[0].ToUpperInvariant();                          var paramPart = parts.Length == 1 ? null : parts[1];                          var paramPartUpper = paramPart == null ? null : paramPart.ToUpperInvariant();                            // switch off the switch part                          switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }                      }                      else                      {                          // not a switch -- it's an unknown parameter                          ndx = OnUnknownParameter(args' ndx' null' null);                      }                  }              }
Magic Number,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: if (args != null)              {                  var levelSpecified = false;                  var renamingSpecified = false;                  var killSpecified = false;                  var minifySpecified = false;                  bool parameterFlag;                  for (var ndx = 0; ndx < args.Length; ++ndx)                  {                      // parameter switch                      var thisArg = args[ndx];                        // don't use the forward-slash for switches if this is running under the Mono runtime.                       // Mono is a .NET for UNIX implementation' and the UNIX OS uses forward slashes as the directory separator.                      if (thisArg.Length > 1                        && (thisArg.StartsWith("-"' StringComparison.Ordinal) // this is a normal hyphen (minus character)                        || thisArg.StartsWith(""' StringComparison.Ordinal) // this character is what Word will convert a hyphen to                        || (!m_isMono && thisArg.StartsWith("/"' StringComparison.Ordinal))))                      {                          // general switch syntax is -switch:param                          var parts = thisArg.Substring(1).Split(':');                          var switchPart = parts[0].ToUpperInvariant();                          var paramPart = parts.Length == 1 ? null : parts[1];                          var paramPartUpper = paramPart == null ? null : paramPart.ToUpperInvariant();                            // switch off the switch part                          switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }                      }                      else                      {                          // not a switch -- it's an unknown parameter                          ndx = OnUnknownParameter(args' ndx' null' null);                      }                  }              }
Magic Number,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: if (args != null)              {                  var levelSpecified = false;                  var renamingSpecified = false;                  var killSpecified = false;                  var minifySpecified = false;                  bool parameterFlag;                  for (var ndx = 0; ndx < args.Length; ++ndx)                  {                      // parameter switch                      var thisArg = args[ndx];                        // don't use the forward-slash for switches if this is running under the Mono runtime.                       // Mono is a .NET for UNIX implementation' and the UNIX OS uses forward slashes as the directory separator.                      if (thisArg.Length > 1                        && (thisArg.StartsWith("-"' StringComparison.Ordinal) // this is a normal hyphen (minus character)                        || thisArg.StartsWith(""' StringComparison.Ordinal) // this character is what Word will convert a hyphen to                        || (!m_isMono && thisArg.StartsWith("/"' StringComparison.Ordinal))))                      {                          // general switch syntax is -switch:param                          var parts = thisArg.Substring(1).Split(':');                          var switchPart = parts[0].ToUpperInvariant();                          var paramPart = parts.Length == 1 ? null : parts[1];                          var paramPartUpper = paramPart == null ? null : paramPart.ToUpperInvariant();                            // switch off the switch part                          switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }                      }                      else                      {                          // not a switch -- it's an unknown parameter                          ndx = OnUnknownParameter(args' ndx' null' null);                      }                  }              }
Magic Number,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: if (args != null)              {                  var levelSpecified = false;                  var renamingSpecified = false;                  var killSpecified = false;                  var minifySpecified = false;                  bool parameterFlag;                  for (var ndx = 0; ndx < args.Length; ++ndx)                  {                      // parameter switch                      var thisArg = args[ndx];                        // don't use the forward-slash for switches if this is running under the Mono runtime.                       // Mono is a .NET for UNIX implementation' and the UNIX OS uses forward slashes as the directory separator.                      if (thisArg.Length > 1                        && (thisArg.StartsWith("-"' StringComparison.Ordinal) // this is a normal hyphen (minus character)                        || thisArg.StartsWith(""' StringComparison.Ordinal) // this character is what Word will convert a hyphen to                        || (!m_isMono && thisArg.StartsWith("/"' StringComparison.Ordinal))))                      {                          // general switch syntax is -switch:param                          var parts = thisArg.Substring(1).Split(':');                          var switchPart = parts[0].ToUpperInvariant();                          var paramPart = parts.Length == 1 ? null : parts[1];                          var paramPartUpper = paramPart == null ? null : paramPart.ToUpperInvariant();                            // switch off the switch part                          switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }                      }                      else                      {                          // not a switch -- it's an unknown parameter                          ndx = OnUnknownParameter(args' ndx' null' null);                      }                  }              }
Magic Number,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: if (args != null)              {                  var levelSpecified = false;                  var renamingSpecified = false;                  var killSpecified = false;                  var minifySpecified = false;                  bool parameterFlag;                  for (var ndx = 0; ndx < args.Length; ++ndx)                  {                      // parameter switch                      var thisArg = args[ndx];                        // don't use the forward-slash for switches if this is running under the Mono runtime.                       // Mono is a .NET for UNIX implementation' and the UNIX OS uses forward slashes as the directory separator.                      if (thisArg.Length > 1                        && (thisArg.StartsWith("-"' StringComparison.Ordinal) // this is a normal hyphen (minus character)                        || thisArg.StartsWith(""' StringComparison.Ordinal) // this character is what Word will convert a hyphen to                        || (!m_isMono && thisArg.StartsWith("/"' StringComparison.Ordinal))))                      {                          // general switch syntax is -switch:param                          var parts = thisArg.Substring(1).Split(':');                          var switchPart = parts[0].ToUpperInvariant();                          var paramPart = parts.Length == 1 ? null : parts[1];                          var paramPartUpper = paramPart == null ? null : paramPart.ToUpperInvariant();                            // switch off the switch part                          switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }                      }                      else                      {                          // not a switch -- it's an unknown parameter                          ndx = OnUnknownParameter(args' ndx' null' null);                      }                  }              }
Magic Number,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: if (args != null)              {                  var levelSpecified = false;                  var renamingSpecified = false;                  var killSpecified = false;                  var minifySpecified = false;                  bool parameterFlag;                  for (var ndx = 0; ndx < args.Length; ++ndx)                  {                      // parameter switch                      var thisArg = args[ndx];                        // don't use the forward-slash for switches if this is running under the Mono runtime.                       // Mono is a .NET for UNIX implementation' and the UNIX OS uses forward slashes as the directory separator.                      if (thisArg.Length > 1                        && (thisArg.StartsWith("-"' StringComparison.Ordinal) // this is a normal hyphen (minus character)                        || thisArg.StartsWith(""' StringComparison.Ordinal) // this character is what Word will convert a hyphen to                        || (!m_isMono && thisArg.StartsWith("/"' StringComparison.Ordinal))))                      {                          // general switch syntax is -switch:param                          var parts = thisArg.Substring(1).Split(':');                          var switchPart = parts[0].ToUpperInvariant();                          var paramPart = parts.Length == 1 ? null : parts[1];                          var paramPartUpper = paramPart == null ? null : paramPart.ToUpperInvariant();                            // switch off the switch part                          switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }                      }                      else                      {                          // not a switch -- it's an unknown parameter                          ndx = OnUnknownParameter(args' ndx' null' null);                      }                  }              }
Magic Number,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: if (args != null)              {                  var levelSpecified = false;                  var renamingSpecified = false;                  var killSpecified = false;                  var minifySpecified = false;                  bool parameterFlag;                  for (var ndx = 0; ndx < args.Length; ++ndx)                  {                      // parameter switch                      var thisArg = args[ndx];                        // don't use the forward-slash for switches if this is running under the Mono runtime.                       // Mono is a .NET for UNIX implementation' and the UNIX OS uses forward slashes as the directory separator.                      if (thisArg.Length > 1                        && (thisArg.StartsWith("-"' StringComparison.Ordinal) // this is a normal hyphen (minus character)                        || thisArg.StartsWith(""' StringComparison.Ordinal) // this character is what Word will convert a hyphen to                        || (!m_isMono && thisArg.StartsWith("/"' StringComparison.Ordinal))))                      {                          // general switch syntax is -switch:param                          var parts = thisArg.Substring(1).Split(':');                          var switchPart = parts[0].ToUpperInvariant();                          var paramPart = parts.Length == 1 ? null : parts[1];                          var paramPartUpper = paramPart == null ? null : paramPart.ToUpperInvariant();                            // switch off the switch part                          switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }                      }                      else                      {                          // not a switch -- it's an unknown parameter                          ndx = OnUnknownParameter(args' ndx' null' null);                      }                  }              }
Magic Number,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: if (args != null)              {                  var levelSpecified = false;                  var renamingSpecified = false;                  var killSpecified = false;                  var minifySpecified = false;                  bool parameterFlag;                  for (var ndx = 0; ndx < args.Length; ++ndx)                  {                      // parameter switch                      var thisArg = args[ndx];                        // don't use the forward-slash for switches if this is running under the Mono runtime.                       // Mono is a .NET for UNIX implementation' and the UNIX OS uses forward slashes as the directory separator.                      if (thisArg.Length > 1                        && (thisArg.StartsWith("-"' StringComparison.Ordinal) // this is a normal hyphen (minus character)                        || thisArg.StartsWith(""' StringComparison.Ordinal) // this character is what Word will convert a hyphen to                        || (!m_isMono && thisArg.StartsWith("/"' StringComparison.Ordinal))))                      {                          // general switch syntax is -switch:param                          var parts = thisArg.Substring(1).Split(':');                          var switchPart = parts[0].ToUpperInvariant();                          var paramPart = parts.Length == 1 ? null : parts[1];                          var paramPartUpper = paramPart == null ? null : paramPart.ToUpperInvariant();                            // switch off the switch part                          switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }                      }                      else                      {                          // not a switch -- it's an unknown parameter                          ndx = OnUnknownParameter(args' ndx' null' null);                      }                  }              }
Magic Number,Baker.Text,MinifierParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierParser.cs,Parse,The following statement contains a magic number: if (args != null)              {                  var levelSpecified = false;                  var renamingSpecified = false;                  var killSpecified = false;                  var minifySpecified = false;                  bool parameterFlag;                  for (var ndx = 0; ndx < args.Length; ++ndx)                  {                      // parameter switch                      var thisArg = args[ndx];                        // don't use the forward-slash for switches if this is running under the Mono runtime.                       // Mono is a .NET for UNIX implementation' and the UNIX OS uses forward slashes as the directory separator.                      if (thisArg.Length > 1                        && (thisArg.StartsWith("-"' StringComparison.Ordinal) // this is a normal hyphen (minus character)                        || thisArg.StartsWith(""' StringComparison.Ordinal) // this character is what Word will convert a hyphen to                        || (!m_isMono && thisArg.StartsWith("/"' StringComparison.Ordinal))))                      {                          // general switch syntax is -switch:param                          var parts = thisArg.Substring(1).Split(':');                          var switchPart = parts[0].ToUpperInvariant();                          var paramPart = parts.Length == 1 ? null : parts[1];                          var paramPartUpper = paramPart == null ? null : paramPart.ToUpperInvariant();                            // switch off the switch part                          switch (switchPart)                          {                              case "ANALYZE":                              case "A": // <-- old-style                                  // ignore any arguments                                  AnalyzeMode = true;                                    // by default' we have no report format                                  ReportFormat = null;                                  if (paramPartUpper != null)                                  {                                      var items = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var item in items)                                      {                                          if (string.CompareOrdinal(item' "OUT") == 0)                                          {                                              // if the analyze part is "out'" then the NEXT arg string                                              // is the output path the analyze scope report should be written to.                                              if (ndx >= args.Length - 1)                                              {                                                  // must be followed by a path                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                              else                                              {                                                  ReportPath = args[++ndx];                                              }                                          }                                          else                                          {                                              // must be a report format. There can be only one' so clobber whatever                                              // is there from before -- last one listed wins.                                              ReportFormat = item;                                          }                                      }                                  }                                    // if analyze was specified but no warning level' jack up the warning level                                  // so everything is shown                                  if (!levelSpecified)                                  {                                      // we want to analyze' and we didn't specify a particular warning level.                                      // go ahead and report all errors                                      WarningLevel = int.MaxValue;                                  }                                    break;                                case "ASPNET":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // same setting for both CSS and JS                                      JSSettings.AllowEmbeddedAspNetBlocks =                                          CssSettings.AllowEmbeddedAspNetBlocks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "BRACES":                                  if (paramPartUpper == "NEW")                                  {                                      JSSettings.BlocksStartOnSameLine =                                           CssSettings.BlocksStartOnSameLine = MinifierBlockStart.NewLine;                                  }                                  else if (paramPartUpper == "SAME")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.SameLine;                                  }                                  else if (paramPartUpper == "SOURCE")                                  {                                      JSSettings.BlocksStartOnSameLine =                                          CssSettings.BlocksStartOnSameLine = MinifierBlockStart.UseSource;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "CC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // actually' the flag is the opposite of the member -- turn CC ON and we DON'T                                      // want to ignore them; turn CC OFF and we DO want to ignore them                                      JSSettings.IgnoreConditionalCompilation = !parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "COLORS":                                  // two options: hex or names                                  if (paramPartUpper == "HEX")                                  {                                      CssSettings.ColorNames = CssColor.Hex;                                  }                                  else if (paramPartUpper == "STRICT")                                  {                                      CssSettings.ColorNames = CssColor.Strict;                                  }                                  else if (paramPartUpper == "MAJOR")                                  {                                      CssSettings.ColorNames = CssColor.Major;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnCssOnlyParameter();                                  break;                                case "COMMENTS":                                  // four options for css: none' all' important' or hacks                                  // two options for js: none' important                                  // (default is important)                                  if (paramPartUpper == "NONE")                                  {                                      CssSettings.CommentMode = CssComment.None;                                      JSSettings.PreserveImportantComments = false;                                  }                                  else if (paramPartUpper == "ALL")                                  {                                      CssSettings.CommentMode = CssComment.All;                                      OnCssOnlyParameter();                                  }                                  else if (paramPartUpper == "IMPORTANT")                                  {                                      CssSettings.CommentMode = CssComment.Important;                                      JSSettings.PreserveImportantComments = true;                                  }                                  else if (paramPartUpper == "HACKS")                                  {                                      CssSettings.CommentMode = CssComment.Hacks;                                      OnCssOnlyParameter();                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    break;                                case "CONST":                                  // options: MOZ or ES6 (ES6 is the default)                                  if (paramPartUpper == "MOZ")                                  {                                      JSSettings.ConstStatementsMozilla = true;                                  }                                  else if (paramPartUpper == "ES6")                                  {                                      JSSettings.ConstStatementsMozilla = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "CSS":                                  OnCssOnlyParameter();                                  if (paramPartUpper != null)                                  {                                      switch (paramPartUpper)                                      {                                          case "FULL":                                              CssSettings.CssType = CssType.FullStyleSheet;                                              break;                                            case "DECLS":                                              CssSettings.CssType = CssType.DeclarationList;                                              break;                                            default:                                              // not an expected value                                              OnInvalidSwitch(switchPart' paramPart);                                              break;                                      }                                  }                                  break;                                case "DEBUG":                                  // see if the param part is a comma-delimited list                                  if (paramPartUpper != null && paramPartUpper.IndexOf(''') >= 0)                                  {                                      // we have a comma-separated list.                                      // the first item is the flag (if any)' and the rest (if any) are the "debug" lookup names                                      var items = paramPart.Split(listSeparators);                                        // use the first value as the debug boolean switch.                                      // since we are splitting the non-uppercase param part' we need to                                       // make sure the first item is capitalized for our boolean test.                                      if (BooleanSwitch(items[0].ToUpperInvariant()' true' out parameterFlag))                                      {                                          // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                          // strip debug statements' and a FALSE means we DO want to strip them                                          JSSettings.StripDebugStatements = !parameterFlag;                                            // make sure we align the DEBUG define to the new switch value                                          AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                        // clear out the existing debug list                                      JSSettings.DebugLookupList = null;                                        // start with index 1' since index 0 was the flag                                      for (var item = 1; item < items.Length; ++item)                                      {                                          // get the identifier that was specified                                          var identifier = items[item];                                          if (!identifier.IsNullOrWhiteSpace())                                          {                                              if (!JSSettings.AddDebugLookup(identifier))                                              {                                                  OnInvalidSwitch(switchPart' identifier);                                              }                                          }                                      }                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // no commas -- just use the entire param part as the boolean value.                                      // just putting the debug switch on the command line without any arguments                                      // is the same as putting -debug:true and perfectly valid.                                        // actually the inverse - a TRUE on the -debug switch means we DON'T want to                                      // strip debug statements' and a FALSE means we DO want to strip them                                      JSSettings.StripDebugStatements = !parameterFlag;                                        // make sure we align the DEBUG define to the new switch value                                      AlignDebugDefine(JSSettings.StripDebugStatements' JSSettings.PreprocessorValues);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "DEFINE":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string define in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          string trimmedName;                                          string value;                                          var ndxEquals = define.IndexOf('=');                                          if (ndxEquals < 0)                                          {                                              trimmedName = define.Trim();                                              value = string.Empty;                                          }                                          else                                          {                                              trimmedName = define.Substring(0' ndxEquals).Trim();                                              value = define.Substring(ndxEquals + 1);                                          }                                            // better be a valid JavaScript identifier                                          if (!JsScanner.IsValidIdentifier(trimmedName))                                          {                                              OnInvalidSwitch(switchPart' define);                                          }                                          else                                          {                                              // JS Settings                                              JSSettings.PreprocessorValues[trimmedName] = value;                                                // CSS settings                                              CssSettings.PreprocessorValues[trimmedName] = value;                                          }                                            // if we're defining the DEBUG name' set the strip-debug-statements flag to false                                          if (string.Compare(trimmedName' "DEBUG"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              JSSettings.StripDebugStatements = false;                                          }                                      }                                  }                                    break;                                case "ENC":                                  // the encoding is the next argument                                  if (ndx >= args.Length - 1)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      string encoding = args[++ndx];                                        // whether this is an in or an out encoding                                      if (paramPartUpper == "IN")                                      {                                          // save the name -- we'll create the encoding later because we may                                          // override it on a file-by-file basis in an XML file                                          EncodingInputName = encoding;                                      }                                      else if (paramPartUpper == "OUT")                                      {                                          // just save the name -- we'll create the encoding later because we need                                          // to know whether we are JS or CSS to pick the right encoding fallback                                          EncodingOutputName = encoding;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "ESC":                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.AlwaysEscapeNonAscii = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  OnJSOnlyParameter();                                  break;                                case "EVALS":                                  // three options: ignore' make immediate scope safe' or make all scopes safe                                  if (paramPartUpper == "IGNORE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  }                                  else if (paramPartUpper == "IMMEDIATE")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeImmediateSafe;                                  }                                  else if (paramPartUpper == "SAFEALL")                                  {                                      JSSettings.EvalTreatment = JsEvalTreatment.MakeAllSafe;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "EXPR":                                  // two options: minify (default) or raw                                  if (paramPartUpper == "MINIFY")                                  {                                      CssSettings.MinifyExpressions = true;                                  }                                  else if (paramPartUpper == "RAW")                                  {                                      CssSettings.MinifyExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    OnCssOnlyParameter();                                  break;                                case "FNAMES":                                  // three options:                                   // LOCK    -> keep all NFE names' don't allow renaming of function names                                  // KEEP    -> keep all NFE names' but allow function names to be renamed                                  // ONLYREF -> remove unref'd NFE names' allow function named to be renamed (DEFAULT)                                  if (paramPartUpper == "LOCK")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // and preserve the names (don't allow renaming)                                      JSSettings.PreserveFunctionNames = true;                                  }                                  else if (paramPartUpper == "KEEP")                                  {                                      // don't remove function expression names                                      JSSettings.RemoveFunctionExpressionNames = false;                                        // but it's okay to rename them                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      // remove function expression names if they aren't referenced                                      JSSettings.RemoveFunctionExpressionNames = true;                                        // and rename them if we so desire                                      JSSettings.PreserveFunctionNames = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "GLOBAL":                              case "G": // <-- old style                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string global in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddKnownGlobal(global))                                          {                                              OnInvalidSwitch(switchPart' global);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "IGNORE":                                  // list of error codes to ignore (not report)                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string errorCode in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.Compare(errorCode' "ALL"' StringComparison.OrdinalIgnoreCase) == 0)                                          {                                              // we want to ignore ALL errors. So set the appropriate flag                                              JSSettings.IgnoreAllErrors =                                                  CssSettings.IgnoreAllErrors = true;                                          }                                          else                                          {                                              // don't add duplicates                                              JSSettings.IgnoreErrorCollection.Add(errorCode);                                              CssSettings.IgnoreErrorCollection.Add(errorCode);                                          }                                      }                                  }                                  break;                                case "INLINE":                                  if (string.IsNullOrEmpty(paramPart))                                  {                                      // no param parts. This defaults to inline-safe                                      JSSettings.InlineSafeStrings = true;                                  }                                  else                                  {                                      // for each comma-separated part...                                      foreach (var inlinePart in paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          if (string.CompareOrdinal(inlinePart' "FORCE") == 0)                                          {                                              // this is the force flag -- throw an error if any string literal                                              // sources are not properly escaped AND make sure the output is                                               // safe                                              JSSettings.ErrorIfNotInlineSafe = true;                                              JSSettings.InlineSafeStrings = true;                                          }                                          else if (string.CompareOrdinal(inlinePart' "NOFORCE") == 0)                                          {                                              // this is the noforce flag; don't throw an error is the source isn't inline safe.                                              // don't change whatever the output-inline-safe flag may happen to be' though                                              JSSettings.ErrorIfNotInlineSafe = false;                                          }                                          else                                          {                                              // assume it must be the boolean flag.                                              // if no param part' will return true (indicating the default)                                              // if invalid param part' will throw error                                              if (BooleanSwitch(inlinePart' true' out parameterFlag))                                              {                                                  JSSettings.InlineSafeStrings = parameterFlag;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' paramPart);                                              }                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "JS":                                  if (paramPart == null)                                  {                                      // normal settings                                      JSSettings.SourceMode = JsSourceMode.Program;                                      JSSettings.Format = JsFormat.Normal;                                  }                                  else                                  {                                      // comma-delimited list of JS settings                                      var tokens = paramPartUpper.Split('''' ';');                                      foreach (var token in tokens)                                      {                                          switch (token)                                          {                                              case "JSON":                                                  // JSON is incompatible with any other tokens' so throw an error                                                  // if it's not the only token                                                  if (tokens.Length > 1)                                                  {                                                      OnInvalidSwitch(switchPart' paramPart);                                                  }                                                    // nothing to "minify" in the JSON format' so turn off the minify flag                                                  JSSettings.MinifyCode = false;                                                    // JSON affects both the input (it's an expression) and the output                                                  // (use the JSON-output visitor)                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  JSSettings.Format = JsFormat.JSON;                                                  break;                                                case "PROG":                                                  // this is the default setting                                                  JSSettings.SourceMode = JsSourceMode.Program;                                                  break;                                                case "EXPR":                                                  JSSettings.SourceMode = JsSourceMode.Expression;                                                  break;                                                case "EVT":                                                  JSSettings.SourceMode = JsSourceMode.EventHandler;                                                  break;                                                default:                                                  // later: ES5 to convert any ES6 syntax to ES5-compatible                                                  // later: ES6 to create ES6 syntax when optimizing                                                  // etc.                                                  // those two examples will affect the format property.                                                  // but for now' not supported                                                  OnInvalidSwitch(switchPart' paramPart);                                                  break;                                          }                                      }                                  }                                    OnJSOnlyParameter();                                  break;                                case "KILL":                                  killSpecified = true;                                    // optional integer switch argument                                  if (paramPartUpper == null)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      // get the numeric portion                                      long killSwitch;                                      if (paramPartUpper.StartsWith("0X"' StringComparison.OrdinalIgnoreCase))                                      {                                          // it's hex -- convert the number after the "0x"                                          if (paramPartUpper.Substring(2).TryParseLongInvariant(NumberStyles.AllowHexSpecifier' out killSwitch))                                          {                                              // save the switch for both JS and Css                                              JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                                // for CSS' we only look at the first bit: preeserve important comments                                              if ((killSwitch & 1) != 0)                                              {                                                  // we set the kill' so make sure the comments are set to none                                                  CssSettings.CommentMode = CssComment.None;                                              }                                          }                                          else                                          {                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                      else if (paramPartUpper.TryParseLongInvariant(NumberStyles.AllowLeadingSign' out killSwitch))                                      {                                          // save the switch for both JS and CSS                                          JSSettings.KillSwitch = CssSettings.KillSwitch = killSwitch;                                            // for CSS' we only look at the first bit: preeserve important comments                                          if ((killSwitch & 1) != 0)                                          {                                              // we set the kill' so make sure the comments are set to none                                              CssSettings.CommentMode = CssComment.None;                                          }                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LINE":                              case "LINES":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // if no number specified' use the max default threshold                                      JSSettings.LineBreakThreshold =                                          CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                                                            // single-line mode                                      JSSettings.OutputMode =                                           CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                        // and four spaces per indent level                                      JSSettings.IndentSize =                                          CssSettings.IndentSize = 4;                                  }                                  else                                  {                                      // split along commas (case-insensitive)                                      var lineParts = paramPartUpper.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                        // by default' the line-break index will be 1 (the second option).                                      // we will change this index to 0 if the first parameter is multi/single                                      // instead of the line-break character count.                                      var breakIndex = 1;                                      if (lineParts.Length <= 3)                                      {                                          // if the first optional part is numeric' then it's the line threshold.                                          // might also be "multi" or "single"' thereby skipping the line threshold.                                          // (don't need to check length greater than zero -- will always be at least one element returned from Split)                                          if (!string.IsNullOrEmpty(lineParts[0]))                                          {                                              // must be an unsigned decimal integer value                                              int lineThreshold;                                              if (lineParts[0].TryParseIntInvariant(NumberStyles.None' out lineThreshold))                                              {                                                  JSSettings.LineBreakThreshold =                                                      CssSettings.LineBreakThreshold = lineThreshold;                                              }                                              else if (lineParts[0][0] == 'S')                                              {                                                  // single-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else if (lineParts[0][0] == 'M')                                              {                                                  // multiple-line mode                                                  JSSettings.OutputMode =                                                      CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                    // the line-break index was the first one (zero)                                                  breakIndex = 0;                                              }                                              else                                              {                                                  OnInvalidSwitch(switchPart' lineParts[0]);                                              }                                          }                                          else                                          {                                              // use the default                                              JSSettings.LineBreakThreshold =                                                  CssSettings.LineBreakThreshold = int.MaxValue - 1000;                                          }                                            if (lineParts.Length > breakIndex)                                          {                                              // if the line-break index was zero' then we already processed it                                              // and we can skip the logic                                              if (breakIndex > 0)                                              {                                                  // second optional part is single or multiple line output                                                  if (string.IsNullOrEmpty(lineParts[breakIndex]) || lineParts[breakIndex][0] == 'S')                                                  {                                                      // single-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.SingleLine;                                                  }                                                  else if (lineParts[breakIndex][0] == 'M')                                                  {                                                      // multiple-line mode                                                      JSSettings.OutputMode =                                                          CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                                  }                                                  else                                                  {                                                      // must either be missing' or start with S (single) or M (multiple)                                                      OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                  }                                              }                                                // move on to the next part                                              ++breakIndex;                                              if (lineParts.Length > breakIndex)                                              {                                                  // third optional part is the spaces-per-indent value                                                  if (!string.IsNullOrEmpty(lineParts[breakIndex]))                                                  {                                                      // get the numeric portion; must be a decimal integer                                                      int indentSize;                                                      if (lineParts[breakIndex].TryParseIntInvariant(NumberStyles.None' out indentSize))                                                      {                                                          // same value for JS and CSS.                                                          // don't need to check for negative' because the tryparse method above does NOT                                                          // allow for a sign -- no sign' no negative.                                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                                      }                                                      else                                                      {                                                          OnInvalidSwitch(switchPart' lineParts[breakIndex]);                                                      }                                                  }                                                  else                                                  {                                                      // default of 4                                                      JSSettings.IndentSize =                                                          CssSettings.IndentSize = 4;                                                  }                                              }                                          }                                      }                                      else                                      {                                          // only 1-3 parts allowed                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    break;                                case "LITERALS":                                  // two areas with two options each: keep or combine and eval or noeval                                  if (paramPartUpper == "KEEP")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = false;                                  }                                  else if (paramPartUpper == "COMBINE")                                  {                                      // no longer supported....                                      //JSSettings.CombineDuplicateLiterals = true;                                  }                                  else if (paramPartUpper == "EVAL")                                  {                                      JSSettings.EvalLiteralExpressions = true;                                  }                                  else if (paramPartUpper == "NOEVAL")                                  {                                      JSSettings.EvalLiteralExpressions = false;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MAC":                                  // optional boolean switch                                  // no arg is valid scenario (default is true)                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.MacSafariQuirks = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "MINIFY":                                  minifySpecified = true;                                  if (renamingSpecified && JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      // minify can only exist if rename is set to KeepAll                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      // optional boolean switch                                      // no arg is a valid scenario (default is true)                                      JSSettings.MinifyCode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NEW":                                  // two options: keep and collapse                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.CollapseToLiteral = false;                                  }                                  else if (paramPartUpper == "COLLAPSE")                                  {                                      JSSettings.CollapseToLiteral = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NFE": // <-- deprecate; use FNAMES option instead                                  if (paramPartUpper == "KEEPALL")                                  {                                      JSSettings.RemoveFunctionExpressionNames = false;                                  }                                  else if (paramPartUpper == "ONLYREF")                                  {                                      JSSettings.RemoveFunctionExpressionNames = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "NORENAME":                                  // the parts can be a comma-separate list of identifiers                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      foreach (string ident in paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries))                                      {                                          // better be a valid JavaScript identifier                                          if (!JSSettings.AddNoAutoRename(ident))                                          {                                              OnInvalidSwitch(switchPart' ident);                                          }                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "OBJ":                                  // two options: MINify or QUOTE                                  if (paramPartUpper == "MIN")                                  {                                      JSSettings.QuoteObjectLiteralProperties = false;                                  }                                  else if (paramPartUpper == "QUOTE")                                  {                                      JSSettings.QuoteObjectLiteralProperties = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PPONLY":                                  // just putting the pponly switch on the command line without any arguments                                  // is the same as putting -pponly:true and perfectly valid.                                  if (paramPart == null)                                  {                                      JSSettings.PreprocessOnly = true;                                  }                                  else if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.PreprocessOnly = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "PRETTY":                              case "P": // <-- old style                                  // doesn't take a flag -- just set to pretty                                  PrettyPrint = true;                                                // by default' pretty mode turns off minification' which sets a bunch of other flags as well                                  JSSettings.MinifyCode = false;                                    // and some other flags for pretty-mode                                  JSSettings.OutputMode = CssSettings.OutputMode = MinifierOutputMode.MultipleLines;                                  CssSettings.KillSwitch = ~((long)JsTreeModifications.PreserveImportantComments);                                    // optional integer switch argument                                  if (paramPartUpper != null)                                  {                                      // get the numeric portion; must be a decimal integer                                      int indentSize;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out indentSize))                                      {                                          // same value for JS and CSS.                                          // don't need to check for negative' because the tryparse method above does NOT                                          // allow for a sign -- no sign' no negative.                                          JSSettings.IndentSize = CssSettings.IndentSize = indentSize;                                      }                                      else                                       {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  break;                                case "RENAME":                                  if (paramPartUpper == null)                                  {                                      // treat as if it's unknown                                      ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  }                                  else if (paramPartUpper.IndexOf('=') > 0)                                  {                                      // there is at least one equal sign -- treat this as a set of JS identifier                                      // pairs. split on commas -- multiple pairs can be specified                                      var paramPairs = paramPart.Split(listSeparators' StringSplitOptions.RemoveEmptyEntries);                                      foreach (var paramPair in paramPairs)                                      {                                          // split on the equal sign -- each pair needs to have an equal sige                                          var pairParts = paramPair.Split('=');                                          if (pairParts.Length == 2)                                          {                                              // there is an equal sign. The first part is the source name and the                                              // second part is the new name to which to rename those entities.                                              string fromIdentifier = pairParts[0];                                              string toIdentifier = pairParts[1];                                                // make sure both parts are valid JS identifiers                                              var fromIsValid = JsScanner.IsValidIdentifier(fromIdentifier);                                              var toIsValid = JsScanner.IsValidIdentifier(toIdentifier);                                              if (fromIsValid && toIsValid)                                              {                                                  // create the map if it hasn't been created yet.                                                  var toExisting = JSSettings.GetNewName(fromIdentifier);                                                  if (toExisting == null)                                                  {                                                      JSSettings.AddRenamePair(fromIdentifier' toIdentifier);                                                  }                                                  else if (string.CompareOrdinal(toIdentifier' toExisting) != 0)                                                  {                                                      // from-identifier already exists' and the to-identifier doesn't match.                                                      // can't rename the same name to two different names!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                              else                                              {                                                  if (fromIsValid)                                                  {                                                      // the toIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' toIdentifier);                                                  }                                                    if (toIsValid)                                                  {                                                      // the fromIdentifier is invalid!                                                      OnInvalidSwitch(switchPart' fromIdentifier);                                                  }                                              }                                          }                                          else                                          {                                              // either zero or more than one equal sign. Invalid.                                              OnInvalidSwitch(switchPart' paramPart);                                          }                                      }                                  }                                  else                                  {                                      // no equal sign; just a plain option                                      // three options: all' localization' none                                      if (paramPartUpper == "ALL")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "LOCALIZATION")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NONE")                                      {                                          JSSettings.LocalRenaming = JsLocalRenaming.KeepAll;                                            // automatic renaming strategy has been specified by this option                                          renamingSpecified = true;                                      }                                      else if (paramPartUpper == "NOPROPS")                                      {                                          // manual-renaming does not change property names                                          JSSettings.ManualRenamesProperties = false;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  if (JSSettings.LocalRenaming != JsLocalRenaming.KeepAll)                                  {                                      ResetRenamingKill(killSpecified);                                        // if minify was specified as turned off' then this is invalid                                      if (minifySpecified && !JSSettings.MinifyCode)                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "REORDER":                                  // default is true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.ReorderScopeDeclarations = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "STRICT":                                  // default is false' but if we specify this switch without a parameter' then                                  // we assume we are turning it ON                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.StrictMode = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "TERM":                                  // optional boolean argument' defaults to true                                  if (BooleanSwitch(paramPartUpper' true' out parameterFlag))                                  {                                      JSSettings.TermSemicolons =                                          CssSettings.TermSemicolons = parameterFlag;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "UNUSED":                                  // two options: keep and remove                                  if (paramPartUpper == "KEEP")                                  {                                      JSSettings.RemoveUnneededCode = false;                                  }                                  else if (paramPartUpper == "REMOVE")                                  {                                      JSSettings.RemoveUnneededCode = true;                                  }                                  else                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "VAR":                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  else                                  {                                      var firstLetters = paramPart;                                      string partLetters = null;                                        var commaPosition = paramPart.IndexOf(''');                                      if (commaPosition == 0)                                      {                                          // no first letters; just part letters                                          firstLetters = null;                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                      else if (commaPosition > 0)                                      {                                          // first letters and part letters                                          firstLetters = paramPart.Substring(0' commaPosition);                                          partLetters = paramPart.Substring(commaPosition + 1);                                      }                                        // if we specified first letters' set them now                                      if (!string.IsNullOrEmpty(firstLetters))                                      {                                          JsCrunchEnumerator.FirstLetters = firstLetters;                                      }                                        // if we specified part letters' use it -- otherwise use the first letters.                                      if (!string.IsNullOrEmpty(partLetters))                                      {                                          JsCrunchEnumerator.PartLetters = partLetters;                                      }                                      else if (!string.IsNullOrEmpty(firstLetters))                                      {                                          // we don't have any part letters' but we do have first letters. reuse.                                          JsCrunchEnumerator.PartLetters = firstLetters;                                      }                                  }                                    // this is a JS-only switch                                  OnJSOnlyParameter();                                  break;                                case "WARN":                              case "W": // <-- old style                                  if (string.IsNullOrEmpty(paramPartUpper))                                  {                                      // just "-warn" without anything else means all errors and warnings                                      WarningLevel = int.MaxValue;                                  }                                  else                                  {                                      // must be an unsigned decimal integer value                                      int warningLevel;                                      if (paramPart.TryParseIntInvariant(NumberStyles.None' out warningLevel))                                      {                                          WarningLevel = warningLevel;                                      }                                      else                                      {                                          OnInvalidSwitch(switchPart' paramPart);                                      }                                  }                                  levelSpecified = true;                                  break;                                //                              // Backward-compatibility switches different from new switches                              //                                case "D":                                  // equivalent to -debug:false (default behavior)                                  JSSettings.StripDebugStatements = true;                                  OnJSOnlyParameter();                                  break;                                case "E":                              case "EO":                                  // equivalent to -enc:out <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // just save the name -- we'll create the encoding later because we need                                  // to know whether we are JS or CSS to pick the right encoding fallback                                  EncodingOutputName = paramPart;                                  break;                                case "EI":                                  // equivalent to -enc:in <encoding>                                  if (parts.Length < 2)                                  {                                      // must be followed by an encoding                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                    // save the name                                  EncodingInputName = paramPart;                                  break;                                case "H":                                  // equivalent to -rename:all -unused:remove (default behavior)                                  JSSettings.LocalRenaming = JsLocalRenaming.CrunchAll;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HL":                                  // equivalent to -rename:localization -unused:remove                                  JSSettings.LocalRenaming = JsLocalRenaming.KeepLocalizationVars;                                  JSSettings.RemoveUnneededCode = true;                                  OnJSOnlyParameter();                                    // renaming is specified by this option                                  renamingSpecified = true;                                    // since we specified a rename switch OTHER than none'                                   // let's make sure we don't *automatically* turn off switches that would                                   // stop renaming' which we have explicitly said we want.                                  ResetRenamingKill(killSpecified);                                    // if minify was specified as turned off' then this is invalid                                  if (minifySpecified && !JSSettings.MinifyCode)                                  {                                      OnInvalidSwitch(switchPart' paramPart);                                  }                                  break;                                case "HC":                                  // equivalent to -literals:combine -rename:all -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "H";                                case "HLC":                              case "HCL":                                  // equivalent to -literals:combine -rename:localization -unused:remove                                  // literal-combining no longer supported....                                  //JSSettings.CombineDuplicateLiterals = true;                                  goto case "HL";                                case "J":                                  // equivalent to -evals:ignore (default behavior)                                  JSSettings.EvalTreatment = JsEvalTreatment.Ignore;                                  OnJSOnlyParameter();                                  break;                                case "K":                                  // equivalent to -inline:true (default behavior)                                  JSSettings.InlineSafeStrings = true;                                  OnJSOnlyParameter();                                  break;                                case "L":                                  // equivalent to -new:keep (default is collapse)                                  JSSettings.CollapseToLiteral = false;                                  OnJSOnlyParameter();                                  break;                                case "M":                                  // equivalent to -mac:true (default behavior)                                  JSSettings.MacSafariQuirks = true;                                  OnJSOnlyParameter();                                  break;                                case "Z":                                  // equivalent to -term:true (default is false)                                  JSSettings.TermSemicolons =                                      CssSettings.TermSemicolons = true;                                  break;                                // end backward-compatible section                                default:                                  ndx = OnUnknownParameter(args' ndx' switchPart' paramPart);                                  break;                          }                      }                      else                      {                          // not a switch -- it's an unknown parameter                          ndx = OnUnknownParameter(args' ndx' null' null);                      }                  }              }
Magic Number,Baker.Text,MinifierSettings,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierSettings.cs,MinifierSettings,The following statement contains a magic number: IndentSize = 4;
Magic Number,Baker.Text,MinifierSettings,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\MinifierSettings.cs,MinifierSettings,The following statement contains a magic number: LineBreakThreshold = int.MaxValue - 1000;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,FormParagraphs,The following statement contains a magic number: for (int i = 0; i < grafs.Length; i++)              {                  if (grafs[i].Contains("<code ")                       && !grafs[i].Contains("</code>"))                  {                      skipGraphs = true;                  }                  if (grafs[i].Contains("</code>")                       && !grafs[i].Contains("<code "))                  {                      skipGraphs = false;                      continue;                  }                    if (skipGraphs) { continue; }                    if (grafs[i].StartsWith("\x1AH"))                  {                      // unhashify HTML blocks                      if (unhash)                      {                          int sanityCheck = 50; // just for safety' guard against an infinite loop                          bool keepGoing = true; // as long as replacements where made' keep going                          while (keepGoing && sanityCheck > 0)                          {                              keepGoing = false;                              grafs[i] = _htmlBlockHash.Replace(grafs[i]' match =>                              {                                  keepGoing = true;                                  return _htmlBlocks[match.Value];                              });                              sanityCheck--;                          }                          /* if (keepGoing)                          {                              // Logging of an infinite loop goes here.                              // If such a thing should happen' please open a new issue on http://code.google.com/p/markdownsharp/                              // with the input that caused it.                          }*/                      }                  }                  else                  {                      // do span level processing inside the block' then wrap result in <p> tags                      grafs[i] = _leadingWhitespace.Replace(RunSpanGamut(grafs[i])' "<p>") + "</p>";                  }              }
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,LinkEvaluator,The following statement contains a magic number: _urls[linkID] = EncodeAmpsAndAngles(match.Groups[2].Value);
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,LinkEvaluator,The following statement contains a magic number: if (match.Groups[3] != null && match.Groups[3].Length > 0)                  _titles[linkID] = match.Groups[3].Value.Replace("\""' "&quot;");
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,LinkEvaluator,The following statement contains a magic number: if (match.Groups[3] != null && match.Groups[3].Length > 0)                  _titles[linkID] = match.Groups[3].Value.Replace("\""' "&quot;");
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,LinkEvaluator,The following statement contains a magic number: if (match.Groups[3] != null && match.Groups[3].Length > 0)                  _titles[linkID] = match.Groups[3].Value.Replace("\""' "&quot;");
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,AnchorRefEvaluator,The following statement contains a magic number: string linkText = SaveFromAutoLinking(match.Groups[2].Value);
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,AnchorRefEvaluator,The following statement contains a magic number: string linkID = match.Groups[3].Value.ToLowerInvariant();
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,AnchorRefShortcutEvaluator,The following statement contains a magic number: string linkText = SaveFromAutoLinking(match.Groups[2].Value);
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,AnchorInlineEvaluator,The following statement contains a magic number: string linkText = SaveFromAutoLinking(match.Groups[2].Value);
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,AnchorInlineEvaluator,The following statement contains a magic number: string url = match.Groups[3].Value;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,AnchorInlineEvaluator,The following statement contains a magic number: string title = match.Groups[6].Value;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,AnchorInlineEvaluator,The following statement contains a magic number: if (url.StartsWith("<") && url.EndsWith(">"))                  url = url.Substring(1' url.Length - 2);
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,ImageReferenceEvaluator,The following statement contains a magic number: string altText = match.Groups[2].Value;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,ImageReferenceEvaluator,The following statement contains a magic number: string linkID = match.Groups[3].Value.ToLowerInvariant();
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,ImageInlineEvaluator,The following statement contains a magic number: string alt = match.Groups[2].Value;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,ImageInlineEvaluator,The following statement contains a magic number: string url = match.Groups[3].Value;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,ImageInlineEvaluator,The following statement contains a magic number: string title = match.Groups[6].Value;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,ImageInlineEvaluator,The following statement contains a magic number: if (url.StartsWith("<") && url.EndsWith(">"))                  url = url.Substring(1' url.Length - 2);
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,SetextHeaderEvaluator,The following statement contains a magic number: int level = match.Groups[2].Value.StartsWith("=") ? 1 : 2;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,SetextHeaderEvaluator,The following statement contains a magic number: int level = match.Groups[2].Value.StartsWith("=") ? 1 : 2;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,AtxHeaderEvaluator,The following statement contains a magic number: string header = match.Groups[2].Value;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,GetListEvaluator,The following statement contains a magic number: return new MatchEvaluator(match =>              {                  string list = match.Groups[1].Value;                  string listType = Regex.IsMatch(match.Groups[3].Value' _markerUL) ? "ul" : "ol";                  string result;                    result = ProcessListItems(list' listType == "ul" ? _markerUL : _markerOL' isInsideParagraphlessListItem);                    result = string.Format("<{0}>\n{1}</{0}>\n"' listType' result);                  return result;              });
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,ProcessListItems,The following statement contains a magic number: MatchEvaluator ListItemEvaluator = (Match match) =>              {                  string item = match.Groups[3].Value;                    bool endsWithDoubleNewline = item.EndsWith("\n\n");                  bool containsDoubleNewline = endsWithDoubleNewline || item.Contains("\n\n");                    if (containsDoubleNewline || lastItemHadADoubleNewline)                      // we could correct any bad indentation here..                      item = RunBlockGamut(Outdent(item) + "\n"' unhash: false);                  else                  {                      // recursion for sub-lists                      item = DoLists(Outdent(item)' isInsideParagraphlessListItem: true);                      item = item.TrimEnd('\n');                      if (!isInsideParagraphlessListItem) // only the outer-most item should run this' otherwise it's run multiple times for the inner ones                          item = RunSpanGamut(item);                  }                  lastItemHadADoubleNewline = endsWithDoubleNewline;                  return string.Format("<li>{0}</li>\n"' item);              };
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,GithubCodeEvaluator,The following statement contains a magic number: string codeBlock = match.Groups[3].Value;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,GithubCodeEvaluator,The following statement contains a magic number: string typeBlock = match.Groups[2].Value;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,CodeSpanEvaluator,The following statement contains a magic number: string span = match.Groups[2].Value;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,handleTrailingParens,The following statement contains a magic number: var protocol = match.Groups[2].Value;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,handleTrailingParens,The following statement contains a magic number: var link = match.Groups[3].Value;
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,EncodeEmailAddress,The following statement contains a magic number: var sb = new StringBuilder(addr.Length * 5);
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,EncodeEmailAddress,The following statement contains a magic number: foreach (char c in addr)              {                  r = rand.Next(1' 100);                  if ((r > 90 || c == ':') && c != '@')                      sb.Append(c);                         // m                  else if (r < 45)                      sb.AppendFormat("&#x{0:x};"' (int)c); // &#x6D                  else                      sb.AppendFormat("&#{0};"' (int)c);    // &#109              }
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,EncodeEmailAddress,The following statement contains a magic number: foreach (char c in addr)              {                  r = rand.Next(1' 100);                  if ((r > 90 || c == ':') && c != '@')                      sb.Append(c);                         // m                  else if (r < 45)                      sb.AppendFormat("&#x{0:x};"' (int)c); // &#x6D                  else                      sb.AppendFormat("&#{0};"' (int)c);    // &#109              }
Magic Number,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,EncodeEmailAddress,The following statement contains a magic number: foreach (char c in addr)              {                  r = rand.Next(1' 100);                  if ((r > 90 || c == ':') && c != '@')                      sb.Append(c);                         // m                  else if (r < 45)                      sb.AppendFormat("&#x{0:x};"' (int)c); // &#x6D                  else                      sb.AppendFormat("&#{0};"' (int)c);    // &#109              }
Duplicate Code,Baker.Text,HtmlCompressor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Html\HtmlCompressor.cs,preserveBlocks,The method contains a code clone-set at the following line numbers (starting from the method definition): ((99' 122)' (126' 149))
Duplicate Code,Baker.Text,JsParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsParser.cs,ParseForStatement,The method contains a code clone-set at the following line numbers (starting from the method definition): ((137' 156)' (273' 292))
Duplicate Code,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((150' 183)' (194' 251))
Duplicate Code,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((153' 172)' (197' 216)' (209' 228)' (221' 240))
Duplicate Code,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((197' 227)' (209' 239))
Duplicate Code,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,ScanString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((197' 216)' (221' 240))
Missing Default,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseExpressionFunction,The following switch statement is missing a default case: switch (CurrentTokenText)                          {                              case "(":                                  // start a nested paren                                  ++parenLevel;                                  break;                                case ")":                                  // end a nested paren                                   // (we know it's nested because if it wasn't' we wouldn't                                  // have entered the loop)                                  --parenLevel;                                  break;                          }
Missing Default,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,ParseUnit,The following switch statement is missing a default case: switch (CurrentTokenType)              {                  case TokenType.Number:                  case TokenType.Percentage:                  case TokenType.Dimension:                  case TokenType.RelativeLength:                  case TokenType.AbsoluteLength:                  case TokenType.Angle:                  case TokenType.Time:                  case TokenType.Resolution:                  case TokenType.Frequency:                      // output it' skip any whitespace' and mark us as okay                      AppendCurrent();                      SkipSpace();                      parsed = Parsed.True;                      break;                    case TokenType.Function:                      // calc( or attr( are allowed here.                      parsed = ParseFunction();                        // if parsed is false' then we encountered an error with the function                      // and probably already output an error message. So only output an error                      // message if we didn't find ANYTHING                      if (parsed == Parsed.Empty)                      {                          ReportError(0' CssErrorCode.UnexpectedFunction' CurrentTokenText);                          parsed = Parsed.False;                      }                      break;                    case TokenType.Character:                      // only open parenthesis allowed                      if (CurrentTokenText == "(")                      {                          // TODO: make sure there is whitespace before the ( if it would cause                          // it to be the opening paren of a function token                            AppendCurrent();                          SkipSpace();                            // better be a sum inside the parens                          parsed = ParseSum();                          if (parsed != Parsed.True)                          {                              // report error and change the parsed flag to false so we know there was an error                              ReportError(0' CssErrorCode.ExpectedSum' CurrentTokenText);                              parsed = Parsed.False;                          }                          else if (CurrentTokenType != TokenType.Character || CurrentTokenText != ")")                          {                              // needs to be a closing paren here                              ReportError(0' CssErrorCode.ExpectedClosingParenthesis' CurrentTokenText);                              parsed = Parsed.False;                          }                          else                          {                              // we're at the closing paren' so output it now' advance past any                              // subsequent whitespace' and mark us as okay                              AppendCurrent();                              SkipSpace();                              parsed = Parsed.True;                          }                      }                      break;              }
Missing Default,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,Append,The following switch statement is missing a default case: switch (Settings.ColorNames)                      {                          case CssColor.Hex:                              // we don't want any color names in our code.                              // convert ALL known color names to hex' so see if there is a match on                              // the set containing all the name-to-hex values                              if (ColorSlice.AllColorNames.TryGetValue(lowerCaseText' out rgbString))                              {                                  text = rgbString;                                  nameConvertedToHex = true;                              }                              break;                            case CssColor.Strict:                              // we only want strict names in our css.                              // convert all non-strict name to hex' AND any strict names to hex if the hex is                              // shorter than the name. So check the set that contains all non-strict name-to-hex                              // values and all the strict name-to-hex values where hex is shorter than name.                              if (ColorSlice.StrictHexShorterThanNameAndAllNonStrict.TryGetValue(lowerCaseText' out rgbString))                              {                                  text = rgbString;                                  nameConvertedToHex = true;                              }                              break;                            case CssColor.Major:                              // we don't care if there are non-strict color name. So check the set that only                              // contains name-to-hex pairs where the hex is shorter than the name.                              if (ColorSlice.HexShorterThanName.TryGetValue(lowerCaseText' out rgbString))                              {                                  text = rgbString;                                  nameConvertedToHex = true;                              }                              break;                      }
Missing Default,Baker.Text,CssParser,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssParser.cs,MightContainColorNames,The following switch statement is missing a default case: switch (propertyName)                  {                      case "background":                      case "border-top":                      case "border-right":                      case "border-bottom":                      case "border-left":                      case "border":                      case "outline":                          hasColor = true;                          break;                  }
Missing Default,Baker.Text,CssScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\Css\CssScanner.cs,ScanNum,The following switch statement is missing a default case: switch (dimen.ToUpperInvariant())                          {                              case "EM":          // font-size of the element                              case "EX":          // x-height of the element's font                              case "CH":          // width of the zero glyph in the element's font                              case "REM":         // font-size of the root element                              case "VW":          // viewport's width                              case "VH":          // viewport's height                              case "VM":          // viewport width or height' whichever is smaller of the two (use VMIN)                              case "VMIN":        // minimum of the viewport's height and width                              case "VMAX":        // maximum of the viewport's height and width                              case "FR":          // fraction of available space                              case "GR":          // grid unit                              case "GD":          // text grid unit                                  tokenType = TokenType.RelativeLength;                                  break;                                case "CM":          // centimeters                              case "MM":          // millimeters                              case "IN":          // inches (1in == 2.54cm)                              case "PX":          // pixels (1px == 1/96in)                              case "PT":          // points (1pt == 1/72in)                              case "PC":          // picas (1pc == 12pt)                                  tokenType = TokenType.AbsoluteLength;                                  break;                                case "DEG":         // degrees (360deg == 1 full circle)                              case "GRAD":        // gradians (400grad == 1 full circle)                              case "RAD":         // radians (2*pi radians == 1 full circle)                              case "TURN":        // turns (1turn == 1 full circle)                                  tokenType = TokenType.Angle;                                  break;                                case "MS":          // milliseconds                              case "S":           // seconds                                  tokenType = TokenType.Time;                                  break;                                case "DPI":         // dots per inch                              case "DPCM":        // dots per centimeter                              case "DPPX":        // dots per pixel                                  tokenType = TokenType.Resolution;                                  break;                                case "HZ":          // hertz                              case "KHZ":         // kilohertz                                  tokenType = TokenType.Frequency;                                  break;                                case "DB":          // decibel                              case "ST":          // semitones                                  tokenType = TokenType.Speech;                                  break;                          }
Missing Default,Baker.Text,JsConstantWrapper,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsConstantWrapper.cs,IsEquivalentTo,The following switch statement is missing a default case: switch (PrimitiveType)                  {                      case JsPrimitiveType.Boolean:                          // bools must be the same                          return ToBoolean() == otherConstant.ToBoolean();                        case JsPrimitiveType.Null:                          // nulls are always equivalent                          return true;                        case JsPrimitiveType.Number:                          // numbers must be equal                          return ToNumber() == otherConstant.ToNumber();                        case JsPrimitiveType.String:                          // strings must be identical                          return string.CompareOrdinal(Value.ToString()' otherConstant.ToString()) == 0;                        case JsPrimitiveType.Other:                          // others are never the same                          return false;                  }
Missing Default,Baker.Text,JsConstantWrapper,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsConstantWrapper.cs,OkayToDoubleQuote,The following switch statement is missing a default case: switch (text[ndx])                  {                      case '"':                           ++numberOfQuotes;                           break;                      case '\'':                           ++numberOfApostrophes;                           break;                  }
Missing Default,Baker.Text,JsConstantWrapper,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsConstantWrapper.cs,ToString,The following switch statement is missing a default case: switch (PrimitiveType)              {                  case JsPrimitiveType.Null:                      // null is just "null"                      return "null";                    case JsPrimitiveType.Boolean:                      // boolean is "true" or "false"                      return (bool)Value ? "true" : "false";                    case JsPrimitiveType.Number:                      {                          // handle some special values' otherwise just fall through                          // to the default ToString implementation                          double doubleValue = (double)Value;                          if (doubleValue == 0)                          {                              // both -0 and 0 return "0". Go figure.                              return "0";                          }                          if (double.IsNaN(doubleValue))                          {                              return "NaN";                          }                          if (double.IsPositiveInfinity(doubleValue))                          {                              return "Infinity";                          }                          if (double.IsNegativeInfinity(doubleValue))                          {                              return "-Infinity";                          }                            // use the "R" format' which guarantees that the double value can                          // be round-tripped to the same value                          return doubleValue.ToStringInvariant("R");                      }              }
Missing Default,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,EvalToTheLeft,The following switch statement is missing a default case: switch (node.OperatorToken)                  {                      case JsToken.BitwiseAnd:                          newLiteral = BitwiseAnd(otherConstant' thisConstant);                          break;                        case JsToken.BitwiseOr:                          newLiteral = BitwiseOr(otherConstant' thisConstant);                          break;                        case JsToken.BitwiseXor:                          newLiteral = BitwiseXor(otherConstant' thisConstant);                          break;                  }
Missing Default,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,Equal,The following switch statement is missing a default case: switch (leftType)                      {                          case JsPrimitiveType.Null:                              // null == null is true                              newLiteral = new JsConstantWrapper(true' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.Boolean:                              // compare boolean values                              newLiteral = new JsConstantWrapper(left.ToBoolean() == right.ToBoolean()' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.String:                              // compare string ordinally                              if (left.IsOkayToCombine && right.IsOkayToCombine)                              {                                  newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) == 0' JsPrimitiveType.Boolean' null' m_parser);                              }                              break;                            case JsPrimitiveType.Number:                              try                              {                                  // compare the values                                  // +0 and -0 are treated as "equal" in C#' so we don't need to test them separately.                                  // and NaN is always unequal to everything else' including itself.                                  if (left.IsOkayToCombine && right.IsOkayToCombine)                                  {                                      newLiteral = new JsConstantWrapper(left.ToNumber() == right.ToNumber()' JsPrimitiveType.Boolean' null' m_parser);                                  }                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                              break;                      }
Missing Default,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,NotEqual,The following switch statement is missing a default case: switch (leftType)                      {                          case JsPrimitiveType.Null:                              // null != null is false                              newLiteral = new JsConstantWrapper(false' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.Boolean:                              // compare boolean values                              newLiteral = new JsConstantWrapper(left.ToBoolean() != right.ToBoolean()' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.String:                              // compare string ordinally                              if (left.IsOkayToCombine && right.IsOkayToCombine)                              {                                  newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) != 0' JsPrimitiveType.Boolean' null' m_parser);                              }                              break;                            case JsPrimitiveType.Number:                              try                              {                                  // compare the values                                  // +0 and -0 are treated as "equal" in C#' so we don't need to test them separately.                                  // and NaN is always unequal to everything else' including itself.                                  if (left.IsOkayToCombine && right.IsOkayToCombine)                                  {                                      newLiteral = new JsConstantWrapper(left.ToNumber() != right.ToNumber()' JsPrimitiveType.Boolean' null' m_parser);                                  }                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                              break;                      }
Missing Default,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictEqual,The following switch statement is missing a default case: switch (leftType)                      {                          case JsPrimitiveType.Null:                              // null === null is true                              newLiteral = new JsConstantWrapper(true' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.Boolean:                              // compare boolean values                              newLiteral = new JsConstantWrapper(left.ToBoolean() == right.ToBoolean()' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.String:                              // compare string ordinally                              if (left.IsOkayToCombine && right.IsOkayToCombine)                              {                                  newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) == 0' JsPrimitiveType.Boolean' null' m_parser);                              }                              break;                            case JsPrimitiveType.Number:                              try                              {                                  // compare the values                                  // +0 and -0 are treated as "equal" in C#' so we don't need to test them separately.                                  // and NaN is always unequal to everything else' including itself.                                  if (left.IsOkayToCombine && right.IsOkayToCombine)                                  {                                      newLiteral = new JsConstantWrapper(left.ToNumber() == right.ToNumber()' JsPrimitiveType.Boolean' null' m_parser);                                  }                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                              break;                      }
Missing Default,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,StrictNotEqual,The following switch statement is missing a default case: switch (leftType)                      {                          case JsPrimitiveType.Null:                              // null !== null is false                              newLiteral = new JsConstantWrapper(false' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.Boolean:                              // compare boolean values                              newLiteral = new JsConstantWrapper(left.ToBoolean() != right.ToBoolean()' JsPrimitiveType.Boolean' null' m_parser);                              break;                            case JsPrimitiveType.String:                              // compare string ordinally                              if (left.IsOkayToCombine && right.IsOkayToCombine)                              {                                  newLiteral = new JsConstantWrapper(string.CompareOrdinal(left.ToString()' right.ToString()) != 0' JsPrimitiveType.Boolean' null' m_parser);                              }                              break;                            case JsPrimitiveType.Number:                              try                              {                                  // compare the values                                  // +0 and -0 are treated as "equal" in C#' so we don't need to test them separately.                                  // and NaN is always unequal to everything else' including itself.                                  if (left.IsOkayToCombine && right.IsOkayToCombine)                                  {                                      newLiteral = new JsConstantWrapper(left.ToNumber() != right.ToNumber()' JsPrimitiveType.Boolean' null' m_parser);                                  }                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                              break;                      }
Missing Default,Baker.Text,JsEvaluateLiteralVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsEvaluateLiteralVisitor.cs,DoUnaryNode,The following switch statement is missing a default case: switch(node.OperatorToken)                  {                      case JsToken.Void:                          // see if our operand is a ConstantWrapper                          if (literalOperand != null)                          {                              // either number' string' boolean' or null.                              // the void operator evaluates its operand and returns undefined. Since evaluating a literal                              // does nothing' then it doesn't matter what the heck it is. Replace it with a zero -- a one-                              // character literal.                              node.Operand = new JsConstantWrapper(0' JsPrimitiveType.Number' node.Context' m_parser);                          }                          break;                        case JsToken.TypeOf:                          if (literalOperand != null)                          {                              // either number' string' boolean' or null.                              // the operand is a literal. Therefore we already know what the typeof                              // operator will return. Just short-circuit that behavior now and replace the operator                              // with a string literal of the proper value                              string typeName = null;                              if (literalOperand.IsStringLiteral)                              {                                  // "string"                                  typeName = "string";                              }                              else if (literalOperand.IsNumericLiteral)                              {                                  // "number"                                  typeName = "number";                              }                              else if (literalOperand.IsBooleanLiteral)                              {                                  // "boolean"                                  typeName = "boolean";                              }                              else if (literalOperand.Value == null)                              {                                  // "object"                                  typeName = "object";                              }                                if (!string.IsNullOrEmpty(typeName))                              {                                  ReplaceNodeWithLiteral(node' new JsConstantWrapper(typeName' JsPrimitiveType.String' node.Context' m_parser));                              }                          }                          else if (node.Operand is JsObjectLiteral)                          {                              ReplaceNodeWithLiteral(node' new JsConstantWrapper("object"' JsPrimitiveType.String' node.Context' m_parser));                          }                          break;                        case JsToken.Plus:                          if (literalOperand != null)                          {                              try                              {                                  // replace with a constant representing operand.ToNumber'                                  ReplaceNodeWithLiteral(node' new JsConstantWrapper(literalOperand.ToNumber()' JsPrimitiveType.Number' node.Context' m_parser));                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                          }                          break;                        case JsToken.Minus:                          if (literalOperand != null)                          {                              try                              {                                  // replace with a constant representing the negative of operand.ToNumber                                  ReplaceNodeWithLiteral(node' new JsConstantWrapper(-literalOperand.ToNumber()' JsPrimitiveType.Number' node.Context' m_parser));                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                          }                          break;                        case JsToken.BitwiseNot:                          if (literalOperand != null)                          {                              try                              {                                  // replace with a constant representing the bitwise-not of operant.ToInt32                                  ReplaceNodeWithLiteral(node' new JsConstantWrapper(Convert.ToDouble(~literalOperand.ToInt32())' JsPrimitiveType.Number' node.Context' m_parser));                              }                              catch (InvalidCastException)                              {                                  // some kind of casting in ToNumber caused a situation where we don't want                                  // to perform the combination on these operands                              }                          }                          break;                        case JsToken.LogicalNot:                          if (literalOperand != null)                          {                              // replace with a constant representing the opposite of operand.ToBoolean                              try                              {                                  ReplaceNodeWithLiteral(node' new JsConstantWrapper(!literalOperand.ToBoolean()' JsPrimitiveType.Boolean' node.Context' m_parser));                              }                              catch (InvalidCastException)                              {                                  // ignore any invalid cast exceptions                              }                          }                          break;                  }
Missing Default,Baker.Text,JsLogicalNot,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsLogicalNot.cs,MeasureBinaryOperator,The following switch statement is missing a default case: switch (node.OperatorToken)              {                  case JsToken.Equal:                  case JsToken.NotEqual:                  case JsToken.StrictEqual:                  case JsToken.StrictNotEqual:                      // these operators can be turned into a logical not without any                      // delta in code size. == becomes !=' etc.                      break;                    case JsToken.LessThan:                  case JsToken.GreaterThan:                  // these operators would add another character when turnbed into a not.                  // for example' < becomes >=' etc                  //++m_delta;                  //break;                    case JsToken.LessThanEqual:                  case JsToken.GreaterThanEqual:                  // these operators would subtract another character when turnbed into a not.                  // for example' <= becomes >' etc                  //--m_delta;                  //break;                    case JsToken.Assign:                  case JsToken.PlusAssign:                  case JsToken.MinusAssign:                  case JsToken.MultiplyAssign:                  case JsToken.DivideAssign:                  case JsToken.ModuloAssign:                  case JsToken.BitwiseAndAssign:                  case JsToken.BitwiseOrAssign:                  case JsToken.BitwiseXorAssign:                  case JsToken.LeftShiftAssign:                  case JsToken.RightShiftAssign:                  case JsToken.UnsignedRightShiftAssign:                  case JsToken.BitwiseAnd:                  case JsToken.BitwiseOr:                  case JsToken.BitwiseXor:                  case JsToken.Divide:                  case JsToken.Multiply:                  case JsToken.Modulo:                  case JsToken.Minus:                  case JsToken.Plus:                  case JsToken.LeftShift:                  case JsToken.RightShift:                  case JsToken.UnsignedRightShift:                  case JsToken.In:                  case JsToken.InstanceOf:                      // these operators have no logical not' which means we need to wrap them in                      // a unary logical-not operator. And since they have a lower precedence than                      // the unary logical-not' they'll have to be wrapped in parens. So that means                      // logical-not'ing these guys adds three characters                      m_delta += 3;                      break;                    case JsToken.Comma:                      // to logical-not a comma-operator' we just need to logical-not the                      // right-hand side                      node.Operand2.Accept(this);                      break;                    case JsToken.LogicalAnd:                  case JsToken.LogicalOr:                      if (node.Parent is JsBlock || (node.Parent is JsCommaOperator && node.Parent.Parent is JsBlock))                      {                          // if the parent is a block' then this is a simple expression statement:                          // expr1 || expr2; or expr1 && expr2; If so' then the result isn't                          // used anywhere and we're just using the || or && operator as a                          // shorter if-statement. So we don't need to negate the right-hand                          // side' just the left-hand side.                          if (node.Operand1 != null)                          {                              node.Operand1.Accept(this);                          }                      }                      else                      {                          // the logical-not of a logical-and or logical-or operation is the                           // other operation against the not of each operand. Since the opposite                          // operator is the same length as this operator' then we just need                          // to recurse both operands to find the true delta.                          if (node.Operand1 != null)                          {                              node.Operand1.Accept(this);                          }                            if (node.Operand2 != null)                          {                              node.Operand2.Accept(this);                          }                      }                      break;              }
Missing Default,Baker.Text,JsLogicalNot,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsLogicalNot.cs,ConvertBinaryOperator,The following switch statement is missing a default case: switch (node.OperatorToken)              {                  case JsToken.Equal:                      node.OperatorToken = JsToken.NotEqual;                      break;                    case JsToken.NotEqual:                      node.OperatorToken = JsToken.Equal;                      break;                    case JsToken.StrictEqual:                      node.OperatorToken = JsToken.StrictNotEqual;                      break;                    case JsToken.StrictNotEqual:                      node.OperatorToken = JsToken.StrictEqual;                      break;                    case JsToken.LessThan:                  //node.OperatorToken = JSToken.GreaterThanEqual;                  //break;                    case JsToken.GreaterThan:                  //node.OperatorToken = JSToken.LessThanEqual;                  //break;                    case JsToken.LessThanEqual:                  //node.OperatorToken = JSToken.GreaterThan;                  //break;                    case JsToken.GreaterThanEqual:                  //node.OperatorToken = JSToken.LessThan;                  //break;                    case JsToken.Assign:                  case JsToken.PlusAssign:                  case JsToken.MinusAssign:                  case JsToken.MultiplyAssign:                  case JsToken.DivideAssign:                  case JsToken.ModuloAssign:                  case JsToken.BitwiseAndAssign:                  case JsToken.BitwiseOrAssign:                  case JsToken.BitwiseXorAssign:                  case JsToken.LeftShiftAssign:                  case JsToken.RightShiftAssign:                  case JsToken.UnsignedRightShiftAssign:                  case JsToken.BitwiseAnd:                  case JsToken.BitwiseOr:                  case JsToken.BitwiseXor:                  case JsToken.Divide:                  case JsToken.Multiply:                  case JsToken.Modulo:                  case JsToken.Minus:                  case JsToken.Plus:                  case JsToken.LeftShift:                  case JsToken.RightShift:                  case JsToken.UnsignedRightShift:                  case JsToken.In:                  case JsToken.InstanceOf:                      WrapWithLogicalNot(node);                      break;                    case JsToken.Comma:                      // to logical-not a comma-operator' we just need to logical-not the                      // right-hand side                      node.Operand2.Accept(this);                      break;                    case JsToken.LogicalAnd:                  case JsToken.LogicalOr:                      if (node.Parent is JsBlock || (node.Parent is JsCommaOperator && node.Parent.Parent is JsBlock))                      {                          // if the parent is a block' then this is a simple expression statement:                          // expr1 || expr2; or expr1 && expr2; If so' then the result isn't                          // used anywhere and we're just using the || or && operator as a                          // shorter if-statement. So we don't need to negate the right-hand                          // side' just the left-hand side.                          if (node.Operand1 != null)                          {                              node.Operand1.Accept(this);                          }                      }                      else                      {                          // the logical-not of a logical-and or logical-or operation is the                           // other operation against the not of each operand. Since the opposite                          // operator is the same length as this operator' then we just need                          // to recurse both operands and swap the operator token                          if (node.Operand1 != null)                          {                              node.Operand1.Accept(this);                          }                            if (node.Operand2 != null)                          {                              node.Operand2.Accept(this);                          }                      }                      node.OperatorToken = node.OperatorToken == JsToken.LogicalAnd ? JsToken.LogicalOr : JsToken.LogicalAnd;                      break;              }
Missing Default,Baker.Text,JsonOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsonOutputVisitor.cs,Visit,The following switch statement is missing a default case: switch (node.PrimitiveType)                  {                      case JsPrimitiveType.Boolean:                          m_writer.Write((bool)node.Value ? "true" : "false");                          break;                        case JsPrimitiveType.Null:                          m_writer.Write("null");                          break;                        case JsPrimitiveType.Number:                          OutputNumber((double)node.Value' node.Context);                          break;                        case JsPrimitiveType.String:                      case JsPrimitiveType.Other:                          // string -- or treat it like a string                          OutputString(node.Value.ToString());                          break;                  }
Missing Default,Baker.Text,JsOutputVisitor,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsOutputVisitor.cs,Visit,The following switch statement is missing a default case: switch (node.PrimitiveType)                  {                      case JsPrimitiveType.Boolean:                          Output(node.ToBoolean() ? "true" : "false");                          break;                        case JsPrimitiveType.Null:                          Output("null");                          break;                        case JsPrimitiveType.Number:                          if (node.Context == null || !node.Context.HasCode                              || (!node.MayHaveIssues && m_settings.IsModificationAllowed(JsTreeModifications.MinifyNumericLiterals)))                          {                              // apply minification to the literal to get it as small as possible                              Output(NormalizeNumber(node.ToNumber()' node.Context));                          }                          else                          {                              // context is not null but we don't want to minify numeric literals.                              // just use the original literal from the context.                              Output(node.Context.Code);                          }                          break;                        case JsPrimitiveType.Other:                          Output(node.Value.ToString());                          break;                        case JsPrimitiveType.String:                          if (node.Context == null || !node.Context.HasCode)                          {                              // escape the string value because we don't have a raw context value                              // to show anyways                              Output(InlineSafeString(EscapeString(node.Value.ToString())));                          }                          else if (!m_settings.IsModificationAllowed(JsTreeModifications.MinifyStringLiterals))                          {                              // we don't want to modify the strings at all!                              Output(node.Context.Code);                          }                          else if (node.MayHaveIssues                              || (m_settings.AllowEmbeddedAspNetBlocks && node.StringContainsAspNetReplacement))                          {                              // we'd rather show the raw string' but make sure it's safe for inlining                              Output(InlineSafeString(node.Context.Code));                          }                          else                          {                              // we'd rather show the escaped string                              Output(InlineSafeString(EscapeString(node.Value.ToString())));                          }                            break;                  }
Missing Default,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsValidIdentifierStart,The following switch statement is missing a default case: switch (cat)                  {                      case UnicodeCategory.UppercaseLetter:                      case UnicodeCategory.LowercaseLetter:                      case UnicodeCategory.TitlecaseLetter:                      case UnicodeCategory.ModifierLetter:                      case UnicodeCategory.OtherLetter:                      case UnicodeCategory.LetterNumber:                          // okay                          return true;                  }
Missing Default,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,IsValidIdentifierPart,The following switch statement is missing a default case: switch (unicodeCategory)                  {                      case UnicodeCategory.UppercaseLetter:                      case UnicodeCategory.LowercaseLetter:                      case UnicodeCategory.TitlecaseLetter:                      case UnicodeCategory.ModifierLetter:                      case UnicodeCategory.OtherLetter:                      case UnicodeCategory.LetterNumber:                      case UnicodeCategory.NonSpacingMark:                      case UnicodeCategory.SpacingCombiningMark:                      case UnicodeCategory.DecimalDigitNumber:                      case UnicodeCategory.ConnectorPunctuation:                          return true;                  }
Missing Default,Baker.Text,JsScanner,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Minifiers\JavaScript\JsScanner.cs,PPSkipToDirective,The following switch statement is missing a default case: switch (c)                  {                      // EOF                      case '\0':                          if (IsEndOfFile)                          {                              // adjust the scanner state                              m_currentPosition--;                              m_currentToken.EndPosition = m_currentPosition;                              m_currentToken.EndLineNumber = m_currentLine;                              m_currentToken.EndLinePosition = m_startLinePosition;                                // create a clone of the current token and set the ending to be the end of the                              // directive for which we're trying to find an end. Use THAT context for the                               // error context. Then throw an exception so we can bail.                              var contextError = m_currentToken.Clone();                              contextError.EndPosition = endPosition;                              contextError.EndLineNumber = endLineNum;                              contextError.EndLinePosition = endLinePos;                              contextError.HandleError(string.CompareOrdinal(endStrings[0]' "#ENDDEBUG") == 0                                   ? JsError.NoEndDebugDirective                                   : JsError.NoEndIfDirective);                              throw new EndOfStreamException();                          }                            break;                        // line terminator crap                      case '\r':                          if (GetChar(m_currentPosition) == '\n')                          {                              m_currentPosition++;                          }                            m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                      case '\n':                          m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                      case '\u2028':                          m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                      case '\u2029':                          m_currentLine++;                          m_startLinePosition = m_currentPosition;                          break;                        // check for /// (and then followed by any one of the substrings passed to us)                      case '/':                          if (CheckSubstring(m_currentPosition' "//"))                          {                              // skip it                              m_currentPosition += 2;                                // check to see if this is the start of ANOTHER preprocessor construct. If it                              // is' then it's a NESTED statement and we'll need to recursively skip the                               // whole thing so everything stays on track                              if (CheckCaseInsensitiveSubstring("#IFDEF")                                  || CheckCaseInsensitiveSubstring("#IFNDEF")                                  || CheckCaseInsensitiveSubstring("#IF"))                              {                                  PPSkipToDirective("#ENDIF");                              }                              else                              {                                  // now check each of the ending strings that were passed to us to see if one of                                  // them is a match                                  for (var ndx = 0; ndx < endStrings.Length; ++ndx)                                  {                                      if (CheckCaseInsensitiveSubstring(endStrings[ndx]))                                      {                                          // found the ending string                                          return ndx;                                      }                                  }                                    // not something we're looking for -- but is it a simple ///#END?                                  if (CheckCaseInsensitiveSubstring("#END"))                                  {                                      // if the current character is not whitespace' then it's not a simple "#END"                                      c = GetChar(m_currentPosition);                                      if (IsBlankSpace(c) || IsAtEndOfLine)                                      {                                          // it is! Well' we were expecting either #ENDIF or #ENDDEBUG' but we found just an #END.                                          // that's not how the syntax is SUPPOSED to go. But let's let it fly.                                          // the ending token is always the first one.                                          return 0;                                      }                                  }                              }                          }                            break;                  }
Missing Default,Baker.Text,Markdown,C:\repos\Kelindar_misakai-baker\Baker.Runtime\Text\Markdown\MarkdownLibrary.cs,Markdown,The following switch statement is missing a default case: switch (key)                  {                  case "Markdown.AutoHyperlink":                      _autoHyperlink = Convert.ToBoolean(settings[key]);                      break;                  case "Markdown.AutoNewlines":                      _autoNewlines = Convert.ToBoolean(settings[key]);                      break;                  case "Markdown.EmptyElementSuffix":                      _emptyElementSuffix = settings[key];                      break;                  case "Markdown.EncodeProblemUrlCharacters":                      _encodeProblemUrlCharacters = Convert.ToBoolean(settings[key]);                      break;                  case "Markdown.LinkEmails":                      _linkEmails = Convert.ToBoolean(settings[key]);                      break;                  case "Markdown.StrictBoldItalic":                      _strictBoldItalic = Convert.ToBoolean(settings[key]);                      break;                  }
