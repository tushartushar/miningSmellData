Implementation smell,Namespace,Class,File,Method,Description
Long Method,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,The method has 158 lines of code.
Long Method,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,Generate7WordPassphraseSuggestion,The method has 58120 lines of code.
Complex Method,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,TryDecryptHeader,Cyclomatic complexity of the method is 8
Complex Method,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,Cyclomatic complexity of the method is 16
Long Identifier,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,GetShared,The length of the parameter PartnerPublicIDIsBase64Encoded is 30.
Long Statement,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,The length of the statement  "		//throw new InvalidOperationException("Destination File already exists!  Set OverWriteDestination true or choose a different filename."); " is 137.
Long Statement,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The length of the statement  "	return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]); " is 274.
Long Statement,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,GenerateRandomBytes,The length of the statement  "	System.Security.Cryptography.RNGCryptoServiceProvider rng = new System.Security.Cryptography.RNGCryptoServiceProvider (); " is 121.
Long Statement,System,miniLockExtenstions,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Extensions.cs,IsValidBase64,The length of the statement  "	var base64Match = new System.Text.RegularExpressions.Regex (@"^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$"); " is 132.
Long Statement,System,miniLockExtenstions,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Extensions.cs,IsValidBase58,The length of the statement  "	var base58Match = new System.Text.RegularExpressions.Regex ("^[1-9ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$"); " is 121.
Magic Number,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,IngestHeader,The following statement contains a magic number: buffer = new byte[4];  
Magic Number,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,IngestHeader,The following statement contains a magic number: if (headerLength < 630)  	return -1;  
Magic Number,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,The following statement contains a magic number: hLen += 12;  
Magic Number,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,The following statement contains a magic number: do {  	// how big is this chunk? (32bit number' little endien)  	buffer = new byte[4];  	if (SourceFile.Read (buffer' 0' buffer.Length) != buffer.Length) {  		//read error  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	b2sCipher.Update (buffer);  	// have to include ALL the bytes' even the chunk-length bytes  	UInt32 chunkLength = Utilities.BytesToUInt32 (buffer);  	if (chunkLength > MAX_CHUNK_SIZE) {  		//something went wrong!  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	cursor += 4;  	// move past the chunk length  	//the XSalsa20Poly1305 process' ALWAYS expands the plaintext by MacSizeInBytes  	// (authentication)' so read the plaintext chunk length' add those bytes to the  	// value' then read that many bytes out of the ciphertext buffer  	byte[] chunk = new byte[chunkLength + XSalsa20Poly1305.MacSizeInBytes];  	//Array.Copy(buffer' cursor'  	//           chunk' 0'  	//           chunk.Length);  	if (SourceFile.Read (chunk' 0' chunk.Length) != chunk.Length) {  		//read error  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	b2sCipher.Update (chunk);  	// get hash of cipher text to compare to stored File Info Object  	cursor += chunk.Length;  	// move the cursor past this chunk  	if (cursor >= theCliff)// this is the last chunk  	 {  		// set most significant bit of nonce   		chunkNonce [23] |= 0x80;  	}  	byte[] decryptBytes = XSalsa20Poly1305.TryDecrypt (chunk' fileStuff.fileKey' chunkNonce);  	if (decryptBytes == null) {  		// nonce or key incorrect' or chunk has been altered (truncated?)  		buffer = null;  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	if (chunkNumber == 0)// first chunk is always filename '\0' padded  	 {  		results.StoredFilename = new UTF8Encoding ().GetString (decryptBytes).Replace ("\0"' "").Trim ();  	}  	else {  		b2sPlain.Update (decryptBytes);  		// give the user a nice PlainText hash  		tempFS.Write (decryptBytes' 0' decryptBytes.Length);  		// start building the output file  	}  	decryptBytes.Wipe ();  	// DON'T LEAK!!!  	// since the first chunkNonce is just the fileNonce and a bunch of 0x00's'   	//  it's safe to do the chunk number update as a post-process operation  	Utilities.UInt64ToBytes (++chunkNumber' chunkNonce' 16);  }  while (cursor < theCliff);  
Magic Number,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,The following statement contains a magic number: do {  	// how big is this chunk? (32bit number' little endien)  	buffer = new byte[4];  	if (SourceFile.Read (buffer' 0' buffer.Length) != buffer.Length) {  		//read error  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	b2sCipher.Update (buffer);  	// have to include ALL the bytes' even the chunk-length bytes  	UInt32 chunkLength = Utilities.BytesToUInt32 (buffer);  	if (chunkLength > MAX_CHUNK_SIZE) {  		//something went wrong!  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	cursor += 4;  	// move past the chunk length  	//the XSalsa20Poly1305 process' ALWAYS expands the plaintext by MacSizeInBytes  	// (authentication)' so read the plaintext chunk length' add those bytes to the  	// value' then read that many bytes out of the ciphertext buffer  	byte[] chunk = new byte[chunkLength + XSalsa20Poly1305.MacSizeInBytes];  	//Array.Copy(buffer' cursor'  	//           chunk' 0'  	//           chunk.Length);  	if (SourceFile.Read (chunk' 0' chunk.Length) != chunk.Length) {  		//read error  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	b2sCipher.Update (chunk);  	// get hash of cipher text to compare to stored File Info Object  	cursor += chunk.Length;  	// move the cursor past this chunk  	if (cursor >= theCliff)// this is the last chunk  	 {  		// set most significant bit of nonce   		chunkNonce [23] |= 0x80;  	}  	byte[] decryptBytes = XSalsa20Poly1305.TryDecrypt (chunk' fileStuff.fileKey' chunkNonce);  	if (decryptBytes == null) {  		// nonce or key incorrect' or chunk has been altered (truncated?)  		buffer = null;  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	if (chunkNumber == 0)// first chunk is always filename '\0' padded  	 {  		results.StoredFilename = new UTF8Encoding ().GetString (decryptBytes).Replace ("\0"' "").Trim ();  	}  	else {  		b2sPlain.Update (decryptBytes);  		// give the user a nice PlainText hash  		tempFS.Write (decryptBytes' 0' decryptBytes.Length);  		// start building the output file  	}  	decryptBytes.Wipe ();  	// DON'T LEAK!!!  	// since the first chunkNonce is just the fileNonce and a bunch of 0x00's'   	//  it's safe to do the chunk number update as a post-process operation  	Utilities.UInt64ToBytes (++chunkNumber' chunkNonce' 16);  }  while (cursor < theCliff);  
Magic Number,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,The following statement contains a magic number: do {  	// how big is this chunk? (32bit number' little endien)  	buffer = new byte[4];  	if (SourceFile.Read (buffer' 0' buffer.Length) != buffer.Length) {  		//read error  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	b2sCipher.Update (buffer);  	// have to include ALL the bytes' even the chunk-length bytes  	UInt32 chunkLength = Utilities.BytesToUInt32 (buffer);  	if (chunkLength > MAX_CHUNK_SIZE) {  		//something went wrong!  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	cursor += 4;  	// move past the chunk length  	//the XSalsa20Poly1305 process' ALWAYS expands the plaintext by MacSizeInBytes  	// (authentication)' so read the plaintext chunk length' add those bytes to the  	// value' then read that many bytes out of the ciphertext buffer  	byte[] chunk = new byte[chunkLength + XSalsa20Poly1305.MacSizeInBytes];  	//Array.Copy(buffer' cursor'  	//           chunk' 0'  	//           chunk.Length);  	if (SourceFile.Read (chunk' 0' chunk.Length) != chunk.Length) {  		//read error  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	b2sCipher.Update (chunk);  	// get hash of cipher text to compare to stored File Info Object  	cursor += chunk.Length;  	// move the cursor past this chunk  	if (cursor >= theCliff)// this is the last chunk  	 {  		// set most significant bit of nonce   		chunkNonce [23] |= 0x80;  	}  	byte[] decryptBytes = XSalsa20Poly1305.TryDecrypt (chunk' fileStuff.fileKey' chunkNonce);  	if (decryptBytes == null) {  		// nonce or key incorrect' or chunk has been altered (truncated?)  		buffer = null;  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	if (chunkNumber == 0)// first chunk is always filename '\0' padded  	 {  		results.StoredFilename = new UTF8Encoding ().GetString (decryptBytes).Replace ("\0"' "").Trim ();  	}  	else {  		b2sPlain.Update (decryptBytes);  		// give the user a nice PlainText hash  		tempFS.Write (decryptBytes' 0' decryptBytes.Length);  		// start building the output file  	}  	decryptBytes.Wipe ();  	// DON'T LEAK!!!  	// since the first chunkNonce is just the fileNonce and a bunch of 0x00's'   	//  it's safe to do the chunk number update as a post-process operation  	Utilities.UInt64ToBytes (++chunkNumber' chunkNonce' 16);  }  while (cursor < theCliff);  
Magic Number,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,The following statement contains a magic number: do {  	// how big is this chunk? (32bit number' little endien)  	buffer = new byte[4];  	if (SourceFile.Read (buffer' 0' buffer.Length) != buffer.Length) {  		//read error  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	b2sCipher.Update (buffer);  	// have to include ALL the bytes' even the chunk-length bytes  	UInt32 chunkLength = Utilities.BytesToUInt32 (buffer);  	if (chunkLength > MAX_CHUNK_SIZE) {  		//something went wrong!  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	cursor += 4;  	// move past the chunk length  	//the XSalsa20Poly1305 process' ALWAYS expands the plaintext by MacSizeInBytes  	// (authentication)' so read the plaintext chunk length' add those bytes to the  	// value' then read that many bytes out of the ciphertext buffer  	byte[] chunk = new byte[chunkLength + XSalsa20Poly1305.MacSizeInBytes];  	//Array.Copy(buffer' cursor'  	//           chunk' 0'  	//           chunk.Length);  	if (SourceFile.Read (chunk' 0' chunk.Length) != chunk.Length) {  		//read error  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	b2sCipher.Update (chunk);  	// get hash of cipher text to compare to stored File Info Object  	cursor += chunk.Length;  	// move the cursor past this chunk  	if (cursor >= theCliff)// this is the last chunk  	 {  		// set most significant bit of nonce   		chunkNonce [23] |= 0x80;  	}  	byte[] decryptBytes = XSalsa20Poly1305.TryDecrypt (chunk' fileStuff.fileKey' chunkNonce);  	if (decryptBytes == null) {  		// nonce or key incorrect' or chunk has been altered (truncated?)  		buffer = null;  		fileStuff.Clear ();  		SourceFile.Close ();  		SourceFile.Dispose ();  		TrashTempFileStream (tempFS' tempFile);  		return null;  	}  	if (chunkNumber == 0)// first chunk is always filename '\0' padded  	 {  		results.StoredFilename = new UTF8Encoding ().GetString (decryptBytes).Replace ("\0"' "").Trim ();  	}  	else {  		b2sPlain.Update (decryptBytes);  		// give the user a nice PlainText hash  		tempFS.Write (decryptBytes' 0' decryptBytes.Length);  		// start building the output file  	}  	decryptBytes.Wipe ();  	// DON'T LEAK!!!  	// since the first chunkNonce is just the fileNonce and a bunch of 0x00's'   	//  it's safe to do the chunk number update as a post-process operation  	Utilities.UInt64ToBytes (++chunkNumber' chunkNonce' 16);  }  while (cursor < theCliff);  
Magic Number,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,The following statement contains a magic number: buffer = new byte[4];  
Magic Number,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,The following statement contains a magic number: cursor += 4;  
Magic Number,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,The following statement contains a magic number: if (cursor >= theCliff)// this is the last chunk   {  	// set most significant bit of nonce   	chunkNonce [23] |= 0x80;  }  
Magic Number,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,The following statement contains a magic number: chunkNonce [23] |= 0x80;  
Magic Number,miniLockManaged,FileOperations,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Decryptor.cs,DecryptFile,The following statement contains a magic number: Utilities.UInt64ToBytes (++chunkNumber' chunkNonce' 16);  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,Keys,The following statement contains a magic number: _Secret = Utilities.GenerateRandomBytes (32);  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,Initialize,The following statement contains a magic number: if ((int)ScorePotentialPassphrase (Passphrase).Entropy < 100)  	return false;  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,Initialize,The following statement contains a magic number: _Secret = SCrypt.ComputeDerivedKey (mangledPWD' new UTF8Encoding ().GetBytes (EMail.Trim ())' 131072' 8' 1' 1' 32);  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,Initialize,The following statement contains a magic number: _Secret = SCrypt.ComputeDerivedKey (mangledPWD' new UTF8Encoding ().GetBytes (EMail.Trim ())' 131072' 8' 1' 1' 32);  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,Initialize,The following statement contains a magic number: _Secret = SCrypt.ComputeDerivedKey (mangledPWD' new UTF8Encoding ().GetBytes (EMail.Trim ())' 131072' 8' 1' 1' 32);  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,GeneratePublicIDFromSecret,The following statement contains a magic number: Array.Copy (thePublicKey' 0' idwchk' 0' 32);  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,GeneratePublicIDFromSecret,The following statement contains a magic number: idwchk [32] = checkSum;  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,ValidatePublicKey,The following statement contains a magic number: if (PublicKeyBase58Encoded.Length > 55 || PublicKeyBase58Encoded.Length < 40)  	// from original project  	return false;  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,ValidatePublicKey,The following statement contains a magic number: if (PublicKeyBase58Encoded.Length > 55 || PublicKeyBase58Encoded.Length < 40)  	// from original project  	return false;  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,ValidatePublicKey,The following statement contains a magic number: if (test.Length != 33)  	return false;  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,ValidatePublicKey,The following statement contains a magic number: return ComputeChecksum (test) == test [32];  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,GetBytesFromPublicKey,The following statement contains a magic number: Array.Copy (PublicKeyBase58Encoded.ToBytesFromBase58 ()' result' 32);  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,GetPublicIDFromKeyBytes,The following statement contains a magic number: if (PublicKey == null || PublicKey.Length != 32)  	throw new ArgumentOutOfRangeException ("key"' "key must be 32 bytes!");  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,GetPublicIDFromKeyBytes,The following statement contains a magic number: Array.Copy (PublicKey' 0' idwchk' 0' 32);  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,GetPublicIDFromKeyBytes,The following statement contains a magic number: idwchk [32] = checkSum;  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,ComputeChecksum,The following statement contains a magic number: if (key == null || (key.Length != 32 && key.Length != 33)) {  	throw new ArgumentOutOfRangeException ("key must be 32 or 33 bytes");  }  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,ComputeChecksum,The following statement contains a magic number: if (key == null || (key.Length != 32 && key.Length != 33)) {  	throw new ArgumentOutOfRangeException ("key must be 32 or 33 bytes");  }  
Magic Number,miniLockManaged,Keys,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Keys.cs,ComputeChecksum,The following statement contains a magic number: return Blake2S.ComputeHash (key' 0' 32' new Blake2sConfig () {  	OutputSizeInBytes = 1  }) [0];  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt32,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 24) + //  ((UInt32)buf [offset + 2] << 16) + //  ((UInt32)buf [offset + 1] << 8) + //  (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt32,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 24) + //  ((UInt32)buf [offset + 2] << 16) + //  ((UInt32)buf [offset + 1] << 8) + //  (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt32,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 24) + //  ((UInt32)buf [offset + 2] << 16) + //  ((UInt32)buf [offset + 1] << 8) + //  (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt32,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 24) + //  ((UInt32)buf [offset + 2] << 16) + //  ((UInt32)buf [offset + 1] << 8) + //  (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt32,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 24) + //  ((UInt32)buf [offset + 2] << 16) + //  ((UInt32)buf [offset + 1] << 8) + //  (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt32,The following statement contains a magic number: return (((UInt32)buf [3] << 24) + //  ((UInt32)buf [2] << 16) + //  ((UInt32)buf [1] << 8) + //  (UInt32)buf [0]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt32,The following statement contains a magic number: return (((UInt32)buf [3] << 24) + //  ((UInt32)buf [2] << 16) + //  ((UInt32)buf [1] << 8) + //  (UInt32)buf [0]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt32,The following statement contains a magic number: return (((UInt32)buf [3] << 24) + //  ((UInt32)buf [2] << 16) + //  ((UInt32)buf [1] << 8) + //  (UInt32)buf [0]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt32,The following statement contains a magic number: return (((UInt32)buf [3] << 24) + //  ((UInt32)buf [2] << 16) + //  ((UInt32)buf [1] << 8) + //  (UInt32)buf [0]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt32,The following statement contains a magic number: return (((UInt32)buf [3] << 24) + //  ((UInt32)buf [2] << 16) + //  ((UInt32)buf [1] << 8) + //  (UInt32)buf [0]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt32ToBytes,The following statement contains a magic number: buf [offset + 3] = (byte)(value >> 24);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt32ToBytes,The following statement contains a magic number: buf [offset + 3] = (byte)(value >> 24);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt32ToBytes,The following statement contains a magic number: buf [offset + 2] = (byte)(value >> 16);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt32ToBytes,The following statement contains a magic number: buf [offset + 2] = (byte)(value >> 16);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt32ToBytes,The following statement contains a magic number: buf [offset + 1] = (byte)(value >> 8);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt32ToBytes,The following statement contains a magic number: buf [3] = (byte)(value >> 24);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt32ToBytes,The following statement contains a magic number: buf [3] = (byte)(value >> 24);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt32ToBytes,The following statement contains a magic number: buf [2] = (byte)(value >> 16);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt32ToBytes,The following statement contains a magic number: buf [2] = (byte)(value >> 16);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt32ToBytes,The following statement contains a magic number: buf [1] = (byte)(value >> 8);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,BytesToUInt64,The following statement contains a magic number: return (((UInt32)buf [offset + 3] << 56) + ((UInt32)buf [offset + 3] << 48) + ((UInt32)buf [offset + 3] << 40) + ((UInt32)buf [offset + 3] << 32) + ((UInt32)buf [offset + 3] << 24) + ((UInt32)buf [offset + 2] << 16) + ((UInt32)buf [offset + 1] << 8) + (UInt32)buf [offset]);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 7] = (byte)(value >> 56);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 7] = (byte)(value >> 56);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 6] = (byte)(value >> 48);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 6] = (byte)(value >> 48);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 5] = (byte)(value >> 40);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 5] = (byte)(value >> 40);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 4] = (byte)(value >> 32);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 4] = (byte)(value >> 32);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 3] = (byte)(value >> 24);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 3] = (byte)(value >> 24);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 2] = (byte)(value >> 16);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 2] = (byte)(value >> 16);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [offset + 1] = (byte)(value >> 8);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [7] = (byte)(value >> 56);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [7] = (byte)(value >> 56);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [6] = (byte)(value >> 48);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [6] = (byte)(value >> 48);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [5] = (byte)(value >> 40);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [5] = (byte)(value >> 40);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [4] = (byte)(value >> 32);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [4] = (byte)(value >> 32);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [3] = (byte)(value >> 24);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [3] = (byte)(value >> 24);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [2] = (byte)(value >> 16);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [2] = (byte)(value >> 16);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,UInt64ToBytes,The following statement contains a magic number: buf [1] = (byte)(value >> 8);  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,GenerateRandomBytes,The following statement contains a magic number: if (count < 1 || count > 32)  	throw new ArgumentOutOfRangeException ("count");  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,Generate7WordPassphraseSuggestion,The following statement contains a magic number: for (int i = 0; i < 7; i++) {  	UInt32 kicker = BytesToUInt32 (GenerateRandomBytes (4)) % (UInt32)dictionary.Length;  	results.Add (dictionary [kicker]);  }  
Magic Number,miniLockManaged,Utilities,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Utilities.cs,Generate7WordPassphraseSuggestion,The following statement contains a magic number: for (int i = 0; i < 7; i++) {  	UInt32 kicker = BytesToUInt32 (GenerateRandomBytes (4)) % (UInt32)dictionary.Length;  	results.Add (dictionary [kicker]);  }  
Magic Number,System,miniLockExtenstions,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Extensions.cs,Wipe,The following statement contains a magic number: if (data != null && data.Length > 0) {  	//Chaos.NaCl.CryptoBytes.Wipe(data);  	// all this semiphore is required to prevent the compiler from optimizing out the code.  	Array.Clear (data' 0' data.Length);  	data [0] &= data [data.GetLowerBound (0)];  	byte result = 0;  	int count = 0;  	foreach (byte b in data) {  		result ^= (byte)(b & 0x01);  		result >>= 1;  		if (count++ > 100)  			break;  		// don't allow bottlenecks.  	}  	data [data.GetUpperBound (0)] = result;  }  
Magic Number,System,miniLockExtenstions,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Extensions.cs,Wipe,The following statement contains a magic number: foreach (byte b in data) {  	result ^= (byte)(b & 0x01);  	result >>= 1;  	if (count++ > 100)  		break;  	// don't allow bottlenecks.  }  
Magic Number,System,miniLockExtenstions,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Extensions.cs,Wipe,The following statement contains a magic number: if (count++ > 100)  	break;  
Magic Number,System,miniLockExtenstions,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Extensions.cs,ToBase58String,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	intData = intData * 256 + data [i];  }  
Magic Number,System,miniLockExtenstions,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Extensions.cs,ToBase58String,The following statement contains a magic number: intData = intData * 256 + data [i];  
Magic Number,System,miniLockExtenstions,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Extensions.cs,ToBase58String,The following statement contains a magic number: while (intData > 0) {  	int remainder = (int)(intData % 58);  	intData /= 58;  	result = Digits [remainder] + result;  }  
Magic Number,System,miniLockExtenstions,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Extensions.cs,ToBase58String,The following statement contains a magic number: while (intData > 0) {  	int remainder = (int)(intData % 58);  	intData /= 58;  	result = Digits [remainder] + result;  }  
Magic Number,System,miniLockExtenstions,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Extensions.cs,ToBase58String,The following statement contains a magic number: intData /= 58;  
Magic Number,System,miniLockExtenstions,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Extensions.cs,ToBytesFromBase58,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  	int digit = Digits.IndexOf (data [i]);  	//Slow  	if (digit < 0)  		throw new FormatException (string.Format ("Invalid Base58 character '{0}' at position {1}"' data [i]' i));  	intData = intData * 58 + digit;  }  
Magic Number,System,miniLockExtenstions,C:\repos\SparkDustJoe_miniLockManaged\miniLockManaged\Extensions.cs,ToBytesFromBase58,The following statement contains a magic number: intData = intData * 58 + digit;  
