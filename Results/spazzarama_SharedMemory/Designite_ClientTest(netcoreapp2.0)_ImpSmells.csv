Implementation smell,Namespace,Class,File,Method,Description
Long Method,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The method has 100 lines of code.
Long Statement,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The length of the statement  "                Console.WriteLine("Buffer {0} opened' NodeBufferSize: {1}' NodeCount: {2}"' theClient.Name' theClient.NodeBufferSize' theClient.NodeCount); " is 139.
Long Statement,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The length of the statement  "                            Console.WriteLine("Read: {0}' Wait: {1}' {2}MB/s"' ((double)totalBytes / 1048576.0).ToString("F0")' skipCount' (((totalBytes / 1048576.0) / sw.ElapsedMilliseconds) * 1000).ToString("F2")); " is 188.
Magic Number,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The following statement contains a magic number: data[i] = (byte)((i + j) % 255);
Magic Number,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The following statement contains a magic number: j < 256
Magic Number,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The following statement contains a magic number: Action reader = () =>                  {                      int myThreadIndex = Interlocked.Increment(ref threadCount);                      int linesOut = 0;                      bool finalLine = false;                      for (; ; )                      {                          int amount = theClient.Read(writeData' 100);                          //int amount = theClient.Read<byte>(writeData' 100);                            if (amount == 0)                          {                              Interlocked.Increment(ref skipCount);                          }                          else                          {                              // Only check data integrity for first thread                              if (threadCount == 1)                              {                                  bool mismatch = false;                                    writeDataProof = dataList[((int)Interlocked.Read(ref iterations)) % 255];                                  for (var i = 0; i < writeDataProof.Length; i++)                                  {                                      if (writeData[i] != writeDataProof[i])                                      {                                          mismatch = true;                                          Console.WriteLine("Buffers don't match!");                                          break;                                      }                                  }                                    if (mismatch)                                      break;                              }                                Interlocked.Add(ref totalBytes' amount);                                Interlocked.Increment(ref iterations);                          }                            if (threadCount == 1 && Interlocked.Read(ref iterations) > 500)                              finalLine = true;                            if (myThreadIndex < 3 && (finalLine || sw.ElapsedTicks - lastTick > 1000000))                          {                              lastTick = sw.ElapsedTicks;                              Console.WriteLine("Read: {0}' Wait: {1}' {2}MB/s"' ((double)totalBytes / 1048576.0).ToString("F0")' skipCount' (((totalBytes / 1048576.0) / sw.ElapsedMilliseconds) * 1000).ToString("F2"));                              linesOut++;                              if (finalLine || (myThreadIndex > 1 && linesOut > 10))                              {                                  Console.WriteLine("Completed.");                                  break;                              }                          }                      }                  };
Magic Number,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The following statement contains a magic number: Action reader = () =>                  {                      int myThreadIndex = Interlocked.Increment(ref threadCount);                      int linesOut = 0;                      bool finalLine = false;                      for (; ; )                      {                          int amount = theClient.Read(writeData' 100);                          //int amount = theClient.Read<byte>(writeData' 100);                            if (amount == 0)                          {                              Interlocked.Increment(ref skipCount);                          }                          else                          {                              // Only check data integrity for first thread                              if (threadCount == 1)                              {                                  bool mismatch = false;                                    writeDataProof = dataList[((int)Interlocked.Read(ref iterations)) % 255];                                  for (var i = 0; i < writeDataProof.Length; i++)                                  {                                      if (writeData[i] != writeDataProof[i])                                      {                                          mismatch = true;                                          Console.WriteLine("Buffers don't match!");                                          break;                                      }                                  }                                    if (mismatch)                                      break;                              }                                Interlocked.Add(ref totalBytes' amount);                                Interlocked.Increment(ref iterations);                          }                            if (threadCount == 1 && Interlocked.Read(ref iterations) > 500)                              finalLine = true;                            if (myThreadIndex < 3 && (finalLine || sw.ElapsedTicks - lastTick > 1000000))                          {                              lastTick = sw.ElapsedTicks;                              Console.WriteLine("Read: {0}' Wait: {1}' {2}MB/s"' ((double)totalBytes / 1048576.0).ToString("F0")' skipCount' (((totalBytes / 1048576.0) / sw.ElapsedMilliseconds) * 1000).ToString("F2"));                              linesOut++;                              if (finalLine || (myThreadIndex > 1 && linesOut > 10))                              {                                  Console.WriteLine("Completed.");                                  break;                              }                          }                      }                  };
Magic Number,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The following statement contains a magic number: Action reader = () =>                  {                      int myThreadIndex = Interlocked.Increment(ref threadCount);                      int linesOut = 0;                      bool finalLine = false;                      for (; ; )                      {                          int amount = theClient.Read(writeData' 100);                          //int amount = theClient.Read<byte>(writeData' 100);                            if (amount == 0)                          {                              Interlocked.Increment(ref skipCount);                          }                          else                          {                              // Only check data integrity for first thread                              if (threadCount == 1)                              {                                  bool mismatch = false;                                    writeDataProof = dataList[((int)Interlocked.Read(ref iterations)) % 255];                                  for (var i = 0; i < writeDataProof.Length; i++)                                  {                                      if (writeData[i] != writeDataProof[i])                                      {                                          mismatch = true;                                          Console.WriteLine("Buffers don't match!");                                          break;                                      }                                  }                                    if (mismatch)                                      break;                              }                                Interlocked.Add(ref totalBytes' amount);                                Interlocked.Increment(ref iterations);                          }                            if (threadCount == 1 && Interlocked.Read(ref iterations) > 500)                              finalLine = true;                            if (myThreadIndex < 3 && (finalLine || sw.ElapsedTicks - lastTick > 1000000))                          {                              lastTick = sw.ElapsedTicks;                              Console.WriteLine("Read: {0}' Wait: {1}' {2}MB/s"' ((double)totalBytes / 1048576.0).ToString("F0")' skipCount' (((totalBytes / 1048576.0) / sw.ElapsedMilliseconds) * 1000).ToString("F2"));                              linesOut++;                              if (finalLine || (myThreadIndex > 1 && linesOut > 10))                              {                                  Console.WriteLine("Completed.");                                  break;                              }                          }                      }                  };
Magic Number,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The following statement contains a magic number: Action reader = () =>                  {                      int myThreadIndex = Interlocked.Increment(ref threadCount);                      int linesOut = 0;                      bool finalLine = false;                      for (; ; )                      {                          int amount = theClient.Read(writeData' 100);                          //int amount = theClient.Read<byte>(writeData' 100);                            if (amount == 0)                          {                              Interlocked.Increment(ref skipCount);                          }                          else                          {                              // Only check data integrity for first thread                              if (threadCount == 1)                              {                                  bool mismatch = false;                                    writeDataProof = dataList[((int)Interlocked.Read(ref iterations)) % 255];                                  for (var i = 0; i < writeDataProof.Length; i++)                                  {                                      if (writeData[i] != writeDataProof[i])                                      {                                          mismatch = true;                                          Console.WriteLine("Buffers don't match!");                                          break;                                      }                                  }                                    if (mismatch)                                      break;                              }                                Interlocked.Add(ref totalBytes' amount);                                Interlocked.Increment(ref iterations);                          }                            if (threadCount == 1 && Interlocked.Read(ref iterations) > 500)                              finalLine = true;                            if (myThreadIndex < 3 && (finalLine || sw.ElapsedTicks - lastTick > 1000000))                          {                              lastTick = sw.ElapsedTicks;                              Console.WriteLine("Read: {0}' Wait: {1}' {2}MB/s"' ((double)totalBytes / 1048576.0).ToString("F0")' skipCount' (((totalBytes / 1048576.0) / sw.ElapsedMilliseconds) * 1000).ToString("F2"));                              linesOut++;                              if (finalLine || (myThreadIndex > 1 && linesOut > 10))                              {                                  Console.WriteLine("Completed.");                                  break;                              }                          }                      }                  };
Magic Number,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The following statement contains a magic number: Action reader = () =>                  {                      int myThreadIndex = Interlocked.Increment(ref threadCount);                      int linesOut = 0;                      bool finalLine = false;                      for (; ; )                      {                          int amount = theClient.Read(writeData' 100);                          //int amount = theClient.Read<byte>(writeData' 100);                            if (amount == 0)                          {                              Interlocked.Increment(ref skipCount);                          }                          else                          {                              // Only check data integrity for first thread                              if (threadCount == 1)                              {                                  bool mismatch = false;                                    writeDataProof = dataList[((int)Interlocked.Read(ref iterations)) % 255];                                  for (var i = 0; i < writeDataProof.Length; i++)                                  {                                      if (writeData[i] != writeDataProof[i])                                      {                                          mismatch = true;                                          Console.WriteLine("Buffers don't match!");                                          break;                                      }                                  }                                    if (mismatch)                                      break;                              }                                Interlocked.Add(ref totalBytes' amount);                                Interlocked.Increment(ref iterations);                          }                            if (threadCount == 1 && Interlocked.Read(ref iterations) > 500)                              finalLine = true;                            if (myThreadIndex < 3 && (finalLine || sw.ElapsedTicks - lastTick > 1000000))                          {                              lastTick = sw.ElapsedTicks;                              Console.WriteLine("Read: {0}' Wait: {1}' {2}MB/s"' ((double)totalBytes / 1048576.0).ToString("F0")' skipCount' (((totalBytes / 1048576.0) / sw.ElapsedMilliseconds) * 1000).ToString("F2"));                              linesOut++;                              if (finalLine || (myThreadIndex > 1 && linesOut > 10))                              {                                  Console.WriteLine("Completed.");                                  break;                              }                          }                      }                  };
Magic Number,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The following statement contains a magic number: Action reader = () =>                  {                      int myThreadIndex = Interlocked.Increment(ref threadCount);                      int linesOut = 0;                      bool finalLine = false;                      for (; ; )                      {                          int amount = theClient.Read(writeData' 100);                          //int amount = theClient.Read<byte>(writeData' 100);                            if (amount == 0)                          {                              Interlocked.Increment(ref skipCount);                          }                          else                          {                              // Only check data integrity for first thread                              if (threadCount == 1)                              {                                  bool mismatch = false;                                    writeDataProof = dataList[((int)Interlocked.Read(ref iterations)) % 255];                                  for (var i = 0; i < writeDataProof.Length; i++)                                  {                                      if (writeData[i] != writeDataProof[i])                                      {                                          mismatch = true;                                          Console.WriteLine("Buffers don't match!");                                          break;                                      }                                  }                                    if (mismatch)                                      break;                              }                                Interlocked.Add(ref totalBytes' amount);                                Interlocked.Increment(ref iterations);                          }                            if (threadCount == 1 && Interlocked.Read(ref iterations) > 500)                              finalLine = true;                            if (myThreadIndex < 3 && (finalLine || sw.ElapsedTicks - lastTick > 1000000))                          {                              lastTick = sw.ElapsedTicks;                              Console.WriteLine("Read: {0}' Wait: {1}' {2}MB/s"' ((double)totalBytes / 1048576.0).ToString("F0")' skipCount' (((totalBytes / 1048576.0) / sw.ElapsedMilliseconds) * 1000).ToString("F2"));                              linesOut++;                              if (finalLine || (myThreadIndex > 1 && linesOut > 10))                              {                                  Console.WriteLine("Completed.");                                  break;                              }                          }                      }                  };
Magic Number,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The following statement contains a magic number: Action reader = () =>                  {                      int myThreadIndex = Interlocked.Increment(ref threadCount);                      int linesOut = 0;                      bool finalLine = false;                      for (; ; )                      {                          int amount = theClient.Read(writeData' 100);                          //int amount = theClient.Read<byte>(writeData' 100);                            if (amount == 0)                          {                              Interlocked.Increment(ref skipCount);                          }                          else                          {                              // Only check data integrity for first thread                              if (threadCount == 1)                              {                                  bool mismatch = false;                                    writeDataProof = dataList[((int)Interlocked.Read(ref iterations)) % 255];                                  for (var i = 0; i < writeDataProof.Length; i++)                                  {                                      if (writeData[i] != writeDataProof[i])                                      {                                          mismatch = true;                                          Console.WriteLine("Buffers don't match!");                                          break;                                      }                                  }                                    if (mismatch)                                      break;                              }                                Interlocked.Add(ref totalBytes' amount);                                Interlocked.Increment(ref iterations);                          }                            if (threadCount == 1 && Interlocked.Read(ref iterations) > 500)                              finalLine = true;                            if (myThreadIndex < 3 && (finalLine || sw.ElapsedTicks - lastTick > 1000000))                          {                              lastTick = sw.ElapsedTicks;                              Console.WriteLine("Read: {0}' Wait: {1}' {2}MB/s"' ((double)totalBytes / 1048576.0).ToString("F0")' skipCount' (((totalBytes / 1048576.0) / sw.ElapsedMilliseconds) * 1000).ToString("F2"));                              linesOut++;                              if (finalLine || (myThreadIndex > 1 && linesOut > 10))                              {                                  Console.WriteLine("Completed.");                                  break;                              }                          }                      }                  };
Magic Number,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The following statement contains a magic number: Action reader = () =>                  {                      int myThreadIndex = Interlocked.Increment(ref threadCount);                      int linesOut = 0;                      bool finalLine = false;                      for (; ; )                      {                          int amount = theClient.Read(writeData' 100);                          //int amount = theClient.Read<byte>(writeData' 100);                            if (amount == 0)                          {                              Interlocked.Increment(ref skipCount);                          }                          else                          {                              // Only check data integrity for first thread                              if (threadCount == 1)                              {                                  bool mismatch = false;                                    writeDataProof = dataList[((int)Interlocked.Read(ref iterations)) % 255];                                  for (var i = 0; i < writeDataProof.Length; i++)                                  {                                      if (writeData[i] != writeDataProof[i])                                      {                                          mismatch = true;                                          Console.WriteLine("Buffers don't match!");                                          break;                                      }                                  }                                    if (mismatch)                                      break;                              }                                Interlocked.Add(ref totalBytes' amount);                                Interlocked.Increment(ref iterations);                          }                            if (threadCount == 1 && Interlocked.Read(ref iterations) > 500)                              finalLine = true;                            if (myThreadIndex < 3 && (finalLine || sw.ElapsedTicks - lastTick > 1000000))                          {                              lastTick = sw.ElapsedTicks;                              Console.WriteLine("Read: {0}' Wait: {1}' {2}MB/s"' ((double)totalBytes / 1048576.0).ToString("F0")' skipCount' (((totalBytes / 1048576.0) / sw.ElapsedMilliseconds) * 1000).ToString("F2"));                              linesOut++;                              if (finalLine || (myThreadIndex > 1 && linesOut > 10))                              {                                  Console.WriteLine("Completed.");                                  break;                              }                          }                      }                  };
Magic Number,ClientTest,Program,D:\research\architectureSmells\repos1\spazzarama_SharedMemory\Examples\ClientTest\Program.cs,Main,The following statement contains a magic number: Action reader = () =>                  {                      int myThreadIndex = Interlocked.Increment(ref threadCount);                      int linesOut = 0;                      bool finalLine = false;                      for (; ; )                      {                          int amount = theClient.Read(writeData' 100);                          //int amount = theClient.Read<byte>(writeData' 100);                            if (amount == 0)                          {                              Interlocked.Increment(ref skipCount);                          }                          else                          {                              // Only check data integrity for first thread                              if (threadCount == 1)                              {                                  bool mismatch = false;                                    writeDataProof = dataList[((int)Interlocked.Read(ref iterations)) % 255];                                  for (var i = 0; i < writeDataProof.Length; i++)                                  {                                      if (writeData[i] != writeDataProof[i])                                      {                                          mismatch = true;                                          Console.WriteLine("Buffers don't match!");                                          break;                                      }                                  }                                    if (mismatch)                                      break;                              }                                Interlocked.Add(ref totalBytes' amount);                                Interlocked.Increment(ref iterations);                          }                            if (threadCount == 1 && Interlocked.Read(ref iterations) > 500)                              finalLine = true;                            if (myThreadIndex < 3 && (finalLine || sw.ElapsedTicks - lastTick > 1000000))                          {                              lastTick = sw.ElapsedTicks;                              Console.WriteLine("Read: {0}' Wait: {1}' {2}MB/s"' ((double)totalBytes / 1048576.0).ToString("F0")' skipCount' (((totalBytes / 1048576.0) / sw.ElapsedMilliseconds) * 1000).ToString("F2"));                              linesOut++;                              if (finalLine || (myThreadIndex > 1 && linesOut > 10))                              {                                  Console.WriteLine("Completed.");                                  break;                              }                          }                      }                  };
