Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Kinect.Core.Gestures,ClickGesture,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\ClickGesture.cs,CheckLeftClick,Cyclomatic complexity of the method is 9
Complex Method,Kinect.Core.Gestures,ClickGesture,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\ClickGesture.cs,CheckRightClick,Cyclomatic complexity of the method is 9
Complex Method,Kinect.Core.Gestures,GestureFactory,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\GestureFactory.cs,AddSelfTouchGesture,Cyclomatic complexity of the method is 11
Long Statement,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,Context_DepthFrameReady,The length of the statement  "            BitmapSource bitmap = BitmapSource.Create(image.Width' image.Height' 96' 96' PixelFormats.Gray16' null' image.Bits' image.Width * image.BytesPerPixel); " is 151.
Long Statement,Kinect.Core,MyKinect,C:\repos\atosorigin_Kinect\src\Framework\Core\MyKinect.cs,StartKinectThread,The length of the statement  "                        _context.Initialize(RuntimeOptions.UseDepthAndPlayerIndex | RuntimeOptions.UseSkeletalTracking | RuntimeOptions.UseColor);" is 122.
Long Statement,Kinect.Core.Gestures.Helper,Calculator,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\Helper\Calculator.cs,CalculateAngle,The length of the statement  "                    // was resY. i think 0'0 is seen as same as up... There is an error in http://www.carlosfemmer.com/post/2006/02/Calculate-Angle-between-2-points-using-C.aspx  :-) " is 162.
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,Context_VideoFrameReady,The following statement contains a magic number: BitmapSource bitmap = BitmapSource.Create(                 image.Width' image.Height' 96' 96' PixelFormats.Bgr32' null' image.Bits' image.Width*image.BytesPerPixel);
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,Context_VideoFrameReady,The following statement contains a magic number: BitmapSource bitmap = BitmapSource.Create(                 image.Width' image.Height' 96' 96' PixelFormats.Bgr32' null' image.Bits' image.Width*image.BytesPerPixel);
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,Context_DepthFrameReady,The following statement contains a magic number: BitmapSource bitmap = BitmapSource.Create(image.Width' image.Height' 96' 96' PixelFormats.Gray16' null' image.Bits' image.Width * image.BytesPerPixel);
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,Context_DepthFrameReady,The following statement contains a magic number: BitmapSource bitmap = BitmapSource.Create(image.Width' image.Height' 96' 96' PixelFormats.Gray16' null' image.Bits' image.Width * image.BytesPerPixel);
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,CalculateFPS,The following statement contains a magic number: if (time > _lastFPSlog + 1000)             {                 Fps = _frames;                 _frames = 0;                 _lastFPSlog = time;             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following statement contains a magic number: for (int i16 = 0' i32 = 0; i16 < depthFrame16.Count && i32 < _depthFrame32.Length; i16 += 2' i32 += 4)             {                 int player = depthFrame16[i16] & 0x07;                 int realDepth = (depthFrame16[i16 + 1] << 5) | (depthFrame16[i16] >> 3);                 // transform 13-bit depth information into an 8-bit intensity appropriate                 // for display (we disregard information in most significant bit)                 var intensity = (byte) (255 - (255*realDepth/0x0fff));                  _depthFrame32[i32 + RED_IDX] = 0;                 _depthFrame32[i32 + GREEN_IDX] = 0;                 _depthFrame32[i32 + BLUE_IDX] = 0;                  if (!colorUsers)                 {                     //IF the users don't need to get specific colors' please continue                     continue;                 }                  // choose different display colors based on player                 switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }             }
Magic Number,Kinect.Core,MyKinect,C:\repos\atosorigin_Kinect\src\Framework\Core\MyKinect.cs,StartKinectThread,The following statement contains a magic number: lock (SyncRoot)             {                 if (_running ||                     (KinectState.ContextOpen | KinectState.Running | KinectState.Initializing).Has(KinectState))                 {                     //Kinect is already running                     return;                 }                  try                 {                     _running = true;                     try                     {                         _nrOfUsers = 0;                         _context.Initialize(RuntimeOptions.UseDepthAndPlayerIndex | RuntimeOptions.UseSkeletalTracking | RuntimeOptions.UseColor);                         //_context.SkeletonEngine.TransformSmooth = true;                          //_context.SkeletonEngine.SmoothParameters = new TransformSmoothParameters();                         _camera.Context = _context;                         _camera.PropertyChanged += CameraPropertyChanged;                         _camera.Running = true;                          KinectState = KinectState.ContextOpen;                     }                     catch (Exception ex)                     {                         Log.IfError("Runtime initialization failed. Please make sure Kinect device is plugged in. Error: {0}"' ex);                          KinectState = KinectState.Failed;                         _running = false;                         return;                     }                      try                     {                          _context.NuiCamera.ElevationAngle = ElevationAngleInitialPosition;                         _context.VideoStream.Open(ImageStreamType.Video' 2' ImageResolution.Resolution640x480' ImageType.Color);                         _context.DepthStream.Open(ImageStreamType.Depth' 2' ImageResolution.Resolution320x240' ImageType.DepthAndPlayerIndex);                     }                     catch (Exception ex)                     {                         Log.IfError(                             "Failed to open stream. Please make sure to specify a supported image type and resolution. Error: {0}"'                             ex);                         KinectState = KinectState.Failed;                         _running = false;                         return;                     }                      Log.IfInfo("Kinect device found.");                      OnCameraMessage("Kinect device found.");                      KinectState = KinectState.Initializing;                      _camera.Initialize();                      _context.SkeletonFrameReady += ContextSkeletonFrameReady;                     _context.SkeletonEngine.IsEnabled = true;                      _activeUsers = new List<User>();                      Log.IfInfo("Kinect device configured.");                      OnCameraMessage("Kinect device configured.");                      Log.IfInfo("Kinect started");                      KinectState = KinectState.Running;                      OnKinectStarted();                 }                 catch (Exception ex)                 {                     Log.IfError("Kinect failed."' ex);                      OnCameraMessage(ex.Message);                     KinectState = KinectState.Failed;                      _running = false;                     _camera.Running = false;                 }             }
Magic Number,Kinect.Core,MyKinect,C:\repos\atosorigin_Kinect\src\Framework\Core\MyKinect.cs,StartKinectThread,The following statement contains a magic number: lock (SyncRoot)             {                 if (_running ||                     (KinectState.ContextOpen | KinectState.Running | KinectState.Initializing).Has(KinectState))                 {                     //Kinect is already running                     return;                 }                  try                 {                     _running = true;                     try                     {                         _nrOfUsers = 0;                         _context.Initialize(RuntimeOptions.UseDepthAndPlayerIndex | RuntimeOptions.UseSkeletalTracking | RuntimeOptions.UseColor);                         //_context.SkeletonEngine.TransformSmooth = true;                          //_context.SkeletonEngine.SmoothParameters = new TransformSmoothParameters();                         _camera.Context = _context;                         _camera.PropertyChanged += CameraPropertyChanged;                         _camera.Running = true;                          KinectState = KinectState.ContextOpen;                     }                     catch (Exception ex)                     {                         Log.IfError("Runtime initialization failed. Please make sure Kinect device is plugged in. Error: {0}"' ex);                          KinectState = KinectState.Failed;                         _running = false;                         return;                     }                      try                     {                          _context.NuiCamera.ElevationAngle = ElevationAngleInitialPosition;                         _context.VideoStream.Open(ImageStreamType.Video' 2' ImageResolution.Resolution640x480' ImageType.Color);                         _context.DepthStream.Open(ImageStreamType.Depth' 2' ImageResolution.Resolution320x240' ImageType.DepthAndPlayerIndex);                     }                     catch (Exception ex)                     {                         Log.IfError(                             "Failed to open stream. Please make sure to specify a supported image type and resolution. Error: {0}"'                             ex);                         KinectState = KinectState.Failed;                         _running = false;                         return;                     }                      Log.IfInfo("Kinect device found.");                      OnCameraMessage("Kinect device found.");                      KinectState = KinectState.Initializing;                      _camera.Initialize();                      _context.SkeletonFrameReady += ContextSkeletonFrameReady;                     _context.SkeletonEngine.IsEnabled = true;                      _activeUsers = new List<User>();                      Log.IfInfo("Kinect device configured.");                      OnCameraMessage("Kinect device configured.");                      Log.IfInfo("Kinect started");                      KinectState = KinectState.Running;                      OnKinectStarted();                 }                 catch (Exception ex)                 {                     Log.IfError("Kinect failed."' ex);                      OnCameraMessage(ex.Message);                     KinectState = KinectState.Failed;                      _running = false;                     _camera.Running = false;                 }             }
Magic Number,Kinect.Core,MyKinect,C:\repos\atosorigin_Kinect\src\Framework\Core\MyKinect.cs,StartKinectThread,The following statement contains a magic number: while (_running && _context != null)             {                 Thread.Sleep(10);             }
Magic Number,Kinect.Core,MyKinect,C:\repos\atosorigin_Kinect\src\Framework\Core\MyKinect.cs,GetDisplayPosition,The following statement contains a magic number: var newPoint = joint.ScaleTo(640' 480' _maxSkeletonX' _maxSkeletonY);
Magic Number,Kinect.Core,MyKinect,C:\repos\atosorigin_Kinect\src\Framework\Core\MyKinect.cs,GetDisplayPosition,The following statement contains a magic number: var newPoint = joint.ScaleTo(640' 480' _maxSkeletonX' _maxSkeletonY);
Magic Number,Kinect.Core,MyKinect,C:\repos\atosorigin_Kinect\src\Framework\Core\MyKinect.cs,GetDisplayPosition,The following statement contains a magic number: return new Point3D(newPoint.Position.X' newPoint.Position.Y' newPoint.Position.Z * 1000);
Magic Number,Kinect.Core.Filters,CollisionFilter,C:\repos\atosorigin_Kinect\src\Framework\Core\Filters\CollisionFilter.cs,CollisionFilter,The following statement contains a magic number: if (joints.Length < 2)              {                  throw new ArgumentException("Add at least two joints to check");              }
Magic Number,Kinect.Core.Gestures,AccelerationGesture,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\AccelerationGesture.cs,Process,The following statement contains a magic number: if (evt != null)              {                  double predictedarmlength = evt.ShoulderRight.Y - evt.HipRight.Y -                                              ((evt.HipRight.Y - evt.KneeRight.Y)/2);                  double maxposition = evt.ShoulderRight.Y + predictedarmlength;                  double minposition = evt.ShoulderRight.Y - predictedarmlength;                  double position = evt.HandRight.Y - evt.ShoulderRight.Y;                  double ratio = (maxposition - minposition)/2;                  double normalPosition = position/ratio;                    //double predictedarmlength = evt.RightHip.Y - evt.RightShoulder.Y - ((evt.RightKnee.Y - evt.RightHip.Y) / 2);                  //double maxposition = evt.RightShoulder.Y - predictedarmlength;                  //double minposition = evt.RightShoulder.Y + predictedarmlength;                  //double position = evt.RightHand.Y + evt.RightShoulder.Y;                  //double ratio = (maxposition + minposition) / 2;                  //double normalPosition = position / ratio;                    OnAccelerationCalculated(evt.Id' -normalPosition);              }
Magic Number,Kinect.Core.Gestures,AccelerationGesture,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\AccelerationGesture.cs,Process,The following statement contains a magic number: if (evt != null)              {                  double predictedarmlength = evt.ShoulderRight.Y - evt.HipRight.Y -                                              ((evt.HipRight.Y - evt.KneeRight.Y)/2);                  double maxposition = evt.ShoulderRight.Y + predictedarmlength;                  double minposition = evt.ShoulderRight.Y - predictedarmlength;                  double position = evt.HandRight.Y - evt.ShoulderRight.Y;                  double ratio = (maxposition - minposition)/2;                  double normalPosition = position/ratio;                    //double predictedarmlength = evt.RightHip.Y - evt.RightShoulder.Y - ((evt.RightKnee.Y - evt.RightHip.Y) / 2);                  //double maxposition = evt.RightShoulder.Y - predictedarmlength;                  //double minposition = evt.RightShoulder.Y + predictedarmlength;                  //double position = evt.RightHand.Y + evt.RightShoulder.Y;                  //double ratio = (maxposition + minposition) / 2;                  //double normalPosition = position / ratio;                    OnAccelerationCalculated(evt.Id' -normalPosition);              }
Magic Number,Kinect.Core.Gestures,ClapGesture,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\ClapGesture.cs,AddPoints,The following statement contains a magic number: if (DoubleClap != null)              {                  ////Do some work for double clap                  _history.Enqueue(hand);                  ////Do some work for single clap                  bool clap = hand.DetectClap();                  if (clap && _doubleClapCheck < 0)                  {                      _doubleClapCheck = PointCount;                  }                  else if (_doubleClapCheck == 0)                  {                      ////TODO: remove call to camera and use OnSingleclap Camera.Instance.OnKinectEventHandlerEvent(SingleClap);                      _doubleClapCheck--;                  }                  else if (_doubleClapCheck >= 0)                  {                      if (CheckForDoubleClap())                      {                          _doubleClapCheck = -1;                      }                      else                      {                          _doubleClapCheck--;                      }                  }              }              else              {                  ////Do some work for single clap                  if (hand.DetectClap() && _doubleClapCheck < 0)                  {                      _doubleClapCheck = 10;                  }                  else if (_doubleClapCheck >= 0)                  {                      _doubleClapCheck--;                  }              }
Magic Number,Kinect.Core.Gestures,ClapGesture,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\ClapGesture.cs,CheckForDoubleClap,The following statement contains a magic number: foreach (Hands hands in _history)              {                  if (wait > 0)                  {                      wait--;                  }                  else if (hands.DetectClap())                  {                      nrOfClaps++;                      wait = 4;                  }              }
Magic Number,Kinect.Core.Gestures,ClapGesture,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\ClapGesture.cs,CheckForDoubleClap,The following statement contains a magic number: if (nrOfClaps >= 2)              {                  _history.Clear();                  return true;              }
Magic Number,Kinect.Core.Gestures,GestureFactory,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\GestureFactory.cs,AddSemaphoreTouchGesture,The following statement contains a magic number: var fpsFilter = new FramesFilter(6);
Magic Number,Kinect.Core.Gestures,GestureFactory,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\GestureFactory.cs,AddAccelerationGesture,The following statement contains a magic number: var fpsFilter = new FramesFilter(6);
Magic Number,Kinect.Core.Gestures,GestureFactory,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\GestureFactory.cs,AddSelfTouchGesture,The following statement contains a magic number: if (joints.Length < 2)              {                  throw new ArgumentException("At least 2 joints are expected for a SelfTouchGesture"' "joints");              }
Magic Number,Kinect.Core.Gestures,GestureFactory,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\GestureFactory.cs,AddSelfTouchGesture,The following statement contains a magic number: foreach (XElement node in selfTouchGestureNodes)              {                  if (!Convert.ToBoolean(node.Attribute(XName.Get("Active")).Value))                  {                      continue;                  }                    if (!AreJointsMatching(node.Element(XName.Get("PointsToCheck"))' joints))                  {                      continue;                  }                    filters = GetFilters(node.Element(XName.Get("Filters"))' joints);                  if (filters == null || filters.Count == 0)                  {                      filters = GetStandardSelfTouchFilters(joints);                  }                    for (int i = 0; i < filters.Count; i++)                  {                      if (i == 0)                      {                          user.AttachPipeline(filters[i]);                      }                      else                      {                          filters[i - 1].AttachPipeline(filters[i]);                      }                        var correctionFilter = filters[i] as CorrectionFilter;                      if (correctionFilter != null && joints[1].Equals(correctionFilter.JointToCorrect))                      {                          correctionFilter.Correction = correction;                      }                  }                    int historyCount = 10;                  string history = node.Attribute(XName.Get("History")).Value;                  int.TryParse(history' out historyCount);                  selfTouchGesture = new SelfTouchGesture                                         {                                             HistoryCount = historyCount'                                             Joints = joints                                         };                    filters[filters.Count - 1].AttachPipeline(selfTouchGesture);              }
Magic Number,Kinect.Core.Gestures,GestureFactory,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\GestureFactory.cs,AddSelfTouchGestures,The following statement contains a magic number: foreach (XElement node in selfTouchGestureNodes)              {                  if (!Convert.ToBoolean(node.Attribute(XName.Get("Active")).Value))                  {                      continue;                  }                    JointID[] joints = null;                  joints = GetJoints(node.Element(XName.Get("PointsToCheck"))).ToArray();                    if (joints != null)                  {                      List<Filter<IUserChangedEvent>> filters;                      filters = GetFilters(node.Element(XName.Get("Filters"))' joints);                        for (int i = 0; i < filters.Count; i++)                      {                          if (i == 0)                          {                              user.AttachPipeline(filters[i]);                          }                          else                          {                              filters[i - 1].AttachPipeline(filters[i]);                          }                      }                        SelfTouchGesture gesture = null;                      int historyCount;                      string history = node.Attribute(XName.Get("History")).Value;                        if (int.TryParse(history' out historyCount))                      {                          gesture = new SelfTouchGesture {HistoryCount = historyCount' Joints = joints};                      }                      else                      {                          gesture = new SelfTouchGesture {HistoryCount = 10' Joints = joints};                      }                        filters[filters.Count - 1].AttachPipeline(gesture);                      selfTouchGestures.Add(gesture);                  }              }
Magic Number,Kinect.Core.Gestures,GestureFactory,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\GestureFactory.cs,GetStandardSelfTouchFilters,The following statement contains a magic number: if (joints.Length < 2)              {                  throw new ArgumentException("At least 2 joints are expected for a SelfTouchGesture"' "joints");              }
Magic Number,Kinect.Core.Gestures,GestureFactory,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\GestureFactory.cs,GetStandardSelfTouchFilters,The following statement contains a magic number: list.Add(new FramesFilter(6));
Magic Number,Kinect.Core.Gestures,GestureFactory,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\GestureFactory.cs,GetFilters,The following statement contains a magic number: foreach (XElement filter in myFilters)              {                  Filter<IUserChangedEvent> createdFilter = null;                  if (filter.Name == "FramesFilter")                  {                      int fpsCount;                      string fps = filter.Attribute(XName.Get("FPS")).Value;                      if (int.TryParse(fps' out fpsCount))                      {                          createdFilter = new FramesFilter(fpsCount);                      }                      else                      {                          createdFilter = new FramesFilter(10);                      }                  }                  else if (filter.Name == "CollisionFilter")                  {                      int x' y' z;                      string xValue = filter.Attribute(XName.Get("MarginX")).Value;                      string yValue = filter.Attribute(XName.Get("MarginY")).Value;                      string zValue = filter.Attribute(XName.Get("MarginZ")).Value;                        if (int.TryParse(xValue' out x) && int.TryParse(yValue' out y) && int.TryParse(zValue' out z))                      {                          createdFilter = new CollisionFilter(new Point3D(x' y' z)' joints);                      }                      else                      {                          var exception = new ArgumentException("You need to provide the XYZ margins");                            _log.IfError(string.Empty' exception);                            throw exception;                      }                  }                  else if (filter.Name == "CorrectionFilter")                  {                      var correction = new Point3D();                      correction.X = SafeFloatParse(filter.Attribute(XName.Get("MarginX")));                      correction.Y = SafeFloatParse(filter.Attribute(XName.Get("MarginY")));                      correction.Z = SafeFloatParse(filter.Attribute(XName.Get("MarginZ")));                      JointID joint;                        //TODO better catch if XML isn't correct? DTD                      if (Enum.TryParse(filter.Attribute(XName.Get("SkeletonJoint")).Value' out joint))                      {                          createdFilter = new CorrectionFilter(joint' correction);                      }                      else                      {                          var exception = new ArgumentException("You need to provide a SkeletonJoint to correct");                            _log.IfError(string.Empty' exception);                            throw exception;                      }                  }                  else                  {                      var exception = new ArgumentException("The provided filter isn't supported");                        _log.IfError(string.Empty' exception);                        throw exception;                  }                    if (createdFilter != null)                  {                      filterCollection.Add(createdFilter);                  }              }
Magic Number,Kinect.Core.Gestures.Helper,Calculator,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\Helper\Calculator.cs,CalculateAngle,The following statement contains a magic number: if (resX == 0.0)              {                  if (resY == 0.0)                      // was resY. i think 0'0 is seen as same as up... There is an error in http://www.carlosfemmer.com/post/2006/02/Calculate-Angle-between-2-points-using-C.aspx  :-)                  {                      angle = 0.0;                  }                  else if (resY > 0.0)                  {                      angle = Math.PI/2.0;                  }                  else                  {                      angle = Math.PI*3.0/2.0;                  }              }              else if (resY == 0.0)              {                  if (resX > 0.0)                  {                      angle = 0.0;                  }                  else                  {                      angle = Math.PI;                  }              }              else              {                  if (resX < 0.0)                  {                      angle = Math.Atan(resY/resX) + Math.PI;                  }                  else if (resY < 0.0)                  {                      angle = Math.Atan(resY/resX) + (2*Math.PI);                  }                  else                  {                      angle = Math.Atan(resY/resX);                  }              }
Magic Number,Kinect.Core.Gestures.Helper,Calculator,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\Helper\Calculator.cs,CalculateAngle,The following statement contains a magic number: if (resX == 0.0)              {                  if (resY == 0.0)                      // was resY. i think 0'0 is seen as same as up... There is an error in http://www.carlosfemmer.com/post/2006/02/Calculate-Angle-between-2-points-using-C.aspx  :-)                  {                      angle = 0.0;                  }                  else if (resY > 0.0)                  {                      angle = Math.PI/2.0;                  }                  else                  {                      angle = Math.PI*3.0/2.0;                  }              }              else if (resY == 0.0)              {                  if (resX > 0.0)                  {                      angle = 0.0;                  }                  else                  {                      angle = Math.PI;                  }              }              else              {                  if (resX < 0.0)                  {                      angle = Math.Atan(resY/resX) + Math.PI;                  }                  else if (resY < 0.0)                  {                      angle = Math.Atan(resY/resX) + (2*Math.PI);                  }                  else                  {                      angle = Math.Atan(resY/resX);                  }              }
Magic Number,Kinect.Core.Gestures.Helper,Calculator,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\Helper\Calculator.cs,CalculateAngle,The following statement contains a magic number: if (resX == 0.0)              {                  if (resY == 0.0)                      // was resY. i think 0'0 is seen as same as up... There is an error in http://www.carlosfemmer.com/post/2006/02/Calculate-Angle-between-2-points-using-C.aspx  :-)                  {                      angle = 0.0;                  }                  else if (resY > 0.0)                  {                      angle = Math.PI/2.0;                  }                  else                  {                      angle = Math.PI*3.0/2.0;                  }              }              else if (resY == 0.0)              {                  if (resX > 0.0)                  {                      angle = 0.0;                  }                  else                  {                      angle = Math.PI;                  }              }              else              {                  if (resX < 0.0)                  {                      angle = Math.Atan(resY/resX) + Math.PI;                  }                  else if (resY < 0.0)                  {                      angle = Math.Atan(resY/resX) + (2*Math.PI);                  }                  else                  {                      angle = Math.Atan(resY/resX);                  }              }
Magic Number,Kinect.Core.Gestures.Helper,Calculator,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\Helper\Calculator.cs,CalculateAngle,The following statement contains a magic number: if (resX == 0.0)              {                  if (resY == 0.0)                      // was resY. i think 0'0 is seen as same as up... There is an error in http://www.carlosfemmer.com/post/2006/02/Calculate-Angle-between-2-points-using-C.aspx  :-)                  {                      angle = 0.0;                  }                  else if (resY > 0.0)                  {                      angle = Math.PI/2.0;                  }                  else                  {                      angle = Math.PI*3.0/2.0;                  }              }              else if (resY == 0.0)              {                  if (resX > 0.0)                  {                      angle = 0.0;                  }                  else                  {                      angle = Math.PI;                  }              }              else              {                  if (resX < 0.0)                  {                      angle = Math.Atan(resY/resX) + Math.PI;                  }                  else if (resY < 0.0)                  {                      angle = Math.Atan(resY/resX) + (2*Math.PI);                  }                  else                  {                      angle = Math.Atan(resY/resX);                  }              }
Magic Number,Kinect.Core.Gestures.Helper,Calculator,C:\repos\atosorigin_Kinect\src\Framework\Core\Gestures\Helper\Calculator.cs,CalculateAngle,The following statement contains a magic number: angle = angle*180/Math.PI;
Missing Default,Kinect.Core,Camera,C:\repos\atosorigin_Kinect\src\Framework\Core\Camera.cs,ConvertDepthFrame,The following switch statement is missing a default case: switch (player)                 {                     case 0:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/2);                         break;                     case 1:                         _depthFrame32[i32 + RED_IDX] = intensity;                         break;                     case 2:                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         break;                     case 3:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 4:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = intensity;                         _depthFrame32[i32 + BLUE_IDX] = (byte) (intensity/4);                         break;                     case 5:                         _depthFrame32[i32 + RED_IDX] = intensity;                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/4);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 6:                         _depthFrame32[i32 + RED_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (intensity/2);                         _depthFrame32[i32 + BLUE_IDX] = intensity;                         break;                     case 7:                         _depthFrame32[i32 + RED_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + GREEN_IDX] = (byte) (255 - intensity);                         _depthFrame32[i32 + BLUE_IDX] = (byte) (255 - intensity);                         break;                 }
Missing Default,Kinect.Core.Filters.Helper,FilterHelper,C:\repos\atosorigin_Kinect\src\Framework\Core\Filters\Helper\FilterHelper.cs,GetPoint,The following switch statement is missing a default case: switch (joint)              {                  case JointID.Head:                      return evt.Head;                  case JointID.AnkleLeft:                      return evt.AnkleLeft;                  case JointID.ElbowLeft:                      return evt.ElbowLeft;                  case JointID.FootLeft:                      return evt.FootLeft;                  case JointID.HandLeft:                      return evt.HandLeft;                  case JointID.KneeLeft:                      return evt.KneeLeft;                  case JointID.ShoulderLeft:                      return evt.ShoulderLeft;                  case JointID.HipLeft:                      return evt.HipLeft;                  case JointID.ShoulderCenter:                      return evt.ShoulderCenter;                  case JointID.AnkleRight:                      return evt.AnkleRight;                  case JointID.ElbowRight:                      return evt.ElbowRight;                  case JointID.FootRight:                      return evt.FootRight;                  case JointID.HandRight:                      return evt.HandRight;                  case JointID.KneeRight:                      return evt.KneeRight;                  case JointID.HipRight:                      return evt.HipRight;                  case JointID.ShoulderRight:                      return evt.ShoulderRight;                  case JointID.Spine:                      return evt.Spine;                  case JointID.HipCenter:                      return evt.HipCenter;              }
Missing Default,Kinect.Core.Filters.Helper,FilterHelper,C:\repos\atosorigin_Kinect\src\Framework\Core\Filters\Helper\FilterHelper.cs,SetPoint,The following switch statement is missing a default case: switch (joint)              {                  case JointID.Head:                      user.Head = newPoint;                      break;                  case JointID.AnkleLeft:                      user.AnkleLeft = newPoint;                      break;                  case JointID.ElbowLeft:                      user.ElbowLeft = newPoint;                      break;                  case JointID.FootLeft:                      user.FootLeft = newPoint;                      break;                  case JointID.HandLeft:                      user.HandLeft = newPoint;                      break;                  case JointID.KneeLeft:                      user.KneeLeft = newPoint;                      break;                  case JointID.ShoulderLeft:                      user.ShoulderLeft = newPoint;                      break;                  case JointID.HipLeft:                      user.HipLeft = newPoint;                      break;                  case JointID.ShoulderCenter:                      user.ShoulderCenter = newPoint;                      break;                  case JointID.AnkleRight:                      user.AnkleRight = newPoint;                      break;                  case JointID.ElbowRight:                      user.ElbowRight = newPoint;                      break;                  case JointID.FootRight:                      user.FootRight = newPoint;                      break;                  case JointID.HandRight:                      user.HandRight = newPoint;                      break;                  case JointID.KneeRight:                      user.KneeRight = newPoint;                      break;                  case JointID.HipRight:                      user.HipRight = newPoint;                      break;                  case JointID.ShoulderRight:                      user.ShoulderRight = newPoint;                      break;                  case JointID.Spine:                      user.Spine = newPoint;                      break;                  case JointID.HipCenter:                      user.HipCenter = newPoint;                      break;              }
