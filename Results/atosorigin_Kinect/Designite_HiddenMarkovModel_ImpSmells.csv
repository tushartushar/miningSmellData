Implementation smell,Namespace,Class,File,Method,Description
Long Method,Accord.Statistics.Models.Markov.Learning,BaumWelchLearningBase,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Learning\Base\BaumWelchLearningBase.cs,Run,The method has 124 lines of code.
Long Method,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tred2,The method has 104 lines of code.
Long Method,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tql2,The method has 109 lines of code.
Long Method,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The method has 400 lines of code.
Long Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,The method has 128 lines of code.
Long Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The method has 315 lines of code.
Long Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzval,The method has 246 lines of code.
Long Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The method has 228 lines of code.
Long Method,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,init,The method has 149 lines of code.
Long Method,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The method has 569 lines of code.
Long Method,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The method has 104 lines of code.
Complex Method,Accord.Statistics.Models.Markov,ContinuousHiddenMarkovModel,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\ContinuousHiddenMarkovModel.cs,Decode,Cyclomatic complexity of the method is 12
Complex Method,Accord.Statistics.Models.Markov,ForwardBackwardAlgorithm,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\ForwardBackwardAlgorithm.cs,Forward,Cyclomatic complexity of the method is 9
Complex Method,Accord.Statistics.Models.Markov,ForwardBackwardAlgorithm,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\ForwardBackwardAlgorithm.cs,Forward,Cyclomatic complexity of the method is 9
Complex Method,Accord.Statistics.Models.Markov,HiddenMarkovModel,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\HiddenMarkovModel.cs,Decode,Cyclomatic complexity of the method is 11
Complex Method,Accord.Statistics.Models.Markov,HiddenMarkovModel,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\HiddenMarkovModel.cs,Predict,Cyclomatic complexity of the method is 11
Complex Method,AForge.Math,FourierTransform,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\FourierTransform.cs,DFT2,Cyclomatic complexity of the method is 13
Complex Method,AForge.Math,FourierTransform,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\FourierTransform.cs,FFT2,Cyclomatic complexity of the method is 8
Complex Method,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,Cyclomatic complexity of the method is 32
Complex Method,Accord.Math.Decompositions,CholeskyDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\CholeskyDecomposition.cs,Solve,Cyclomatic complexity of the method is 14
Complex Method,Accord.Math.Decompositions,CholeskyDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\CholeskyDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math.Decompositions,CholeskyDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\CholeskyDecomposition.cs,Inverse,Cyclomatic complexity of the method is 12
Complex Method,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tred2,Cyclomatic complexity of the method is 23
Complex Method,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tql2,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,orthes,Cyclomatic complexity of the method is 20
Complex Method,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,Cyclomatic complexity of the method is 66
Complex Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,Cyclomatic complexity of the method is 27
Complex Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,Cyclomatic complexity of the method is 48
Complex Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzval,Cyclomatic complexity of the method is 24
Complex Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,Cyclomatic complexity of the method is 32
Complex Method,Accord.Math.Decompositions,LuDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\LuDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math.Decompositions,LuDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\LuDecomposition.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,Accord.Math.Decompositions,LuDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\LuDecomposition.cs,Inverse,Cyclomatic complexity of the method is 10
Complex Method,Accord.Math.Decompositions,LuDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\LuDecomposition.cs,SolveTranspose,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,init,Cyclomatic complexity of the method is 25
Complex Method,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,nnmf,Cyclomatic complexity of the method is 18
Complex Method,Accord.Math.Decompositions,QrDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\QrDecomposition.cs,QrDecomposition,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math.Decompositions,QrDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\QrDecomposition.cs,Solve,Cyclomatic complexity of the method is 14
Complex Method,Accord.Math.Decompositions,QrDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\QrDecomposition.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,Accord.Math.Decompositions,QrDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\QrDecomposition.cs,SolveTranspose,Cyclomatic complexity of the method is 14
Complex Method,Accord.Math.Decompositions,QrDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\QrDecomposition.cs,Inverse,Cyclomatic complexity of the method is 12
Complex Method,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,Cyclomatic complexity of the method is 69
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,TransposeAndMultiply,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Add,Cyclomatic complexity of the method is 10
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Subtract,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,IsEqual,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,IsEqual,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Transpose,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Transpose,Cyclomatic complexity of the method is 9
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Sum,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Sum,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,CumulativeSum,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Reshape,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,Cyclomatic complexity of the method is 14
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,ElementwiseDivide,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,ElementwiseMultiply,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Max,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Min,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Max,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Min,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,Cyclomatic complexity of the method is 14
Complex Method,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,Cyclomatic complexity of the method is 10
Complex Method,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,Cyclomatic complexity of the method is 14
Complex Method,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Ibeta,Cyclomatic complexity of the method is 17
Complex Method,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,Cyclomatic complexity of the method is 9
Complex Method,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,Cyclomatic complexity of the method is 10
Complex Method,Accord.Math.Formats,MatrixFormatter,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Formats\Base\MatrixFormatter.cs,Format,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math.Formats,MatrixFormatter,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Formats\Base\MatrixFormatter.cs,parseOptions,Cyclomatic complexity of the method is 10
Complex Method,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Mean,Cyclomatic complexity of the method is 8
Complex Method,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Mean,Cyclomatic complexity of the method is 8
Complex Method,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Scatter,Cyclomatic complexity of the method is 11
Complex Method,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Scatter,Cyclomatic complexity of the method is 12
Complex Method,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Scatter,Cyclomatic complexity of the method is 12
Long Parameter List,Accord.Statistics.Models.Markov,HiddenMarkovModel,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\HiddenMarkovModel.cs,Predict,The method has 5 parameters. Parameters: observations' next' logarithm' probability' probabilities
Long Parameter List,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,cdiv,The method has 6 parameters. Parameters: xr' xi' yr' yi' cdivr' cdivi
Long Parameter List,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,The method has 5 parameters. Parameters: n' a' b' matz' z
Long Parameter List,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The method has 7 parameters. Parameters: n' a' b' eps1' matz' z' ierr
Long Parameter List,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzval,The method has 8 parameters. Parameters: n' a' b' alfr' alfi' beta' matz' z
Long Parameter List,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The method has 7 parameters. Parameters: n' a' b' alfr' alfi' beta' z
Long Parameter List,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The method has 7 parameters. Parameters: value' k' algorithm' attempts' maxIterations' errorTolerance' changeTolerance
Long Parameter List,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The method has 8 parameters. Parameters: value' h0' w0' algorithm' attempts' maxIterations' errorTolerance' changeTolerance
Long Parameter List,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,init,The method has 9 parameters. Parameters: value' k' algorithm' h0' w0' attempts' maxIterations' errorTolerance' changeTolerance
Long Parameter List,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,nnmf,The method has 7 parameters. Parameters: value' w0' h0' alg' maxIterations' normChangeThreshold' maxFactorChangeThreshold
Long Parameter List,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The method has 5 parameters. Parameters: value' computeLeftSingularVectors' computeRightSingularVectors' autoTranspose' inPlace
Long Parameter List,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The method has 5 parameters. Parameters: data' startRow' endRow' startColumn' endColumn
Long Parameter List,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Scale,The method has 5 parameters. Parameters: fromMin' fromMax' toMin' toMax' x
Long Parameter List,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Scale,The method has 5 parameters. Parameters: fromMin' fromMax' toMin' toMax' x
Long Parameter List,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Scale,The method has 5 parameters. Parameters: fromMin' fromMax' toMin' toMax' x
Long Parameter List,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Scale,The method has 5 parameters. Parameters: fromMin' fromMax' toMin' toMax' x
Long Parameter List,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Scale,The method has 5 parameters. Parameters: fromMin' fromMax' toMin' toMax' x
Long Parameter List,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Scale,The method has 5 parameters. Parameters: fromMin' fromMax' toMin' toMax' x
Long Parameter List,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Scatter,The method has 5 parameters. Parameters: matrix' means' divisor' dimension' weights
Long Statement,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,init,The length of the statement  "                    "The approximation rank k should be a positive integer equal or less than the number of columns of the matrix to be decomposed."' " is 129.
Long Statement,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,init,The length of the statement  "                        "The initial coefficient matrix should have the same number of columns as the value matrix and the same number of rows as the desired rank approximation."' " is 155.
Long Statement,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,init,The length of the statement  "                        "The initial weight matrix should have the same number of rows as the value matrix and the same number of columns as the desired rank approximation."' " is 150.
Complex Conditional,AForge.Math,FourierTransform,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\FourierTransform.cs,FFT2,The conditional expression  "(!Tools.IsPowerOf2(k)) ||                  (!Tools.IsPowerOf2(n)) ||                  (k < minLength) || (k > maxLength) ||                  (n < minLength) || (n > maxLength)"  is complex.
Complex Conditional,Accord.Math.Decompositions,LuDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\LuDecomposition.cs,LuDecomposition,The conditional expression  "(!transpose && value.GetLength(0) < value.GetLength(1)) ||                  (transpose && value.GetLength(1) < value.GetLength(0))"  is complex.
Complex Conditional,Accord.Math.Decompositions,QrDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\QrDecomposition.cs,QrDecomposition,The conditional expression  "(!transpose && value.GetLength(0) < value.GetLength(1)) ||                  (transpose && value.GetLength(1) < value.GetLength(0))"  is complex.
Complex Conditional,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The conditional expression  "(startRow > endRow) || (startColumn > endColumn) || (startRow < 0) ||                  (startRow >= rows) || (endRow < 0) || (endRow >= rows) ||                  (startColumn < 0) || (startColumn >= cols) || (endColumn < 0) ||                  (endColumn >= cols)"  is complex.
Complex Conditional,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The conditional expression  "(rowIndexes[i] < 0) || (rowIndexes[i] >= data.GetLength(0)) ||                          (columnIndexes[j] < 0) || (columnIndexes[j] >= data.GetLength(1))"  is complex.
Complex Conditional,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The conditional expression  "(i0 > i1) || (i0 < 0) || (i0 >= data.GetLength(0))                  || (i1 < 0) || (i1 >= data.GetLength(0))"  is complex.
Complex Conditional,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The conditional expression  "(j0 > j1) || (j0 < 0) || (j0 >= data.GetLength(1)) || (j1 < 0)                  || (j1 >= data.GetLength(1))"  is complex.
Complex Conditional,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The conditional expression  "(j0 > j1) || (j0 < 0) || (j0 >= data[0].Length) ||                  (j1 < 0) || (j1 >= data[0].Length)"  is complex.
Complex Conditional,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The conditional expression  "(i0 > i1) || (i0 < 0) || (i0 >= data.Length)                  || (i1 < 0) || (i1 >= data.Length)"  is complex.
Magic Number,Accord.Statistics.Distributions.Multivariate,NormalDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Multivariate\NormalDistribution.cs,NormalDistribution,The following statement contains a magic number: constant = 1.0/(System.Math.Pow(2.0*System.Math.PI' k/2.0)*detSqrt);
Magic Number,Accord.Statistics.Distributions.Multivariate,NormalDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Multivariate\NormalDistribution.cs,NormalDistribution,The following statement contains a magic number: constant = 1.0/(System.Math.Pow(2.0*System.Math.PI' k/2.0)*detSqrt);
Magic Number,Accord.Statistics.Distributions.Multivariate,NormalDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Multivariate\NormalDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double r = constant*System.Math.Exp(-0.5*b);
Magic Number,Accord.Statistics.Distributions.Univariate,ChiSquareDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\ChiSquareDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double m1 = System.Math.Pow(x' (v - 2.0)/2.0);
Magic Number,Accord.Statistics.Distributions.Univariate,ChiSquareDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\ChiSquareDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double m1 = System.Math.Pow(x' (v - 2.0)/2.0);
Magic Number,Accord.Statistics.Distributions.Univariate,ChiSquareDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\ChiSquareDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double m2 = System.Math.Exp(-x/2.0);
Magic Number,Accord.Statistics.Distributions.Univariate,ChiSquareDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\ChiSquareDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double m3 = System.Math.Pow(2' v/2.0)*Special.Gamma(v/2.0);
Magic Number,Accord.Statistics.Distributions.Univariate,ChiSquareDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\ChiSquareDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double m3 = System.Math.Pow(2' v/2.0)*Special.Gamma(v/2.0);
Magic Number,Accord.Statistics.Distributions.Univariate,ChiSquareDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\ChiSquareDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double m3 = System.Math.Pow(2' v/2.0)*Special.Gamma(v/2.0);
Magic Number,Accord.Statistics.Distributions.Univariate,FDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\FDistribution.cs,FDistribution,The following statement contains a magic number: b = Special.Beta(degrees1*0.5' degrees2*0.5);
Magic Number,Accord.Statistics.Distributions.Univariate,FDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\FDistribution.cs,FDistribution,The following statement contains a magic number: b = Special.Beta(degrees1*0.5' degrees2*0.5);
Magic Number,Accord.Statistics.Distributions.Univariate,FDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\FDistribution.cs,DistributionFunction,The following statement contains a magic number: return Special.Ibeta(d1*0.5' d2*0.5' u);
Magic Number,Accord.Statistics.Distributions.Univariate,FDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\FDistribution.cs,DistributionFunction,The following statement contains a magic number: return Special.Ibeta(d1*0.5' d2*0.5' u);
Magic Number,Accord.Statistics.Distributions.Univariate,NormalDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\NormalDistribution.cs,NormalDistribution,The following statement contains a magic number: double b = 2.0*System.Math.PI*variance;
Magic Number,Accord.Statistics.Distributions.Univariate,NormalDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\NormalDistribution.cs,DistributionFunction,The following statement contains a magic number: return Special.Erfc(-z/Special.Sqrt2)/2.0;
Magic Number,Accord.Statistics.Distributions.Univariate,NormalDistribution,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\NormalDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: return ((1.0/(Special.SqrtPI*variance))*System.Math.Exp((-z*z)/2.0));
Magic Number,Accord.Statistics.Models.Markov.Learning,BaumWelchLearning,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Learning\BaumWelchLearning.cs,UpdateEmissions,The following statement contains a magic number: num = 1e-10;
Magic Number,AForge.Math,Complex,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Complex.cs,ApproxEqual,The following statement contains a magic number: return ApproxEqual(a' b' 8.8817841970012523233891E-16);
Magic Number,AForge.Math,FourierTransform,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\FourierTransform.cs,DFT,The following statement contains a magic number: arg = -(int) direction*2.0*System.Math.PI*i/n;
Magic Number,AForge.Math,FourierTransform,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\FourierTransform.cs,DFT2,The following statement contains a magic number: arg = -(int) direction*2.0*System.Math.PI*j/m;
Magic Number,AForge.Math,FourierTransform,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\FourierTransform.cs,DFT2,The following statement contains a magic number: arg = -(int) direction*2.0*System.Math.PI*i/n;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Pow2,The following statement contains a magic number: return ((power >= 0) && (power <= 30)) ? (1 << power) : 0;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 2
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 2;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 4
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 3;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 8
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 4;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 16
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 5;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 32
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 6;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 64
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 7;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 128
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 8;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 256
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 9;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 512
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 10;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 1024
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 11;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 2048
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 12;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 4096
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 13;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 8192
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 14;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 16384
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 15;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 32768
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 16;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 65536
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 17;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 131072
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 18;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 262144
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 19;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 524288
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 20;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 1048576
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 21;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 2097152
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 22;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 4194304
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 23;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 8388608
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 24;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 16777216
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 25;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 33554432
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 26;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 67108864
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 27;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 134217728
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 28;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 268435456
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 29;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 536870912
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 30;
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: x <= 1073741824
Magic Number,AForge.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 31;
Magic Number,AForge.Math.Random,StandardGenerator,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Random\StandardGenerator.cs,Next,The following statement contains a magic number: x1 = rand.Next()*2.0 - 1.0;
Magic Number,AForge.Math.Random,StandardGenerator,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Random\StandardGenerator.cs,Next,The following statement contains a magic number: x2 = rand.Next()*2.0 - 1.0;
Magic Number,AForge.Math.Random,StandardGenerator,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Random\StandardGenerator.cs,Next,The following statement contains a magic number: w = System.Math.Sqrt((-2.0*System.Math.Log(w))/w);
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tql2,The following statement contains a magic number: double eps = System.Math.Pow(2.0' -52.0);
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tql2,The following statement contains a magic number: double eps = System.Math.Pow(2.0' -52.0);
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tql2,The following statement contains a magic number: double p = (d[l + 1] - g)/(2.0*e[l]);
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: double eps = System.Math.Pow(2.0' -52.0);
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: double eps = System.Math.Pow(2.0' -52.0);
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,The following statement contains a magic number: n == 2
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,The following statement contains a magic number: nk1 = n - 2 - k;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,The following statement contains a magic number: l = n - lb - 2;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,The following statement contains a magic number: k < n - 2
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: itn = n*30;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: ish = 2;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: its == 10
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: t = (a43*b34 - a33 - a44)*.5;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: a3 = 1.1605;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: notlas = k != na && ish == 2;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: k2 = k + 2;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzval,The following statement contains a magic number: isw == 2
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzval,The following statement contains a magic number: c = (t - s*b12)*.5;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzval,The following statement contains a magic number: isw = 3 - isw;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: isw == 2
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: i == 0 || isw == 2
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: isw == 2
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: isw = 3 - isw;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: i == 0 || isw == 2
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: isw = 2;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: isw == 2
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: isw = 3 - isw;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: isw == 2
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: isw = 3 - isw;
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' k' NonnegativeFactorizationAlgorithm.AlternateLeastSquares'                   null' null' attempts' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' k' NonnegativeFactorizationAlgorithm.AlternateLeastSquares'                   null' null' attempts' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' k' NonnegativeFactorizationAlgorithm.AlternateLeastSquares'                   null' null' attempts' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' k' algorithm' null' null' 1' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' k' algorithm' null' null' 1' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' k' algorithm' null' null' 1' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' w0.GetLength(1)' NonnegativeFactorizationAlgorithm.AlternateLeastSquares' h0' w0' 1' 100' 1e-4'                   1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' w0.GetLength(1)' NonnegativeFactorizationAlgorithm.AlternateLeastSquares' h0' w0' 1' 100' 1e-4'                   1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' w0.GetLength(1)' NonnegativeFactorizationAlgorithm.AlternateLeastSquares' h0' w0' 1' 100' 1e-4'                   1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' w0.GetLength(1)' algorithm' h0' w0' 1' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' w0.GetLength(1)' algorithm' h0' w0' 1' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' w0.GetLength(1)' algorithm' h0' w0' 1' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double eps = System.Math.Pow(2.0' -52.0);
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double eps = System.Math.Pow(2.0' -52.0);
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double tiny = System.Math.Pow(2.0' -966.0);
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double tiny = System.Math.Pow(2.0' -966.0);
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: int nrt = System.Math.Max(0' System.Math.Min(n - 2' m));
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: kase = 4;
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: k == p - 2
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,Accord.Math,Distance,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Distance.cs,Bhattacharyya,The following statement contains a magic number: P[j' i] = P[i' j] = (covX[i' j] + covY[i' j])/2.0;
Magic Number,Accord.Math,Distance,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Distance.cs,Bhattacharyya,The following statement contains a magic number: return (1.0/8.0)*SquareMahalanobis(meanY' meanX' P.Inverse())                     + (0.5)*System.Math.Log(detP/System.Math.Sqrt(detP1*detP2));
Magic Number,Accord.Math,Distance,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Distance.cs,Bhattacharyya,The following statement contains a magic number: return (1.0/8.0)*SquareMahalanobis(meanY' meanX' P.Inverse())                     + (0.5)*System.Math.Log(detP/System.Math.Sqrt(detP1*detP2));
Magic Number,Accord.Math,HilbertTransform,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: cdata[i].Re *= 2.0;
Magic Number,Accord.Math,HilbertTransform,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: cdata[i].Im *= 2.0;
Magic Number,Accord.Math,HilbertTransform,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: i < (N/2)
Magic Number,Accord.Math,HilbertTransform,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: shift[i].Re *= 2.0;
Magic Number,Accord.Math,HilbertTransform,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: shift[i].Im *= 2.0;
Magic Number,Accord.Math,HilbertTransform,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: i < (N/2)
Magic Number,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: size < 3
Magic Number,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: int a = (size + 1)/2;
Magic Number,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;
Magic Number,Accord.Math,Matrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: (size%2) == 1
Magic Number,Accord.Math,ComplexMatrix,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Complex.cs,ToArray,The following statement contains a magic number: var arr = new double[c.Length'2];
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] P =                  {                      1.60119522476751861407E-4'                      1.19135147006586384913E-3'                      1.04213797561761569935E-2'                      4.76367800457137231464E-2'                      2.07448227648435975150E-1'                      4.94214826801497100753E-1'                      9.99999999999999996796E-1                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] P =                  {                      1.60119522476751861407E-4'                      1.19135147006586384913E-3'                      1.04213797561761569935E-2'                      4.76367800457137231464E-2'                      2.07448227648435975150E-1'                      4.94214826801497100753E-1'                      9.99999999999999996796E-1                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] P =                  {                      1.60119522476751861407E-4'                      1.19135147006586384913E-3'                      1.04213797561761569935E-2'                      4.76367800457137231464E-2'                      2.07448227648435975150E-1'                      4.94214826801497100753E-1'                      9.99999999999999996796E-1                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] P =                  {                      1.60119522476751861407E-4'                      1.19135147006586384913E-3'                      1.04213797561761569935E-2'                      4.76367800457137231464E-2'                      2.07448227648435975150E-1'                      4.94214826801497100753E-1'                      9.99999999999999996796E-1                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] P =                  {                      1.60119522476751861407E-4'                      1.19135147006586384913E-3'                      1.04213797561761569935E-2'                      4.76367800457137231464E-2'                      2.07448227648435975150E-1'                      4.94214826801497100753E-1'                      9.99999999999999996796E-1                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] P =                  {                      1.60119522476751861407E-4'                      1.19135147006586384913E-3'                      1.04213797561761569935E-2'                      4.76367800457137231464E-2'                      2.07448227648435975150E-1'                      4.94214826801497100753E-1'                      9.99999999999999996796E-1                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: z > 0.5
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: q > 33.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: x >= 3.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: x < 2.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: (x == 2.0) || (x == 3.0)
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: (x == 2.0) || (x == 3.0)
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: x -= 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: p = Polevl(x' P' 6);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: q = Polevl(x' Q' 7);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: nz > 0.5
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: nz != 0.5
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: y = y - 0.57721566490153286061;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: x <= 10.0 & x == System.Math.Floor(x)
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double[] STIR =                  {                      7.87311395793093628397E-4'                      -2.29549961613378126380E-4'                      -2.68132617805781232825E-3'                      3.47222221605458667310E-3'                      8.33333333333482257126E-2'                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double[] STIR =                  {                      7.87311395793093628397E-4'                      -2.29549961613378126380E-4'                      -2.68132617805781232825E-3'                      3.47222221605458667310E-3'                      8.33333333333482257126E-2'                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double[] STIR =                  {                      7.87311395793093628397E-4'                      -2.29549961613378126380E-4'                      -2.68132617805781232825E-3'                      3.47222221605458667310E-3'                      8.33333333333482257126E-2'                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double[] STIR =                  {                      7.87311395793093628397E-4'                      -2.29549961613378126380E-4'                      -2.68132617805781232825E-3'                      3.47222221605458667310E-3'                      8.33333333333482257126E-2'                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double[] STIR =                  {                      7.87311395793093628397E-4'                      -2.29549961613378126380E-4'                      -2.68132617805781232825E-3'                      3.47222221605458667310E-3'                      8.33333333333482257126E-2'                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double MAXSTIR = 143.01608;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: w = 1.0 + w*Polevl(w' STIR' 4);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double v = System.Math.Pow(x' 0.5*x - 0.25);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double v = System.Math.Pow(x' 0.5*x - 0.25);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Igamc,The following statement contains a magic number: double big = 4.503599627370496e15;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Igamc,The following statement contains a magic number: double biginv = 2.22044604925031308085e-16;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Igamc,The following statement contains a magic number: z += 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] A =                  {                      8.11614167470508450300E-4'                      -5.95061904284301438324E-4'                      7.93650340457716943945E-4'                      -2.77777777730099687205E-3'                      8.33333333333331927722E-2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] A =                  {                      8.11614167470508450300E-4'                      -5.95061904284301438324E-4'                      7.93650340457716943945E-4'                      -2.77777777730099687205E-3'                      8.33333333333331927722E-2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] A =                  {                      8.11614167470508450300E-4'                      -5.95061904284301438324E-4'                      7.93650340457716943945E-4'                      -2.77777777730099687205E-3'                      8.33333333333331927722E-2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] A =                  {                      8.11614167470508450300E-4'                      -5.95061904284301438324E-4'                      7.93650340457716943945E-4'                      -2.77777777730099687205E-3'                      8.33333333333331927722E-2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] A =                  {                      8.11614167470508450300E-4'                      -5.95061904284301438324E-4'                      7.93650340457716943945E-4'                      -2.77777777730099687205E-3'                      8.33333333333331927722E-2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] B =                  {                      -1.37825152569120859100E3'                      -3.88016315134637840924E4'                      -3.31612992738871184744E5'                      -1.16237097492762307383E6'                      -1.72173700820839662146E6'                      -8.53555664245765465627E5                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] B =                  {                      -1.37825152569120859100E3'                      -3.88016315134637840924E4'                      -3.31612992738871184744E5'                      -1.16237097492762307383E6'                      -1.72173700820839662146E6'                      -8.53555664245765465627E5                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] B =                  {                      -1.37825152569120859100E3'                      -3.88016315134637840924E4'                      -3.31612992738871184744E5'                      -1.16237097492762307383E6'                      -1.72173700820839662146E6'                      -8.53555664245765465627E5                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] B =                  {                      -1.37825152569120859100E3'                      -3.88016315134637840924E4'                      -3.31612992738871184744E5'                      -1.16237097492762307383E6'                      -1.72173700820839662146E6'                      -8.53555664245765465627E5                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] B =                  {                      -1.37825152569120859100E3'                      -3.88016315134637840924E4'                      -3.31612992738871184744E5'                      -1.16237097492762307383E6'                      -1.72173700820839662146E6'                      -8.53555664245765465627E5                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] B =                  {                      -1.37825152569120859100E3'                      -3.88016315134637840924E4'                      -3.31612992738871184744E5'                      -1.16237097492762307383E6'                      -1.72173700820839662146E6'                      -8.53555664245765465627E5                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] C =                  {                      -3.51815701436523470549E2'                      -1.70642106651881159223E4'                      -2.20528590553854454839E5'                      -1.13933444367982507207E6'                      -2.53252307177582951285E6'                      -2.01889141433532773231E6                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] C =                  {                      -3.51815701436523470549E2'                      -1.70642106651881159223E4'                      -2.20528590553854454839E5'                      -1.13933444367982507207E6'                      -2.53252307177582951285E6'                      -2.01889141433532773231E6                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] C =                  {                      -3.51815701436523470549E2'                      -1.70642106651881159223E4'                      -2.20528590553854454839E5'                      -1.13933444367982507207E6'                      -2.53252307177582951285E6'                      -2.01889141433532773231E6                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] C =                  {                      -3.51815701436523470549E2'                      -1.70642106651881159223E4'                      -2.20528590553854454839E5'                      -1.13933444367982507207E6'                      -2.53252307177582951285E6'                      -2.01889141433532773231E6                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] C =                  {                      -3.51815701436523470549E2'                      -1.70642106651881159223E4'                      -2.20528590553854454839E5'                      -1.13933444367982507207E6'                      -2.53252307177582951285E6'                      -2.01889141433532773231E6                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] C =                  {                      -3.51815701436523470549E2'                      -1.70642106651881159223E4'                      -2.20528590553854454839E5'                      -1.13933444367982507207E6'                      -2.53252307177582951285E6'                      -2.01889141433532773231E6                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: z > 0.5
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: x < -34.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: x >= 3.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: x < 2.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: x == 2.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: x -= 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: p = x*Polevl(x' B' 5)/P1evl(x' C' 6);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: p = x*Polevl(x' B' 5)/P1evl(x' C' 6);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: x < 13.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: x > 2.556348e305
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: q = (x - 0.5)*System.Math.Log(x) - x + 0.91893853320467274178;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: q = (x - 0.5)*System.Math.Log(x) - x + 0.91893853320467274178;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: x > 1.0e8
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: q += ((7.9365079365079365079365e-4*p                         - 2.7777777777777777777778e-3)*p                        + 0.0833333333333333333333)/x;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: q += ((7.9365079365079365079365e-4*p                         - 2.7777777777777777777778e-3)*p                        + 0.0833333333333333333333)/x;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: q += ((7.9365079365079365079365e-4*p                         - 2.7777777777777777777778e-3)*p                        + 0.0833333333333333333333)/x;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: x >= 1000.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Ibeta,The following statement contains a magic number: (bb*xx) <= 1.0 && xx <= 0.95
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Ibeta,The following statement contains a magic number: flag && (b*x) <= 1.0 && x <= 0.95
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Ibeta,The following statement contains a magic number: y = x*(a + b - 2.0) - (a - 1.0);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: double big = 4.503599627370496e15;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: double biginv = 2.22044604925031308085e-16;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: k8 = a + 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: thresh = 3.0*DoubleEpsilon;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: k3 += 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: k4 += 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: k7 += 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: k8 += 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: double big = 4.503599627370496e15;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: double biginv = 2.22044604925031308085e-16;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: k8 = a + 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: thresh = 3.0*DoubleEpsilon;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: k3 += 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: k4 += 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: k7 += 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: k8 += 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,PowerSeries,The following statement contains a magic number: n = 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,ChiSq,The following statement contains a magic number: return Igam(df/2.0' x/2.0);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,ChiSq,The following statement contains a magic number: return Igam(df/2.0' x/2.0);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,ChiSqc,The following statement contains a magic number: return Igamc(df/2.0' x/2.0);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,ChiSqc,The following statement contains a magic number: return Igamc(df/2.0' x/2.0);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Normal,The following statement contains a magic number: return 0.5*Erfc(-z);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double s2pi = System.Math.Sqrt(2.0*System.Math.PI);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P0 =                  {                      -59.963350101410789'                      98.001075418599967'                      -56.676285746907027'                      13.931260938727968'                      -1.2391658386738125                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P0 =                  {                      -59.963350101410789'                      98.001075418599967'                      -56.676285746907027'                      13.931260938727968'                      -1.2391658386738125                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P0 =                  {                      -59.963350101410789'                      98.001075418599967'                      -56.676285746907027'                      13.931260938727968'                      -1.2391658386738125                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P0 =                  {                      -59.963350101410789'                      98.001075418599967'                      -56.676285746907027'                      13.931260938727968'                      -1.2391658386738125                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P0 =                  {                      -59.963350101410789'                      98.001075418599967'                      -56.676285746907027'                      13.931260938727968'                      -1.2391658386738125                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: y > 0.8646647167633873
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: y -= 0.5;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: x = y + y*((y2*Polevl(y2' P0' 4))/P1evl(y2' Q0' 8));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: x = y + y*((y2*Polevl(y2' P0' 4))/P1evl(y2' Q0' 8));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: y > 0.1353352832366127
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: x = System.Math.Sqrt(-2.0*System.Math.Log(y));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: x1 = (z*Polevl(z' P1' 8))/P1evl(z' Q1' 8);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: x1 = (z*Polevl(z' P1' 8))/P1evl(z' Q1' 8);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: x < 8.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] R =                  {                      5.64189583547755073984E-1'                      1.27536670759978104416E0'                      5.01905042251180477414E0'                      6.16021097993053585195E0'                      7.40974269950448939160E0'                      2.97886665372100240670E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] R =                  {                      5.64189583547755073984E-1'                      1.27536670759978104416E0'                      5.01905042251180477414E0'                      6.16021097993053585195E0'                      7.40974269950448939160E0'                      2.97886665372100240670E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] R =                  {                      5.64189583547755073984E-1'                      1.27536670759978104416E0'                      5.01905042251180477414E0'                      6.16021097993053585195E0'                      7.40974269950448939160E0'                      2.97886665372100240670E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] R =                  {                      5.64189583547755073984E-1'                      1.27536670759978104416E0'                      5.01905042251180477414E0'                      6.16021097993053585195E0'                      7.40974269950448939160E0'                      2.97886665372100240670E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] R =                  {                      5.64189583547755073984E-1'                      1.27536670759978104416E0'                      5.01905042251180477414E0'                      6.16021097993053585195E0'                      7.40974269950448939160E0'                      2.97886665372100240670E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] R =                  {                      5.64189583547755073984E-1'                      1.27536670759978104416E0'                      5.01905042251180477414E0'                      6.16021097993053585195E0'                      7.40974269950448939160E0'                      2.97886665372100240670E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] S =                  {                      2.26052863220117276590E0'                      9.39603524938001434673E0'                      1.20489539808096656605E1'                      1.70814450747565897222E1'                      9.60896809063285878198E0'                      3.36907645100081516050E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] S =                  {                      2.26052863220117276590E0'                      9.39603524938001434673E0'                      1.20489539808096656605E1'                      1.70814450747565897222E1'                      9.60896809063285878198E0'                      3.36907645100081516050E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] S =                  {                      2.26052863220117276590E0'                      9.39603524938001434673E0'                      1.20489539808096656605E1'                      1.70814450747565897222E1'                      9.60896809063285878198E0'                      3.36907645100081516050E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] S =                  {                      2.26052863220117276590E0'                      9.39603524938001434673E0'                      1.20489539808096656605E1'                      1.70814450747565897222E1'                      9.60896809063285878198E0'                      3.36907645100081516050E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] S =                  {                      2.26052863220117276590E0'                      9.39603524938001434673E0'                      1.20489539808096656605E1'                      1.70814450747565897222E1'                      9.60896809063285878198E0'                      3.36907645100081516050E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] S =                  {                      2.26052863220117276590E0'                      9.39603524938001434673E0'                      1.20489539808096656605E1'                      1.70814450747565897222E1'                      9.60896809063285878198E0'                      3.36907645100081516050E0                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: return (2.0);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: p = Polevl(x' P' 8);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: q = P1evl(x' Q' 8);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: x < 8.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: y = 2.0 - y;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: return 2.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] T =                  {                      9.60497373987051638749E0'                      9.00260197203842689217E1'                      2.23200534594684319226E3'                      7.00332514112805075473E3'                      5.55923013010394962768E4                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] T =                  {                      9.60497373987051638749E0'                      9.00260197203842689217E1'                      2.23200534594684319226E3'                      7.00332514112805075473E3'                      5.55923013010394962768E4                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] T =                  {                      9.60497373987051638749E0'                      9.00260197203842689217E1'                      2.23200534594684319226E3'                      7.00332514112805075473E3'                      5.55923013010394962768E4                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] T =                  {                      9.60497373987051638749E0'                      9.00260197203842689217E1'                      2.23200534594684319226E3'                      7.00332514112805075473E3'                      5.55923013010394962768E4                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] T =                  {                      9.60497373987051638749E0'                      9.00260197203842689217E1'                      2.23200534594684319226E3'                      7.00332514112805075473E3'                      5.55923013010394962768E4                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] U =                  {                      3.35617141647503099647E1'                      5.21357949780152679795E2'                      4.59432382970980127987E3'                      2.26290000613890934246E4'                      4.92673942608635921086E4                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] U =                  {                      3.35617141647503099647E1'                      5.21357949780152679795E2'                      4.59432382970980127987E3'                      2.26290000613890934246E4'                      4.92673942608635921086E4                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] U =                  {                      3.35617141647503099647E1'                      5.21357949780152679795E2'                      4.59432382970980127987E3'                      2.26290000613890934246E4'                      4.92673942608635921086E4                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] U =                  {                      3.35617141647503099647E1'                      5.21357949780152679795E2'                      4.59432382970980127987E3'                      2.26290000613890934246E4'                      4.92673942608635921086E4                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] U =                  {                      3.35617141647503099647E1'                      5.21357949780152679795E2'                      4.59432382970980127987E3'                      2.26290000613890934246E4'                      4.92673942608635921086E4                  };
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: y = x*Polevl(z' T' 4)/P1evl(z' U' 5);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: y = x*Polevl(z' T' 4)/P1evl(z' U' 5);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BSpline,The following statement contains a magic number: c = Binomial(n + 1' k)*Tools.TruncatedPower(x + (n + 1.0)/2.0 - k' n);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Binomial,The following statement contains a magic number: return System.Math.Floor(0.5 + System.Math.Exp(Lfactorial(n) - Lfactorial(k) - Lfactorial(n - k)));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lfactorial,The following statement contains a magic number: lnfcache = new double[101];
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lfactorial,The following statement contains a magic number: n <= 100
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: fcache = new double[33];
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: fcache[2] = 2;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: fcache[2] = 2;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: fcache[3] = 6;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: fcache[3] = 6;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: fcache[4] = 24;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: fcache[4] = 24;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: ftop = 4;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: n > 32
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: (ax = System.Math.Abs(x)) < 8.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: (ax = System.Math.Abs(x)) < 8.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: double ACC = 40.0;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: double BIGNO = 1.0e+10;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: double BIGNI = 1.0e-10;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: return x < 0.0 && n%2 == 1 ? -ans : ans;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: x < 8.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: x < 8.0
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: tox = 2.0/x;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Log1p,The following statement contains a magic number: System.Math.Abs(x) > 1e-4
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Log1p,The following statement contains a magic number: return (-0.5*x + 1.0)*x;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Expm1,The following statement contains a magic number: return x + 0.5*x*x;
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Expm1,The following statement contains a magic number: System.Math.Abs(x) < 1e-5
Magic Number,Accord.Math,Special,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Epslon,The following statement contains a magic number: a = 1.3333333333333333;
Magic Number,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,NextPowerOf2,The following statement contains a magic number: x |= x >> 2;
Magic Number,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,NextPowerOf2,The following statement contains a magic number: x |= x >> 4;
Magic Number,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,NextPowerOf2,The following statement contains a magic number: x |= x >> 8;
Magic Number,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,NextPowerOf2,The following statement contains a magic number: x |= x >> 16;
Magic Number,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,PreviousPowerOf2,The following statement contains a magic number: return NextPowerOf2(x + 1)/2;
Magic Number,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Atanh,The following statement contains a magic number: return 0.5*System.Math.Log((1.0 + d)/(1.0 - d));
Magic Number,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,InvSqrt,The following statement contains a magic number: float xhalf = 0.5f*f;
Magic Number,Accord.Math,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,InvSqrt,The following statement contains a magic number: f = f*(1.5f - xhalf*f*f);
Magic Number,Accord.Math.Formats,MatrixFormatter,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Formats\Base\MatrixFormatter.cs,Format,The following statement contains a magic number: matrix.Rank > 2
Magic Number,Accord.Math.Formats,MatrixFormatter,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Formats\Base\MatrixFormatter.cs,Format,The following statement contains a magic number: int cols = (matrix.Rank == 2) ? matrix.GetLength(1) : 0;
Magic Number,Accord.Math.Formats,MatrixFormatter,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Formats\Base\MatrixFormatter.cs,parseOptions,The following statement contains a magic number: options.Length == 2
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: return (data[N/2] + data[(N/2) - 1])*0.5;
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: return (data[N/2] + data[(N/2) - 1])*0.5;
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: return (data[N/2] + data[(N/2) - 1])*0.5;
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: N%2 == 0
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Skewness,The following statement contains a magic number: sum += System.Math.Pow(values[i] - mean' 3);
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Skewness,The following statement contains a magic number: return sum/(n*System.Math.Pow(standardDeviation' 3));
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Kurtosis,The following statement contains a magic number: sum += System.Math.Pow(deviation' 4);
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Kurtosis,The following statement contains a magic number: return sum/(n*System.Math.Pow(standardDeviation' 4)) - 3.0;
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Kurtosis,The following statement contains a magic number: return sum/(n*System.Math.Pow(standardDeviation' 4)) - 3.0;
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: medians[i] = (data[N/2] + data[(N/2) - 1])*0.5;
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: medians[i] = (data[N/2] + data[(N/2) - 1])*0.5;
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: medians[i] = (data[N/2] + data[(N/2) - 1])*0.5;
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: N%2 == 0
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: medians[i] = (data[N/2] + data[(N/2) - 1])*0.5;
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: medians[i] = (data[N/2] + data[(N/2) - 1])*0.5;
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: medians[i] = (data[N/2] + data[(N/2) - 1])*0.5;
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: N%2 == 0
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Skewness,The following statement contains a magic number: sum += System.Math.Pow(matrix[i' j] - means[j]' 3);
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Skewness,The following statement contains a magic number: skewness[j] = sum/((n - 1)*System.Math.Pow(standardDeviations[j]' 3));
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Kurtosis,The following statement contains a magic number: sum += System.Math.Pow(matrix[i' j] - means[j]' 4);
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Kurtosis,The following statement contains a magic number: kurtosis[j] = sum/(n*System.Math.Pow(standardDeviations[j]' 4)) - 3.0;
Magic Number,Accord.Statistics,Tools,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Kurtosis,The following statement contains a magic number: kurtosis[j] = sum/(n*System.Math.Pow(standardDeviations[j]' 4)) - 3.0;
Magic Number,HiddenMarkovModel.Utils,MotionCalculator,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Utils\MotionCalculator.cs,CalculateMotion,The following statement contains a magic number: double x = Math.Atan2(end.Y - start.Y' end.X - start.X)*180/Math.PI;
Magic Number,HiddenMarkovModel.Utils,MotionCalculator,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Utils\MotionCalculator.cs,CalculateMotion,The following statement contains a magic number: x += 360;
Missing Default,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following switch statement is missing a default case: switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }
Missing Default,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following switch statement is missing a default case: switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }
Missing Default,Accord.Math.Decompositions,SingularValueDecomposition,D:\research\architectureSmells\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following switch statement is missing a default case: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
