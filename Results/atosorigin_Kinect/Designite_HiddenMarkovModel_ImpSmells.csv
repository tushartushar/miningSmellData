Implementation smell,Namespace,Class,File,Method,Description
Long Method,Accord.Statistics.Models.Markov.Learning,BaumWelchLearningBase,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Learning\Base\BaumWelchLearningBase.cs,Run,The method has 124 lines of code.
Long Method,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tred2,The method has 104 lines of code.
Long Method,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tql2,The method has 109 lines of code.
Long Method,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The method has 400 lines of code.
Long Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,The method has 128 lines of code.
Long Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The method has 315 lines of code.
Long Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzval,The method has 246 lines of code.
Long Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The method has 228 lines of code.
Long Method,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,init,The method has 149 lines of code.
Long Method,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The method has 569 lines of code.
Long Method,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The method has 104 lines of code.
Complex Method,Accord.Statistics.Models.Markov,ContinuousHiddenMarkovModel,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\ContinuousHiddenMarkovModel.cs,Decode,Cyclomatic complexity of the method is 12
Complex Method,Accord.Statistics.Models.Markov,ForwardBackwardAlgorithm,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\ForwardBackwardAlgorithm.cs,Forward,Cyclomatic complexity of the method is 9
Complex Method,Accord.Statistics.Models.Markov,ForwardBackwardAlgorithm,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\ForwardBackwardAlgorithm.cs,Forward,Cyclomatic complexity of the method is 9
Complex Method,Accord.Statistics.Models.Markov,HiddenMarkovModel,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\HiddenMarkovModel.cs,Decode,Cyclomatic complexity of the method is 11
Complex Method,Accord.Statistics.Models.Markov,HiddenMarkovModel,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\HiddenMarkovModel.cs,Predict,Cyclomatic complexity of the method is 11
Complex Method,AForge.Math,FourierTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\FourierTransform.cs,DFT2,Cyclomatic complexity of the method is 11
Complex Method,AForge.Math,FourierTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\FourierTransform.cs,FFT2,Cyclomatic complexity of the method is 8
Complex Method,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,Cyclomatic complexity of the method is 32
Complex Method,Accord.Math.Decompositions,CholeskyDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\CholeskyDecomposition.cs,Solve,Cyclomatic complexity of the method is 14
Complex Method,Accord.Math.Decompositions,CholeskyDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\CholeskyDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math.Decompositions,CholeskyDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\CholeskyDecomposition.cs,Inverse,Cyclomatic complexity of the method is 12
Complex Method,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tred2,Cyclomatic complexity of the method is 14
Complex Method,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tql2,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,orthes,Cyclomatic complexity of the method is 20
Complex Method,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,Cyclomatic complexity of the method is 21
Complex Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,Cyclomatic complexity of the method is 27
Complex Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,Cyclomatic complexity of the method is 48
Complex Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzval,Cyclomatic complexity of the method is 24
Complex Method,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,Cyclomatic complexity of the method is 32
Complex Method,Accord.Math.Decompositions,LuDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\LuDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math.Decompositions,LuDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\LuDecomposition.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,Accord.Math.Decompositions,LuDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\LuDecomposition.cs,Inverse,Cyclomatic complexity of the method is 10
Complex Method,Accord.Math.Decompositions,LuDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\LuDecomposition.cs,SolveTranspose,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,init,Cyclomatic complexity of the method is 24
Complex Method,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,nnmf,Cyclomatic complexity of the method is 18
Complex Method,Accord.Math.Decompositions,QrDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\QrDecomposition.cs,QrDecomposition,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math.Decompositions,QrDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\QrDecomposition.cs,Solve,Cyclomatic complexity of the method is 14
Complex Method,Accord.Math.Decompositions,QrDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\QrDecomposition.cs,Solve,Cyclomatic complexity of the method is 9
Complex Method,Accord.Math.Decompositions,QrDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\QrDecomposition.cs,SolveTranspose,Cyclomatic complexity of the method is 14
Complex Method,Accord.Math.Decompositions,QrDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\QrDecomposition.cs,Inverse,Cyclomatic complexity of the method is 12
Complex Method,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,Cyclomatic complexity of the method is 40
Complex Method,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,TransposeAndMultiply,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,IsEqual,Cyclomatic complexity of the method is 11
Complex Method,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,IsEqual,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,Cyclomatic complexity of the method is 12
Complex Method,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,Cyclomatic complexity of the method is 8
Complex Method,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,Cyclomatic complexity of the method is 14
Complex Method,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Ibeta,Cyclomatic complexity of the method is 17
Complex Method,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,Cyclomatic complexity of the method is 9
Complex Method,Accord.Math.Formats,MatrixFormatter,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Formats\Base\MatrixFormatter.cs,Format,Cyclomatic complexity of the method is 9
Long Parameter List,Accord.Statistics.Models.Markov,HiddenMarkovModel,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\HiddenMarkovModel.cs,Predict,The method has 5 parameters. Parameters: observations' next' logarithm' probability' probabilities
Long Parameter List,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,cdiv,The method has 6 parameters. Parameters: xr' xi' yr' yi' cdivr' cdivi
Long Parameter List,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,The method has 5 parameters. Parameters: n' a' b' matz' z
Long Parameter List,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The method has 7 parameters. Parameters: n' a' b' eps1' matz' z' ierr
Long Parameter List,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzval,The method has 8 parameters. Parameters: n' a' b' alfr' alfi' beta' matz' z
Long Parameter List,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The method has 7 parameters. Parameters: n' a' b' alfr' alfi' beta' z
Long Parameter List,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The method has 7 parameters. Parameters: value' k' algorithm' attempts' maxIterations' errorTolerance' changeTolerance
Long Parameter List,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The method has 8 parameters. Parameters: value' h0' w0' algorithm' attempts' maxIterations' errorTolerance' changeTolerance
Long Parameter List,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,init,The method has 9 parameters. Parameters: value' k' algorithm' h0' w0' attempts' maxIterations' errorTolerance' changeTolerance
Long Parameter List,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,nnmf,The method has 7 parameters. Parameters: value' w0' h0' alg' maxIterations' normChangeThreshold' maxFactorChangeThreshold
Long Parameter List,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The method has 5 parameters. Parameters: value' computeLeftSingularVectors' computeRightSingularVectors' autoTranspose' inPlace
Long Parameter List,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The method has 5 parameters. Parameters: data' startRow' endRow' startColumn' endColumn
Long Parameter List,Accord.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Scale,The method has 5 parameters. Parameters: fromMin' fromMax' toMin' toMax' x
Long Parameter List,Accord.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Scale,The method has 5 parameters. Parameters: fromMin' fromMax' toMin' toMax' x
Long Parameter List,Accord.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Scale,The method has 5 parameters. Parameters: fromMin' fromMax' toMin' toMax' x
Long Parameter List,Accord.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Scale,The method has 5 parameters. Parameters: fromMin' fromMax' toMin' toMax' x
Long Parameter List,Accord.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Scale,The method has 5 parameters. Parameters: fromMin' fromMax' toMin' toMax' x
Long Parameter List,Accord.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Scale,The method has 5 parameters. Parameters: fromMin' fromMax' toMin' toMax' x
Long Parameter List,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Scatter,The method has 5 parameters. Parameters: matrix' means' divisor' dimension' weights
Long Statement,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,init,The length of the statement  "                    "The approximation rank k should be a positive integer equal or less than the number of columns of the matrix to be decomposed."' " is 129.
Long Statement,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,init,The length of the statement  "                        "The initial coefficient matrix should have the same number of columns as the value matrix and the same number of rows as the desired rank approximation."' " is 155.
Long Statement,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,init,The length of the statement  "                        "The initial weight matrix should have the same number of rows as the value matrix and the same number of columns as the desired rank approximation."' " is 150.
Complex Conditional,AForge.Math,FourierTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\FourierTransform.cs,FFT2,The conditional expression  "(!Tools.IsPowerOf2(k)) ||                  (!Tools.IsPowerOf2(n)) ||                  (k < minLength) || (k > maxLength) ||                  (n < minLength) || (n > maxLength)"  is complex.
Complex Conditional,Accord.Math.Decompositions,LuDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\LuDecomposition.cs,LuDecomposition,The conditional expression  "(!transpose && value.GetLength(0) < value.GetLength(1)) ||                  (transpose && value.GetLength(1) < value.GetLength(0))"  is complex.
Complex Conditional,Accord.Math.Decompositions,QrDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\QrDecomposition.cs,QrDecomposition,The conditional expression  "(!transpose && value.GetLength(0) < value.GetLength(1)) ||                  (transpose && value.GetLength(1) < value.GetLength(0))"  is complex.
Complex Conditional,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The conditional expression  "(startRow > endRow) || (startColumn > endColumn) || (startRow < 0) ||                  (startRow >= rows) || (endRow < 0) || (endRow >= rows) ||                  (startColumn < 0) || (startColumn >= cols) || (endColumn < 0) ||                  (endColumn >= cols)"  is complex.
Complex Conditional,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The conditional expression  "(rowIndexes[i] < 0) || (rowIndexes[i] >= data.GetLength(0)) ||                          (columnIndexes[j] < 0) || (columnIndexes[j] >= data.GetLength(1))"  is complex.
Complex Conditional,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The conditional expression  "(i0 > i1) || (i0 < 0) || (i0 >= data.GetLength(0))                  || (i1 < 0) || (i1 >= data.GetLength(0))"  is complex.
Complex Conditional,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The conditional expression  "(j0 > j1) || (j0 < 0) || (j0 >= data.GetLength(1)) || (j1 < 0)                  || (j1 >= data.GetLength(1))"  is complex.
Complex Conditional,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The conditional expression  "(j0 > j1) || (j0 < 0) || (j0 >= data[0].Length) ||                  (j1 < 0) || (j1 >= data[0].Length)"  is complex.
Complex Conditional,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Submatrix,The conditional expression  "(i0 > i1) || (i0 < 0) || (i0 >= data.Length)                  || (i1 < 0) || (i1 >= data.Length)"  is complex.
Magic Number,Accord.Statistics.Models.Markov,ContinuousHiddenMarkovModel,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\ContinuousHiddenMarkovModel.cs,Decode,The following statement contains a magic number: for (int t = T - 2; t >= 0; t--)                  path[t] = s[path[t + 1]' t + 1];
Magic Number,Accord.Statistics.Models.Markov,ForwardBackwardAlgorithm,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\ForwardBackwardAlgorithm.cs,Backward,The following statement contains a magic number: for (int t = T - 2; t >= 0; t--)              {                  for (int i = 0; i < states; i++)                  {                      double sum = 0;                      for (int j = 0; j < states; j++)                          sum += A[i' j]*B[j' observations[t + 1]]*bwd[t + 1' j];                      bwd[t' i] += sum/scaling[t];                  }              }
Magic Number,Accord.Statistics.Models.Markov,ForwardBackwardAlgorithm,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\ForwardBackwardAlgorithm.cs,Backward,The following statement contains a magic number: for (int t = T - 2; t >= 0; t--)              {                  for (int i = 0; i < states; i++)                  {                      double sum = 0;                      for (int j = 0; j < states; j++)                          sum += A[i' j]*B[j].ProbabilityFunction(observations[t + 1])*bwd[t + 1' j];                      bwd[t' i] += sum/scaling[t];                  }              }
Magic Number,Accord.Statistics.Models.Markov,HiddenMarkovModel,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\HiddenMarkovModel.cs,Decode,The following statement contains a magic number: for (int t = T - 2; t >= 0; t--)                  path[t] = s[path[t + 1]' t + 1];
Magic Number,Accord.Statistics.Distributions.Multivariate,NormalDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Multivariate\NormalDistribution.cs,NormalDistribution,The following statement contains a magic number: constant = 1.0/(System.Math.Pow(2.0*System.Math.PI' k/2.0)*detSqrt);
Magic Number,Accord.Statistics.Distributions.Multivariate,NormalDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Multivariate\NormalDistribution.cs,NormalDistribution,The following statement contains a magic number: constant = 1.0/(System.Math.Pow(2.0*System.Math.PI' k/2.0)*detSqrt);
Magic Number,Accord.Statistics.Distributions.Multivariate,NormalDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Multivariate\NormalDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double r = constant*System.Math.Exp(-0.5*b);
Magic Number,Accord.Statistics.Distributions.Univariate,ChiSquareDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\ChiSquareDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double m1 = System.Math.Pow(x' (v - 2.0)/2.0);
Magic Number,Accord.Statistics.Distributions.Univariate,ChiSquareDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\ChiSquareDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double m1 = System.Math.Pow(x' (v - 2.0)/2.0);
Magic Number,Accord.Statistics.Distributions.Univariate,ChiSquareDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\ChiSquareDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double m2 = System.Math.Exp(-x/2.0);
Magic Number,Accord.Statistics.Distributions.Univariate,ChiSquareDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\ChiSquareDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double m3 = System.Math.Pow(2' v/2.0)*Special.Gamma(v/2.0);
Magic Number,Accord.Statistics.Distributions.Univariate,ChiSquareDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\ChiSquareDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double m3 = System.Math.Pow(2' v/2.0)*Special.Gamma(v/2.0);
Magic Number,Accord.Statistics.Distributions.Univariate,ChiSquareDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\ChiSquareDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: double m3 = System.Math.Pow(2' v/2.0)*Special.Gamma(v/2.0);
Magic Number,Accord.Statistics.Distributions.Univariate,FDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\FDistribution.cs,FDistribution,The following statement contains a magic number: b = Special.Beta(degrees1*0.5' degrees2*0.5);
Magic Number,Accord.Statistics.Distributions.Univariate,FDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\FDistribution.cs,FDistribution,The following statement contains a magic number: b = Special.Beta(degrees1*0.5' degrees2*0.5);
Magic Number,Accord.Statistics.Distributions.Univariate,FDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\FDistribution.cs,DistributionFunction,The following statement contains a magic number: return Special.Ibeta(d1*0.5' d2*0.5' u);
Magic Number,Accord.Statistics.Distributions.Univariate,FDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\FDistribution.cs,DistributionFunction,The following statement contains a magic number: return Special.Ibeta(d1*0.5' d2*0.5' u);
Magic Number,Accord.Statistics.Distributions.Univariate,NormalDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\NormalDistribution.cs,NormalDistribution,The following statement contains a magic number: double b = 2.0*System.Math.PI*variance;
Magic Number,Accord.Statistics.Distributions.Univariate,NormalDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\NormalDistribution.cs,DistributionFunction,The following statement contains a magic number: return Special.Erfc(-z/Special.Sqrt2)/2.0;
Magic Number,Accord.Statistics.Distributions.Univariate,NormalDistribution,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Distributions\Univariate\NormalDistribution.cs,ProbabilityDensityFunction,The following statement contains a magic number: return ((1.0/(Special.SqrtPI*variance))*System.Math.Exp((-z*z)/2.0));
Magic Number,Accord.Statistics.Models.Markov.Learning,BaumWelchLearning,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Learning\BaumWelchLearning.cs,UpdateEmissions,The following statement contains a magic number: for (int i = 0; i < states; i++)              {                  for (int j = 0; j < symbols; j++)                  {                      double sum = 0' num = 0;                        for (int k = 0; k < discreteObservations.Length; k++)                      {                          int T = discreteObservations[k].Length;                          double['] gammak = Gamma[k];                            for (int l = 0; l < T; l++)                          {                              if (discreteObservations[k][l] == j)                                  num += gammak[l' i];                                sum += gammak[l' i];                          }                      }                        // avoid locking a parameter in zero.                      if (num == 0) num = 1e-10;                        B[i' j] = (sum != 0) ? num/sum : num;                  }              }
Magic Number,AForge.Math,Complex,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Complex.cs,ApproxEqual,The following statement contains a magic number: return ApproxEqual(a' b' 8.8817841970012523233891E-16);
Magic Number,AForge.Math,Complex,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Complex.cs,Sqrt,The following statement contains a magic number: if ((a.Re == 0.0) && (a.Im == 0.0))              {                  return result;              }              else if (a.Im == 0.0)              {                  result.Re = (a.Re > 0) ? System.Math.Sqrt(a.Re) : System.Math.Sqrt(-a.Re);                  result.Im = 0.0;              }              else              {                  double modulus = a.Magnitude;                    result.Re = System.Math.Sqrt(0.5*(modulus + a.Re));                  result.Im = System.Math.Sqrt(0.5*(modulus - a.Re));                  if (a.Im < 0.0)                      result.Im = -result.Im;              }
Magic Number,AForge.Math,Complex,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Complex.cs,Sqrt,The following statement contains a magic number: if ((a.Re == 0.0) && (a.Im == 0.0))              {                  return result;              }              else if (a.Im == 0.0)              {                  result.Re = (a.Re > 0) ? System.Math.Sqrt(a.Re) : System.Math.Sqrt(-a.Re);                  result.Im = 0.0;              }              else              {                  double modulus = a.Magnitude;                    result.Re = System.Math.Sqrt(0.5*(modulus + a.Re));                  result.Im = System.Math.Sqrt(0.5*(modulus - a.Re));                  if (a.Im < 0.0)                      result.Im = -result.Im;              }
Magic Number,AForge.Math,Complex,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Complex.cs,Log,The following statement contains a magic number: if ((a.Re > 0.0) && (a.Im == 0.0))              {                  result.Re = System.Math.Log(a.Re);                  result.Im = 0.0;              }              else if (a.Re == 0.0)              {                  if (a.Im > 0.0)                  {                      result.Re = System.Math.Log(a.Im);                      result.Im = System.Math.PI/2.0;                  }                  else                  {                      result.Re = System.Math.Log(-(a.Im));                      result.Im = -System.Math.PI/2.0;                  }              }              else              {                  result.Re = System.Math.Log(a.Magnitude);                  result.Im = System.Math.Atan2(a.Im' a.Re);              }
Magic Number,AForge.Math,Complex,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Complex.cs,Log,The following statement contains a magic number: if ((a.Re > 0.0) && (a.Im == 0.0))              {                  result.Re = System.Math.Log(a.Re);                  result.Im = 0.0;              }              else if (a.Re == 0.0)              {                  if (a.Im > 0.0)                  {                      result.Re = System.Math.Log(a.Im);                      result.Im = System.Math.PI/2.0;                  }                  else                  {                      result.Re = System.Math.Log(-(a.Im));                      result.Im = -System.Math.PI/2.0;                  }              }              else              {                  result.Re = System.Math.Log(a.Magnitude);                  result.Im = System.Math.Atan2(a.Im' a.Re);              }
Magic Number,AForge.Math,Complex,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Complex.cs,Tan,The following statement contains a magic number: if (a.Im == 0.0)              {                  result.Re = System.Math.Tan(a.Re);                  result.Im = 0.0;              }              else              {                  double real2 = 2*a.Re;                  double imag2 = 2*a.Im;                  double denom = System.Math.Cos(real2) + System.Math.Cosh(real2);                    result.Re = System.Math.Sin(real2)/denom;                  result.Im = System.Math.Sinh(imag2)/denom;              }
Magic Number,AForge.Math,Complex,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Complex.cs,Tan,The following statement contains a magic number: if (a.Im == 0.0)              {                  result.Re = System.Math.Tan(a.Re);                  result.Im = 0.0;              }              else              {                  double real2 = 2*a.Re;                  double imag2 = 2*a.Im;                  double denom = System.Math.Cos(real2) + System.Math.Cosh(real2);                    result.Re = System.Math.Sin(real2)/denom;                  result.Im = System.Math.Sinh(imag2)/denom;              }
Magic Number,AForge.Math,FourierTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\FourierTransform.cs,DFT,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  dst[i] = Complex.Zero;                    arg = -(int) direction*2.0*System.Math.PI*i/n;                    // sum source elements                  for (int j = 0; j < n; j++)                  {                      cos = System.Math.Cos(j*arg);                      sin = System.Math.Sin(j*arg);                        dst[i].Re += (data[j].Re*cos - data[j].Im*sin);                      dst[i].Im += (data[j].Re*sin + data[j].Im*cos);                  }              }
Magic Number,AForge.Math,FourierTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\FourierTransform.cs,DFT2,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  for (int j = 0; j < m; j++)                  {                      dst[j] = Complex.Zero;                        arg = -(int) direction*2.0*System.Math.PI*j/m;                        // sum source elements                      for (int k = 0; k < m; k++)                      {                          cos = System.Math.Cos(k*arg);                          sin = System.Math.Sin(k*arg);                            dst[j].Re += (data[i' k].Re*cos - data[i' k].Im*sin);                          dst[j].Im += (data[i' k].Re*sin + data[i' k].Im*cos);                      }                  }                    // copy elements                  if (direction == Direction.Forward)                  {                      // devide also for forward transform                      for (int j = 0; j < m; j++)                      {                          data[i' j].Re = dst[j].Re/m;                          data[i' j].Im = dst[j].Im/m;                      }                  }                  else                  {                      for (int j = 0; j < m; j++)                      {                          data[i' j].Re = dst[j].Re;                          data[i' j].Im = dst[j].Im;                      }                  }              }
Magic Number,AForge.Math,FourierTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\FourierTransform.cs,DFT2,The following statement contains a magic number: for (int j = 0; j < m; j++)              {                  for (int i = 0; i < n; i++)                  {                      dst[i] = Complex.Zero;                        arg = -(int) direction*2.0*System.Math.PI*i/n;                        // sum source elements                      for (int k = 0; k < n; k++)                      {                          cos = System.Math.Cos(k*arg);                          sin = System.Math.Sin(k*arg);                            dst[i].Re += (data[k' j].Re*cos - data[k' j].Im*sin);                          dst[i].Im += (data[k' j].Re*sin + data[k' j].Im*cos);                      }                  }                    // copy elements                  if (direction == Direction.Forward)                  {                      // devide also for forward transform                      for (int i = 0; i < n; i++)                      {                          data[i' j].Re = dst[i].Re/n;                          data[i' j].Im = dst[i].Im/n;                      }                  }                  else                  {                      for (int i = 0; i < n; i++)                      {                          data[i' j].Re = dst[i].Re;                          data[i' j].Im = dst[i].Im;                      }                  }              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Pow2,The following statement contains a magic number: return ((power >= 0) && (power <= 30)) ? (1 << power) : 0;
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 65536)              {                  if (x <= 256)                  {                      if (x <= 16)                      {                          if (x <= 4)                          {                              if (x <= 2)                              {                                  if (x <= 1)                                      return 0;                                  return 1;                              }                              return 2;                          }                          if (x <= 8)                              return 3;                          return 4;                      }                      if (x <= 64)                      {                          if (x <= 32)                              return 5;                          return 6;                      }                      if (x <= 128)                          return 7;                      return 8;                  }                  if (x <= 4096)                  {                      if (x <= 1024)                      {                          if (x <= 512)                              return 9;                          return 10;                      }                      if (x <= 2048)                          return 11;                      return 12;                  }                  if (x <= 16384)                  {                      if (x <= 8192)                          return 13;                      return 14;                  }                  if (x <= 32768)                      return 15;                  return 16;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 16777216)              {                  if (x <= 1048576)                  {                      if (x <= 262144)                      {                          if (x <= 131072)                              return 17;                          return 18;                      }                      if (x <= 524288)                          return 19;                      return 20;                  }                  if (x <= 4194304)                  {                      if (x <= 2097152)                          return 21;                      return 22;                  }                  if (x <= 8388608)                      return 23;                  return 24;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 268435456)              {                  if (x <= 67108864)                  {                      if (x <= 33554432)                          return 25;                      return 26;                  }                  if (x <= 134217728)                      return 27;                  return 28;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 268435456)              {                  if (x <= 67108864)                  {                      if (x <= 33554432)                          return 25;                      return 26;                  }                  if (x <= 134217728)                      return 27;                  return 28;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 268435456)              {                  if (x <= 67108864)                  {                      if (x <= 33554432)                          return 25;                      return 26;                  }                  if (x <= 134217728)                      return 27;                  return 28;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 268435456)              {                  if (x <= 67108864)                  {                      if (x <= 33554432)                          return 25;                      return 26;                  }                  if (x <= 134217728)                      return 27;                  return 28;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 268435456)              {                  if (x <= 67108864)                  {                      if (x <= 33554432)                          return 25;                      return 26;                  }                  if (x <= 134217728)                      return 27;                  return 28;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 268435456)              {                  if (x <= 67108864)                  {                      if (x <= 33554432)                          return 25;                      return 26;                  }                  if (x <= 134217728)                      return 27;                  return 28;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 268435456)              {                  if (x <= 67108864)                  {                      if (x <= 33554432)                          return 25;                      return 26;                  }                  if (x <= 134217728)                      return 27;                  return 28;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 268435456)              {                  if (x <= 67108864)                  {                      if (x <= 33554432)                          return 25;                      return 26;                  }                  if (x <= 134217728)                      return 27;                  return 28;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 1073741824)              {                  if (x <= 536870912)                      return 29;                  return 30;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 1073741824)              {                  if (x <= 536870912)                      return 29;                  return 30;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 1073741824)              {                  if (x <= 536870912)                      return 29;                  return 30;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: if (x <= 1073741824)              {                  if (x <= 536870912)                      return 29;                  return 30;              }
Magic Number,AForge.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Tools.cs,Log2,The following statement contains a magic number: return 31;
Magic Number,AForge.Math.Random,StandardGenerator,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Random\StandardGenerator.cs,Next,The following statement contains a magic number: do              {                  x1 = rand.Next()*2.0 - 1.0;                  x2 = rand.Next()*2.0 - 1.0;                  w = x1*x1 + x2*x2;              } while (w >= 1.0);
Magic Number,AForge.Math.Random,StandardGenerator,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Random\StandardGenerator.cs,Next,The following statement contains a magic number: do              {                  x1 = rand.Next()*2.0 - 1.0;                  x2 = rand.Next()*2.0 - 1.0;                  w = x1*x1 + x2*x2;              } while (w >= 1.0);
Magic Number,AForge.Math.Random,StandardGenerator,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\AForge\Math\Random\StandardGenerator.cs,Next,The following statement contains a magic number: w = System.Math.Sqrt((-2.0*System.Math.Log(w))/w);
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tql2,The following statement contains a magic number: double eps = System.Math.Pow(2.0' -52.0);
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tql2,The following statement contains a magic number: double eps = System.Math.Pow(2.0' -52.0);
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tql2,The following statement contains a magic number: for (int l = 0; l < n; l++)              {                  // Find small subdiagonal element.                  tst1 = System.Math.Max(tst1' System.Math.Abs(d[l]) + System.Math.Abs(e[l]));                  int m = l;                  while (m < n)                  {                      if (System.Math.Abs(e[m]) <= eps*tst1)                          break;                      m++;                  }                    // If m == l' d[l] is an eigenvalue' otherwise' iterate.                  if (m > l)                  {                      int iter = 0;                      do                      {                          iter = iter + 1; // (Could check iteration count here.)                            // Compute implicit shift                          double g = d[l];                          double p = (d[l + 1] - g)/(2.0*e[l]);                          double r = Tools.Hypotenuse(p' 1.0);                          if (p < 0)                          {                              r = -r;                          }                            d[l] = e[l]/(p + r);                          d[l + 1] = e[l]*(p + r);                          double dl1 = d[l + 1];                          double h = g - d[l];                          for (int i = l + 2; i < n; i++)                          {                              d[i] -= h;                          }                            f = f + h;                            // Implicit QL transformation.                          p = d[m];                          double c = 1.0;                          double c2 = c;                          double c3 = c;                          double el1 = e[l + 1];                          double s = 0.0;                          double s2 = 0.0;                          for (int i = m - 1; i >= l; i--)                          {                              c3 = c2;                              c2 = c;                              s2 = s;                              g = c*e[i];                              h = c*p;                              r = Tools.Hypotenuse(p' e[i]);                              e[i + 1] = s*r;                              s = e[i]/r;                              c = p/r;                              p = c*d[i] - s*g;                              d[i + 1] = h + s*(c*g + s*d[i]);                                // Accumulate transformation.                              for (int k = 0; k < n; k++)                              {                                  h = V[k' i + 1];                                  V[k' i + 1] = s*V[k' i] + c*h;                                  V[k' i] = c*V[k' i] - s*h;                              }                          }                            p = -s*s2*c3*el1*e[l]/dl1;                          e[l] = s*p;                          d[l] = c*p;                            // Check for convergence.                      } while (System.Math.Abs(e[l]) > eps*tst1);                  }                  d[l] = d[l] + f;                  e[l] = 0.0;              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,tql2,The following statement contains a magic number: for (int l = 0; l < n; l++)              {                  // Find small subdiagonal element.                  tst1 = System.Math.Max(tst1' System.Math.Abs(d[l]) + System.Math.Abs(e[l]));                  int m = l;                  while (m < n)                  {                      if (System.Math.Abs(e[m]) <= eps*tst1)                          break;                      m++;                  }                    // If m == l' d[l] is an eigenvalue' otherwise' iterate.                  if (m > l)                  {                      int iter = 0;                      do                      {                          iter = iter + 1; // (Could check iteration count here.)                            // Compute implicit shift                          double g = d[l];                          double p = (d[l + 1] - g)/(2.0*e[l]);                          double r = Tools.Hypotenuse(p' 1.0);                          if (p < 0)                          {                              r = -r;                          }                            d[l] = e[l]/(p + r);                          d[l + 1] = e[l]*(p + r);                          double dl1 = d[l + 1];                          double h = g - d[l];                          for (int i = l + 2; i < n; i++)                          {                              d[i] -= h;                          }                            f = f + h;                            // Implicit QL transformation.                          p = d[m];                          double c = 1.0;                          double c2 = c;                          double c3 = c;                          double el1 = e[l + 1];                          double s = 0.0;                          double s2 = 0.0;                          for (int i = m - 1; i >= l; i--)                          {                              c3 = c2;                              c2 = c;                              s2 = s;                              g = c*e[i];                              h = c*p;                              r = Tools.Hypotenuse(p' e[i]);                              e[i + 1] = s*r;                              s = e[i]/r;                              c = p/r;                              p = c*d[i] - s*g;                              d[i + 1] = h + s*(c*g + s*d[i]);                                // Accumulate transformation.                              for (int k = 0; k < n; k++)                              {                                  h = V[k' i + 1];                                  V[k' i + 1] = s*V[k' i] + c*h;                                  V[k' i] = c*V[k' i] - s*h;                              }                          }                            p = -s*s2*c3*el1*e[l]/dl1;                          e[l] = s*p;                          d[l] = c*p;                            // Check for convergence.                      } while (System.Math.Abs(e[l]) > eps*tst1);                  }                  d[l] = d[l] + f;                  e[l] = 0.0;              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: double eps = System.Math.Pow(2.0' -52.0);
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: double eps = System.Math.Pow(2.0' -52.0);
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                  int l = n;                  while (l > low)                  {                      s = System.Math.Abs(H[l - 1' l - 1]) + System.Math.Abs(H[l' l]);                      if (s == 0.0) s = norm;                      if (System.Math.Abs(H[l' l - 1]) < eps*s)                          break;                        l--;                  }                    // Check for convergence                  if (l == n)                  {                      // One root found                      H[n' n] = H[n' n] + exshift;                      d[n] = H[n' n];                      e[n] = 0.0;                      n--;                      iter = 0;                  }                  else if (l == n - 1)                  {                      // Two roots found                      w = H[n' n - 1]*H[n - 1' n];                      p = (H[n - 1' n - 1] - H[n' n])/2.0;                      q = p*p + w;                      z = System.Math.Sqrt(System.Math.Abs(q));                      H[n' n] = H[n' n] + exshift;                      H[n - 1' n - 1] = H[n - 1' n - 1] + exshift;                      x = H[n' n];                        if (q >= 0)                      {                          // Real pair                          z = (p >= 0) ? (p + z) : (p - z);                          d[n - 1] = x + z;                          d[n] = d[n - 1];                          if (z != 0.0)                              d[n] = x - w/z;                          e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n' n - 1];                          s = System.Math.Abs(x) + System.Math.Abs(z);                          p = x/s;                          q = z/s;                          r = System.Math.Sqrt(p*p + q*q);                          p = p/r;                          q = q/r;                            // Row modification                          for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1' j];                              H[n - 1' j] = q*z + p*H[n' j];                              H[n' j] = q*H[n' j] - p*z;                          }                            // Column modification                          for (int i = 0; i <= n; i++)                          {                              z = H[i' n - 1];                              H[i' n - 1] = q*z + p*H[i' n];                              H[i' n] = q*H[i' n] - p*z;                          }                            // Accumulate transformations                          for (int i = low; i <= high; i++)                          {                              z = V[i' n - 1];                              V[i' n - 1] = q*z + p*V[i' n];                              V[i' n] = q*V[i' n] - p*z;                          }                      }                      else                      {                          // Complex pair                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                  }                  else                  {                      // No convergence yet	                         // Form shift                      x = H[n' n];                      y = 0.0;                      w = 0.0;                      if (l < n)                      {                          y = H[n - 1' n - 1];                          w = H[n' n - 1]*H[n - 1' n];                      }                        // Wilkinson's original ad hoc shift                      if (iter == 10)                      {                          exshift += x;                          for (int i = low; i <= n; i++)                              H[i' i] -= x;                            s = System.Math.Abs(H[n' n - 1]) + System.Math.Abs(H[n - 1' n - 2]);                          x = y = 0.75*s;                          w = -0.4375*s*s;                      }                        // MATLAB's new ad hoc shift                      if (iter == 30)                      {                          s = (y - x)/2.0;                          s = s*s + w;                          if (s > 0)                          {                              s = System.Math.Sqrt(s);                              if (y < x) s = -s;                              s = x - w/((y - x)/2.0 + s);                              for (int i = low; i <= n; i++)                                  H[i' i] -= s;                              exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1;                        // Look for two consecutive small sub-diagonal elements                      int m = n - 2;                      while (m >= l)                      {                          z = H[m' m];                          r = x - z;                          s = y - z;                          p = (r*s - w)/H[m + 1' m] + H[m' m + 1];                          q = H[m + 1' m + 1] - z - r - s;                          r = H[m + 2' m + 1];                          s = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                          p = p/s;                          q = q/s;                          r = r/s;                          if (m == l)                              break;                          if (System.Math.Abs(H[m' m - 1])*(System.Math.Abs(q) + System.Math.Abs(r)) <                              eps*                              (System.Math.Abs(p)*                               (System.Math.Abs(H[m - 1' m - 1]) + System.Math.Abs(z) + System.Math.Abs(H[m + 1' m + 1]))))                              break;                          m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i' i - 2] = 0.0;                          if (i > m + 2)                              H[i' i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                      for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                          if (k != m)                          {                              p = H[k' k - 1];                              q = H[k + 1' k - 1];                              r = (notlast ? H[k + 2' k - 1] : 0.0);                              x = System.Math.Abs(p) + System.Math.Abs(q) + System.Math.Abs(r);                              if (x != 0.0)                              {                                  p = p/x;                                  q = q/x;                                  r = r/x;                              }                          }                            if (x == 0.0) break;                            s = System.Math.Sqrt(p*p + q*q + r*r);                          if (p < 0) s = -s;                            if (s != 0)                          {                              if (k != m)                                  H[k' k - 1] = -s*x;                              else if (l != m)                                  H[k' k - 1] = -H[k' k - 1];                                p = p + s;                              x = p/s;                              y = q/s;                              z = r/s;                              q = q/p;                              r = r/p;                                // Row modification                              for (int j = k; j < nn; j++)                              {                                  p = H[k' j] + q*H[k + 1' j];                                  if (notlast)                                  {                                      p = p + r*H[k + 2' j];                                      H[k + 2' j] = H[k + 2' j] - p*z;                                  }                                    H[k' j] = H[k' j] - p*x;                                  H[k + 1' j] = H[k + 1' j] - p*y;                              }                                // Column modification                              for (int i = 0; i <= System.Math.Min(n' k + 3); i++)                              {                                  p = x*H[i' k] + y*H[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*H[i' k + 2];                                      H[i' k + 2] = H[i' k + 2] - p*r;                                  }                                    H[i' k] = H[i' k] - p;                                  H[i' k + 1] = H[i' k + 1] - p*q;                              }                                // Accumulate transformations                              for (int i = low; i <= high; i++)                              {                                  p = x*V[i' k] + y*V[i' k + 1];                                  if (notlast)                                  {                                      p = p + z*V[i' k + 2];                                      V[i' k + 2] = V[i' k + 2] - p*r;                                  }                                    V[i' k] = V[i' k] - p;                                  V[i' k + 1] = V[i' k + 1] - p*q;                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: for (n = nn - 1; n >= 0; n--)              {                  p = d[n];                  q = e[n];                    // Real vector                  if (q == 0)                  {                      int l = n;                      H[n' n] = 1.0;                      for (int i = n - 1; i >= 0; i--)                      {                          w = H[i' i] - p;                          r = 0.0;                          for (int j = l; j <= n; j++)                              r = r + H[i' j]*H[j' n];                            if (e[i] < 0.0)                          {                              z = w;                              s = r;                          }                          else                          {                              l = i;                              if (e[i] == 0.0)                              {                                  H[i' n] = (w != 0.0) ? (-r/w) : (-r/(eps*norm));                              }                              else                              {                                  // Solve real equations                                  x = H[i' i + 1];                                  y = H[i + 1' i];                                  q = (d[i] - p)*(d[i] - p) + e[i]*e[i];                                  t = (x*s - z*r)/q;                                  H[i' n] = t;                                  H[i + 1' n] = (System.Math.Abs(x) > System.Math.Abs(z))                                                    ? ((-r - w*t)/x)                                                    : ((-s - y*t)/z);                              }                                // Overflow control                              t = System.Math.Abs(H[i' n]);                              if ((eps*t)*t > 1)                                  for (int j = i; j <= n; j++)                                      H[j' n] = H[j' n]/t;                          }                      }                  }                  else if (q < 0)                  {                      // Complex vector                      int l = n - 1;                        // Last vector component imaginary so matrix is triangular                      if (System.Math.Abs(H[n' n - 1]) > System.Math.Abs(H[n - 1' n]))                      {                          H[n - 1' n - 1] = q/H[n' n - 1];                          H[n - 1' n] = -(H[n' n] - p)/H[n' n - 1];                      }                      else                      {                          cdiv(0.0' -H[n - 1' n]' H[n - 1' n - 1] - p' q' out H[n - 1' n - 1]' out H[n - 1' n]);                      }                        H[n' n - 1] = 0.0;                      H[n' n] = 1.0;                      for (int i = n - 2; i >= 0; i--)                      {                          double ra' sa' vr' vi;                          ra = 0.0;                          sa = 0.0;                          for (int j = l; j <= n; j++)                          {                              ra = ra + H[i' j]*H[j' n - 1];                              sa = sa + H[i' j]*H[j' n];                          }                            w = H[i' i] - p;                            if (e[i] < 0.0)                          {                              z = w;                              r = ra;                              s = sa;                          }                          else                          {                              l = i;                              if (e[i] == 0)                              {                                  cdiv(-ra' -sa' w' q' out H[i' n - 1]' out H[i' n]);                              }                              else                              {                                  // Solve complex equations                                  x = H[i' i + 1];                                  y = H[i + 1' i];                                  vr = (d[i] - p)*(d[i] - p) + e[i]*e[i] - q*q;                                  vi = (d[i] - p)*2.0*q;                                  if (vr == 0.0 & vi == 0.0)                                      vr = eps*norm*                                           (System.Math.Abs(w) + System.Math.Abs(q) + System.Math.Abs(x) +                                            System.Math.Abs(y) + System.Math.Abs(z));                                  cdiv(x*r - z*ra + q*sa' x*s - z*sa - q*ra' vr' vi' out H[i' n - 1]' out H[i' n]);                                  if (System.Math.Abs(x) > (System.Math.Abs(z) + System.Math.Abs(q)))                                  {                                      H[i + 1' n - 1] = (-ra - w*H[i' n - 1] + q*H[i' n])/x;                                      H[i + 1' n] = (-sa - w*H[i' n] - q*H[i' n - 1])/x;                                  }                                  else                                  {                                      cdiv(-r - y*H[i' n - 1]' -s - y*H[i' n]' z' q' out H[i + 1' n - 1]' out H[i + 1' n]);                                  }                              }                                // Overflow control                              t = System.Math.Max(System.Math.Abs(H[i' n - 1])' System.Math.Abs(H[i' n]));                              if ((eps*t)*t > 1)                              {                                  for (int j = i; j <= n; j++)                                  {                                      H[j' n - 1] = H[j' n - 1]/t;                                      H[j' n] = H[j' n]/t;                                  }                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,EigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\EigenValueDecomposition.cs,hqr2,The following statement contains a magic number: for (n = nn - 1; n >= 0; n--)              {                  p = d[n];                  q = e[n];                    // Real vector                  if (q == 0)                  {                      int l = n;                      H[n' n] = 1.0;                      for (int i = n - 1; i >= 0; i--)                      {                          w = H[i' i] - p;                          r = 0.0;                          for (int j = l; j <= n; j++)                              r = r + H[i' j]*H[j' n];                            if (e[i] < 0.0)                          {                              z = w;                              s = r;                          }                          else                          {                              l = i;                              if (e[i] == 0.0)                              {                                  H[i' n] = (w != 0.0) ? (-r/w) : (-r/(eps*norm));                              }                              else                              {                                  // Solve real equations                                  x = H[i' i + 1];                                  y = H[i + 1' i];                                  q = (d[i] - p)*(d[i] - p) + e[i]*e[i];                                  t = (x*s - z*r)/q;                                  H[i' n] = t;                                  H[i + 1' n] = (System.Math.Abs(x) > System.Math.Abs(z))                                                    ? ((-r - w*t)/x)                                                    : ((-s - y*t)/z);                              }                                // Overflow control                              t = System.Math.Abs(H[i' n]);                              if ((eps*t)*t > 1)                                  for (int j = i; j <= n; j++)                                      H[j' n] = H[j' n]/t;                          }                      }                  }                  else if (q < 0)                  {                      // Complex vector                      int l = n - 1;                        // Last vector component imaginary so matrix is triangular                      if (System.Math.Abs(H[n' n - 1]) > System.Math.Abs(H[n - 1' n]))                      {                          H[n - 1' n - 1] = q/H[n' n - 1];                          H[n - 1' n] = -(H[n' n] - p)/H[n' n - 1];                      }                      else                      {                          cdiv(0.0' -H[n - 1' n]' H[n - 1' n - 1] - p' q' out H[n - 1' n - 1]' out H[n - 1' n]);                      }                        H[n' n - 1] = 0.0;                      H[n' n] = 1.0;                      for (int i = n - 2; i >= 0; i--)                      {                          double ra' sa' vr' vi;                          ra = 0.0;                          sa = 0.0;                          for (int j = l; j <= n; j++)                          {                              ra = ra + H[i' j]*H[j' n - 1];                              sa = sa + H[i' j]*H[j' n];                          }                            w = H[i' i] - p;                            if (e[i] < 0.0)                          {                              z = w;                              r = ra;                              s = sa;                          }                          else                          {                              l = i;                              if (e[i] == 0)                              {                                  cdiv(-ra' -sa' w' q' out H[i' n - 1]' out H[i' n]);                              }                              else                              {                                  // Solve complex equations                                  x = H[i' i + 1];                                  y = H[i + 1' i];                                  vr = (d[i] - p)*(d[i] - p) + e[i]*e[i] - q*q;                                  vi = (d[i] - p)*2.0*q;                                  if (vr == 0.0 & vi == 0.0)                                      vr = eps*norm*                                           (System.Math.Abs(w) + System.Math.Abs(q) + System.Math.Abs(x) +                                            System.Math.Abs(y) + System.Math.Abs(z));                                  cdiv(x*r - z*ra + q*sa' x*s - z*sa - q*ra' vr' vi' out H[i' n - 1]' out H[i' n]);                                  if (System.Math.Abs(x) > (System.Math.Abs(z) + System.Math.Abs(q)))                                  {                                      H[i + 1' n - 1] = (-ra - w*H[i' n - 1] + q*H[i' n])/x;                                      H[i + 1' n] = (-sa - w*H[i' n] - q*H[i' n - 1])/x;                                  }                                  else                                  {                                      cdiv(-r - y*H[i' n - 1]' -s - y*H[i' n]' z' q' out H[i + 1' n - 1]' out H[i + 1' n]);                                  }                              }                                // Overflow control                              t = System.Math.Max(System.Math.Abs(H[i' n - 1])' System.Math.Abs(H[i' n]));                              if ((eps*t)*t > 1)                              {                                  for (int j = i; j <= n; j++)                                  {                                      H[j' n - 1] = H[j' n - 1]/t;                                      H[j' n] = H[j' n]/t;                                  }                              }                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,The following statement contains a magic number: if (n == 2) return 0;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,The following statement contains a magic number: for (k = 0; k < n - 2; ++k)              {                  nk1 = n - 2 - k;                    // for l=n-1 step -1 until k+1 do                  for (lb = 0; lb < nk1; ++lb)                  {                      l = n - lb - 2;                      l1 = l + 1;                        // Zero a(l+1'k)                      s = (System.Math.Abs(a[l' k])) + (System.Math.Abs(a[l1' k]));                        if (s == 0.0) continue;                      u1 = a[l' k]/s;                      u2 = a[l1' k]/s;                      r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                      v1 = -(u1 + r)/r;                      v2 = -u2/r;                      u2 = v2/v1;                        for (j = k; j < n; ++j)                      {                          t = a[l' j] + u2*a[l1' j];                          a[l' j] += t*v1;                          a[l1' j] += t*v2;                      }                        a[l1' k] = 0.0;                        for (j = l; j < n; ++j)                      {                          t = b[l' j] + u2*b[l1' j];                          b[l' j] += t*v1;                          b[l1' j] += t*v2;                      }                        // Zero b(l+1'l)                      s = (System.Math.Abs(b[l1' l1])) + (System.Math.Abs(b[l1' l]));                        if (s == 0.0) continue;                      u1 = b[l1' l1]/s;                      u2 = b[l1' l]/s;                      r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                      v1 = -(u1 + r)/r;                      v2 = -u2/r;                      u2 = v2/v1;                        for (i = 0; i <= l1; ++i)                      {                          t = b[i' l1] + u2*b[i' l];                          b[i' l1] += t*v1;                          b[i' l] += t*v2;                      }                        b[l1' l] = 0.0;                        for (i = 0; i < n; ++i)                      {                          t = a[i' l1] + u2*a[i' l];                          a[i' l1] += t*v1;                          a[i' l] += t*v2;                      }                        if (matz)                      {                          for (i = 0; i < n; ++i)                          {                              t = z[i' l1] + u2*z[i' l];                              z[i' l1] += t*v1;                              z[i' l] += t*v2;                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,The following statement contains a magic number: for (k = 0; k < n - 2; ++k)              {                  nk1 = n - 2 - k;                    // for l=n-1 step -1 until k+1 do                  for (lb = 0; lb < nk1; ++lb)                  {                      l = n - lb - 2;                      l1 = l + 1;                        // Zero a(l+1'k)                      s = (System.Math.Abs(a[l' k])) + (System.Math.Abs(a[l1' k]));                        if (s == 0.0) continue;                      u1 = a[l' k]/s;                      u2 = a[l1' k]/s;                      r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                      v1 = -(u1 + r)/r;                      v2 = -u2/r;                      u2 = v2/v1;                        for (j = k; j < n; ++j)                      {                          t = a[l' j] + u2*a[l1' j];                          a[l' j] += t*v1;                          a[l1' j] += t*v2;                      }                        a[l1' k] = 0.0;                        for (j = l; j < n; ++j)                      {                          t = b[l' j] + u2*b[l1' j];                          b[l' j] += t*v1;                          b[l1' j] += t*v2;                      }                        // Zero b(l+1'l)                      s = (System.Math.Abs(b[l1' l1])) + (System.Math.Abs(b[l1' l]));                        if (s == 0.0) continue;                      u1 = b[l1' l1]/s;                      u2 = b[l1' l]/s;                      r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                      v1 = -(u1 + r)/r;                      v2 = -u2/r;                      u2 = v2/v1;                        for (i = 0; i <= l1; ++i)                      {                          t = b[i' l1] + u2*b[i' l];                          b[i' l1] += t*v1;                          b[i' l] += t*v2;                      }                        b[l1' l] = 0.0;                        for (i = 0; i < n; ++i)                      {                          t = a[i' l1] + u2*a[i' l];                          a[i' l1] += t*v1;                          a[i' l] += t*v2;                      }                        if (matz)                      {                          for (i = 0; i < n; ++i)                          {                              t = z[i' l1] + u2*z[i' l];                              z[i' l1] += t*v1;                              z[i' l] += t*v2;                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzhes,The following statement contains a magic number: for (k = 0; k < n - 2; ++k)              {                  nk1 = n - 2 - k;                    // for l=n-1 step -1 until k+1 do                  for (lb = 0; lb < nk1; ++lb)                  {                      l = n - lb - 2;                      l1 = l + 1;                        // Zero a(l+1'k)                      s = (System.Math.Abs(a[l' k])) + (System.Math.Abs(a[l1' k]));                        if (s == 0.0) continue;                      u1 = a[l' k]/s;                      u2 = a[l1' k]/s;                      r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                      v1 = -(u1 + r)/r;                      v2 = -u2/r;                      u2 = v2/v1;                        for (j = k; j < n; ++j)                      {                          t = a[l' j] + u2*a[l1' j];                          a[l' j] += t*v1;                          a[l1' j] += t*v2;                      }                        a[l1' k] = 0.0;                        for (j = l; j < n; ++j)                      {                          t = b[l' j] + u2*b[l1' j];                          b[l' j] += t*v1;                          b[l1' j] += t*v2;                      }                        // Zero b(l+1'l)                      s = (System.Math.Abs(b[l1' l1])) + (System.Math.Abs(b[l1' l]));                        if (s == 0.0) continue;                      u1 = b[l1' l1]/s;                      u2 = b[l1' l]/s;                      r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                      v1 = -(u1 + r)/r;                      v2 = -u2/r;                      u2 = v2/v1;                        for (i = 0; i <= l1; ++i)                      {                          t = b[i' l1] + u2*b[i' l];                          b[i' l1] += t*v1;                          b[i' l] += t*v2;                      }                        b[l1' l] = 0.0;                        for (i = 0; i < n; ++i)                      {                          t = a[i' l1] + u2*a[i' l];                          a[i' l1] += t*v1;                          a[i' l] += t*v2;                      }                        if (matz)                      {                          for (i = 0; i < n; ++i)                          {                              t = z[i' l1] + u2*z[i' l];                              z[i' l1] += t*v1;                              z[i' l] += t*v2;                          }                      }                  }              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: itn = n*30;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: L70:              ish = 2;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: if (its == 10) goto L155;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: t = (a43*b34 - a33 - a44)*.5;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: a3 = 1.1605;
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: for (k = l; k <= na; ++k)              {                  notlas = k != na && ish == 2;                  k1 = k + 1;                  k2 = k + 2;                    km1 = System.Math.Max(k' l + 1) - 1; // Computing MAX                  ll = System.Math.Min(en' k1 + ish); // Computing MIN                    if (notlas) goto L190;                    // Zero a(k+1'k-1)                  if (k == l) goto L170;                  a1 = a[k' km1];                  a2 = a[k1' km1];                    L170:                  s = System.Math.Abs(a1) + System.Math.Abs(a2);                  if (s == 0.0) goto L70;                  u1 = a1/s;                  u2 = a2/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  u2 = v2/v1;                    for (j = km1; j < enorn; ++j)                  {                      t = a[k' j] + u2*a[k1' j];                      a[k' j] += t*v1;                      a[k1' j] += t*v2;                        t = b[k' j] + u2*b[k1' j];                      b[k' j] += t*v1;                      b[k1' j] += t*v2;                  }                    if (k != l)                      a[k1' km1] = 0.0;                  goto L240;                    // Zero a(k+1'k-1) and a(k+2'k-1)                  L190:                  if (k == l) goto L200;                  a1 = a[k' km1];                  a2 = a[k1' km1];                  a3 = a[k2' km1];                    L200:                  s = System.Math.Abs(a1) + System.Math.Abs(a2) + System.Math.Abs(a3);                  if (s == 0.0) goto L260;                  u1 = a1/s;                  u2 = a2/s;                  u3 = a3/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2 + u3*u3)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  v3 = -u3/r;                  u2 = v2/v1;                  u3 = v3/v1;                    for (j = km1; j < enorn; ++j)                  {                      t = a[k' j] + u2*a[k1' j] + u3*a[k2' j];                      a[k' j] += t*v1;                      a[k1' j] += t*v2;                      a[k2' j] += t*v3;                        t = b[k' j] + u2*b[k1' j] + u3*b[k2' j];                      b[k' j] += t*v1;                      b[k1' j] += t*v2;                      b[k2' j] += t*v3;                  }                    if (k == l) goto L220;                  a[k1' km1] = 0.0;                  a[k2' km1] = 0.0;                    // Zero b(k+2'k+1) and b(k+2'k)                  L220:                  s = (System.Math.Abs(b[k2' k2])) + (System.Math.Abs(b[k2' k1])) + (System.Math.Abs(b[k2' k]));                  if (s == 0.0) goto L240;                  u1 = b[k2' k2]/s;                  u2 = b[k2' k1]/s;                  u3 = b[k2' k]/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2 + u3*u3)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  v3 = -u3/r;                  u2 = v2/v1;                  u3 = v3/v1;                    for (i = lor1; i < ll + 1; ++i)                  {                      t = a[i' k2] + u2*a[i' k1] + u3*a[i' k];                      a[i' k2] += t*v1;                      a[i' k1] += t*v2;                      a[i' k] += t*v3;                        t = b[i' k2] + u2*b[i' k1] + u3*b[i' k];                      b[i' k2] += t*v1;                      b[i' k1] += t*v2;                      b[i' k] += t*v3;                  }                    b[k2' k] = 0.0;                  b[k2' k1] = 0.0;                    if (matz)                  {                      for (i = 0; i < n; ++i)                      {                          t = z[i' k2] + u2*z[i' k1] + u3*z[i' k];                          z[i' k2] += t*v1;                          z[i' k1] += t*v2;                          z[i' k] += t*v3;                      }                  }                    // Zero b(k+1'k)                  L240:                  s = (System.Math.Abs(b[k1' k1])) + (System.Math.Abs(b[k1' k]));                  if (s == 0.0) goto L260;                  u1 = b[k1' k1]/s;                  u2 = b[k1' k]/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  u2 = v2/v1;                    for (i = lor1; i < ll + 1; ++i)                  {                      t = a[i' k1] + u2*a[i' k];                      a[i' k1] += t*v1;                      a[i' k] += t*v2;                        t = b[i' k1] + u2*b[i' k];                      b[i' k1] += t*v1;                      b[i' k] += t*v2;                  }                    b[k1' k] = 0.0;                    if (matz)                  {                      for (i = 0; i < n; ++i)                      {                          t = z[i' k1] + u2*z[i' k];                          z[i' k1] += t*v1;                          z[i' k] += t*v2;                      }                  }                    L260:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzit,The following statement contains a magic number: for (k = l; k <= na; ++k)              {                  notlas = k != na && ish == 2;                  k1 = k + 1;                  k2 = k + 2;                    km1 = System.Math.Max(k' l + 1) - 1; // Computing MAX                  ll = System.Math.Min(en' k1 + ish); // Computing MIN                    if (notlas) goto L190;                    // Zero a(k+1'k-1)                  if (k == l) goto L170;                  a1 = a[k' km1];                  a2 = a[k1' km1];                    L170:                  s = System.Math.Abs(a1) + System.Math.Abs(a2);                  if (s == 0.0) goto L70;                  u1 = a1/s;                  u2 = a2/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  u2 = v2/v1;                    for (j = km1; j < enorn; ++j)                  {                      t = a[k' j] + u2*a[k1' j];                      a[k' j] += t*v1;                      a[k1' j] += t*v2;                        t = b[k' j] + u2*b[k1' j];                      b[k' j] += t*v1;                      b[k1' j] += t*v2;                  }                    if (k != l)                      a[k1' km1] = 0.0;                  goto L240;                    // Zero a(k+1'k-1) and a(k+2'k-1)                  L190:                  if (k == l) goto L200;                  a1 = a[k' km1];                  a2 = a[k1' km1];                  a3 = a[k2' km1];                    L200:                  s = System.Math.Abs(a1) + System.Math.Abs(a2) + System.Math.Abs(a3);                  if (s == 0.0) goto L260;                  u1 = a1/s;                  u2 = a2/s;                  u3 = a3/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2 + u3*u3)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  v3 = -u3/r;                  u2 = v2/v1;                  u3 = v3/v1;                    for (j = km1; j < enorn; ++j)                  {                      t = a[k' j] + u2*a[k1' j] + u3*a[k2' j];                      a[k' j] += t*v1;                      a[k1' j] += t*v2;                      a[k2' j] += t*v3;                        t = b[k' j] + u2*b[k1' j] + u3*b[k2' j];                      b[k' j] += t*v1;                      b[k1' j] += t*v2;                      b[k2' j] += t*v3;                  }                    if (k == l) goto L220;                  a[k1' km1] = 0.0;                  a[k2' km1] = 0.0;                    // Zero b(k+2'k+1) and b(k+2'k)                  L220:                  s = (System.Math.Abs(b[k2' k2])) + (System.Math.Abs(b[k2' k1])) + (System.Math.Abs(b[k2' k]));                  if (s == 0.0) goto L240;                  u1 = b[k2' k2]/s;                  u2 = b[k2' k1]/s;                  u3 = b[k2' k]/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2 + u3*u3)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  v3 = -u3/r;                  u2 = v2/v1;                  u3 = v3/v1;                    for (i = lor1; i < ll + 1; ++i)                  {                      t = a[i' k2] + u2*a[i' k1] + u3*a[i' k];                      a[i' k2] += t*v1;                      a[i' k1] += t*v2;                      a[i' k] += t*v3;                        t = b[i' k2] + u2*b[i' k1] + u3*b[i' k];                      b[i' k2] += t*v1;                      b[i' k1] += t*v2;                      b[i' k] += t*v3;                  }                    b[k2' k] = 0.0;                  b[k2' k1] = 0.0;                    if (matz)                  {                      for (i = 0; i < n; ++i)                      {                          t = z[i' k2] + u2*z[i' k1] + u3*z[i' k];                          z[i' k2] += t*v1;                          z[i' k1] += t*v2;                          z[i' k] += t*v3;                      }                  }                    // Zero b(k+1'k)                  L240:                  s = (System.Math.Abs(b[k1' k1])) + (System.Math.Abs(b[k1' k]));                  if (s == 0.0) goto L260;                  u1 = b[k1' k1]/s;                  u2 = b[k1' k]/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  u2 = v2/v1;                    for (i = lor1; i < ll + 1; ++i)                  {                      t = a[i' k1] + u2*a[i' k];                      a[i' k1] += t*v1;                      a[i' k] += t*v2;                        t = b[i' k1] + u2*b[i' k];                      b[i' k1] += t*v1;                      b[i' k] += t*v2;                  }                    b[k1' k] = 0.0;                    if (matz)                  {                      for (i = 0; i < n; ++i)                      {                          t = z[i' k1] + u2*z[i' k];                          z[i' k1] += t*v1;                          z[i' k] += t*v2;                      }                  }                    L260:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzval,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                    if (isw == 2) goto L505;                  if (en == 0) goto L410;                  if (a[en' na] != 0.0) goto L420;                    // 1-by-1 block' one real root                  L410:                  alfr[en] = a[en' en];                  if (b[en' en] < 0.0)                  {                      alfr[en] = -alfr[en];                  }                  beta[en] = (System.Math.Abs(b[en' en]));                  alfi[en] = 0.0;                  goto L510;                    // 2-by-2 block                  L420:                  if (System.Math.Abs(b[na' na]) <= epsb) goto L455;                  if (System.Math.Abs(b[en' en]) > epsb) goto L430;                  a1 = a[en' en];                  a2 = a[en' na];                  bn = 0.0;                  goto L435;                    L430:                  an = System.Math.Abs(a[na' na]) + System.Math.Abs(a[na' en]) + System.Math.Abs(a[en' na]) +                       System.Math.Abs(a[en' en]);                  bn = System.Math.Abs(b[na' na]) + System.Math.Abs(b[na' en]) + System.Math.Abs(b[en' en]);                  a11 = a[na' na]/an;                  a12 = a[na' en]/an;                  a21 = a[en' na]/an;                  a22 = a[en' en]/an;                  b11 = b[na' na]/bn;                  b12 = b[na' en]/bn;                  b22 = b[en' en]/bn;                  e = a11/b11;                  ei = a22/b22;                  s = a21/(b11*b22);                  t = (a22 - e*b22)/b22;                    if (System.Math.Abs(e) <= System.Math.Abs(ei))                      goto L431;                    e = ei;                  t = (a11 - e*b11)/b11;                    L431:                  c = (t - s*b12)*.5;                  d = c*c + s*(a12 - e*b12);                  if (d < 0.0) goto L480;                    // Two real roots. Zero both a(en'na) and b(en'na)                  e += c + Special.Sign(System.Math.Sqrt(d)' c);                  a11 -= e*b11;                  a12 -= e*b12;                  a22 -= e*b22;                    if (System.Math.Abs(a11) + System.Math.Abs(a12) < System.Math.Abs(a21) + System.Math.Abs(a22))                      goto L432;                    a1 = a12;                  a2 = a11;                  goto L435;                    L432:                  a1 = a22;                  a2 = a21;                    // Choose and apply real z                  L435:                  s = System.Math.Abs(a1) + System.Math.Abs(a2);                  u1 = a1/s;                  u2 = a2/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  u2 = v2/v1;                    for (i = 0; i <= en; ++i)                  {                      t = a[i' en] + u2*a[i' na];                      a[i' en] += t*v1;                      a[i' na] += t*v2;                        t = b[i' en] + u2*b[i' na];                      b[i' en] += t*v1;                      b[i' na] += t*v2;                  }                    if (matz)                  {                      for (i = 0; i < n; ++i)                      {                          t = z[i' en] + u2*z[i' na];                          z[i' en] += t*v1;                          z[i' na] += t*v2;                      }                  }                    if (bn == 0.0) goto L475;                  if (an < System.Math.Abs(e)*bn) goto L455;                  a1 = b[na' na];                  a2 = b[en' na];                  goto L460;                    L455:                  a1 = a[na' na];                  a2 = a[en' na];                    // Choose and apply real q                  L460:                  s = System.Math.Abs(a1) + System.Math.Abs(a2);                  if (s == 0.0) goto L475;                  u1 = a1/s;                  u2 = a2/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  u2 = v2/v1;                    for (j = na; j < n; ++j)                  {                      t = a[na' j] + u2*a[en' j];                      a[na' j] += t*v1;                      a[en' j] += t*v2;                        t = b[na' j] + u2*b[en' j];                      b[na' j] += t*v1;                      b[en' j] += t*v2;                  }                    L475:                  a[en' na] = 0.0;                  b[en' na] = 0.0;                  alfr[na] = a[na' na];                  alfr[en] = a[en' en];                    if (b[na' na] < 0.0)                      alfr[na] = -alfr[na];                    if (b[en' en] < 0.0)                      alfr[en] = -alfr[en];                    beta[na] = (System.Math.Abs(b[na' na]));                  beta[en] = (System.Math.Abs(b[en' en]));                  alfi[en] = 0.0;                  alfi[na] = 0.0;                  goto L505;                    // Two complex roots                  L480:                  e += c;                  ei = System.Math.Sqrt(-d);                  a11r = a11 - e*b11;                  a11i = ei*b11;                  a12r = a12 - e*b12;                  a12i = ei*b12;                  a22r = a22 - e*b22;                  a22i = ei*b22;                    if (System.Math.Abs(a11r) + System.Math.Abs(a11i) +                      System.Math.Abs(a12r) + System.Math.Abs(a12i) <                      System.Math.Abs(a21) + System.Math.Abs(a22r)                      + System.Math.Abs(a22i))                      goto L482;                    a1 = a12r;                  a1i = a12i;                  a2 = -a11r;                  a2i = -a11i;                  goto L485;                    L482:                  a1 = a22r;                  a1i = a22i;                  a2 = -a21;                  a2i = 0.0;                    // Choose complex z                  L485:                  cz = System.Math.Sqrt(a1*a1 + a1i*a1i);                  if (cz == 0.0) goto L487;                  szr = (a1*a2 + a1i*a2i)/cz;                  szi = (a1*a2i - a1i*a2)/cz;                  r = System.Math.Sqrt(cz*cz + szr*szr + szi*szi);                  cz /= r;                  szr /= r;                  szi /= r;                  goto L490;                    L487:                  szr = 1.0;                  szi = 0.0;                    L490:                  if (an < (System.Math.Abs(e) + ei)*bn) goto L492;                  a1 = cz*b11 + szr*b12;                  a1i = szi*b12;                  a2 = szr*b22;                  a2i = szi*b22;                  goto L495;                    L492:                  a1 = cz*a11 + szr*a12;                  a1i = szi*a12;                  a2 = cz*a21 + szr*a22;                  a2i = szi*a22;                    // Choose complex q                  L495:                  cq = System.Math.Sqrt(a1*a1 + a1i*a1i);                  if (cq == 0.0) goto L497;                  sqr = (a1*a2 + a1i*a2i)/cq;                  sqi = (a1*a2i - a1i*a2)/cq;                  r = System.Math.Sqrt(cq*cq + sqr*sqr + sqi*sqi);                  cq /= r;                  sqr /= r;                  sqi /= r;                  goto L500;                    L497:                  sqr = 1.0;                  sqi = 0.0;                    // Compute diagonal elements that would result if transformations were applied                  L500:                  ssr = sqr*szr + sqi*szi;                  ssi = sqr*szi - sqi*szr;                  i = 0;                  tr = cq*cz*a11 + cq*szr*a12 + sqr*cz*a21 + ssr*a22;                  ti = cq*szi*a12 - sqi*cz*a21 + ssi*a22;                  dr = cq*cz*b11 + cq*szr*b12 + ssr*b22;                  di = cq*szi*b12 + ssi*b22;                  goto L503;                    L502:                  i = 1;                  tr = ssr*a11 - sqr*cz*a12 - cq*szr*a21 + cq*cz*a22;                  ti = -ssi*a11 - sqi*cz*a12 + cq*szi*a21;                  dr = ssr*b11 - sqr*cz*b12 + cq*cz*b22;                  di = -ssi*b11 - sqi*cz*b12;                    L503:                  t = ti*dr - tr*di;                  j = na;                    if (t < 0.0)                      j = en;                    r = System.Math.Sqrt(dr*dr + di*di);                  beta[j] = bn*r;                  alfr[j] = an*(tr*dr + ti*di)/r;                  alfi[j] = an*t/r;                  if (i == 0) goto L502;                    L505:                  isw = 3 - isw;                    L510:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzval,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                    if (isw == 2) goto L505;                  if (en == 0) goto L410;                  if (a[en' na] != 0.0) goto L420;                    // 1-by-1 block' one real root                  L410:                  alfr[en] = a[en' en];                  if (b[en' en] < 0.0)                  {                      alfr[en] = -alfr[en];                  }                  beta[en] = (System.Math.Abs(b[en' en]));                  alfi[en] = 0.0;                  goto L510;                    // 2-by-2 block                  L420:                  if (System.Math.Abs(b[na' na]) <= epsb) goto L455;                  if (System.Math.Abs(b[en' en]) > epsb) goto L430;                  a1 = a[en' en];                  a2 = a[en' na];                  bn = 0.0;                  goto L435;                    L430:                  an = System.Math.Abs(a[na' na]) + System.Math.Abs(a[na' en]) + System.Math.Abs(a[en' na]) +                       System.Math.Abs(a[en' en]);                  bn = System.Math.Abs(b[na' na]) + System.Math.Abs(b[na' en]) + System.Math.Abs(b[en' en]);                  a11 = a[na' na]/an;                  a12 = a[na' en]/an;                  a21 = a[en' na]/an;                  a22 = a[en' en]/an;                  b11 = b[na' na]/bn;                  b12 = b[na' en]/bn;                  b22 = b[en' en]/bn;                  e = a11/b11;                  ei = a22/b22;                  s = a21/(b11*b22);                  t = (a22 - e*b22)/b22;                    if (System.Math.Abs(e) <= System.Math.Abs(ei))                      goto L431;                    e = ei;                  t = (a11 - e*b11)/b11;                    L431:                  c = (t - s*b12)*.5;                  d = c*c + s*(a12 - e*b12);                  if (d < 0.0) goto L480;                    // Two real roots. Zero both a(en'na) and b(en'na)                  e += c + Special.Sign(System.Math.Sqrt(d)' c);                  a11 -= e*b11;                  a12 -= e*b12;                  a22 -= e*b22;                    if (System.Math.Abs(a11) + System.Math.Abs(a12) < System.Math.Abs(a21) + System.Math.Abs(a22))                      goto L432;                    a1 = a12;                  a2 = a11;                  goto L435;                    L432:                  a1 = a22;                  a2 = a21;                    // Choose and apply real z                  L435:                  s = System.Math.Abs(a1) + System.Math.Abs(a2);                  u1 = a1/s;                  u2 = a2/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  u2 = v2/v1;                    for (i = 0; i <= en; ++i)                  {                      t = a[i' en] + u2*a[i' na];                      a[i' en] += t*v1;                      a[i' na] += t*v2;                        t = b[i' en] + u2*b[i' na];                      b[i' en] += t*v1;                      b[i' na] += t*v2;                  }                    if (matz)                  {                      for (i = 0; i < n; ++i)                      {                          t = z[i' en] + u2*z[i' na];                          z[i' en] += t*v1;                          z[i' na] += t*v2;                      }                  }                    if (bn == 0.0) goto L475;                  if (an < System.Math.Abs(e)*bn) goto L455;                  a1 = b[na' na];                  a2 = b[en' na];                  goto L460;                    L455:                  a1 = a[na' na];                  a2 = a[en' na];                    // Choose and apply real q                  L460:                  s = System.Math.Abs(a1) + System.Math.Abs(a2);                  if (s == 0.0) goto L475;                  u1 = a1/s;                  u2 = a2/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  u2 = v2/v1;                    for (j = na; j < n; ++j)                  {                      t = a[na' j] + u2*a[en' j];                      a[na' j] += t*v1;                      a[en' j] += t*v2;                        t = b[na' j] + u2*b[en' j];                      b[na' j] += t*v1;                      b[en' j] += t*v2;                  }                    L475:                  a[en' na] = 0.0;                  b[en' na] = 0.0;                  alfr[na] = a[na' na];                  alfr[en] = a[en' en];                    if (b[na' na] < 0.0)                      alfr[na] = -alfr[na];                    if (b[en' en] < 0.0)                      alfr[en] = -alfr[en];                    beta[na] = (System.Math.Abs(b[na' na]));                  beta[en] = (System.Math.Abs(b[en' en]));                  alfi[en] = 0.0;                  alfi[na] = 0.0;                  goto L505;                    // Two complex roots                  L480:                  e += c;                  ei = System.Math.Sqrt(-d);                  a11r = a11 - e*b11;                  a11i = ei*b11;                  a12r = a12 - e*b12;                  a12i = ei*b12;                  a22r = a22 - e*b22;                  a22i = ei*b22;                    if (System.Math.Abs(a11r) + System.Math.Abs(a11i) +                      System.Math.Abs(a12r) + System.Math.Abs(a12i) <                      System.Math.Abs(a21) + System.Math.Abs(a22r)                      + System.Math.Abs(a22i))                      goto L482;                    a1 = a12r;                  a1i = a12i;                  a2 = -a11r;                  a2i = -a11i;                  goto L485;                    L482:                  a1 = a22r;                  a1i = a22i;                  a2 = -a21;                  a2i = 0.0;                    // Choose complex z                  L485:                  cz = System.Math.Sqrt(a1*a1 + a1i*a1i);                  if (cz == 0.0) goto L487;                  szr = (a1*a2 + a1i*a2i)/cz;                  szi = (a1*a2i - a1i*a2)/cz;                  r = System.Math.Sqrt(cz*cz + szr*szr + szi*szi);                  cz /= r;                  szr /= r;                  szi /= r;                  goto L490;                    L487:                  szr = 1.0;                  szi = 0.0;                    L490:                  if (an < (System.Math.Abs(e) + ei)*bn) goto L492;                  a1 = cz*b11 + szr*b12;                  a1i = szi*b12;                  a2 = szr*b22;                  a2i = szi*b22;                  goto L495;                    L492:                  a1 = cz*a11 + szr*a12;                  a1i = szi*a12;                  a2 = cz*a21 + szr*a22;                  a2i = szi*a22;                    // Choose complex q                  L495:                  cq = System.Math.Sqrt(a1*a1 + a1i*a1i);                  if (cq == 0.0) goto L497;                  sqr = (a1*a2 + a1i*a2i)/cq;                  sqi = (a1*a2i - a1i*a2)/cq;                  r = System.Math.Sqrt(cq*cq + sqr*sqr + sqi*sqi);                  cq /= r;                  sqr /= r;                  sqi /= r;                  goto L500;                    L497:                  sqr = 1.0;                  sqi = 0.0;                    // Compute diagonal elements that would result if transformations were applied                  L500:                  ssr = sqr*szr + sqi*szi;                  ssi = sqr*szi - sqi*szr;                  i = 0;                  tr = cq*cz*a11 + cq*szr*a12 + sqr*cz*a21 + ssr*a22;                  ti = cq*szi*a12 - sqi*cz*a21 + ssi*a22;                  dr = cq*cz*b11 + cq*szr*b12 + ssr*b22;                  di = cq*szi*b12 + ssi*b22;                  goto L503;                    L502:                  i = 1;                  tr = ssr*a11 - sqr*cz*a12 - cq*szr*a21 + cq*cz*a22;                  ti = -ssi*a11 - sqi*cz*a12 + cq*szi*a21;                  dr = ssr*b11 - sqr*cz*b12 + cq*cz*b22;                  di = -ssi*b11 - sqi*cz*b12;                    L503:                  t = ti*dr - tr*di;                  j = na;                    if (t < 0.0)                      j = en;                    r = System.Math.Sqrt(dr*dr + di*di);                  beta[j] = bn*r;                  alfr[j] = an*(tr*dr + ti*di)/r;                  alfi[j] = an*t/r;                  if (i == 0) goto L502;                    L505:                  isw = 3 - isw;                    L510:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzval,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                    if (isw == 2) goto L505;                  if (en == 0) goto L410;                  if (a[en' na] != 0.0) goto L420;                    // 1-by-1 block' one real root                  L410:                  alfr[en] = a[en' en];                  if (b[en' en] < 0.0)                  {                      alfr[en] = -alfr[en];                  }                  beta[en] = (System.Math.Abs(b[en' en]));                  alfi[en] = 0.0;                  goto L510;                    // 2-by-2 block                  L420:                  if (System.Math.Abs(b[na' na]) <= epsb) goto L455;                  if (System.Math.Abs(b[en' en]) > epsb) goto L430;                  a1 = a[en' en];                  a2 = a[en' na];                  bn = 0.0;                  goto L435;                    L430:                  an = System.Math.Abs(a[na' na]) + System.Math.Abs(a[na' en]) + System.Math.Abs(a[en' na]) +                       System.Math.Abs(a[en' en]);                  bn = System.Math.Abs(b[na' na]) + System.Math.Abs(b[na' en]) + System.Math.Abs(b[en' en]);                  a11 = a[na' na]/an;                  a12 = a[na' en]/an;                  a21 = a[en' na]/an;                  a22 = a[en' en]/an;                  b11 = b[na' na]/bn;                  b12 = b[na' en]/bn;                  b22 = b[en' en]/bn;                  e = a11/b11;                  ei = a22/b22;                  s = a21/(b11*b22);                  t = (a22 - e*b22)/b22;                    if (System.Math.Abs(e) <= System.Math.Abs(ei))                      goto L431;                    e = ei;                  t = (a11 - e*b11)/b11;                    L431:                  c = (t - s*b12)*.5;                  d = c*c + s*(a12 - e*b12);                  if (d < 0.0) goto L480;                    // Two real roots. Zero both a(en'na) and b(en'na)                  e += c + Special.Sign(System.Math.Sqrt(d)' c);                  a11 -= e*b11;                  a12 -= e*b12;                  a22 -= e*b22;                    if (System.Math.Abs(a11) + System.Math.Abs(a12) < System.Math.Abs(a21) + System.Math.Abs(a22))                      goto L432;                    a1 = a12;                  a2 = a11;                  goto L435;                    L432:                  a1 = a22;                  a2 = a21;                    // Choose and apply real z                  L435:                  s = System.Math.Abs(a1) + System.Math.Abs(a2);                  u1 = a1/s;                  u2 = a2/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  u2 = v2/v1;                    for (i = 0; i <= en; ++i)                  {                      t = a[i' en] + u2*a[i' na];                      a[i' en] += t*v1;                      a[i' na] += t*v2;                        t = b[i' en] + u2*b[i' na];                      b[i' en] += t*v1;                      b[i' na] += t*v2;                  }                    if (matz)                  {                      for (i = 0; i < n; ++i)                      {                          t = z[i' en] + u2*z[i' na];                          z[i' en] += t*v1;                          z[i' na] += t*v2;                      }                  }                    if (bn == 0.0) goto L475;                  if (an < System.Math.Abs(e)*bn) goto L455;                  a1 = b[na' na];                  a2 = b[en' na];                  goto L460;                    L455:                  a1 = a[na' na];                  a2 = a[en' na];                    // Choose and apply real q                  L460:                  s = System.Math.Abs(a1) + System.Math.Abs(a2);                  if (s == 0.0) goto L475;                  u1 = a1/s;                  u2 = a2/s;                  r = Special.Sign(System.Math.Sqrt(u1*u1 + u2*u2)' u1);                  v1 = -(u1 + r)/r;                  v2 = -u2/r;                  u2 = v2/v1;                    for (j = na; j < n; ++j)                  {                      t = a[na' j] + u2*a[en' j];                      a[na' j] += t*v1;                      a[en' j] += t*v2;                        t = b[na' j] + u2*b[en' j];                      b[na' j] += t*v1;                      b[en' j] += t*v2;                  }                    L475:                  a[en' na] = 0.0;                  b[en' na] = 0.0;                  alfr[na] = a[na' na];                  alfr[en] = a[en' en];                    if (b[na' na] < 0.0)                      alfr[na] = -alfr[na];                    if (b[en' en] < 0.0)                      alfr[en] = -alfr[en];                    beta[na] = (System.Math.Abs(b[na' na]));                  beta[en] = (System.Math.Abs(b[en' en]));                  alfi[en] = 0.0;                  alfi[na] = 0.0;                  goto L505;                    // Two complex roots                  L480:                  e += c;                  ei = System.Math.Sqrt(-d);                  a11r = a11 - e*b11;                  a11i = ei*b11;                  a12r = a12 - e*b12;                  a12i = ei*b12;                  a22r = a22 - e*b22;                  a22i = ei*b22;                    if (System.Math.Abs(a11r) + System.Math.Abs(a11i) +                      System.Math.Abs(a12r) + System.Math.Abs(a12i) <                      System.Math.Abs(a21) + System.Math.Abs(a22r)                      + System.Math.Abs(a22i))                      goto L482;                    a1 = a12r;                  a1i = a12i;                  a2 = -a11r;                  a2i = -a11i;                  goto L485;                    L482:                  a1 = a22r;                  a1i = a22i;                  a2 = -a21;                  a2i = 0.0;                    // Choose complex z                  L485:                  cz = System.Math.Sqrt(a1*a1 + a1i*a1i);                  if (cz == 0.0) goto L487;                  szr = (a1*a2 + a1i*a2i)/cz;                  szi = (a1*a2i - a1i*a2)/cz;                  r = System.Math.Sqrt(cz*cz + szr*szr + szi*szi);                  cz /= r;                  szr /= r;                  szi /= r;                  goto L490;                    L487:                  szr = 1.0;                  szi = 0.0;                    L490:                  if (an < (System.Math.Abs(e) + ei)*bn) goto L492;                  a1 = cz*b11 + szr*b12;                  a1i = szi*b12;                  a2 = szr*b22;                  a2i = szi*b22;                  goto L495;                    L492:                  a1 = cz*a11 + szr*a12;                  a1i = szi*a12;                  a2 = cz*a21 + szr*a22;                  a2i = szi*a22;                    // Choose complex q                  L495:                  cq = System.Math.Sqrt(a1*a1 + a1i*a1i);                  if (cq == 0.0) goto L497;                  sqr = (a1*a2 + a1i*a2i)/cq;                  sqi = (a1*a2i - a1i*a2)/cq;                  r = System.Math.Sqrt(cq*cq + sqr*sqr + sqi*sqi);                  cq /= r;                  sqr /= r;                  sqi /= r;                  goto L500;                    L497:                  sqr = 1.0;                  sqi = 0.0;                    // Compute diagonal elements that would result if transformations were applied                  L500:                  ssr = sqr*szr + sqi*szi;                  ssi = sqr*szi - sqi*szr;                  i = 0;                  tr = cq*cz*a11 + cq*szr*a12 + sqr*cz*a21 + ssr*a22;                  ti = cq*szi*a12 - sqi*cz*a21 + ssi*a22;                  dr = cq*cz*b11 + cq*szr*b12 + ssr*b22;                  di = cq*szi*b12 + ssi*b22;                  goto L503;                    L502:                  i = 1;                  tr = ssr*a11 - sqr*cz*a12 - cq*szr*a21 + cq*cz*a22;                  ti = -ssi*a11 - sqi*cz*a12 + cq*szi*a21;                  dr = ssr*b11 - sqr*cz*b12 + cq*cz*b22;                  di = -ssi*b11 - sqi*cz*b12;                    L503:                  t = ti*dr - tr*di;                  j = na;                    if (t < 0.0)                      j = en;                    r = System.Math.Sqrt(dr*dr + di*di);                  beta[j] = bn*r;                  alfr[j] = an*(tr*dr + ti*di)/r;                  alfi[j] = an*t/r;                  if (i == 0) goto L502;                    L505:                  isw = 3 - isw;                    L510:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                  if (isw == 2) goto L795;                  if (alfi[en] != 0.0) goto L710;                    // Real vector                  m = en;                  b[en' en] = 1.0;                  if (na == -1) goto L800;                  alfm = alfr[m];                  betm = beta[m];                    // for i=en-1 step -1 until 1 do --                  for (ii = 0; ii <= na; ++ii)                  {                      i = en - ii - 1;                      w = betm*a[i' i] - alfm*b[i' i];                      r = 0.0;                        for (j = m; j <= en; ++j)                          r += (betm*a[i' j] - alfm*b[i' j])*b[j' en];                        if (i == 0 || isw == 2)                          goto L630;                        if (betm*a[i' i - 1] == 0.0)                          goto L630;                        zz = w;                      s = r;                      goto L690;                        L630:                      m = i;                      if (isw == 2) goto L640;                        // Real 1-by-1 block                      t = w;                      if (w == 0.0)                          t = epsb;                      b[i' en] = -r/t;                      goto L700;                        // Real 2-by-2 block                      L640:                      x = betm*a[i' i + 1] - alfm*b[i' i + 1];                      y = betm*a[i + 1' i];                      q = w*zz - x*y;                      t = (x*s - zz*r)/q;                      b[i' en] = t;                      if (System.Math.Abs(x) <= System.Math.Abs(zz)) goto L650;                      b[i + 1' en] = (-r - w*t)/x;                      goto L690;                        L650:                      b[i + 1' en] = (-s - y*t)/zz;                        L690:                      isw = 3 - isw;                        L700:                      ;                  }                  // End real vector                  goto L800;                    // Complex vector                  L710:                  m = na;                  almr = alfr[m];                  almi = alfi[m];                  betm = beta[m];                    // last vector component chosen imaginary so that eigenvector matrix is triangular                  y = betm*a[en' na];                  b[na' na] = -almi*b[en' en]/y;                  b[na' en] = (almr*b[en' en] - betm*a[en' en])/y;                  b[en' na] = 0.0;                  b[en' en] = 1.0;                  enm2 = na;                  if (enm2 == 0) goto L795;                    // for i=en-2 step -1 until 1 do --                  for (ii = 0; ii < enm2; ++ii)                  {                      i = na - ii - 1;                      w = betm*a[i' i] - almr*b[i' i];                      w1 = -almi*b[i' i];                      ra = 0.0;                      sa = 0.0;                        for (j = m; j <= en; ++j)                      {                          x = betm*a[i' j] - almr*b[i' j];                          x1 = -almi*b[i' j];                          ra = ra + x*b[j' na] - x1*b[j' en];                          sa = sa + x*b[j' en] + x1*b[j' na];                      }                        if (i == 0 || isw == 2) goto L770;                      if (betm*a[i' i - 1] == 0.0) goto L770;                        zz = w;                      z1 = w1;                      r = ra;                      s = sa;                      isw = 2;                      goto L790;                        L770:                      m = i;                      if (isw == 2) goto L780;                        // Complex 1-by-1 block                       tr = -ra;                      ti = -sa;                        L773:                      dr = w;                      di = w1;                        // Complex divide (t1't2) = (tr'ti) / (dr'di)                      L775:                      if (System.Math.Abs(di) > System.Math.Abs(dr)) goto L777;                      rr = di/dr;                      d = dr + di*rr;                      t1 = (tr + ti*rr)/d;                      t2 = (ti - tr*rr)/d;                        switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        L777:                      rr = dr/di;                      d = dr*rr + di;                      t1 = (tr*rr + ti)/d;                      t2 = (ti*rr - tr)/d;                      switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        // Complex 2-by-2 block                       L780:                      x = betm*a[i' i + 1] - almr*b[i' i + 1];                      x1 = -almi*b[i' i + 1];                      y = betm*a[i + 1' i];                      tr = y*ra - w*r + w1*s;                      ti = y*sa - w*s - w1*r;                      dr = w*zz - w1*z1 - x*y;                      di = w*z1 + w1*zz - x1*y;                      if (dr == 0.0 && di == 0.0)                          dr = epsb;                      goto L775;                        L782:                      b[i + 1' na] = t1;                      b[i + 1' en] = t2;                      isw = 1;                      if (System.Math.Abs(y) > System.Math.Abs(w) + System.Math.Abs(w1))                          goto L785;                      tr = -ra - x*b[(i + 1)' na] + x1*b[(i + 1)' en];                      ti = -sa - x*b[(i + 1)' en] - x1*b[(i + 1)' na];                      goto L773;                        L785:                      t1 = (-r - zz*b[(i + 1)' na] + z1*b[(i + 1)' en])/y;                      t2 = (-s - zz*b[(i + 1)' en] - z1*b[(i + 1)' na])/y;                        L787:                      b[i' na] = t1;                      b[i' en] = t2;                        L790:                      ;                  }                    // End complex vector                  L795:                  isw = 3 - isw;                    L800:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                  if (isw == 2) goto L795;                  if (alfi[en] != 0.0) goto L710;                    // Real vector                  m = en;                  b[en' en] = 1.0;                  if (na == -1) goto L800;                  alfm = alfr[m];                  betm = beta[m];                    // for i=en-1 step -1 until 1 do --                  for (ii = 0; ii <= na; ++ii)                  {                      i = en - ii - 1;                      w = betm*a[i' i] - alfm*b[i' i];                      r = 0.0;                        for (j = m; j <= en; ++j)                          r += (betm*a[i' j] - alfm*b[i' j])*b[j' en];                        if (i == 0 || isw == 2)                          goto L630;                        if (betm*a[i' i - 1] == 0.0)                          goto L630;                        zz = w;                      s = r;                      goto L690;                        L630:                      m = i;                      if (isw == 2) goto L640;                        // Real 1-by-1 block                      t = w;                      if (w == 0.0)                          t = epsb;                      b[i' en] = -r/t;                      goto L700;                        // Real 2-by-2 block                      L640:                      x = betm*a[i' i + 1] - alfm*b[i' i + 1];                      y = betm*a[i + 1' i];                      q = w*zz - x*y;                      t = (x*s - zz*r)/q;                      b[i' en] = t;                      if (System.Math.Abs(x) <= System.Math.Abs(zz)) goto L650;                      b[i + 1' en] = (-r - w*t)/x;                      goto L690;                        L650:                      b[i + 1' en] = (-s - y*t)/zz;                        L690:                      isw = 3 - isw;                        L700:                      ;                  }                  // End real vector                  goto L800;                    // Complex vector                  L710:                  m = na;                  almr = alfr[m];                  almi = alfi[m];                  betm = beta[m];                    // last vector component chosen imaginary so that eigenvector matrix is triangular                  y = betm*a[en' na];                  b[na' na] = -almi*b[en' en]/y;                  b[na' en] = (almr*b[en' en] - betm*a[en' en])/y;                  b[en' na] = 0.0;                  b[en' en] = 1.0;                  enm2 = na;                  if (enm2 == 0) goto L795;                    // for i=en-2 step -1 until 1 do --                  for (ii = 0; ii < enm2; ++ii)                  {                      i = na - ii - 1;                      w = betm*a[i' i] - almr*b[i' i];                      w1 = -almi*b[i' i];                      ra = 0.0;                      sa = 0.0;                        for (j = m; j <= en; ++j)                      {                          x = betm*a[i' j] - almr*b[i' j];                          x1 = -almi*b[i' j];                          ra = ra + x*b[j' na] - x1*b[j' en];                          sa = sa + x*b[j' en] + x1*b[j' na];                      }                        if (i == 0 || isw == 2) goto L770;                      if (betm*a[i' i - 1] == 0.0) goto L770;                        zz = w;                      z1 = w1;                      r = ra;                      s = sa;                      isw = 2;                      goto L790;                        L770:                      m = i;                      if (isw == 2) goto L780;                        // Complex 1-by-1 block                       tr = -ra;                      ti = -sa;                        L773:                      dr = w;                      di = w1;                        // Complex divide (t1't2) = (tr'ti) / (dr'di)                      L775:                      if (System.Math.Abs(di) > System.Math.Abs(dr)) goto L777;                      rr = di/dr;                      d = dr + di*rr;                      t1 = (tr + ti*rr)/d;                      t2 = (ti - tr*rr)/d;                        switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        L777:                      rr = dr/di;                      d = dr*rr + di;                      t1 = (tr*rr + ti)/d;                      t2 = (ti*rr - tr)/d;                      switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        // Complex 2-by-2 block                       L780:                      x = betm*a[i' i + 1] - almr*b[i' i + 1];                      x1 = -almi*b[i' i + 1];                      y = betm*a[i + 1' i];                      tr = y*ra - w*r + w1*s;                      ti = y*sa - w*s - w1*r;                      dr = w*zz - w1*z1 - x*y;                      di = w*z1 + w1*zz - x1*y;                      if (dr == 0.0 && di == 0.0)                          dr = epsb;                      goto L775;                        L782:                      b[i + 1' na] = t1;                      b[i + 1' en] = t2;                      isw = 1;                      if (System.Math.Abs(y) > System.Math.Abs(w) + System.Math.Abs(w1))                          goto L785;                      tr = -ra - x*b[(i + 1)' na] + x1*b[(i + 1)' en];                      ti = -sa - x*b[(i + 1)' en] - x1*b[(i + 1)' na];                      goto L773;                        L785:                      t1 = (-r - zz*b[(i + 1)' na] + z1*b[(i + 1)' en])/y;                      t2 = (-s - zz*b[(i + 1)' en] - z1*b[(i + 1)' na])/y;                        L787:                      b[i' na] = t1;                      b[i' en] = t2;                        L790:                      ;                  }                    // End complex vector                  L795:                  isw = 3 - isw;                    L800:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                  if (isw == 2) goto L795;                  if (alfi[en] != 0.0) goto L710;                    // Real vector                  m = en;                  b[en' en] = 1.0;                  if (na == -1) goto L800;                  alfm = alfr[m];                  betm = beta[m];                    // for i=en-1 step -1 until 1 do --                  for (ii = 0; ii <= na; ++ii)                  {                      i = en - ii - 1;                      w = betm*a[i' i] - alfm*b[i' i];                      r = 0.0;                        for (j = m; j <= en; ++j)                          r += (betm*a[i' j] - alfm*b[i' j])*b[j' en];                        if (i == 0 || isw == 2)                          goto L630;                        if (betm*a[i' i - 1] == 0.0)                          goto L630;                        zz = w;                      s = r;                      goto L690;                        L630:                      m = i;                      if (isw == 2) goto L640;                        // Real 1-by-1 block                      t = w;                      if (w == 0.0)                          t = epsb;                      b[i' en] = -r/t;                      goto L700;                        // Real 2-by-2 block                      L640:                      x = betm*a[i' i + 1] - alfm*b[i' i + 1];                      y = betm*a[i + 1' i];                      q = w*zz - x*y;                      t = (x*s - zz*r)/q;                      b[i' en] = t;                      if (System.Math.Abs(x) <= System.Math.Abs(zz)) goto L650;                      b[i + 1' en] = (-r - w*t)/x;                      goto L690;                        L650:                      b[i + 1' en] = (-s - y*t)/zz;                        L690:                      isw = 3 - isw;                        L700:                      ;                  }                  // End real vector                  goto L800;                    // Complex vector                  L710:                  m = na;                  almr = alfr[m];                  almi = alfi[m];                  betm = beta[m];                    // last vector component chosen imaginary so that eigenvector matrix is triangular                  y = betm*a[en' na];                  b[na' na] = -almi*b[en' en]/y;                  b[na' en] = (almr*b[en' en] - betm*a[en' en])/y;                  b[en' na] = 0.0;                  b[en' en] = 1.0;                  enm2 = na;                  if (enm2 == 0) goto L795;                    // for i=en-2 step -1 until 1 do --                  for (ii = 0; ii < enm2; ++ii)                  {                      i = na - ii - 1;                      w = betm*a[i' i] - almr*b[i' i];                      w1 = -almi*b[i' i];                      ra = 0.0;                      sa = 0.0;                        for (j = m; j <= en; ++j)                      {                          x = betm*a[i' j] - almr*b[i' j];                          x1 = -almi*b[i' j];                          ra = ra + x*b[j' na] - x1*b[j' en];                          sa = sa + x*b[j' en] + x1*b[j' na];                      }                        if (i == 0 || isw == 2) goto L770;                      if (betm*a[i' i - 1] == 0.0) goto L770;                        zz = w;                      z1 = w1;                      r = ra;                      s = sa;                      isw = 2;                      goto L790;                        L770:                      m = i;                      if (isw == 2) goto L780;                        // Complex 1-by-1 block                       tr = -ra;                      ti = -sa;                        L773:                      dr = w;                      di = w1;                        // Complex divide (t1't2) = (tr'ti) / (dr'di)                      L775:                      if (System.Math.Abs(di) > System.Math.Abs(dr)) goto L777;                      rr = di/dr;                      d = dr + di*rr;                      t1 = (tr + ti*rr)/d;                      t2 = (ti - tr*rr)/d;                        switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        L777:                      rr = dr/di;                      d = dr*rr + di;                      t1 = (tr*rr + ti)/d;                      t2 = (ti*rr - tr)/d;                      switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        // Complex 2-by-2 block                       L780:                      x = betm*a[i' i + 1] - almr*b[i' i + 1];                      x1 = -almi*b[i' i + 1];                      y = betm*a[i + 1' i];                      tr = y*ra - w*r + w1*s;                      ti = y*sa - w*s - w1*r;                      dr = w*zz - w1*z1 - x*y;                      di = w*z1 + w1*zz - x1*y;                      if (dr == 0.0 && di == 0.0)                          dr = epsb;                      goto L775;                        L782:                      b[i + 1' na] = t1;                      b[i + 1' en] = t2;                      isw = 1;                      if (System.Math.Abs(y) > System.Math.Abs(w) + System.Math.Abs(w1))                          goto L785;                      tr = -ra - x*b[(i + 1)' na] + x1*b[(i + 1)' en];                      ti = -sa - x*b[(i + 1)' en] - x1*b[(i + 1)' na];                      goto L773;                        L785:                      t1 = (-r - zz*b[(i + 1)' na] + z1*b[(i + 1)' en])/y;                      t2 = (-s - zz*b[(i + 1)' en] - z1*b[(i + 1)' na])/y;                        L787:                      b[i' na] = t1;                      b[i' en] = t2;                        L790:                      ;                  }                    // End complex vector                  L795:                  isw = 3 - isw;                    L800:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                  if (isw == 2) goto L795;                  if (alfi[en] != 0.0) goto L710;                    // Real vector                  m = en;                  b[en' en] = 1.0;                  if (na == -1) goto L800;                  alfm = alfr[m];                  betm = beta[m];                    // for i=en-1 step -1 until 1 do --                  for (ii = 0; ii <= na; ++ii)                  {                      i = en - ii - 1;                      w = betm*a[i' i] - alfm*b[i' i];                      r = 0.0;                        for (j = m; j <= en; ++j)                          r += (betm*a[i' j] - alfm*b[i' j])*b[j' en];                        if (i == 0 || isw == 2)                          goto L630;                        if (betm*a[i' i - 1] == 0.0)                          goto L630;                        zz = w;                      s = r;                      goto L690;                        L630:                      m = i;                      if (isw == 2) goto L640;                        // Real 1-by-1 block                      t = w;                      if (w == 0.0)                          t = epsb;                      b[i' en] = -r/t;                      goto L700;                        // Real 2-by-2 block                      L640:                      x = betm*a[i' i + 1] - alfm*b[i' i + 1];                      y = betm*a[i + 1' i];                      q = w*zz - x*y;                      t = (x*s - zz*r)/q;                      b[i' en] = t;                      if (System.Math.Abs(x) <= System.Math.Abs(zz)) goto L650;                      b[i + 1' en] = (-r - w*t)/x;                      goto L690;                        L650:                      b[i + 1' en] = (-s - y*t)/zz;                        L690:                      isw = 3 - isw;                        L700:                      ;                  }                  // End real vector                  goto L800;                    // Complex vector                  L710:                  m = na;                  almr = alfr[m];                  almi = alfi[m];                  betm = beta[m];                    // last vector component chosen imaginary so that eigenvector matrix is triangular                  y = betm*a[en' na];                  b[na' na] = -almi*b[en' en]/y;                  b[na' en] = (almr*b[en' en] - betm*a[en' en])/y;                  b[en' na] = 0.0;                  b[en' en] = 1.0;                  enm2 = na;                  if (enm2 == 0) goto L795;                    // for i=en-2 step -1 until 1 do --                  for (ii = 0; ii < enm2; ++ii)                  {                      i = na - ii - 1;                      w = betm*a[i' i] - almr*b[i' i];                      w1 = -almi*b[i' i];                      ra = 0.0;                      sa = 0.0;                        for (j = m; j <= en; ++j)                      {                          x = betm*a[i' j] - almr*b[i' j];                          x1 = -almi*b[i' j];                          ra = ra + x*b[j' na] - x1*b[j' en];                          sa = sa + x*b[j' en] + x1*b[j' na];                      }                        if (i == 0 || isw == 2) goto L770;                      if (betm*a[i' i - 1] == 0.0) goto L770;                        zz = w;                      z1 = w1;                      r = ra;                      s = sa;                      isw = 2;                      goto L790;                        L770:                      m = i;                      if (isw == 2) goto L780;                        // Complex 1-by-1 block                       tr = -ra;                      ti = -sa;                        L773:                      dr = w;                      di = w1;                        // Complex divide (t1't2) = (tr'ti) / (dr'di)                      L775:                      if (System.Math.Abs(di) > System.Math.Abs(dr)) goto L777;                      rr = di/dr;                      d = dr + di*rr;                      t1 = (tr + ti*rr)/d;                      t2 = (ti - tr*rr)/d;                        switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        L777:                      rr = dr/di;                      d = dr*rr + di;                      t1 = (tr*rr + ti)/d;                      t2 = (ti*rr - tr)/d;                      switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        // Complex 2-by-2 block                       L780:                      x = betm*a[i' i + 1] - almr*b[i' i + 1];                      x1 = -almi*b[i' i + 1];                      y = betm*a[i + 1' i];                      tr = y*ra - w*r + w1*s;                      ti = y*sa - w*s - w1*r;                      dr = w*zz - w1*z1 - x*y;                      di = w*z1 + w1*zz - x1*y;                      if (dr == 0.0 && di == 0.0)                          dr = epsb;                      goto L775;                        L782:                      b[i + 1' na] = t1;                      b[i + 1' en] = t2;                      isw = 1;                      if (System.Math.Abs(y) > System.Math.Abs(w) + System.Math.Abs(w1))                          goto L785;                      tr = -ra - x*b[(i + 1)' na] + x1*b[(i + 1)' en];                      ti = -sa - x*b[(i + 1)' en] - x1*b[(i + 1)' na];                      goto L773;                        L785:                      t1 = (-r - zz*b[(i + 1)' na] + z1*b[(i + 1)' en])/y;                      t2 = (-s - zz*b[(i + 1)' en] - z1*b[(i + 1)' na])/y;                        L787:                      b[i' na] = t1;                      b[i' en] = t2;                        L790:                      ;                  }                    // End complex vector                  L795:                  isw = 3 - isw;                    L800:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                  if (isw == 2) goto L795;                  if (alfi[en] != 0.0) goto L710;                    // Real vector                  m = en;                  b[en' en] = 1.0;                  if (na == -1) goto L800;                  alfm = alfr[m];                  betm = beta[m];                    // for i=en-1 step -1 until 1 do --                  for (ii = 0; ii <= na; ++ii)                  {                      i = en - ii - 1;                      w = betm*a[i' i] - alfm*b[i' i];                      r = 0.0;                        for (j = m; j <= en; ++j)                          r += (betm*a[i' j] - alfm*b[i' j])*b[j' en];                        if (i == 0 || isw == 2)                          goto L630;                        if (betm*a[i' i - 1] == 0.0)                          goto L630;                        zz = w;                      s = r;                      goto L690;                        L630:                      m = i;                      if (isw == 2) goto L640;                        // Real 1-by-1 block                      t = w;                      if (w == 0.0)                          t = epsb;                      b[i' en] = -r/t;                      goto L700;                        // Real 2-by-2 block                      L640:                      x = betm*a[i' i + 1] - alfm*b[i' i + 1];                      y = betm*a[i + 1' i];                      q = w*zz - x*y;                      t = (x*s - zz*r)/q;                      b[i' en] = t;                      if (System.Math.Abs(x) <= System.Math.Abs(zz)) goto L650;                      b[i + 1' en] = (-r - w*t)/x;                      goto L690;                        L650:                      b[i + 1' en] = (-s - y*t)/zz;                        L690:                      isw = 3 - isw;                        L700:                      ;                  }                  // End real vector                  goto L800;                    // Complex vector                  L710:                  m = na;                  almr = alfr[m];                  almi = alfi[m];                  betm = beta[m];                    // last vector component chosen imaginary so that eigenvector matrix is triangular                  y = betm*a[en' na];                  b[na' na] = -almi*b[en' en]/y;                  b[na' en] = (almr*b[en' en] - betm*a[en' en])/y;                  b[en' na] = 0.0;                  b[en' en] = 1.0;                  enm2 = na;                  if (enm2 == 0) goto L795;                    // for i=en-2 step -1 until 1 do --                  for (ii = 0; ii < enm2; ++ii)                  {                      i = na - ii - 1;                      w = betm*a[i' i] - almr*b[i' i];                      w1 = -almi*b[i' i];                      ra = 0.0;                      sa = 0.0;                        for (j = m; j <= en; ++j)                      {                          x = betm*a[i' j] - almr*b[i' j];                          x1 = -almi*b[i' j];                          ra = ra + x*b[j' na] - x1*b[j' en];                          sa = sa + x*b[j' en] + x1*b[j' na];                      }                        if (i == 0 || isw == 2) goto L770;                      if (betm*a[i' i - 1] == 0.0) goto L770;                        zz = w;                      z1 = w1;                      r = ra;                      s = sa;                      isw = 2;                      goto L790;                        L770:                      m = i;                      if (isw == 2) goto L780;                        // Complex 1-by-1 block                       tr = -ra;                      ti = -sa;                        L773:                      dr = w;                      di = w1;                        // Complex divide (t1't2) = (tr'ti) / (dr'di)                      L775:                      if (System.Math.Abs(di) > System.Math.Abs(dr)) goto L777;                      rr = di/dr;                      d = dr + di*rr;                      t1 = (tr + ti*rr)/d;                      t2 = (ti - tr*rr)/d;                        switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        L777:                      rr = dr/di;                      d = dr*rr + di;                      t1 = (tr*rr + ti)/d;                      t2 = (ti*rr - tr)/d;                      switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        // Complex 2-by-2 block                       L780:                      x = betm*a[i' i + 1] - almr*b[i' i + 1];                      x1 = -almi*b[i' i + 1];                      y = betm*a[i + 1' i];                      tr = y*ra - w*r + w1*s;                      ti = y*sa - w*s - w1*r;                      dr = w*zz - w1*z1 - x*y;                      di = w*z1 + w1*zz - x1*y;                      if (dr == 0.0 && di == 0.0)                          dr = epsb;                      goto L775;                        L782:                      b[i + 1' na] = t1;                      b[i + 1' en] = t2;                      isw = 1;                      if (System.Math.Abs(y) > System.Math.Abs(w) + System.Math.Abs(w1))                          goto L785;                      tr = -ra - x*b[(i + 1)' na] + x1*b[(i + 1)' en];                      ti = -sa - x*b[(i + 1)' en] - x1*b[(i + 1)' na];                      goto L773;                        L785:                      t1 = (-r - zz*b[(i + 1)' na] + z1*b[(i + 1)' en])/y;                      t2 = (-s - zz*b[(i + 1)' en] - z1*b[(i + 1)' na])/y;                        L787:                      b[i' na] = t1;                      b[i' en] = t2;                        L790:                      ;                  }                    // End complex vector                  L795:                  isw = 3 - isw;                    L800:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                  if (isw == 2) goto L795;                  if (alfi[en] != 0.0) goto L710;                    // Real vector                  m = en;                  b[en' en] = 1.0;                  if (na == -1) goto L800;                  alfm = alfr[m];                  betm = beta[m];                    // for i=en-1 step -1 until 1 do --                  for (ii = 0; ii <= na; ++ii)                  {                      i = en - ii - 1;                      w = betm*a[i' i] - alfm*b[i' i];                      r = 0.0;                        for (j = m; j <= en; ++j)                          r += (betm*a[i' j] - alfm*b[i' j])*b[j' en];                        if (i == 0 || isw == 2)                          goto L630;                        if (betm*a[i' i - 1] == 0.0)                          goto L630;                        zz = w;                      s = r;                      goto L690;                        L630:                      m = i;                      if (isw == 2) goto L640;                        // Real 1-by-1 block                      t = w;                      if (w == 0.0)                          t = epsb;                      b[i' en] = -r/t;                      goto L700;                        // Real 2-by-2 block                      L640:                      x = betm*a[i' i + 1] - alfm*b[i' i + 1];                      y = betm*a[i + 1' i];                      q = w*zz - x*y;                      t = (x*s - zz*r)/q;                      b[i' en] = t;                      if (System.Math.Abs(x) <= System.Math.Abs(zz)) goto L650;                      b[i + 1' en] = (-r - w*t)/x;                      goto L690;                        L650:                      b[i + 1' en] = (-s - y*t)/zz;                        L690:                      isw = 3 - isw;                        L700:                      ;                  }                  // End real vector                  goto L800;                    // Complex vector                  L710:                  m = na;                  almr = alfr[m];                  almi = alfi[m];                  betm = beta[m];                    // last vector component chosen imaginary so that eigenvector matrix is triangular                  y = betm*a[en' na];                  b[na' na] = -almi*b[en' en]/y;                  b[na' en] = (almr*b[en' en] - betm*a[en' en])/y;                  b[en' na] = 0.0;                  b[en' en] = 1.0;                  enm2 = na;                  if (enm2 == 0) goto L795;                    // for i=en-2 step -1 until 1 do --                  for (ii = 0; ii < enm2; ++ii)                  {                      i = na - ii - 1;                      w = betm*a[i' i] - almr*b[i' i];                      w1 = -almi*b[i' i];                      ra = 0.0;                      sa = 0.0;                        for (j = m; j <= en; ++j)                      {                          x = betm*a[i' j] - almr*b[i' j];                          x1 = -almi*b[i' j];                          ra = ra + x*b[j' na] - x1*b[j' en];                          sa = sa + x*b[j' en] + x1*b[j' na];                      }                        if (i == 0 || isw == 2) goto L770;                      if (betm*a[i' i - 1] == 0.0) goto L770;                        zz = w;                      z1 = w1;                      r = ra;                      s = sa;                      isw = 2;                      goto L790;                        L770:                      m = i;                      if (isw == 2) goto L780;                        // Complex 1-by-1 block                       tr = -ra;                      ti = -sa;                        L773:                      dr = w;                      di = w1;                        // Complex divide (t1't2) = (tr'ti) / (dr'di)                      L775:                      if (System.Math.Abs(di) > System.Math.Abs(dr)) goto L777;                      rr = di/dr;                      d = dr + di*rr;                      t1 = (tr + ti*rr)/d;                      t2 = (ti - tr*rr)/d;                        switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        L777:                      rr = dr/di;                      d = dr*rr + di;                      t1 = (tr*rr + ti)/d;                      t2 = (ti*rr - tr)/d;                      switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        // Complex 2-by-2 block                       L780:                      x = betm*a[i' i + 1] - almr*b[i' i + 1];                      x1 = -almi*b[i' i + 1];                      y = betm*a[i + 1' i];                      tr = y*ra - w*r + w1*s;                      ti = y*sa - w*s - w1*r;                      dr = w*zz - w1*z1 - x*y;                      di = w*z1 + w1*zz - x1*y;                      if (dr == 0.0 && di == 0.0)                          dr = epsb;                      goto L775;                        L782:                      b[i + 1' na] = t1;                      b[i + 1' en] = t2;                      isw = 1;                      if (System.Math.Abs(y) > System.Math.Abs(w) + System.Math.Abs(w1))                          goto L785;                      tr = -ra - x*b[(i + 1)' na] + x1*b[(i + 1)' en];                      ti = -sa - x*b[(i + 1)' en] - x1*b[(i + 1)' na];                      goto L773;                        L785:                      t1 = (-r - zz*b[(i + 1)' na] + z1*b[(i + 1)' en])/y;                      t2 = (-s - zz*b[(i + 1)' en] - z1*b[(i + 1)' na])/y;                        L787:                      b[i' na] = t1;                      b[i' en] = t2;                        L790:                      ;                  }                    // End complex vector                  L795:                  isw = 3 - isw;                    L800:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                  if (isw == 2) goto L795;                  if (alfi[en] != 0.0) goto L710;                    // Real vector                  m = en;                  b[en' en] = 1.0;                  if (na == -1) goto L800;                  alfm = alfr[m];                  betm = beta[m];                    // for i=en-1 step -1 until 1 do --                  for (ii = 0; ii <= na; ++ii)                  {                      i = en - ii - 1;                      w = betm*a[i' i] - alfm*b[i' i];                      r = 0.0;                        for (j = m; j <= en; ++j)                          r += (betm*a[i' j] - alfm*b[i' j])*b[j' en];                        if (i == 0 || isw == 2)                          goto L630;                        if (betm*a[i' i - 1] == 0.0)                          goto L630;                        zz = w;                      s = r;                      goto L690;                        L630:                      m = i;                      if (isw == 2) goto L640;                        // Real 1-by-1 block                      t = w;                      if (w == 0.0)                          t = epsb;                      b[i' en] = -r/t;                      goto L700;                        // Real 2-by-2 block                      L640:                      x = betm*a[i' i + 1] - alfm*b[i' i + 1];                      y = betm*a[i + 1' i];                      q = w*zz - x*y;                      t = (x*s - zz*r)/q;                      b[i' en] = t;                      if (System.Math.Abs(x) <= System.Math.Abs(zz)) goto L650;                      b[i + 1' en] = (-r - w*t)/x;                      goto L690;                        L650:                      b[i + 1' en] = (-s - y*t)/zz;                        L690:                      isw = 3 - isw;                        L700:                      ;                  }                  // End real vector                  goto L800;                    // Complex vector                  L710:                  m = na;                  almr = alfr[m];                  almi = alfi[m];                  betm = beta[m];                    // last vector component chosen imaginary so that eigenvector matrix is triangular                  y = betm*a[en' na];                  b[na' na] = -almi*b[en' en]/y;                  b[na' en] = (almr*b[en' en] - betm*a[en' en])/y;                  b[en' na] = 0.0;                  b[en' en] = 1.0;                  enm2 = na;                  if (enm2 == 0) goto L795;                    // for i=en-2 step -1 until 1 do --                  for (ii = 0; ii < enm2; ++ii)                  {                      i = na - ii - 1;                      w = betm*a[i' i] - almr*b[i' i];                      w1 = -almi*b[i' i];                      ra = 0.0;                      sa = 0.0;                        for (j = m; j <= en; ++j)                      {                          x = betm*a[i' j] - almr*b[i' j];                          x1 = -almi*b[i' j];                          ra = ra + x*b[j' na] - x1*b[j' en];                          sa = sa + x*b[j' en] + x1*b[j' na];                      }                        if (i == 0 || isw == 2) goto L770;                      if (betm*a[i' i - 1] == 0.0) goto L770;                        zz = w;                      z1 = w1;                      r = ra;                      s = sa;                      isw = 2;                      goto L790;                        L770:                      m = i;                      if (isw == 2) goto L780;                        // Complex 1-by-1 block                       tr = -ra;                      ti = -sa;                        L773:                      dr = w;                      di = w1;                        // Complex divide (t1't2) = (tr'ti) / (dr'di)                      L775:                      if (System.Math.Abs(di) > System.Math.Abs(dr)) goto L777;                      rr = di/dr;                      d = dr + di*rr;                      t1 = (tr + ti*rr)/d;                      t2 = (ti - tr*rr)/d;                        switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        L777:                      rr = dr/di;                      d = dr*rr + di;                      t1 = (tr*rr + ti)/d;                      t2 = (ti*rr - tr)/d;                      switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        // Complex 2-by-2 block                       L780:                      x = betm*a[i' i + 1] - almr*b[i' i + 1];                      x1 = -almi*b[i' i + 1];                      y = betm*a[i + 1' i];                      tr = y*ra - w*r + w1*s;                      ti = y*sa - w*s - w1*r;                      dr = w*zz - w1*z1 - x*y;                      di = w*z1 + w1*zz - x1*y;                      if (dr == 0.0 && di == 0.0)                          dr = epsb;                      goto L775;                        L782:                      b[i + 1' na] = t1;                      b[i + 1' en] = t2;                      isw = 1;                      if (System.Math.Abs(y) > System.Math.Abs(w) + System.Math.Abs(w1))                          goto L785;                      tr = -ra - x*b[(i + 1)' na] + x1*b[(i + 1)' en];                      ti = -sa - x*b[(i + 1)' en] - x1*b[(i + 1)' na];                      goto L773;                        L785:                      t1 = (-r - zz*b[(i + 1)' na] + z1*b[(i + 1)' en])/y;                      t2 = (-s - zz*b[(i + 1)' en] - z1*b[(i + 1)' na])/y;                        L787:                      b[i' na] = t1;                      b[i' en] = t2;                        L790:                      ;                  }                    // End complex vector                  L795:                  isw = 3 - isw;                    L800:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                  if (isw == 2) goto L795;                  if (alfi[en] != 0.0) goto L710;                    // Real vector                  m = en;                  b[en' en] = 1.0;                  if (na == -1) goto L800;                  alfm = alfr[m];                  betm = beta[m];                    // for i=en-1 step -1 until 1 do --                  for (ii = 0; ii <= na; ++ii)                  {                      i = en - ii - 1;                      w = betm*a[i' i] - alfm*b[i' i];                      r = 0.0;                        for (j = m; j <= en; ++j)                          r += (betm*a[i' j] - alfm*b[i' j])*b[j' en];                        if (i == 0 || isw == 2)                          goto L630;                        if (betm*a[i' i - 1] == 0.0)                          goto L630;                        zz = w;                      s = r;                      goto L690;                        L630:                      m = i;                      if (isw == 2) goto L640;                        // Real 1-by-1 block                      t = w;                      if (w == 0.0)                          t = epsb;                      b[i' en] = -r/t;                      goto L700;                        // Real 2-by-2 block                      L640:                      x = betm*a[i' i + 1] - alfm*b[i' i + 1];                      y = betm*a[i + 1' i];                      q = w*zz - x*y;                      t = (x*s - zz*r)/q;                      b[i' en] = t;                      if (System.Math.Abs(x) <= System.Math.Abs(zz)) goto L650;                      b[i + 1' en] = (-r - w*t)/x;                      goto L690;                        L650:                      b[i + 1' en] = (-s - y*t)/zz;                        L690:                      isw = 3 - isw;                        L700:                      ;                  }                  // End real vector                  goto L800;                    // Complex vector                  L710:                  m = na;                  almr = alfr[m];                  almi = alfi[m];                  betm = beta[m];                    // last vector component chosen imaginary so that eigenvector matrix is triangular                  y = betm*a[en' na];                  b[na' na] = -almi*b[en' en]/y;                  b[na' en] = (almr*b[en' en] - betm*a[en' en])/y;                  b[en' na] = 0.0;                  b[en' en] = 1.0;                  enm2 = na;                  if (enm2 == 0) goto L795;                    // for i=en-2 step -1 until 1 do --                  for (ii = 0; ii < enm2; ++ii)                  {                      i = na - ii - 1;                      w = betm*a[i' i] - almr*b[i' i];                      w1 = -almi*b[i' i];                      ra = 0.0;                      sa = 0.0;                        for (j = m; j <= en; ++j)                      {                          x = betm*a[i' j] - almr*b[i' j];                          x1 = -almi*b[i' j];                          ra = ra + x*b[j' na] - x1*b[j' en];                          sa = sa + x*b[j' en] + x1*b[j' na];                      }                        if (i == 0 || isw == 2) goto L770;                      if (betm*a[i' i - 1] == 0.0) goto L770;                        zz = w;                      z1 = w1;                      r = ra;                      s = sa;                      isw = 2;                      goto L790;                        L770:                      m = i;                      if (isw == 2) goto L780;                        // Complex 1-by-1 block                       tr = -ra;                      ti = -sa;                        L773:                      dr = w;                      di = w1;                        // Complex divide (t1't2) = (tr'ti) / (dr'di)                      L775:                      if (System.Math.Abs(di) > System.Math.Abs(dr)) goto L777;                      rr = di/dr;                      d = dr + di*rr;                      t1 = (tr + ti*rr)/d;                      t2 = (ti - tr*rr)/d;                        switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        L777:                      rr = dr/di;                      d = dr*rr + di;                      t1 = (tr*rr + ti)/d;                      t2 = (ti*rr - tr)/d;                      switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        // Complex 2-by-2 block                       L780:                      x = betm*a[i' i + 1] - almr*b[i' i + 1];                      x1 = -almi*b[i' i + 1];                      y = betm*a[i + 1' i];                      tr = y*ra - w*r + w1*s;                      ti = y*sa - w*s - w1*r;                      dr = w*zz - w1*z1 - x*y;                      di = w*z1 + w1*zz - x1*y;                      if (dr == 0.0 && di == 0.0)                          dr = epsb;                      goto L775;                        L782:                      b[i + 1' na] = t1;                      b[i + 1' en] = t2;                      isw = 1;                      if (System.Math.Abs(y) > System.Math.Abs(w) + System.Math.Abs(w1))                          goto L785;                      tr = -ra - x*b[(i + 1)' na] + x1*b[(i + 1)' en];                      ti = -sa - x*b[(i + 1)' en] - x1*b[(i + 1)' na];                      goto L773;                        L785:                      t1 = (-r - zz*b[(i + 1)' na] + z1*b[(i + 1)' en])/y;                      t2 = (-s - zz*b[(i + 1)' en] - z1*b[(i + 1)' na])/y;                        L787:                      b[i' na] = t1;                      b[i' en] = t2;                        L790:                      ;                  }                    // End complex vector                  L795:                  isw = 3 - isw;                    L800:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                  if (isw == 2) goto L795;                  if (alfi[en] != 0.0) goto L710;                    // Real vector                  m = en;                  b[en' en] = 1.0;                  if (na == -1) goto L800;                  alfm = alfr[m];                  betm = beta[m];                    // for i=en-1 step -1 until 1 do --                  for (ii = 0; ii <= na; ++ii)                  {                      i = en - ii - 1;                      w = betm*a[i' i] - alfm*b[i' i];                      r = 0.0;                        for (j = m; j <= en; ++j)                          r += (betm*a[i' j] - alfm*b[i' j])*b[j' en];                        if (i == 0 || isw == 2)                          goto L630;                        if (betm*a[i' i - 1] == 0.0)                          goto L630;                        zz = w;                      s = r;                      goto L690;                        L630:                      m = i;                      if (isw == 2) goto L640;                        // Real 1-by-1 block                      t = w;                      if (w == 0.0)                          t = epsb;                      b[i' en] = -r/t;                      goto L700;                        // Real 2-by-2 block                      L640:                      x = betm*a[i' i + 1] - alfm*b[i' i + 1];                      y = betm*a[i + 1' i];                      q = w*zz - x*y;                      t = (x*s - zz*r)/q;                      b[i' en] = t;                      if (System.Math.Abs(x) <= System.Math.Abs(zz)) goto L650;                      b[i + 1' en] = (-r - w*t)/x;                      goto L690;                        L650:                      b[i + 1' en] = (-s - y*t)/zz;                        L690:                      isw = 3 - isw;                        L700:                      ;                  }                  // End real vector                  goto L800;                    // Complex vector                  L710:                  m = na;                  almr = alfr[m];                  almi = alfi[m];                  betm = beta[m];                    // last vector component chosen imaginary so that eigenvector matrix is triangular                  y = betm*a[en' na];                  b[na' na] = -almi*b[en' en]/y;                  b[na' en] = (almr*b[en' en] - betm*a[en' en])/y;                  b[en' na] = 0.0;                  b[en' en] = 1.0;                  enm2 = na;                  if (enm2 == 0) goto L795;                    // for i=en-2 step -1 until 1 do --                  for (ii = 0; ii < enm2; ++ii)                  {                      i = na - ii - 1;                      w = betm*a[i' i] - almr*b[i' i];                      w1 = -almi*b[i' i];                      ra = 0.0;                      sa = 0.0;                        for (j = m; j <= en; ++j)                      {                          x = betm*a[i' j] - almr*b[i' j];                          x1 = -almi*b[i' j];                          ra = ra + x*b[j' na] - x1*b[j' en];                          sa = sa + x*b[j' en] + x1*b[j' na];                      }                        if (i == 0 || isw == 2) goto L770;                      if (betm*a[i' i - 1] == 0.0) goto L770;                        zz = w;                      z1 = w1;                      r = ra;                      s = sa;                      isw = 2;                      goto L790;                        L770:                      m = i;                      if (isw == 2) goto L780;                        // Complex 1-by-1 block                       tr = -ra;                      ti = -sa;                        L773:                      dr = w;                      di = w1;                        // Complex divide (t1't2) = (tr'ti) / (dr'di)                      L775:                      if (System.Math.Abs(di) > System.Math.Abs(dr)) goto L777;                      rr = di/dr;                      d = dr + di*rr;                      t1 = (tr + ti*rr)/d;                      t2 = (ti - tr*rr)/d;                        switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        L777:                      rr = dr/di;                      d = dr*rr + di;                      t1 = (tr*rr + ti)/d;                      t2 = (ti*rr - tr)/d;                      switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        // Complex 2-by-2 block                       L780:                      x = betm*a[i' i + 1] - almr*b[i' i + 1];                      x1 = -almi*b[i' i + 1];                      y = betm*a[i + 1' i];                      tr = y*ra - w*r + w1*s;                      ti = y*sa - w*s - w1*r;                      dr = w*zz - w1*z1 - x*y;                      di = w*z1 + w1*zz - x1*y;                      if (dr == 0.0 && di == 0.0)                          dr = epsb;                      goto L775;                        L782:                      b[i + 1' na] = t1;                      b[i + 1' en] = t2;                      isw = 1;                      if (System.Math.Abs(y) > System.Math.Abs(w) + System.Math.Abs(w1))                          goto L785;                      tr = -ra - x*b[(i + 1)' na] + x1*b[(i + 1)' en];                      ti = -sa - x*b[(i + 1)' en] - x1*b[(i + 1)' na];                      goto L773;                        L785:                      t1 = (-r - zz*b[(i + 1)' na] + z1*b[(i + 1)' en])/y;                      t2 = (-s - zz*b[(i + 1)' en] - z1*b[(i + 1)' na])/y;                        L787:                      b[i' na] = t1;                      b[i' en] = t2;                        L790:                      ;                  }                    // End complex vector                  L795:                  isw = 3 - isw;                    L800:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: for (nn = 0; nn < n; ++nn)              {                  en = n - nn - 1;                  na = en - 1;                  if (isw == 2) goto L795;                  if (alfi[en] != 0.0) goto L710;                    // Real vector                  m = en;                  b[en' en] = 1.0;                  if (na == -1) goto L800;                  alfm = alfr[m];                  betm = beta[m];                    // for i=en-1 step -1 until 1 do --                  for (ii = 0; ii <= na; ++ii)                  {                      i = en - ii - 1;                      w = betm*a[i' i] - alfm*b[i' i];                      r = 0.0;                        for (j = m; j <= en; ++j)                          r += (betm*a[i' j] - alfm*b[i' j])*b[j' en];                        if (i == 0 || isw == 2)                          goto L630;                        if (betm*a[i' i - 1] == 0.0)                          goto L630;                        zz = w;                      s = r;                      goto L690;                        L630:                      m = i;                      if (isw == 2) goto L640;                        // Real 1-by-1 block                      t = w;                      if (w == 0.0)                          t = epsb;                      b[i' en] = -r/t;                      goto L700;                        // Real 2-by-2 block                      L640:                      x = betm*a[i' i + 1] - alfm*b[i' i + 1];                      y = betm*a[i + 1' i];                      q = w*zz - x*y;                      t = (x*s - zz*r)/q;                      b[i' en] = t;                      if (System.Math.Abs(x) <= System.Math.Abs(zz)) goto L650;                      b[i + 1' en] = (-r - w*t)/x;                      goto L690;                        L650:                      b[i + 1' en] = (-s - y*t)/zz;                        L690:                      isw = 3 - isw;                        L700:                      ;                  }                  // End real vector                  goto L800;                    // Complex vector                  L710:                  m = na;                  almr = alfr[m];                  almi = alfi[m];                  betm = beta[m];                    // last vector component chosen imaginary so that eigenvector matrix is triangular                  y = betm*a[en' na];                  b[na' na] = -almi*b[en' en]/y;                  b[na' en] = (almr*b[en' en] - betm*a[en' en])/y;                  b[en' na] = 0.0;                  b[en' en] = 1.0;                  enm2 = na;                  if (enm2 == 0) goto L795;                    // for i=en-2 step -1 until 1 do --                  for (ii = 0; ii < enm2; ++ii)                  {                      i = na - ii - 1;                      w = betm*a[i' i] - almr*b[i' i];                      w1 = -almi*b[i' i];                      ra = 0.0;                      sa = 0.0;                        for (j = m; j <= en; ++j)                      {                          x = betm*a[i' j] - almr*b[i' j];                          x1 = -almi*b[i' j];                          ra = ra + x*b[j' na] - x1*b[j' en];                          sa = sa + x*b[j' en] + x1*b[j' na];                      }                        if (i == 0 || isw == 2) goto L770;                      if (betm*a[i' i - 1] == 0.0) goto L770;                        zz = w;                      z1 = w1;                      r = ra;                      s = sa;                      isw = 2;                      goto L790;                        L770:                      m = i;                      if (isw == 2) goto L780;                        // Complex 1-by-1 block                       tr = -ra;                      ti = -sa;                        L773:                      dr = w;                      di = w1;                        // Complex divide (t1't2) = (tr'ti) / (dr'di)                      L775:                      if (System.Math.Abs(di) > System.Math.Abs(dr)) goto L777;                      rr = di/dr;                      d = dr + di*rr;                      t1 = (tr + ti*rr)/d;                      t2 = (ti - tr*rr)/d;                        switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        L777:                      rr = dr/di;                      d = dr*rr + di;                      t1 = (tr*rr + ti)/d;                      t2 = (ti*rr - tr)/d;                      switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }                        // Complex 2-by-2 block                       L780:                      x = betm*a[i' i + 1] - almr*b[i' i + 1];                      x1 = -almi*b[i' i + 1];                      y = betm*a[i + 1' i];                      tr = y*ra - w*r + w1*s;                      ti = y*sa - w*s - w1*r;                      dr = w*zz - w1*z1 - x*y;                      di = w*z1 + w1*zz - x1*y;                      if (dr == 0.0 && di == 0.0)                          dr = epsb;                      goto L775;                        L782:                      b[i + 1' na] = t1;                      b[i + 1' en] = t2;                      isw = 1;                      if (System.Math.Abs(y) > System.Math.Abs(w) + System.Math.Abs(w1))                          goto L785;                      tr = -ra - x*b[(i + 1)' na] + x1*b[(i + 1)' en];                      ti = -sa - x*b[(i + 1)' en] - x1*b[(i + 1)' na];                      goto L773;                        L785:                      t1 = (-r - zz*b[(i + 1)' na] + z1*b[(i + 1)' en])/y;                      t2 = (-s - zz*b[(i + 1)' en] - z1*b[(i + 1)' na])/y;                        L787:                      b[i' na] = t1;                      b[i' en] = t2;                        L790:                      ;                  }                    // End complex vector                  L795:                  isw = 3 - isw;                    L800:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: for (j = 0; j < n; ++j)              {                  d = 0.0;                  if (isw == 2) goto L920;                  if (alfi[j] != 0.0) goto L945;                    for (i = 0; i < n; ++i)                  {                      if ((System.Math.Abs(z[i' j])) > d)                          d = (System.Math.Abs(z[i' j]));                  }                    for (i = 0; i < n; ++i)                      z[i' j] /= d;                    goto L950;                    L920:                  for (i = 0; i < n; ++i)                  {                      r = System.Math.Abs(z[i' j - 1]) + System.Math.Abs(z[i' j]);                      if (r != 0.0)                      {                          // Computing 2nd power                          double u1 = z[i' j - 1]/r;                          double u2 = z[i' j]/r;                          r *= System.Math.Sqrt(u1*u1 + u2*u2);                      }                      if (r > d)                          d = r;                  }                    for (i = 0; i < n; ++i)                  {                      z[i' j - 1] /= d;                      z[i' j] /= d;                  }                    L945:                  isw = 3 - isw;                    L950:                  ;              }
Magic Number,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following statement contains a magic number: for (j = 0; j < n; ++j)              {                  d = 0.0;                  if (isw == 2) goto L920;                  if (alfi[j] != 0.0) goto L945;                    for (i = 0; i < n; ++i)                  {                      if ((System.Math.Abs(z[i' j])) > d)                          d = (System.Math.Abs(z[i' j]));                  }                    for (i = 0; i < n; ++i)                      z[i' j] /= d;                    goto L950;                    L920:                  for (i = 0; i < n; ++i)                  {                      r = System.Math.Abs(z[i' j - 1]) + System.Math.Abs(z[i' j]);                      if (r != 0.0)                      {                          // Computing 2nd power                          double u1 = z[i' j - 1]/r;                          double u2 = z[i' j]/r;                          r *= System.Math.Sqrt(u1*u1 + u2*u2);                      }                      if (r > d)                          d = r;                  }                    for (i = 0; i < n; ++i)                  {                      z[i' j - 1] /= d;                      z[i' j] /= d;                  }                    L945:                  isw = 3 - isw;                    L950:                  ;              }
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' k' NonnegativeFactorizationAlgorithm.AlternateLeastSquares'                   null' null' attempts' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' k' NonnegativeFactorizationAlgorithm.AlternateLeastSquares'                   null' null' attempts' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' k' NonnegativeFactorizationAlgorithm.AlternateLeastSquares'                   null' null' attempts' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' k' algorithm' null' null' 1' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' k' algorithm' null' null' 1' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' k' algorithm' null' null' 1' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' w0.GetLength(1)' NonnegativeFactorizationAlgorithm.AlternateLeastSquares' h0' w0' 1' 100' 1e-4'                   1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' w0.GetLength(1)' NonnegativeFactorizationAlgorithm.AlternateLeastSquares' h0' w0' 1' 100' 1e-4'                   1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' w0.GetLength(1)' NonnegativeFactorizationAlgorithm.AlternateLeastSquares' h0' w0' 1' 100' 1e-4'                   1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' w0.GetLength(1)' algorithm' h0' w0' 1' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' w0.GetLength(1)' algorithm' h0' w0' 1' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,NonnegativeFactorization,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\NonnegativeFactorization.cs,NonnegativeFactorization,The following statement contains a magic number: init(value' w0.GetLength(1)' algorithm' h0' w0' 1' 100' 1e-4' 1e-4);
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double eps = System.Math.Pow(2.0' -52.0);
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double eps = System.Math.Pow(2.0' -52.0);
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double tiny = System.Math.Pow(2.0' -966.0);
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: double tiny = System.Math.Pow(2.0' -966.0);
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: int nrt = System.Math.Max(0' System.Math.Min(n - 2' m));
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                        if (System.Math.Abs(e[k]) <=                          tiny + eps*(System.Math.Abs(s[k]) + System.Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                  {                      kase = 4;                  }                  else                  {                      int ks;                      for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                            double t = (ks != p ? System.Math.Abs(e[ks]) : 0.0) +                                     (ks != k + 1 ? System.Math.Abs(e[ks - 1]) : 0.0);                          if (System.Math.Abs(s[ks]) <= tiny + eps*t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,Accord.Math,Distance,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Distance.cs,Bhattacharyya,The following statement contains a magic number: for (int i = 0; i < n; i++)                  for (int j = 0; j < n - i; j++)                      P[j' i] = P[i' j] = (covX[i' j] + covY[i' j])/2.0;
Magic Number,Accord.Math,Distance,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Distance.cs,Bhattacharyya,The following statement contains a magic number: return (1.0/8.0)*SquareMahalanobis(meanY' meanX' P.Inverse())                     + (0.5)*System.Math.Log(detP/System.Math.Sqrt(detP1*detP2));
Magic Number,Accord.Math,Distance,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Distance.cs,Bhattacharyya,The following statement contains a magic number: return (1.0/8.0)*SquareMahalanobis(meanY' meanX' P.Inverse())                     + (0.5)*System.Math.Log(detP/System.Math.Sqrt(detP1*detP2));
Magic Number,Accord.Math,HilbertTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: if (direction == FourierTransform.Direction.Forward)              {                  // Copy the input to a complex array which can be processed                  //  in the complex domain by the FFT                  var cdata = new Complex[N];                  for (int i = 0; i < N; i++)                      cdata[i].Re = data[i];                    // Perform FFT                  FourierTransform.FFT(cdata' FourierTransform.Direction.Forward);                    //double positive frequencies                  for (int i = 1; i < (N/2); i++)                  {                      cdata[i].Re *= 2.0;                      cdata[i].Im *= 2.0;                  }                    // zero out negative frequencies                  //  (leaving out the dc component)                  for (int i = (N/2) + 1; i < N; i++)                  {                      cdata[i].Re = 0.0;                      cdata[i].Im = 0.0;                  }                    // Reverse the FFT                  FourierTransform.FFT(cdata' FourierTransform.Direction.Backward);                    // Convert back to our initial double array                  for (int i = 0; i < N; i++)                      data[i] = cdata[i].Im;              }                else // Backward operation              {                  // The inverse Hilbert can be calculated by                  //  negating the transform and reapplying the                  //  transformation.                  //                  // H^1{h(t)} = H{h(t)}                    FHT(data' FourierTransform.Direction.Forward);                    for (int i = 0; i < data.Length; i++)                      data[i] = -data[i];              }
Magic Number,Accord.Math,HilbertTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: if (direction == FourierTransform.Direction.Forward)              {                  // Copy the input to a complex array which can be processed                  //  in the complex domain by the FFT                  var cdata = new Complex[N];                  for (int i = 0; i < N; i++)                      cdata[i].Re = data[i];                    // Perform FFT                  FourierTransform.FFT(cdata' FourierTransform.Direction.Forward);                    //double positive frequencies                  for (int i = 1; i < (N/2); i++)                  {                      cdata[i].Re *= 2.0;                      cdata[i].Im *= 2.0;                  }                    // zero out negative frequencies                  //  (leaving out the dc component)                  for (int i = (N/2) + 1; i < N; i++)                  {                      cdata[i].Re = 0.0;                      cdata[i].Im = 0.0;                  }                    // Reverse the FFT                  FourierTransform.FFT(cdata' FourierTransform.Direction.Backward);                    // Convert back to our initial double array                  for (int i = 0; i < N; i++)                      data[i] = cdata[i].Im;              }                else // Backward operation              {                  // The inverse Hilbert can be calculated by                  //  negating the transform and reapplying the                  //  transformation.                  //                  // H^1{h(t)} = H{h(t)}                    FHT(data' FourierTransform.Direction.Forward);                    for (int i = 0; i < data.Length; i++)                      data[i] = -data[i];              }
Magic Number,Accord.Math,HilbertTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: if (direction == FourierTransform.Direction.Forward)              {                  // Copy the input to a complex array which can be processed                  //  in the complex domain by the FFT                  var cdata = new Complex[N];                  for (int i = 0; i < N; i++)                      cdata[i].Re = data[i];                    // Perform FFT                  FourierTransform.FFT(cdata' FourierTransform.Direction.Forward);                    //double positive frequencies                  for (int i = 1; i < (N/2); i++)                  {                      cdata[i].Re *= 2.0;                      cdata[i].Im *= 2.0;                  }                    // zero out negative frequencies                  //  (leaving out the dc component)                  for (int i = (N/2) + 1; i < N; i++)                  {                      cdata[i].Re = 0.0;                      cdata[i].Im = 0.0;                  }                    // Reverse the FFT                  FourierTransform.FFT(cdata' FourierTransform.Direction.Backward);                    // Convert back to our initial double array                  for (int i = 0; i < N; i++)                      data[i] = cdata[i].Im;              }                else // Backward operation              {                  // The inverse Hilbert can be calculated by                  //  negating the transform and reapplying the                  //  transformation.                  //                  // H^1{h(t)} = H{h(t)}                    FHT(data' FourierTransform.Direction.Forward);                    for (int i = 0; i < data.Length; i++)                      data[i] = -data[i];              }
Magic Number,Accord.Math,HilbertTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: if (direction == FourierTransform.Direction.Forward)              {                  // Copy the input to a complex array which can be processed                  //  in the complex domain by the FFT                  var cdata = new Complex[N];                  for (int i = 0; i < N; i++)                      cdata[i].Re = data[i];                    // Perform FFT                  FourierTransform.FFT(cdata' FourierTransform.Direction.Forward);                    //double positive frequencies                  for (int i = 1; i < (N/2); i++)                  {                      cdata[i].Re *= 2.0;                      cdata[i].Im *= 2.0;                  }                    // zero out negative frequencies                  //  (leaving out the dc component)                  for (int i = (N/2) + 1; i < N; i++)                  {                      cdata[i].Re = 0.0;                      cdata[i].Im = 0.0;                  }                    // Reverse the FFT                  FourierTransform.FFT(cdata' FourierTransform.Direction.Backward);                    // Convert back to our initial double array                  for (int i = 0; i < N; i++)                      data[i] = cdata[i].Im;              }                else // Backward operation              {                  // The inverse Hilbert can be calculated by                  //  negating the transform and reapplying the                  //  transformation.                  //                  // H^1{h(t)} = H{h(t)}                    FHT(data' FourierTransform.Direction.Forward);                    for (int i = 0; i < data.Length; i++)                      data[i] = -data[i];              }
Magic Number,Accord.Math,HilbertTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: if (direction == FourierTransform.Direction.Forward)              {                  // Makes a copy of the data so we don't lose the                  //  original information to build our final signal                  var shift = (Complex[]) data.Clone();                    // Perform FFT                  FourierTransform.FFT(shift' FourierTransform.Direction.Backward);                    //double positive frequencies                  for (int i = 1; i < (N/2); i++)                  {                      shift[i].Re *= 2.0;                      shift[i].Im *= 2.0;                  }                  // zero out negative frequencies                  //  (leaving out the dc component)                  for (int i = (N/2) + 1; i < N; i++)                  {                      shift[i].Re = 0.0;                      shift[i].Im = 0.0;                  }                    // Reverse the FFT                  FourierTransform.FFT(shift' FourierTransform.Direction.Forward);                    // Put the Hilbert transform in the Imaginary part                  //  of the input signal' creating a Analytic Signal                  for (int i = 0; i < N; i++)                      data[i].Im = shift[i].Im;              }                else // Backward operation              {                  // Just discard the imaginary part                  for (int i = 0; i < data.Length; i++)                      data[i].Im = 0.0;              }
Magic Number,Accord.Math,HilbertTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: if (direction == FourierTransform.Direction.Forward)              {                  // Makes a copy of the data so we don't lose the                  //  original information to build our final signal                  var shift = (Complex[]) data.Clone();                    // Perform FFT                  FourierTransform.FFT(shift' FourierTransform.Direction.Backward);                    //double positive frequencies                  for (int i = 1; i < (N/2); i++)                  {                      shift[i].Re *= 2.0;                      shift[i].Im *= 2.0;                  }                  // zero out negative frequencies                  //  (leaving out the dc component)                  for (int i = (N/2) + 1; i < N; i++)                  {                      shift[i].Re = 0.0;                      shift[i].Im = 0.0;                  }                    // Reverse the FFT                  FourierTransform.FFT(shift' FourierTransform.Direction.Forward);                    // Put the Hilbert transform in the Imaginary part                  //  of the input signal' creating a Analytic Signal                  for (int i = 0; i < N; i++)                      data[i].Im = shift[i].Im;              }                else // Backward operation              {                  // Just discard the imaginary part                  for (int i = 0; i < data.Length; i++)                      data[i].Im = 0.0;              }
Magic Number,Accord.Math,HilbertTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: if (direction == FourierTransform.Direction.Forward)              {                  // Makes a copy of the data so we don't lose the                  //  original information to build our final signal                  var shift = (Complex[]) data.Clone();                    // Perform FFT                  FourierTransform.FFT(shift' FourierTransform.Direction.Backward);                    //double positive frequencies                  for (int i = 1; i < (N/2); i++)                  {                      shift[i].Re *= 2.0;                      shift[i].Im *= 2.0;                  }                  // zero out negative frequencies                  //  (leaving out the dc component)                  for (int i = (N/2) + 1; i < N; i++)                  {                      shift[i].Re = 0.0;                      shift[i].Im = 0.0;                  }                    // Reverse the FFT                  FourierTransform.FFT(shift' FourierTransform.Direction.Forward);                    // Put the Hilbert transform in the Imaginary part                  //  of the input signal' creating a Analytic Signal                  for (int i = 0; i < N; i++)                      data[i].Im = shift[i].Im;              }                else // Backward operation              {                  // Just discard the imaginary part                  for (int i = 0; i < data.Length; i++)                      data[i].Im = 0.0;              }
Magic Number,Accord.Math,HilbertTransform,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\HilbertTransform.cs,FHT,The following statement contains a magic number: if (direction == FourierTransform.Direction.Forward)              {                  // Makes a copy of the data so we don't lose the                  //  original information to build our final signal                  var shift = (Complex[]) data.Clone();                    // Perform FFT                  FourierTransform.FFT(shift' FourierTransform.Direction.Backward);                    //double positive frequencies                  for (int i = 1; i < (N/2); i++)                  {                      shift[i].Re *= 2.0;                      shift[i].Im *= 2.0;                  }                  // zero out negative frequencies                  //  (leaving out the dc component)                  for (int i = (N/2) + 1; i < N; i++)                  {                      shift[i].Re = 0.0;                      shift[i].Im = 0.0;                  }                    // Reverse the FFT                  FourierTransform.FFT(shift' FourierTransform.Direction.Forward);                    // Put the Hilbert transform in the Imaginary part                  //  of the input signal' creating a Analytic Signal                  for (int i = 0; i < N; i++)                      data[i].Im = shift[i].Im;              }                else // Backward operation              {                  // Just discard the imaginary part                  for (int i = 0; i < data.Length; i++)                      data[i].Im = 0.0;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,VectorProduct,The following statement contains a magic number: return new[]                         {                             a[1]*b[2] - a[2]*b[1]'                             a[2]*b[0] - a[0]*b[2]'                             a[0]*b[1] - a[1]*b[0]                         };
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if (size < 3)                  throw new ArgumentException("The square size must be greater or equal to 3."' "size");
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,Matrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Algebra.cs,Magic,The following statement contains a magic number: if ((size%2) == 1)              {                  int a = (size + 1)/2;                  int b = (size + 1);                    for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          matrix[i' j] = size*((i + j + a)%size) + ((i + 2*j + b)%size) + 1;              }                    // Second algorithm: Even order (double)              else if ((size%4) == 0)              {                  for (int j = 0; j < size; j++)                      for (int i = 0; i < size; i++)                          if (((i + 1)/2)%2 == ((j + 1)/2)%2)                              matrix[i' j] = size*size - size*i - j;                          else                              matrix[i' j] = size*i + j + 1;              }                    // Third algorithm: Even order (single)              else              {                  int n = size/2;                  int p = (size - 2)/4;                  double t;                    double['] block = Magic(n);                    for (int j = 0; j < n; j++)                  {                      for (int i = 0; i < n; i++)                      {                          double e = block[i' j];                          matrix[i' j] = e;                          matrix[i' j + n] = e + 2*n*n;                          matrix[i + n' j] = e + 3*n*n;                          matrix[i + n' j + n] = e + n*n;                      }                  }                    for (int i = 0; i < n; i++)                  {                      // Swap M[i'j] and M[i+n'j]                      for (int j = 0; j < p; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                      for (int j = size - p + 1; j < size; j++)                      {                          t = matrix[i' j];                          matrix[i' j] = matrix[i + n' j];                          matrix[i + n' j] = t;                      }                  }                    // Continue swaping in the boundary                  t = matrix[p' 0];                  matrix[p' 0] = matrix[p + n' 0];                  matrix[p + n' 0] = t;                    t = matrix[p' p];                  matrix[p' p] = matrix[p + n' p];                  matrix[p + n' p] = t;              }
Magic Number,Accord.Math,ComplexMatrix,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Matrix\Matrix.Complex.cs,ToArray,The following statement contains a magic number: var arr = new double[c.Length'2];
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] P =                  {                      1.60119522476751861407E-4'                      1.19135147006586384913E-3'                      1.04213797561761569935E-2'                      4.76367800457137231464E-2'                      2.07448227648435975150E-1'                      4.94214826801497100753E-1'                      9.99999999999999996796E-1                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] P =                  {                      1.60119522476751861407E-4'                      1.19135147006586384913E-3'                      1.04213797561761569935E-2'                      4.76367800457137231464E-2'                      2.07448227648435975150E-1'                      4.94214826801497100753E-1'                      9.99999999999999996796E-1                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] P =                  {                      1.60119522476751861407E-4'                      1.19135147006586384913E-3'                      1.04213797561761569935E-2'                      4.76367800457137231464E-2'                      2.07448227648435975150E-1'                      4.94214826801497100753E-1'                      9.99999999999999996796E-1                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] P =                  {                      1.60119522476751861407E-4'                      1.19135147006586384913E-3'                      1.04213797561761569935E-2'                      4.76367800457137231464E-2'                      2.07448227648435975150E-1'                      4.94214826801497100753E-1'                      9.99999999999999996796E-1                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] P =                  {                      1.60119522476751861407E-4'                      1.19135147006586384913E-3'                      1.04213797561761569935E-2'                      4.76367800457137231464E-2'                      2.07448227648435975150E-1'                      4.94214826801497100753E-1'                      9.99999999999999996796E-1                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] P =                  {                      1.60119522476751861407E-4'                      1.19135147006586384913E-3'                      1.04213797561761569935E-2'                      4.76367800457137231464E-2'                      2.07448227648435975150E-1'                      4.94214826801497100753E-1'                      9.99999999999999996796E-1                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: double[] Q =                  {                      -2.31581873324120129819E-5'                      5.39605580493303397842E-4'                      -4.45641913851797240494E-3'                      1.18139785222060435552E-2'                      3.58236398605498653373E-2'                      -2.34591795718243348568E-1'                      7.14304917030273074085E-2'                      1.00000000000000000320E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: if (q > 33.0)              {                  if (x < 0.0)                  {                      p = System.Math.Floor(q);                        if (p == q)                          throw new OverflowException();                        z = q - p;                      if (z > 0.5)                      {                          p += 1.0;                          z = q - p;                      }                      z = q*System.Math.Sin(System.Math.PI*z);                        if (z == 0.0)                          throw new OverflowException();                        z = System.Math.Abs(z);                      z = System.Math.PI/(z*Stirf(q));                        return -z;                  }                  else                  {                      return Stirf(x);                  }              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: if (q > 33.0)              {                  if (x < 0.0)                  {                      p = System.Math.Floor(q);                        if (p == q)                          throw new OverflowException();                        z = q - p;                      if (z > 0.5)                      {                          p += 1.0;                          z = q - p;                      }                      z = q*System.Math.Sin(System.Math.PI*z);                        if (z == 0.0)                          throw new OverflowException();                        z = System.Math.Abs(z);                      z = System.Math.PI/(z*Stirf(q));                        return -z;                  }                  else                  {                      return Stirf(x);                  }              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: while (x >= 3.0)              {                  x -= 1.0;                  z *= x;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: while (x < 0.0)              {                  if (x == 0.0)                  {                      throw new ArithmeticException();                  }                  else if (x > -1.0E-9)                  {                      return (z/((1.0 + 0.5772156649015329*x)*x));                  }                  z /= x;                  x += 1.0;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: while (x < 0.0)              {                  if (x == 0.0)                  {                      throw new ArithmeticException();                  }                  else if (x > -1.0E-9)                  {                      return (z/((1.0 + 0.5772156649015329*x)*x));                  }                  z /= x;                  x += 1.0;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: while (x < 2.0)              {                  if (x == 0.0)                  {                      throw new ArithmeticException();                  }                  else if (x < 1.0E-9)                  {                      return (z/((1.0 + 0.5772156649015329*x)*x));                  }                    z /= x;                  x += 1.0;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: while (x < 2.0)              {                  if (x == 0.0)                  {                      throw new ArithmeticException();                  }                  else if (x < 1.0E-9)                  {                      return (z/((1.0 + 0.5772156649015329*x)*x));                  }                    z /= x;                  x += 1.0;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: while (x < 2.0)              {                  if (x == 0.0)                  {                      throw new ArithmeticException();                  }                  else if (x < 1.0E-9)                  {                      return (z/((1.0 + 0.5772156649015329*x)*x));                  }                    z /= x;                  x += 1.0;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: if ((x == 2.0) || (x == 3.0)) return z;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: if ((x == 2.0) || (x == 3.0)) return z;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: x -= 2.0;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: p = Polevl(x' P' 6);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Gamma,The following statement contains a magic number: q = Polevl(x' Q' 7);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 0.0)              {                  negative = true;                  double q = x;                  double p = (int) System.Math.Floor(q);                    if (p == q)                      throw new OverflowException("Function computation resulted in arithmetic overflow.");                    nz = q - p;                    if (nz != 0.5)                  {                      if (nz > 0.5)                      {                          p = p + 1.0;                          nz = q - p;                      }                      nz = System.Math.PI/System.Math.Tan(System.Math.PI*nz);                  }                  else                  {                      nz = 0.0;                  }                    x = 1.0 - x;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 0.0)              {                  negative = true;                  double q = x;                  double p = (int) System.Math.Floor(q);                    if (p == q)                      throw new OverflowException("Function computation resulted in arithmetic overflow.");                    nz = q - p;                    if (nz != 0.5)                  {                      if (nz > 0.5)                      {                          p = p + 1.0;                          nz = q - p;                      }                      nz = System.Math.PI/System.Math.Tan(System.Math.PI*nz);                  }                  else                  {                      nz = 0.0;                  }                    x = 1.0 - x;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 10.0 & x == System.Math.Floor(x))              {                  y = 0.0;                  var n = (int) System.Math.Floor(x);                  for (int i = 1; i <= n - 1; i++)                  {                      w = i;                      y = y + 1.0/w;                  }                  y = y - 0.57721566490153286061;              }              else              {                  s = x;                  w = 0.0;                    while (s < 10.0)                  {                      w = w + 1.0/s;                      s = s + 1.0;                  }                    if (s < 1.0E17)                  {                      z = 1.0/(s*s);                        double polv = 8.33333333333333333333E-2;                      polv = polv*z - 2.10927960927960927961E-2;                      polv = polv*z + 7.57575757575757575758E-3;                      polv = polv*z - 4.16666666666666666667E-3;                      polv = polv*z + 3.96825396825396825397E-3;                      polv = polv*z - 8.33333333333333333333E-3;                      polv = polv*z + 8.33333333333333333333E-2;                      y = z*polv;                  }                  else                  {                      y = 0.0;                  }                  y = System.Math.Log(s) - 0.5/s - y - w;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 10.0 & x == System.Math.Floor(x))              {                  y = 0.0;                  var n = (int) System.Math.Floor(x);                  for (int i = 1; i <= n - 1; i++)                  {                      w = i;                      y = y + 1.0/w;                  }                  y = y - 0.57721566490153286061;              }              else              {                  s = x;                  w = 0.0;                    while (s < 10.0)                  {                      w = w + 1.0/s;                      s = s + 1.0;                  }                    if (s < 1.0E17)                  {                      z = 1.0/(s*s);                        double polv = 8.33333333333333333333E-2;                      polv = polv*z - 2.10927960927960927961E-2;                      polv = polv*z + 7.57575757575757575758E-3;                      polv = polv*z - 4.16666666666666666667E-3;                      polv = polv*z + 3.96825396825396825397E-3;                      polv = polv*z - 8.33333333333333333333E-3;                      polv = polv*z + 8.33333333333333333333E-2;                      y = z*polv;                  }                  else                  {                      y = 0.0;                  }                  y = System.Math.Log(s) - 0.5/s - y - w;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 10.0 & x == System.Math.Floor(x))              {                  y = 0.0;                  var n = (int) System.Math.Floor(x);                  for (int i = 1; i <= n - 1; i++)                  {                      w = i;                      y = y + 1.0/w;                  }                  y = y - 0.57721566490153286061;              }              else              {                  s = x;                  w = 0.0;                    while (s < 10.0)                  {                      w = w + 1.0/s;                      s = s + 1.0;                  }                    if (s < 1.0E17)                  {                      z = 1.0/(s*s);                        double polv = 8.33333333333333333333E-2;                      polv = polv*z - 2.10927960927960927961E-2;                      polv = polv*z + 7.57575757575757575758E-3;                      polv = polv*z - 4.16666666666666666667E-3;                      polv = polv*z + 3.96825396825396825397E-3;                      polv = polv*z - 8.33333333333333333333E-3;                      polv = polv*z + 8.33333333333333333333E-2;                      y = z*polv;                  }                  else                  {                      y = 0.0;                  }                  y = System.Math.Log(s) - 0.5/s - y - w;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 10.0 & x == System.Math.Floor(x))              {                  y = 0.0;                  var n = (int) System.Math.Floor(x);                  for (int i = 1; i <= n - 1; i++)                  {                      w = i;                      y = y + 1.0/w;                  }                  y = y - 0.57721566490153286061;              }              else              {                  s = x;                  w = 0.0;                    while (s < 10.0)                  {                      w = w + 1.0/s;                      s = s + 1.0;                  }                    if (s < 1.0E17)                  {                      z = 1.0/(s*s);                        double polv = 8.33333333333333333333E-2;                      polv = polv*z - 2.10927960927960927961E-2;                      polv = polv*z + 7.57575757575757575758E-3;                      polv = polv*z - 4.16666666666666666667E-3;                      polv = polv*z + 3.96825396825396825397E-3;                      polv = polv*z - 8.33333333333333333333E-3;                      polv = polv*z + 8.33333333333333333333E-2;                      y = z*polv;                  }                  else                  {                      y = 0.0;                  }                  y = System.Math.Log(s) - 0.5/s - y - w;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 10.0 & x == System.Math.Floor(x))              {                  y = 0.0;                  var n = (int) System.Math.Floor(x);                  for (int i = 1; i <= n - 1; i++)                  {                      w = i;                      y = y + 1.0/w;                  }                  y = y - 0.57721566490153286061;              }              else              {                  s = x;                  w = 0.0;                    while (s < 10.0)                  {                      w = w + 1.0/s;                      s = s + 1.0;                  }                    if (s < 1.0E17)                  {                      z = 1.0/(s*s);                        double polv = 8.33333333333333333333E-2;                      polv = polv*z - 2.10927960927960927961E-2;                      polv = polv*z + 7.57575757575757575758E-3;                      polv = polv*z - 4.16666666666666666667E-3;                      polv = polv*z + 3.96825396825396825397E-3;                      polv = polv*z - 8.33333333333333333333E-3;                      polv = polv*z + 8.33333333333333333333E-2;                      y = z*polv;                  }                  else                  {                      y = 0.0;                  }                  y = System.Math.Log(s) - 0.5/s - y - w;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 10.0 & x == System.Math.Floor(x))              {                  y = 0.0;                  var n = (int) System.Math.Floor(x);                  for (int i = 1; i <= n - 1; i++)                  {                      w = i;                      y = y + 1.0/w;                  }                  y = y - 0.57721566490153286061;              }              else              {                  s = x;                  w = 0.0;                    while (s < 10.0)                  {                      w = w + 1.0/s;                      s = s + 1.0;                  }                    if (s < 1.0E17)                  {                      z = 1.0/(s*s);                        double polv = 8.33333333333333333333E-2;                      polv = polv*z - 2.10927960927960927961E-2;                      polv = polv*z + 7.57575757575757575758E-3;                      polv = polv*z - 4.16666666666666666667E-3;                      polv = polv*z + 3.96825396825396825397E-3;                      polv = polv*z - 8.33333333333333333333E-3;                      polv = polv*z + 8.33333333333333333333E-2;                      y = z*polv;                  }                  else                  {                      y = 0.0;                  }                  y = System.Math.Log(s) - 0.5/s - y - w;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 10.0 & x == System.Math.Floor(x))              {                  y = 0.0;                  var n = (int) System.Math.Floor(x);                  for (int i = 1; i <= n - 1; i++)                  {                      w = i;                      y = y + 1.0/w;                  }                  y = y - 0.57721566490153286061;              }              else              {                  s = x;                  w = 0.0;                    while (s < 10.0)                  {                      w = w + 1.0/s;                      s = s + 1.0;                  }                    if (s < 1.0E17)                  {                      z = 1.0/(s*s);                        double polv = 8.33333333333333333333E-2;                      polv = polv*z - 2.10927960927960927961E-2;                      polv = polv*z + 7.57575757575757575758E-3;                      polv = polv*z - 4.16666666666666666667E-3;                      polv = polv*z + 3.96825396825396825397E-3;                      polv = polv*z - 8.33333333333333333333E-3;                      polv = polv*z + 8.33333333333333333333E-2;                      y = z*polv;                  }                  else                  {                      y = 0.0;                  }                  y = System.Math.Log(s) - 0.5/s - y - w;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 10.0 & x == System.Math.Floor(x))              {                  y = 0.0;                  var n = (int) System.Math.Floor(x);                  for (int i = 1; i <= n - 1; i++)                  {                      w = i;                      y = y + 1.0/w;                  }                  y = y - 0.57721566490153286061;              }              else              {                  s = x;                  w = 0.0;                    while (s < 10.0)                  {                      w = w + 1.0/s;                      s = s + 1.0;                  }                    if (s < 1.0E17)                  {                      z = 1.0/(s*s);                        double polv = 8.33333333333333333333E-2;                      polv = polv*z - 2.10927960927960927961E-2;                      polv = polv*z + 7.57575757575757575758E-3;                      polv = polv*z - 4.16666666666666666667E-3;                      polv = polv*z + 3.96825396825396825397E-3;                      polv = polv*z - 8.33333333333333333333E-3;                      polv = polv*z + 8.33333333333333333333E-2;                      y = z*polv;                  }                  else                  {                      y = 0.0;                  }                  y = System.Math.Log(s) - 0.5/s - y - w;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 10.0 & x == System.Math.Floor(x))              {                  y = 0.0;                  var n = (int) System.Math.Floor(x);                  for (int i = 1; i <= n - 1; i++)                  {                      w = i;                      y = y + 1.0/w;                  }                  y = y - 0.57721566490153286061;              }              else              {                  s = x;                  w = 0.0;                    while (s < 10.0)                  {                      w = w + 1.0/s;                      s = s + 1.0;                  }                    if (s < 1.0E17)                  {                      z = 1.0/(s*s);                        double polv = 8.33333333333333333333E-2;                      polv = polv*z - 2.10927960927960927961E-2;                      polv = polv*z + 7.57575757575757575758E-3;                      polv = polv*z - 4.16666666666666666667E-3;                      polv = polv*z + 3.96825396825396825397E-3;                      polv = polv*z - 8.33333333333333333333E-3;                      polv = polv*z + 8.33333333333333333333E-2;                      y = z*polv;                  }                  else                  {                      y = 0.0;                  }                  y = System.Math.Log(s) - 0.5/s - y - w;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 10.0 & x == System.Math.Floor(x))              {                  y = 0.0;                  var n = (int) System.Math.Floor(x);                  for (int i = 1; i <= n - 1; i++)                  {                      w = i;                      y = y + 1.0/w;                  }                  y = y - 0.57721566490153286061;              }              else              {                  s = x;                  w = 0.0;                    while (s < 10.0)                  {                      w = w + 1.0/s;                      s = s + 1.0;                  }                    if (s < 1.0E17)                  {                      z = 1.0/(s*s);                        double polv = 8.33333333333333333333E-2;                      polv = polv*z - 2.10927960927960927961E-2;                      polv = polv*z + 7.57575757575757575758E-3;                      polv = polv*z - 4.16666666666666666667E-3;                      polv = polv*z + 3.96825396825396825397E-3;                      polv = polv*z - 8.33333333333333333333E-3;                      polv = polv*z + 8.33333333333333333333E-2;                      y = z*polv;                  }                  else                  {                      y = 0.0;                  }                  y = System.Math.Log(s) - 0.5/s - y - w;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 10.0 & x == System.Math.Floor(x))              {                  y = 0.0;                  var n = (int) System.Math.Floor(x);                  for (int i = 1; i <= n - 1; i++)                  {                      w = i;                      y = y + 1.0/w;                  }                  y = y - 0.57721566490153286061;              }              else              {                  s = x;                  w = 0.0;                    while (s < 10.0)                  {                      w = w + 1.0/s;                      s = s + 1.0;                  }                    if (s < 1.0E17)                  {                      z = 1.0/(s*s);                        double polv = 8.33333333333333333333E-2;                      polv = polv*z - 2.10927960927960927961E-2;                      polv = polv*z + 7.57575757575757575758E-3;                      polv = polv*z - 4.16666666666666666667E-3;                      polv = polv*z + 3.96825396825396825397E-3;                      polv = polv*z - 8.33333333333333333333E-3;                      polv = polv*z + 8.33333333333333333333E-2;                      y = z*polv;                  }                  else                  {                      y = 0.0;                  }                  y = System.Math.Log(s) - 0.5/s - y - w;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Digamma,The following statement contains a magic number: if (x <= 10.0 & x == System.Math.Floor(x))              {                  y = 0.0;                  var n = (int) System.Math.Floor(x);                  for (int i = 1; i <= n - 1; i++)                  {                      w = i;                      y = y + 1.0/w;                  }                  y = y - 0.57721566490153286061;              }              else              {                  s = x;                  w = 0.0;                    while (s < 10.0)                  {                      w = w + 1.0/s;                      s = s + 1.0;                  }                    if (s < 1.0E17)                  {                      z = 1.0/(s*s);                        double polv = 8.33333333333333333333E-2;                      polv = polv*z - 2.10927960927960927961E-2;                      polv = polv*z + 7.57575757575757575758E-3;                      polv = polv*z - 4.16666666666666666667E-3;                      polv = polv*z + 3.96825396825396825397E-3;                      polv = polv*z - 8.33333333333333333333E-3;                      polv = polv*z + 8.33333333333333333333E-2;                      y = z*polv;                  }                  else                  {                      y = 0.0;                  }                  y = System.Math.Log(s) - 0.5/s - y - w;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double[] STIR =                  {                      7.87311395793093628397E-4'                      -2.29549961613378126380E-4'                      -2.68132617805781232825E-3'                      3.47222221605458667310E-3'                      8.33333333333482257126E-2'                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double[] STIR =                  {                      7.87311395793093628397E-4'                      -2.29549961613378126380E-4'                      -2.68132617805781232825E-3'                      3.47222221605458667310E-3'                      8.33333333333482257126E-2'                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double[] STIR =                  {                      7.87311395793093628397E-4'                      -2.29549961613378126380E-4'                      -2.68132617805781232825E-3'                      3.47222221605458667310E-3'                      8.33333333333482257126E-2'                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double[] STIR =                  {                      7.87311395793093628397E-4'                      -2.29549961613378126380E-4'                      -2.68132617805781232825E-3'                      3.47222221605458667310E-3'                      8.33333333333482257126E-2'                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double[] STIR =                  {                      7.87311395793093628397E-4'                      -2.29549961613378126380E-4'                      -2.68132617805781232825E-3'                      3.47222221605458667310E-3'                      8.33333333333482257126E-2'                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: double MAXSTIR = 143.01608;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: w = 1.0 + w*Polevl(w' STIR' 4);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: if (x > MAXSTIR)              {                  double v = System.Math.Pow(x' 0.5*x - 0.25);                  y = v*(v/y);              }              else              {                  y = System.Math.Pow(x' x - 0.5)/y;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: if (x > MAXSTIR)              {                  double v = System.Math.Pow(x' 0.5*x - 0.25);                  y = v*(v/y);              }              else              {                  y = System.Math.Pow(x' x - 0.5)/y;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Stirf,The following statement contains a magic number: if (x > MAXSTIR)              {                  double v = System.Math.Pow(x' 0.5*x - 0.25);                  y = v*(v/y);              }              else              {                  y = System.Math.Pow(x' x - 0.5)/y;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Igamc,The following statement contains a magic number: double big = 4.503599627370496e15;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Igamc,The following statement contains a magic number: double biginv = 2.22044604925031308085e-16;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Igamc,The following statement contains a magic number: do              {                  c += 1.0;                  y += 1.0;                  z += 2.0;                  yc = y*c;                  pk = pkm1*z - pkm2*yc;                  qk = qkm1*z - qkm2*yc;                  if (qk != 0)                  {                      r = pk/qk;                      t = System.Math.Abs((ans - r)/r);                      ans = r;                  }                  else                      t = 1.0;                    pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                  if (System.Math.Abs(pk) > big)                  {                      pkm2 *= biginv;                      pkm1 *= biginv;                      qkm2 *= biginv;                      qkm1 *= biginv;                  }              } while (t > DoubleEpsilon);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] A =                  {                      8.11614167470508450300E-4'                      -5.95061904284301438324E-4'                      7.93650340457716943945E-4'                      -2.77777777730099687205E-3'                      8.33333333333331927722E-2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] A =                  {                      8.11614167470508450300E-4'                      -5.95061904284301438324E-4'                      7.93650340457716943945E-4'                      -2.77777777730099687205E-3'                      8.33333333333331927722E-2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] A =                  {                      8.11614167470508450300E-4'                      -5.95061904284301438324E-4'                      7.93650340457716943945E-4'                      -2.77777777730099687205E-3'                      8.33333333333331927722E-2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] A =                  {                      8.11614167470508450300E-4'                      -5.95061904284301438324E-4'                      7.93650340457716943945E-4'                      -2.77777777730099687205E-3'                      8.33333333333331927722E-2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] A =                  {                      8.11614167470508450300E-4'                      -5.95061904284301438324E-4'                      7.93650340457716943945E-4'                      -2.77777777730099687205E-3'                      8.33333333333331927722E-2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] B =                  {                      -1.37825152569120859100E3'                      -3.88016315134637840924E4'                      -3.31612992738871184744E5'                      -1.16237097492762307383E6'                      -1.72173700820839662146E6'                      -8.53555664245765465627E5                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] B =                  {                      -1.37825152569120859100E3'                      -3.88016315134637840924E4'                      -3.31612992738871184744E5'                      -1.16237097492762307383E6'                      -1.72173700820839662146E6'                      -8.53555664245765465627E5                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] B =                  {                      -1.37825152569120859100E3'                      -3.88016315134637840924E4'                      -3.31612992738871184744E5'                      -1.16237097492762307383E6'                      -1.72173700820839662146E6'                      -8.53555664245765465627E5                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] B =                  {                      -1.37825152569120859100E3'                      -3.88016315134637840924E4'                      -3.31612992738871184744E5'                      -1.16237097492762307383E6'                      -1.72173700820839662146E6'                      -8.53555664245765465627E5                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] B =                  {                      -1.37825152569120859100E3'                      -3.88016315134637840924E4'                      -3.31612992738871184744E5'                      -1.16237097492762307383E6'                      -1.72173700820839662146E6'                      -8.53555664245765465627E5                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] B =                  {                      -1.37825152569120859100E3'                      -3.88016315134637840924E4'                      -3.31612992738871184744E5'                      -1.16237097492762307383E6'                      -1.72173700820839662146E6'                      -8.53555664245765465627E5                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] C =                  {                      -3.51815701436523470549E2'                      -1.70642106651881159223E4'                      -2.20528590553854454839E5'                      -1.13933444367982507207E6'                      -2.53252307177582951285E6'                      -2.01889141433532773231E6                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] C =                  {                      -3.51815701436523470549E2'                      -1.70642106651881159223E4'                      -2.20528590553854454839E5'                      -1.13933444367982507207E6'                      -2.53252307177582951285E6'                      -2.01889141433532773231E6                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] C =                  {                      -3.51815701436523470549E2'                      -1.70642106651881159223E4'                      -2.20528590553854454839E5'                      -1.13933444367982507207E6'                      -2.53252307177582951285E6'                      -2.01889141433532773231E6                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] C =                  {                      -3.51815701436523470549E2'                      -1.70642106651881159223E4'                      -2.20528590553854454839E5'                      -1.13933444367982507207E6'                      -2.53252307177582951285E6'                      -2.01889141433532773231E6                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] C =                  {                      -3.51815701436523470549E2'                      -1.70642106651881159223E4'                      -2.20528590553854454839E5'                      -1.13933444367982507207E6'                      -2.53252307177582951285E6'                      -2.01889141433532773231E6                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: double[] C =                  {                      -3.51815701436523470549E2'                      -1.70642106651881159223E4'                      -2.20528590553854454839E5'                      -1.13933444367982507207E6'                      -2.53252307177582951285E6'                      -2.01889141433532773231E6                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x < -34.0)              {                  q = -x;                  w = Lgamma(q);                  p = System.Math.Floor(q);                    if (p == q)                      throw new OverflowException("lgamma");                    z = q - p;                  if (z > 0.5)                  {                      p += 1.0;                      z = p - q;                  }                  z = q*System.Math.Sin(System.Math.PI*z);                    if (z == 0.0)                      throw new OverflowException("lgamma");                    z = LogPI - System.Math.Log(z) - w;                  return z;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x < -34.0)              {                  q = -x;                  w = Lgamma(q);                  p = System.Math.Floor(q);                    if (p == q)                      throw new OverflowException("lgamma");                    z = q - p;                  if (z > 0.5)                  {                      p += 1.0;                      z = p - q;                  }                  z = q*System.Math.Sin(System.Math.PI*z);                    if (z == 0.0)                      throw new OverflowException("lgamma");                    z = LogPI - System.Math.Log(z) - w;                  return z;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x < 13.0)              {                  z = 1.0;                  while (x >= 3.0)                  {                      x -= 1.0;                      z *= x;                  }                  while (x < 2.0)                  {                      if (x == 0.0)                          throw new OverflowException("lgamma");                        z /= x;                      x += 1.0;                  }                  if (z < 0.0) z = -z;                  if (x == 2.0) return System.Math.Log(z);                  x -= 2.0;                  p = x*Polevl(x' B' 5)/P1evl(x' C' 6);                  return (System.Math.Log(z) + p);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x < 13.0)              {                  z = 1.0;                  while (x >= 3.0)                  {                      x -= 1.0;                      z *= x;                  }                  while (x < 2.0)                  {                      if (x == 0.0)                          throw new OverflowException("lgamma");                        z /= x;                      x += 1.0;                  }                  if (z < 0.0) z = -z;                  if (x == 2.0) return System.Math.Log(z);                  x -= 2.0;                  p = x*Polevl(x' B' 5)/P1evl(x' C' 6);                  return (System.Math.Log(z) + p);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x < 13.0)              {                  z = 1.0;                  while (x >= 3.0)                  {                      x -= 1.0;                      z *= x;                  }                  while (x < 2.0)                  {                      if (x == 0.0)                          throw new OverflowException("lgamma");                        z /= x;                      x += 1.0;                  }                  if (z < 0.0) z = -z;                  if (x == 2.0) return System.Math.Log(z);                  x -= 2.0;                  p = x*Polevl(x' B' 5)/P1evl(x' C' 6);                  return (System.Math.Log(z) + p);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x < 13.0)              {                  z = 1.0;                  while (x >= 3.0)                  {                      x -= 1.0;                      z *= x;                  }                  while (x < 2.0)                  {                      if (x == 0.0)                          throw new OverflowException("lgamma");                        z /= x;                      x += 1.0;                  }                  if (z < 0.0) z = -z;                  if (x == 2.0) return System.Math.Log(z);                  x -= 2.0;                  p = x*Polevl(x' B' 5)/P1evl(x' C' 6);                  return (System.Math.Log(z) + p);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x < 13.0)              {                  z = 1.0;                  while (x >= 3.0)                  {                      x -= 1.0;                      z *= x;                  }                  while (x < 2.0)                  {                      if (x == 0.0)                          throw new OverflowException("lgamma");                        z /= x;                      x += 1.0;                  }                  if (z < 0.0) z = -z;                  if (x == 2.0) return System.Math.Log(z);                  x -= 2.0;                  p = x*Polevl(x' B' 5)/P1evl(x' C' 6);                  return (System.Math.Log(z) + p);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x < 13.0)              {                  z = 1.0;                  while (x >= 3.0)                  {                      x -= 1.0;                      z *= x;                  }                  while (x < 2.0)                  {                      if (x == 0.0)                          throw new OverflowException("lgamma");                        z /= x;                      x += 1.0;                  }                  if (z < 0.0) z = -z;                  if (x == 2.0) return System.Math.Log(z);                  x -= 2.0;                  p = x*Polevl(x' B' 5)/P1evl(x' C' 6);                  return (System.Math.Log(z) + p);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x < 13.0)              {                  z = 1.0;                  while (x >= 3.0)                  {                      x -= 1.0;                      z *= x;                  }                  while (x < 2.0)                  {                      if (x == 0.0)                          throw new OverflowException("lgamma");                        z /= x;                      x += 1.0;                  }                  if (z < 0.0) z = -z;                  if (x == 2.0) return System.Math.Log(z);                  x -= 2.0;                  p = x*Polevl(x' B' 5)/P1evl(x' C' 6);                  return (System.Math.Log(z) + p);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x > 2.556348e305)                  throw new OverflowException("lgamma");
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: q = (x - 0.5)*System.Math.Log(x) - x + 0.91893853320467274178;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: q = (x - 0.5)*System.Math.Log(x) - x + 0.91893853320467274178;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x > 1.0e8) return (q);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x >= 1000.0)              {                  q += ((7.9365079365079365079365e-4*p                         - 2.7777777777777777777778e-3)*p                        + 0.0833333333333333333333)/x;              }              else              {                  q += Polevl(p' A' 4)/x;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x >= 1000.0)              {                  q += ((7.9365079365079365079365e-4*p                         - 2.7777777777777777777778e-3)*p                        + 0.0833333333333333333333)/x;              }              else              {                  q += Polevl(p' A' 4)/x;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x >= 1000.0)              {                  q += ((7.9365079365079365079365e-4*p                         - 2.7777777777777777777778e-3)*p                        + 0.0833333333333333333333)/x;              }              else              {                  q += Polevl(p' A' 4)/x;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x >= 1000.0)              {                  q += ((7.9365079365079365079365e-4*p                         - 2.7777777777777777777778e-3)*p                        + 0.0833333333333333333333)/x;              }              else              {                  q += Polevl(p' A' 4)/x;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lgamma,The following statement contains a magic number: if (x >= 1000.0)              {                  q += ((7.9365079365079365079365e-4*p                         - 2.7777777777777777777778e-3)*p                        + 0.0833333333333333333333)/x;              }              else              {                  q += Polevl(p' A' 4)/x;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Ibeta,The following statement contains a magic number: if ((bb*xx) <= 1.0 && xx <= 0.95)              {                  t = PowerSeries(aa' bb' xx);                  return t;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Ibeta,The following statement contains a magic number: if (flag && (b*x) <= 1.0 && x <= 0.95)              {                  t = PowerSeries(a' b' x);                  if (t <= DoubleEpsilon) t = 1.0 - DoubleEpsilon;                  else t = 1.0 - t;                  return t;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Ibeta,The following statement contains a magic number: y = x*(a + b - 2.0) - (a - 1.0);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: double big = 4.503599627370496e15;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: double biginv = 2.22044604925031308085e-16;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: k8 = a + 2.0;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: thresh = 3.0*DoubleEpsilon;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: do              {                  xk = -(x*k1*k2)/(k3*k4);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    xk = (x*k5*k6)/(k7*k8);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    if (qk != 0) r = pk/qk;                  if (r != 0)                  {                      t = System.Math.Abs((ans - r)/r);                      ans = r;                  }                  else                      t = 1.0;                    if (t < thresh) return ans;                    k1 += 1.0;                  k2 += 1.0;                  k3 += 2.0;                  k4 += 2.0;                  k5 += 1.0;                  k6 -= 1.0;                  k7 += 2.0;                  k8 += 2.0;                    if ((System.Math.Abs(qk) + System.Math.Abs(pk)) > big)                  {                      pkm2 *= biginv;                      pkm1 *= biginv;                      qkm2 *= biginv;                      qkm1 *= biginv;                  }                  if ((System.Math.Abs(qk) < biginv) || (System.Math.Abs(pk) < biginv))                  {                      pkm2 *= big;                      pkm1 *= big;                      qkm2 *= big;                      qkm1 *= big;                  }              } while (++n < 300);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: do              {                  xk = -(x*k1*k2)/(k3*k4);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    xk = (x*k5*k6)/(k7*k8);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    if (qk != 0) r = pk/qk;                  if (r != 0)                  {                      t = System.Math.Abs((ans - r)/r);                      ans = r;                  }                  else                      t = 1.0;                    if (t < thresh) return ans;                    k1 += 1.0;                  k2 += 1.0;                  k3 += 2.0;                  k4 += 2.0;                  k5 += 1.0;                  k6 -= 1.0;                  k7 += 2.0;                  k8 += 2.0;                    if ((System.Math.Abs(qk) + System.Math.Abs(pk)) > big)                  {                      pkm2 *= biginv;                      pkm1 *= biginv;                      qkm2 *= biginv;                      qkm1 *= biginv;                  }                  if ((System.Math.Abs(qk) < biginv) || (System.Math.Abs(pk) < biginv))                  {                      pkm2 *= big;                      pkm1 *= big;                      qkm2 *= big;                      qkm1 *= big;                  }              } while (++n < 300);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: do              {                  xk = -(x*k1*k2)/(k3*k4);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    xk = (x*k5*k6)/(k7*k8);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    if (qk != 0) r = pk/qk;                  if (r != 0)                  {                      t = System.Math.Abs((ans - r)/r);                      ans = r;                  }                  else                      t = 1.0;                    if (t < thresh) return ans;                    k1 += 1.0;                  k2 += 1.0;                  k3 += 2.0;                  k4 += 2.0;                  k5 += 1.0;                  k6 -= 1.0;                  k7 += 2.0;                  k8 += 2.0;                    if ((System.Math.Abs(qk) + System.Math.Abs(pk)) > big)                  {                      pkm2 *= biginv;                      pkm1 *= biginv;                      qkm2 *= biginv;                      qkm1 *= biginv;                  }                  if ((System.Math.Abs(qk) < biginv) || (System.Math.Abs(pk) < biginv))                  {                      pkm2 *= big;                      pkm1 *= big;                      qkm2 *= big;                      qkm1 *= big;                  }              } while (++n < 300);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: do              {                  xk = -(x*k1*k2)/(k3*k4);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    xk = (x*k5*k6)/(k7*k8);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    if (qk != 0) r = pk/qk;                  if (r != 0)                  {                      t = System.Math.Abs((ans - r)/r);                      ans = r;                  }                  else                      t = 1.0;                    if (t < thresh) return ans;                    k1 += 1.0;                  k2 += 1.0;                  k3 += 2.0;                  k4 += 2.0;                  k5 += 1.0;                  k6 -= 1.0;                  k7 += 2.0;                  k8 += 2.0;                    if ((System.Math.Abs(qk) + System.Math.Abs(pk)) > big)                  {                      pkm2 *= biginv;                      pkm1 *= biginv;                      qkm2 *= biginv;                      qkm1 *= biginv;                  }                  if ((System.Math.Abs(qk) < biginv) || (System.Math.Abs(pk) < biginv))                  {                      pkm2 *= big;                      pkm1 *= big;                      qkm2 *= big;                      qkm1 *= big;                  }              } while (++n < 300);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbcf,The following statement contains a magic number: do              {                  xk = -(x*k1*k2)/(k3*k4);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    xk = (x*k5*k6)/(k7*k8);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    if (qk != 0) r = pk/qk;                  if (r != 0)                  {                      t = System.Math.Abs((ans - r)/r);                      ans = r;                  }                  else                      t = 1.0;                    if (t < thresh) return ans;                    k1 += 1.0;                  k2 += 1.0;                  k3 += 2.0;                  k4 += 2.0;                  k5 += 1.0;                  k6 -= 1.0;                  k7 += 2.0;                  k8 += 2.0;                    if ((System.Math.Abs(qk) + System.Math.Abs(pk)) > big)                  {                      pkm2 *= biginv;                      pkm1 *= biginv;                      qkm2 *= biginv;                      qkm1 *= biginv;                  }                  if ((System.Math.Abs(qk) < biginv) || (System.Math.Abs(pk) < biginv))                  {                      pkm2 *= big;                      pkm1 *= big;                      qkm2 *= big;                      qkm1 *= big;                  }              } while (++n < 300);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: double big = 4.503599627370496e15;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: double biginv = 2.22044604925031308085e-16;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: k8 = a + 2.0;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: thresh = 3.0*DoubleEpsilon;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: do              {                  xk = -(z*k1*k2)/(k3*k4);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    xk = (z*k5*k6)/(k7*k8);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    if (qk != 0) r = pk/qk;                  if (r != 0)                  {                      t = System.Math.Abs((ans - r)/r);                      ans = r;                  }                  else                      t = 1.0;                    if (t < thresh) return ans;                    k1 += 1.0;                  k2 -= 1.0;                  k3 += 2.0;                  k4 += 2.0;                  k5 += 1.0;                  k6 += 1.0;                  k7 += 2.0;                  k8 += 2.0;                    if ((System.Math.Abs(qk) + System.Math.Abs(pk)) > big)                  {                      pkm2 *= biginv;                      pkm1 *= biginv;                      qkm2 *= biginv;                      qkm1 *= biginv;                  }                  if ((System.Math.Abs(qk) < biginv) || (System.Math.Abs(pk) < biginv))                  {                      pkm2 *= big;                      pkm1 *= big;                      qkm2 *= big;                      qkm1 *= big;                  }              } while (++n < 300);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: do              {                  xk = -(z*k1*k2)/(k3*k4);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    xk = (z*k5*k6)/(k7*k8);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    if (qk != 0) r = pk/qk;                  if (r != 0)                  {                      t = System.Math.Abs((ans - r)/r);                      ans = r;                  }                  else                      t = 1.0;                    if (t < thresh) return ans;                    k1 += 1.0;                  k2 -= 1.0;                  k3 += 2.0;                  k4 += 2.0;                  k5 += 1.0;                  k6 += 1.0;                  k7 += 2.0;                  k8 += 2.0;                    if ((System.Math.Abs(qk) + System.Math.Abs(pk)) > big)                  {                      pkm2 *= biginv;                      pkm1 *= biginv;                      qkm2 *= biginv;                      qkm1 *= biginv;                  }                  if ((System.Math.Abs(qk) < biginv) || (System.Math.Abs(pk) < biginv))                  {                      pkm2 *= big;                      pkm1 *= big;                      qkm2 *= big;                      qkm1 *= big;                  }              } while (++n < 300);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: do              {                  xk = -(z*k1*k2)/(k3*k4);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    xk = (z*k5*k6)/(k7*k8);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    if (qk != 0) r = pk/qk;                  if (r != 0)                  {                      t = System.Math.Abs((ans - r)/r);                      ans = r;                  }                  else                      t = 1.0;                    if (t < thresh) return ans;                    k1 += 1.0;                  k2 -= 1.0;                  k3 += 2.0;                  k4 += 2.0;                  k5 += 1.0;                  k6 += 1.0;                  k7 += 2.0;                  k8 += 2.0;                    if ((System.Math.Abs(qk) + System.Math.Abs(pk)) > big)                  {                      pkm2 *= biginv;                      pkm1 *= biginv;                      qkm2 *= biginv;                      qkm1 *= biginv;                  }                  if ((System.Math.Abs(qk) < biginv) || (System.Math.Abs(pk) < biginv))                  {                      pkm2 *= big;                      pkm1 *= big;                      qkm2 *= big;                      qkm1 *= big;                  }              } while (++n < 300);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: do              {                  xk = -(z*k1*k2)/(k3*k4);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    xk = (z*k5*k6)/(k7*k8);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    if (qk != 0) r = pk/qk;                  if (r != 0)                  {                      t = System.Math.Abs((ans - r)/r);                      ans = r;                  }                  else                      t = 1.0;                    if (t < thresh) return ans;                    k1 += 1.0;                  k2 -= 1.0;                  k3 += 2.0;                  k4 += 2.0;                  k5 += 1.0;                  k6 += 1.0;                  k7 += 2.0;                  k8 += 2.0;                    if ((System.Math.Abs(qk) + System.Math.Abs(pk)) > big)                  {                      pkm2 *= biginv;                      pkm1 *= biginv;                      qkm2 *= biginv;                      qkm1 *= biginv;                  }                  if ((System.Math.Abs(qk) < biginv) || (System.Math.Abs(pk) < biginv))                  {                      pkm2 *= big;                      pkm1 *= big;                      qkm2 *= big;                      qkm1 *= big;                  }              } while (++n < 300);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Incbd,The following statement contains a magic number: do              {                  xk = -(z*k1*k2)/(k3*k4);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    xk = (z*k5*k6)/(k7*k8);                  pk = pkm1 + pkm2*xk;                  qk = qkm1 + qkm2*xk;                  pkm2 = pkm1;                  pkm1 = pk;                  qkm2 = qkm1;                  qkm1 = qk;                    if (qk != 0) r = pk/qk;                  if (r != 0)                  {                      t = System.Math.Abs((ans - r)/r);                      ans = r;                  }                  else                      t = 1.0;                    if (t < thresh) return ans;                    k1 += 1.0;                  k2 -= 1.0;                  k3 += 2.0;                  k4 += 2.0;                  k5 += 1.0;                  k6 += 1.0;                  k7 += 2.0;                  k8 += 2.0;                    if ((System.Math.Abs(qk) + System.Math.Abs(pk)) > big)                  {                      pkm2 *= biginv;                      pkm1 *= biginv;                      qkm2 *= biginv;                      qkm1 *= biginv;                  }                  if ((System.Math.Abs(qk) < biginv) || (System.Math.Abs(pk) < biginv))                  {                      pkm2 *= big;                      pkm1 *= big;                      qkm2 *= big;                      qkm1 *= big;                  }              } while (++n < 300);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,PowerSeries,The following statement contains a magic number: n = 2.0;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,ChiSq,The following statement contains a magic number: return Igam(df/2.0' x/2.0);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,ChiSq,The following statement contains a magic number: return Igam(df/2.0' x/2.0);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,ChiSqc,The following statement contains a magic number: return Igamc(df/2.0' x/2.0);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,ChiSqc,The following statement contains a magic number: return Igamc(df/2.0' x/2.0);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Normal,The following statement contains a magic number: return 0.5*Erfc(-z);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double s2pi = System.Math.Sqrt(2.0*System.Math.PI);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P0 =                  {                      -59.963350101410789'                      98.001075418599967'                      -56.676285746907027'                      13.931260938727968'                      -1.2391658386738125                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P0 =                  {                      -59.963350101410789'                      98.001075418599967'                      -56.676285746907027'                      13.931260938727968'                      -1.2391658386738125                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P0 =                  {                      -59.963350101410789'                      98.001075418599967'                      -56.676285746907027'                      13.931260938727968'                      -1.2391658386738125                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P0 =                  {                      -59.963350101410789'                      98.001075418599967'                      -56.676285746907027'                      13.931260938727968'                      -1.2391658386738125                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P0 =                  {                      -59.963350101410789'                      98.001075418599967'                      -56.676285746907027'                      13.931260938727968'                      -1.2391658386738125                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q0 =                  {                      1.9544885833814176'                      4.6762791289888153'                      86.360242139089053'                      -225.46268785411937'                      200.26021238006066'                      -82.037225616833339'                      15.90562251262117'                      -1.1833162112133                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P1 =                  {                      4.0554489230596245'                      31.525109459989388'                      57.162819224642128'                      44.080507389320083'                      14.684956192885803'                      2.1866330685079025'                      -0.14025607917135449'                      -0.035042462682784818'                      -0.00085745678515468545                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q1 =                  {                      15.779988325646675'                      45.390763512887922'                      41.317203825467203'                      15.04253856929075'                      2.5046494620830941'                      -0.14218292285478779'                      -0.038080640769157827'                      -0.00093325948089545744                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] P2 =                  {                      3.2377489177694603'                      6.9152288906898418'                      3.9388102529247444'                      1.3330346081580755'                      0.20148538954917908'                      0.012371663481782003'                      0.00030158155350823543'                      2.6580697468673755E-06'                      6.2397453918498331E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: double[] Q2 =                  {                      6.02427039364742'                      3.6798356385616087'                      1.3770209948908132'                      0.21623699359449663'                      0.013420400608854318'                      0.00032801446468212774'                      2.8924786474538068E-06'                      6.7901940800998127E-09                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: if (y > 0.8646647167633873)              {                  y = 1.0 - y;                  code = 0;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: if (y > 0.1353352832366127)              {                  y -= 0.5;                  double y2 = y*y;                  x = y + y*((y2*Polevl(y2' P0' 4))/P1evl(y2' Q0' 8));                  x *= s2pi;                  return x;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: if (y > 0.1353352832366127)              {                  y -= 0.5;                  double y2 = y*y;                  x = y + y*((y2*Polevl(y2' P0' 4))/P1evl(y2' Q0' 8));                  x *= s2pi;                  return x;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: if (y > 0.1353352832366127)              {                  y -= 0.5;                  double y2 = y*y;                  x = y + y*((y2*Polevl(y2' P0' 4))/P1evl(y2' Q0' 8));                  x *= s2pi;                  return x;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: if (y > 0.1353352832366127)              {                  y -= 0.5;                  double y2 = y*y;                  x = y + y*((y2*Polevl(y2' P0' 4))/P1evl(y2' Q0' 8));                  x *= s2pi;                  return x;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: x = System.Math.Sqrt(-2.0*System.Math.Log(y));
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: if (x < 8.0)              {                  x1 = (z*Polevl(z' P1' 8))/P1evl(z' Q1' 8);              }              else              {                  x1 = (z*Polevl(z' P2' 8))/P1evl(z' Q2' 8);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: if (x < 8.0)              {                  x1 = (z*Polevl(z' P1' 8))/P1evl(z' Q1' 8);              }              else              {                  x1 = (z*Polevl(z' P2' 8))/P1evl(z' Q2' 8);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: if (x < 8.0)              {                  x1 = (z*Polevl(z' P1' 8))/P1evl(z' Q1' 8);              }              else              {                  x1 = (z*Polevl(z' P2' 8))/P1evl(z' Q2' 8);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: if (x < 8.0)              {                  x1 = (z*Polevl(z' P1' 8))/P1evl(z' Q1' 8);              }              else              {                  x1 = (z*Polevl(z' P2' 8))/P1evl(z' Q2' 8);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,NormalInverse,The following statement contains a magic number: if (x < 8.0)              {                  x1 = (z*Polevl(z' P1' 8))/P1evl(z' Q1' 8);              }              else              {                  x1 = (z*Polevl(z' P2' 8))/P1evl(z' Q2' 8);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] P =                  {                      2.46196981473530512524E-10'                      5.64189564831068821977E-1'                      7.46321056442269912687E0'                      4.86371970985681366614E1'                      1.96520832956077098242E2'                      5.26445194995477358631E2'                      9.34528527171957607540E2'                      1.02755188689515710272E3'                      5.57535335369399327526E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] Q =                  {                      1.32281951154744992508E1'                      8.67072140885989742329E1'                      3.54937778887819891062E2'                      9.75708501743205489753E2'                      1.82390916687909736289E3'                      2.24633760818710981792E3'                      1.65666309194161350182E3'                      5.57535340817727675546E2                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] R =                  {                      5.64189583547755073984E-1'                      1.27536670759978104416E0'                      5.01905042251180477414E0'                      6.16021097993053585195E0'                      7.40974269950448939160E0'                      2.97886665372100240670E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] R =                  {                      5.64189583547755073984E-1'                      1.27536670759978104416E0'                      5.01905042251180477414E0'                      6.16021097993053585195E0'                      7.40974269950448939160E0'                      2.97886665372100240670E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] R =                  {                      5.64189583547755073984E-1'                      1.27536670759978104416E0'                      5.01905042251180477414E0'                      6.16021097993053585195E0'                      7.40974269950448939160E0'                      2.97886665372100240670E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] R =                  {                      5.64189583547755073984E-1'                      1.27536670759978104416E0'                      5.01905042251180477414E0'                      6.16021097993053585195E0'                      7.40974269950448939160E0'                      2.97886665372100240670E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] R =                  {                      5.64189583547755073984E-1'                      1.27536670759978104416E0'                      5.01905042251180477414E0'                      6.16021097993053585195E0'                      7.40974269950448939160E0'                      2.97886665372100240670E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] R =                  {                      5.64189583547755073984E-1'                      1.27536670759978104416E0'                      5.01905042251180477414E0'                      6.16021097993053585195E0'                      7.40974269950448939160E0'                      2.97886665372100240670E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] S =                  {                      2.26052863220117276590E0'                      9.39603524938001434673E0'                      1.20489539808096656605E1'                      1.70814450747565897222E1'                      9.60896809063285878198E0'                      3.36907645100081516050E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] S =                  {                      2.26052863220117276590E0'                      9.39603524938001434673E0'                      1.20489539808096656605E1'                      1.70814450747565897222E1'                      9.60896809063285878198E0'                      3.36907645100081516050E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] S =                  {                      2.26052863220117276590E0'                      9.39603524938001434673E0'                      1.20489539808096656605E1'                      1.70814450747565897222E1'                      9.60896809063285878198E0'                      3.36907645100081516050E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] S =                  {                      2.26052863220117276590E0'                      9.39603524938001434673E0'                      1.20489539808096656605E1'                      1.70814450747565897222E1'                      9.60896809063285878198E0'                      3.36907645100081516050E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] S =                  {                      2.26052863220117276590E0'                      9.39603524938001434673E0'                      1.20489539808096656605E1'                      1.70814450747565897222E1'                      9.60896809063285878198E0'                      3.36907645100081516050E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: double[] S =                  {                      2.26052863220117276590E0'                      9.39603524938001434673E0'                      1.20489539808096656605E1'                      1.70814450747565897222E1'                      9.60896809063285878198E0'                      3.36907645100081516050E0                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: if (z < -LogMax)              {                  if (value < 0) return (2.0);                  else return (0.0);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: if (x < 8.0)              {                  p = Polevl(x' P' 8);                  q = P1evl(x' Q' 8);              }              else              {                  p = Polevl(x' R' 5);                  q = P1evl(x' S' 6);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: if (x < 8.0)              {                  p = Polevl(x' P' 8);                  q = P1evl(x' Q' 8);              }              else              {                  p = Polevl(x' R' 5);                  q = P1evl(x' S' 6);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: if (x < 8.0)              {                  p = Polevl(x' P' 8);                  q = P1evl(x' Q' 8);              }              else              {                  p = Polevl(x' R' 5);                  q = P1evl(x' S' 6);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: if (x < 8.0)              {                  p = Polevl(x' P' 8);                  q = P1evl(x' Q' 8);              }              else              {                  p = Polevl(x' R' 5);                  q = P1evl(x' S' 6);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: if (x < 8.0)              {                  p = Polevl(x' P' 8);                  q = P1evl(x' Q' 8);              }              else              {                  p = Polevl(x' R' 5);                  q = P1evl(x' S' 6);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: if (value < 0) y = 2.0 - y;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erfc,The following statement contains a magic number: if (y == 0.0)              {                  if (value < 0) return 2.0;                  else return (0.0);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] T =                  {                      9.60497373987051638749E0'                      9.00260197203842689217E1'                      2.23200534594684319226E3'                      7.00332514112805075473E3'                      5.55923013010394962768E4                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] T =                  {                      9.60497373987051638749E0'                      9.00260197203842689217E1'                      2.23200534594684319226E3'                      7.00332514112805075473E3'                      5.55923013010394962768E4                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] T =                  {                      9.60497373987051638749E0'                      9.00260197203842689217E1'                      2.23200534594684319226E3'                      7.00332514112805075473E3'                      5.55923013010394962768E4                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] T =                  {                      9.60497373987051638749E0'                      9.00260197203842689217E1'                      2.23200534594684319226E3'                      7.00332514112805075473E3'                      5.55923013010394962768E4                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] T =                  {                      9.60497373987051638749E0'                      9.00260197203842689217E1'                      2.23200534594684319226E3'                      7.00332514112805075473E3'                      5.55923013010394962768E4                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] U =                  {                      3.35617141647503099647E1'                      5.21357949780152679795E2'                      4.59432382970980127987E3'                      2.26290000613890934246E4'                      4.92673942608635921086E4                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] U =                  {                      3.35617141647503099647E1'                      5.21357949780152679795E2'                      4.59432382970980127987E3'                      2.26290000613890934246E4'                      4.92673942608635921086E4                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] U =                  {                      3.35617141647503099647E1'                      5.21357949780152679795E2'                      4.59432382970980127987E3'                      2.26290000613890934246E4'                      4.92673942608635921086E4                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] U =                  {                      3.35617141647503099647E1'                      5.21357949780152679795E2'                      4.59432382970980127987E3'                      2.26290000613890934246E4'                      4.92673942608635921086E4                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: double[] U =                  {                      3.35617141647503099647E1'                      5.21357949780152679795E2'                      4.59432382970980127987E3'                      2.26290000613890934246E4'                      4.92673942608635921086E4                  };
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: y = x*Polevl(z' T' 4)/P1evl(z' U' 5);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Erf,The following statement contains a magic number: y = x*Polevl(z' T' 4)/P1evl(z' U' 5);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BSpline,The following statement contains a magic number: for (int k = 0; k <= n + 1; k++)              {                  c = Binomial(n + 1' k)*Tools.TruncatedPower(x + (n + 1.0)/2.0 - k' n);                  a += positive ? c : -c;                  positive = !positive;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Binomial,The following statement contains a magic number: return System.Math.Floor(0.5 + System.Math.Exp(Lfactorial(n) - Lfactorial(k) - Lfactorial(n - k)));
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lfactorial,The following statement contains a magic number: if (lnfcache == null)                  lnfcache = new double[101];
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Lfactorial,The following statement contains a magic number: if (n <= 100)              {                  // Compute the factorial using ln(gamma(n)) approximation' using the cache                  // if the value has been previously computed.                  return (lnfcache[n] > 0) ? lnfcache[n] : (lnfcache[n] = Lgamma(n + 1.0));              }              else              {                  // Just compute the factorial using ln(gamma(n)) approximation.                  return Lgamma(n + 1.0);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: if (fcache == null)              {                  // Initialize factorial cache                  fcache = new double[33];                  fcache[0] = 1;                  fcache[1] = 1;                  fcache[2] = 2;                  fcache[3] = 6;                  fcache[4] = 24;                  ftop = 4;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: if (fcache == null)              {                  // Initialize factorial cache                  fcache = new double[33];                  fcache[0] = 1;                  fcache[1] = 1;                  fcache[2] = 2;                  fcache[3] = 6;                  fcache[4] = 24;                  ftop = 4;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: if (fcache == null)              {                  // Initialize factorial cache                  fcache = new double[33];                  fcache[0] = 1;                  fcache[1] = 1;                  fcache[2] = 2;                  fcache[3] = 6;                  fcache[4] = 24;                  ftop = 4;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: if (fcache == null)              {                  // Initialize factorial cache                  fcache = new double[33];                  fcache[0] = 1;                  fcache[1] = 1;                  fcache[2] = 2;                  fcache[3] = 6;                  fcache[4] = 24;                  ftop = 4;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: if (fcache == null)              {                  // Initialize factorial cache                  fcache = new double[33];                  fcache[0] = 1;                  fcache[1] = 1;                  fcache[2] = 2;                  fcache[3] = 6;                  fcache[4] = 24;                  ftop = 4;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: if (fcache == null)              {                  // Initialize factorial cache                  fcache = new double[33];                  fcache[0] = 1;                  fcache[1] = 1;                  fcache[2] = 2;                  fcache[3] = 6;                  fcache[4] = 24;                  ftop = 4;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: if (fcache == null)              {                  // Initialize factorial cache                  fcache = new double[33];                  fcache[0] = 1;                  fcache[1] = 1;                  fcache[2] = 2;                  fcache[3] = 6;                  fcache[4] = 24;                  ftop = 4;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: if (fcache == null)              {                  // Initialize factorial cache                  fcache = new double[33];                  fcache[0] = 1;                  fcache[1] = 1;                  fcache[2] = 2;                  fcache[3] = 6;                  fcache[4] = 24;                  ftop = 4;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Factorial,The following statement contains a magic number: if (n > 32)              {                  // Return Gamma approximation using exp(gammaln(n+1))'                  //  which for some reason is faster than gamma(n+1).                  return System.Math.Exp(Lgamma(n + 1.0));              }              else              {                  // Compute in the standard way' but use the                  //  factorial cache to speed up computations.                  while (ftop < n)                  {                      int j = ftop++;                      fcache[ftop] = fcache[j]*ftop;                  }                  return fcache[n];              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ0,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  double y = x*x;                  double ans1 = 57568490574.0 + y*(-13362590354.0 + y*(651619640.7                                                                       +                                                                       y*                                                                       (-11214424.18 + y*(77392.33017 + y*(-184.9052456)))));                  double ans2 = 57568490411.0 + y*(1029532985.0 + y*(9494680.718                                                                     + y*(59272.64853 + y*(267.8532712 + y*1.0))));                    return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double y = z*z;                  double xx = ax - 0.785398164;                  double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 - y*0.934935152e-7)));                    return System.Math.Sqrt(0.636619772/ax)*                         (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if ((ax = System.Math.Abs(x)) < 8.0)              {                  y = x*x;                  ans1 = x*(72362614232.0 + y*(-7895059235.0 + y*(242396853.1                                                                  + y*(-2972611.439 + y*(15704.48260 + y*(-30.16036606))))));                  ans2 = 144725228442.0 + y*(2300535178.0 + y*(18583304.74                                                               + y*(99447.43394 + y*(376.9991397 + y*1.0))));                  return ans1/ans2;              }              else              {                  double z = 8.0/ax;                  double xx = ax - 2.356194491;                  y = z*z;                    ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                   + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  ans2 = 0.04687499995 + y*(-0.2002690873e-3                                            + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                      + y*0.105787412e-6)));                  double ans = System.Math.Sqrt(0.636619772/ax)*                               (System.Math.Cos(xx)*ans1 - z*System.Math.Sin(xx)*ans2);                  if (x < 0.0) ans = -ans;                  return ans;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: double ACC = 40.0;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: double BIGNO = 1.0e+10;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: double BIGNI = 1.0e-10;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if (ax == 0.0) return 0.0;              else if (ax > n)              {                  tox = 2.0/ax;                  bjm = BesselJ0(ax);                  bj = BesselJ(ax);                  for (j = 1; j < n; j++)                  {                      bjp = j*tox*bj - bjm;                      bjm = bj;                      bj = bjp;                  }                  ans = bj;              }              else              {                  tox = 2.0/ax;                  m = 2*((n + (int) System.Math.Sqrt(ACC*n))/2);                  jsum = false;                  bjp = ans = sum = 0.0;                  bj = 1.0;                  for (j = m; j > 0; j--)                  {                      bjm = j*tox*bj - bjp;                      bjp = bj;                      bj = bjm;                      if (System.Math.Abs(bj) > BIGNO)                      {                          bj *= BIGNI;                          bjp *= BIGNI;                          ans *= BIGNI;                          sum *= BIGNI;                      }                      if (jsum) sum += bj;                      jsum = !jsum;                      if (j == n) ans = bjp;                  }                  sum = 2.0*sum - bj;                  ans /= sum;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if (ax == 0.0) return 0.0;              else if (ax > n)              {                  tox = 2.0/ax;                  bjm = BesselJ0(ax);                  bj = BesselJ(ax);                  for (j = 1; j < n; j++)                  {                      bjp = j*tox*bj - bjm;                      bjm = bj;                      bj = bjp;                  }                  ans = bj;              }              else              {                  tox = 2.0/ax;                  m = 2*((n + (int) System.Math.Sqrt(ACC*n))/2);                  jsum = false;                  bjp = ans = sum = 0.0;                  bj = 1.0;                  for (j = m; j > 0; j--)                  {                      bjm = j*tox*bj - bjp;                      bjp = bj;                      bj = bjm;                      if (System.Math.Abs(bj) > BIGNO)                      {                          bj *= BIGNI;                          bjp *= BIGNI;                          ans *= BIGNI;                          sum *= BIGNI;                      }                      if (jsum) sum += bj;                      jsum = !jsum;                      if (j == n) ans = bjp;                  }                  sum = 2.0*sum - bj;                  ans /= sum;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if (ax == 0.0) return 0.0;              else if (ax > n)              {                  tox = 2.0/ax;                  bjm = BesselJ0(ax);                  bj = BesselJ(ax);                  for (j = 1; j < n; j++)                  {                      bjp = j*tox*bj - bjm;                      bjm = bj;                      bj = bjp;                  }                  ans = bj;              }              else              {                  tox = 2.0/ax;                  m = 2*((n + (int) System.Math.Sqrt(ACC*n))/2);                  jsum = false;                  bjp = ans = sum = 0.0;                  bj = 1.0;                  for (j = m; j > 0; j--)                  {                      bjm = j*tox*bj - bjp;                      bjp = bj;                      bj = bjm;                      if (System.Math.Abs(bj) > BIGNO)                      {                          bj *= BIGNI;                          bjp *= BIGNI;                          ans *= BIGNI;                          sum *= BIGNI;                      }                      if (jsum) sum += bj;                      jsum = !jsum;                      if (j == n) ans = bjp;                  }                  sum = 2.0*sum - bj;                  ans /= sum;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if (ax == 0.0) return 0.0;              else if (ax > n)              {                  tox = 2.0/ax;                  bjm = BesselJ0(ax);                  bj = BesselJ(ax);                  for (j = 1; j < n; j++)                  {                      bjp = j*tox*bj - bjm;                      bjm = bj;                      bj = bjp;                  }                  ans = bj;              }              else              {                  tox = 2.0/ax;                  m = 2*((n + (int) System.Math.Sqrt(ACC*n))/2);                  jsum = false;                  bjp = ans = sum = 0.0;                  bj = 1.0;                  for (j = m; j > 0; j--)                  {                      bjm = j*tox*bj - bjp;                      bjp = bj;                      bj = bjm;                      if (System.Math.Abs(bj) > BIGNO)                      {                          bj *= BIGNI;                          bjp *= BIGNI;                          ans *= BIGNI;                          sum *= BIGNI;                      }                      if (jsum) sum += bj;                      jsum = !jsum;                      if (j == n) ans = bjp;                  }                  sum = 2.0*sum - bj;                  ans /= sum;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: if (ax == 0.0) return 0.0;              else if (ax > n)              {                  tox = 2.0/ax;                  bjm = BesselJ0(ax);                  bj = BesselJ(ax);                  for (j = 1; j < n; j++)                  {                      bjp = j*tox*bj - bjm;                      bjm = bj;                      bj = bjp;                  }                  ans = bj;              }              else              {                  tox = 2.0/ax;                  m = 2*((n + (int) System.Math.Sqrt(ACC*n))/2);                  jsum = false;                  bjp = ans = sum = 0.0;                  bj = 1.0;                  for (j = m; j > 0; j--)                  {                      bjm = j*tox*bj - bjp;                      bjp = bj;                      bj = bjm;                      if (System.Math.Abs(bj) > BIGNO)                      {                          bj *= BIGNI;                          bjp *= BIGNI;                          ans *= BIGNI;                          sum *= BIGNI;                      }                      if (jsum) sum += bj;                      jsum = !jsum;                      if (j == n) ans = bjp;                  }                  sum = 2.0*sum - bj;                  ans /= sum;              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselJ,The following statement contains a magic number: return x < 0.0 && n%2 == 1 ? -ans : ans;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY0,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                    double ans1 = -2957821389.0 + y*(7062834065.0 + y*(-512359803.6                                                                     + y*(10879881.29 + y*(-86327.92757 + y*228.4622733))));                  double ans2 = 40076544269.0 + y*(745249964.8 + y*(7189466.438                                                                    + y*(47447.26470 + y*(226.1030244 + y*1.0))));                    return (ans1/ans2) + 0.636619772*BesselJ0(x)*System.Math.Log(x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 0.785398164;                    double ans1 = 1.0 + y*(-0.1098628627e-2 + y*(0.2734510407e-4                                                               + y*(-0.2073370639e-5 + y*0.2093887211e-6)));                  double ans2 = -0.1562499995e-1 + y*(0.1430488765e-3                                                      + y*(-0.6911147651e-5 + y*(0.7621095161e-6                                                                                 + y*(-0.934945152e-7))));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: if (x < 8.0)              {                  double y = x*x;                  double ans1 = x*(-0.4900604943e13 + y*(0.1275274390e13                                                         + y*(-0.5153438139e11 + y*(0.7349264551e9                                                                                    +                                                                                    y*(-0.4237922726e7 + y*0.8511937935e4)))));                  double ans2 = 0.2499580570e14 + y*(0.4244419664e12                                                     + y*(0.3733650367e10 + y*(0.2245904002e8                                                                               +                                                                               y*(0.1020426050e6 + y*(0.3549632885e3 + y)))));                  return (ans1/ans2) + 0.636619772*(BesselJ(x)*System.Math.Log(x) - 1.0/x);              }              else              {                  double z = 8.0/x;                  double y = z*z;                  double xx = x - 2.356194491;                  double ans1 = 1.0 + y*(0.183105e-2 + y*(-0.3516396496e-4                                                          + y*(0.2457520174e-5 + y*(-0.240337019e-6))));                  double ans2 = 0.04687499995 + y*(-0.2002690873e-3                                                   + y*(0.8449199096e-5 + y*(-0.88228987e-6                                                                             + y*0.105787412e-6)));                  return System.Math.Sqrt(0.636619772/x)*                         (System.Math.Sin(xx)*ans1 + z*System.Math.Cos(xx)*ans2);              }
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,BesselY,The following statement contains a magic number: tox = 2.0/x;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Log1p,The following statement contains a magic number: if (System.Math.Abs(x) > 1e-4)                  return System.Math.Log(1.0 + x);
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Log1p,The following statement contains a magic number: return (-0.5*x + 1.0)*x;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Expm1,The following statement contains a magic number: if (System.Math.Abs(x) < 1e-5)                  return x + 0.5*x*x;              else                  return System.Math.Exp(x) - 1.0;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Expm1,The following statement contains a magic number: if (System.Math.Abs(x) < 1e-5)                  return x + 0.5*x*x;              else                  return System.Math.Exp(x) - 1.0;
Magic Number,Accord.Math,Special,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Special.cs,Epslon,The following statement contains a magic number: a = 1.3333333333333333;
Magic Number,Accord.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,NextPowerOf2,The following statement contains a magic number: x |= x >> 2;
Magic Number,Accord.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,NextPowerOf2,The following statement contains a magic number: x |= x >> 4;
Magic Number,Accord.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,NextPowerOf2,The following statement contains a magic number: x |= x >> 8;
Magic Number,Accord.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,NextPowerOf2,The following statement contains a magic number: x |= x >> 16;
Magic Number,Accord.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,PreviousPowerOf2,The following statement contains a magic number: return NextPowerOf2(x + 1)/2;
Magic Number,Accord.Math,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Tools.cs,Atanh,The following statement contains a magic number: return 0.5*System.Math.Log((1.0 + d)/(1.0 - d));
Magic Number,Accord.Math.Formats,MatrixFormatter,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Formats\Base\MatrixFormatter.cs,Format,The following statement contains a magic number: if (matrix.Rank > 2)              {                  throw new NotSupportedException("Matrices with more than two dimensions are not supported.");              }
Magic Number,Accord.Math.Formats,MatrixFormatter,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Formats\Base\MatrixFormatter.cs,Format,The following statement contains a magic number: int cols = (matrix.Rank == 2) ? matrix.GetLength(1) : 0;
Magic Number,Accord.Math.Formats,MatrixFormatter,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Formats\Base\MatrixFormatter.cs,parseOptions,The following statement contains a magic number: if (options.Length == 2)              {                  elementFormat = options[1];                    switch (options[0])                  {                      case "Mn":                          newline = "\n";                          break;                        case "Mnr":                          newline = "\n\r";                          break;                        case "Ms":                          newline = String.Empty;                          break;                        default:                          newline = String.Empty;                          return false;                  }                    return true;              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: if (N%2 == 0)                  return (data[N/2] + data[(N/2) - 1])*0.5; // N is even               else return data[N/2];
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: if (N%2 == 0)                  return (data[N/2] + data[(N/2) - 1])*0.5; // N is even               else return data[N/2];
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: if (N%2 == 0)                  return (data[N/2] + data[(N/2) - 1])*0.5; // N is even               else return data[N/2];
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: if (N%2 == 0)                  return (data[N/2] + data[(N/2) - 1])*0.5; // N is even               else return data[N/2];
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: if (N%2 == 0)                  return (data[N/2] + data[(N/2) - 1])*0.5; // N is even               else return data[N/2];
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Skewness,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  // Sum of third moment deviations                  sum += System.Math.Pow(values[i] - mean' 3);              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Skewness,The following statement contains a magic number: return sum/(n*System.Math.Pow(standardDeviation' 3));
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Kurtosis,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  // Sum of fourth moment deviations                  deviation = (values[i] - mean);                  sum += System.Math.Pow(deviation' 4);              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Kurtosis,The following statement contains a magic number: return sum/(n*System.Math.Pow(standardDeviation' 4)) - 3.0;
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Kurtosis,The following statement contains a magic number: return sum/(n*System.Math.Pow(standardDeviation' 4)) - 3.0;
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: for (int i = 0; i < cols; i++)              {                  var data = new double[rows];                    // Creates a copy of the given values                  for (int j = 0; j < rows; j++)                      data[j] = matrix[j' i];                    Array.Sort(data); // Sort it                    int N = data.Length;                    if (N%2 == 0)                      medians[i] = (data[N/2] + data[(N/2) - 1])*0.5; // N is even                   else medians[i] = data[N/2]; // N is odd              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: for (int i = 0; i < cols; i++)              {                  var data = new double[rows];                    // Creates a copy of the given values                  for (int j = 0; j < rows; j++)                      data[j] = matrix[j' i];                    Array.Sort(data); // Sort it                    int N = data.Length;                    if (N%2 == 0)                      medians[i] = (data[N/2] + data[(N/2) - 1])*0.5; // N is even                   else medians[i] = data[N/2]; // N is odd              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: for (int i = 0; i < cols; i++)              {                  var data = new double[rows];                    // Creates a copy of the given values                  for (int j = 0; j < rows; j++)                      data[j] = matrix[j' i];                    Array.Sort(data); // Sort it                    int N = data.Length;                    if (N%2 == 0)                      medians[i] = (data[N/2] + data[(N/2) - 1])*0.5; // N is even                   else medians[i] = data[N/2]; // N is odd              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: for (int i = 0; i < cols; i++)              {                  var data = new double[rows];                    // Creates a copy of the given values                  for (int j = 0; j < rows; j++)                      data[j] = matrix[j' i];                    Array.Sort(data); // Sort it                    int N = data.Length;                    if (N%2 == 0)                      medians[i] = (data[N/2] + data[(N/2) - 1])*0.5; // N is even                   else medians[i] = data[N/2]; // N is odd              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: for (int i = 0; i < cols; i++)              {                  var data = new double[rows];                    // Creates a copy of the given values                  for (int j = 0; j < rows; j++)                      data[j] = matrix[j' i];                    Array.Sort(data); // Sort it                    int N = data.Length;                    if (N%2 == 0)                      medians[i] = (data[N/2] + data[(N/2) - 1])*0.5; // N is even                   else medians[i] = data[N/2]; // N is odd              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: for (int i = 0; i < cols; i++)              {                  var data = new double[rows];                    // Creates a copy of the given values                  for (int j = 0; j < rows; j++)                      data[j] = matrix[j][i];                    Array.Sort(data); // Sort it                    int N = data.Length;                    if (N%2 == 0)                      medians[i] = (data[N/2] + data[(N/2) - 1])*0.5; // N is even                   else medians[i] = data[N/2]; // N is odd              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: for (int i = 0; i < cols; i++)              {                  var data = new double[rows];                    // Creates a copy of the given values                  for (int j = 0; j < rows; j++)                      data[j] = matrix[j][i];                    Array.Sort(data); // Sort it                    int N = data.Length;                    if (N%2 == 0)                      medians[i] = (data[N/2] + data[(N/2) - 1])*0.5; // N is even                   else medians[i] = data[N/2]; // N is odd              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: for (int i = 0; i < cols; i++)              {                  var data = new double[rows];                    // Creates a copy of the given values                  for (int j = 0; j < rows; j++)                      data[j] = matrix[j][i];                    Array.Sort(data); // Sort it                    int N = data.Length;                    if (N%2 == 0)                      medians[i] = (data[N/2] + data[(N/2) - 1])*0.5; // N is even                   else medians[i] = data[N/2]; // N is odd              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: for (int i = 0; i < cols; i++)              {                  var data = new double[rows];                    // Creates a copy of the given values                  for (int j = 0; j < rows; j++)                      data[j] = matrix[j][i];                    Array.Sort(data); // Sort it                    int N = data.Length;                    if (N%2 == 0)                      medians[i] = (data[N/2] + data[(N/2) - 1])*0.5; // N is even                   else medians[i] = data[N/2]; // N is odd              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Median,The following statement contains a magic number: for (int i = 0; i < cols; i++)              {                  var data = new double[rows];                    // Creates a copy of the given values                  for (int j = 0; j < rows; j++)                      data[j] = matrix[j][i];                    Array.Sort(data); // Sort it                    int N = data.Length;                    if (N%2 == 0)                      medians[i] = (data[N/2] + data[(N/2) - 1])*0.5; // N is even                   else medians[i] = data[N/2]; // N is odd              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Skewness,The following statement contains a magic number: for (int j = 0; j < skewness.Length; j++)              {                  double sum = 0.0;                  for (int i = 0; i < n; i++)                  {                      // Sum of third moment deviations                      sum += System.Math.Pow(matrix[i' j] - means[j]' 3);                  }                    skewness[j] = sum/((n - 1)*System.Math.Pow(standardDeviations[j]' 3));              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Skewness,The following statement contains a magic number: for (int j = 0; j < skewness.Length; j++)              {                  double sum = 0.0;                  for (int i = 0; i < n; i++)                  {                      // Sum of third moment deviations                      sum += System.Math.Pow(matrix[i' j] - means[j]' 3);                  }                    skewness[j] = sum/((n - 1)*System.Math.Pow(standardDeviations[j]' 3));              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Kurtosis,The following statement contains a magic number: for (int j = 0; j < kurtosis.Length; j++)              {                  double sum = 0.0;                  for (int i = 0; i < n; i++)                  {                      // Sum of fourth moment deviations                      sum += System.Math.Pow(matrix[i' j] - means[j]' 4);                  }                    kurtosis[j] = sum/(n*System.Math.Pow(standardDeviations[j]' 4)) - 3.0;              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Kurtosis,The following statement contains a magic number: for (int j = 0; j < kurtosis.Length; j++)              {                  double sum = 0.0;                  for (int i = 0; i < n; i++)                  {                      // Sum of fourth moment deviations                      sum += System.Math.Pow(matrix[i' j] - means[j]' 4);                  }                    kurtosis[j] = sum/(n*System.Math.Pow(standardDeviations[j]' 4)) - 3.0;              }
Magic Number,Accord.Statistics,Tools,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Tools.cs,Kurtosis,The following statement contains a magic number: for (int j = 0; j < kurtosis.Length; j++)              {                  double sum = 0.0;                  for (int i = 0; i < n; i++)                  {                      // Sum of fourth moment deviations                      sum += System.Math.Pow(matrix[i' j] - means[j]' 4);                  }                    kurtosis[j] = sum/(n*System.Math.Pow(standardDeviations[j]' 4)) - 3.0;              }
Magic Number,HiddenMarkovModel.Utils,MotionCalculator,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Utils\MotionCalculator.cs,CalculateMotion,The following statement contains a magic number: double x = Math.Atan2(end.Y - start.Y' end.X - start.X)*180/Math.PI;
Magic Number,HiddenMarkovModel.Utils,MotionCalculator,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Utils\MotionCalculator.cs,CalculateMotion,The following statement contains a magic number: if (x != Math.Abs(x))              {                  x += 360;              }
Missing Default,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following switch statement is missing a default case: switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }
Missing Default,Accord.Math.Decompositions,GeneralizedEigenvalueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\GeneralizedEigenvalueDecomposition.cs,qzvec,The following switch statement is missing a default case: switch (isw)                      {                          case 1:                              goto L787;                          case 2:                              goto L782;                      }
Missing Default,Accord.Math.Decompositions,SingularValueDecomposition,C:\repos\atosorigin_Kinect\src\Extensions\HiddenMarkovModel\Math\Decomposition\SingularValueDecomposition.cs,SingularValueDecomposition,The following switch statement is missing a default case: switch (kase)                  {                          // Deflate negligible s(p).                      case 1:                          {                              double f = e[p - 2];                              e[p - 2] = 0.0;                              for (int j = p - 2; j >= k; j--)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  if (j != k)                                  {                                      f = -sn*e[j - 1];                                      e[j - 1] = cs*e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs*v[i' j] + sn*v[i' p - 1];                                          v[i' p - 1] = -sn*v[i' j] + cs*v[i' p - 1];                                          v[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Split at negligible s(k).                      case 2:                          {                              double f = e[k - 1];                              e[k - 1] = 0.0;                              for (int j = k; j < p; j++)                              {                                  double t = Tools.Hypotenuse(s[j]' f);                                  double cs = s[j]/t;                                  double sn = f/t;                                  s[j] = t;                                  f = -sn*e[j];                                  e[j] = cs*e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs*u[i' j] + sn*u[i' k - 1];                                          u[i' k - 1] = -sn*u[i' j] + cs*u[i' k - 1];                                          u[i' j] = t;                                      }                                  }                              }                          }                          break;                            // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              double scale =                                  System.Math.Max(                                      System.Math.Max(                                          System.Math.Max(                                              System.Math.Max(System.Math.Abs(s[p - 1])' System.Math.Abs(s[p - 2]))'                                              System.Math.Abs(e[p - 2]))' System.Math.Abs(s[k]))' System.Math.Abs(e[k]));                              double sp = s[p - 1]/scale;                              double spm1 = s[p - 2]/scale;                              double epm1 = e[p - 2]/scale;                              double sk = s[k]/scale;                              double ek = e[k]/scale;                              double b = ((spm1 + sp)*(spm1 - sp) + epm1*epm1)/2.0;                              double c = (sp*epm1)*(sp*epm1);                              double shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  if (b < 0.0)                                      shift = -System.Math.Sqrt(b*b + c);                                  else                                      shift = System.Math.Sqrt(b*b + c);                                    shift = c/(b + shift);                              }                                double f = (sk + sp)*(sk - sp) + shift;                              double g = sk*ek;                                // Chase zeros.                              for (int j = k; j < p - 1; j++)                              {                                  double t = Tools.Hypotenuse(f' g);                                  double cs = f/t;                                  double sn = g/t;                                  if (j != k) e[j - 1] = t;                                  f = cs*s[j] + sn*e[j];                                  e[j] = cs*e[j] - sn*s[j];                                  g = sn*s[j + 1];                                  s[j + 1] = cs*s[j + 1];                                    if (wantv)                                  {                                      unsafe                                      {                                          fixed (double* ptr_vj = &v[0' j])                                          {                                              double* vj = ptr_vj;                                              double* vj1 = ptr_vj + 1;                                                for (int i = 0; i < n; i++)                                              {                                                  /*t = cs * v[i' j] + sn * v[i' j + 1];                                                  v[i' j + 1] = -sn * v[i' j] + cs * v[i' j + 1];                                                  v[i' j] = t;*/                                                    double vij = *vj;                                                  double vij1 = *vj1;                                                    t = cs*vij + sn*vij1;                                                  *vj1 = -sn*vij + cs*vij1;                                                  *vj = t;                                                    vj += n;                                                  vj1 += n;                                              }                                          }                                      }                                  }                                    t = Tools.Hypotenuse(f' g);                                  cs = f/t;                                  sn = g/t;                                  s[j] = t;                                  f = cs*e[j] + sn*s[j + 1];                                  s[j + 1] = -sn*e[j] + cs*s[j + 1];                                  g = sn*e[j + 1];                                  e[j + 1] = cs*e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      unsafe                                      {                                          fixed (double* ptr_uj = &u[0' j])                                          {                                              double* uj = ptr_uj;                                              double* uj1 = ptr_uj + 1;                                                for (int i = 0; i < m; i++)                                              {                                                  /* t = cs * u[i' j] + sn * u[i' j + 1];                                                   u[i' j + 1] = -sn * u[i' j] + cs * u[i' j + 1];                                                   u[i' j] = t;*/                                                    double uij = *uj;                                                  double uij1 = *uj1;                                                    t = cs*uij + sn*uij1;                                                  *uj1 = -sn*uij + cs*uij1;                                                  *uj = t;                                                    uj += nu;                                                  uj1 += nu;                                              }                                          }                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                            // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                  if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                          v[i' k] = -v[i' k];                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    double t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    int ti = si[k];                                  si[k] = si[k + 1];                                  si[k + 1] = ti;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = v[i' k + 1];                                          v[i' k + 1] = v[i' k];                                          v[i' k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = u[i' k + 1];                                          u[i' k + 1] = u[i' k];                                          u[i' k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
