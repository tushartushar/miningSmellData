Implementation smell,Namespace,Class,File,Method,Description
Long Method,LightNode.Server,LightNodeServer,C:\repos\neuecc_LightNode\Source\LightNode.Server\LightNodeServer.cs,ProcessRequest,The method has 113 lines of code.
Long Method,LightNode.Server,MetaEnum,C:\repos\neuecc_LightNode\Source\LightNode.Server\Utility\MetaEnum.cs,TryParse,The method has 117 lines of code.
Long Method,LightNode.Server,OperationHandler,C:\repos\neuecc_LightNode\Source\LightNode.Server\OperationHandler.cs,OperationHandler,The method has 115 lines of code.
Long Method,LightNode.Server,ValueProvider,C:\repos\neuecc_LightNode\Source\LightNode.Server\ValueProvider.cs,ParseMultipartValue,The method has 156 lines of code.
Complex Method,LightNode.Server,LightNodeServer,C:\repos\neuecc_LightNode\Source\LightNode.Server\LightNodeServer.cs,SelectHandler,Cyclomatic complexity of the method is 8
Complex Method,LightNode.Server,LightNodeServer,C:\repos\neuecc_LightNode\Source\LightNode.Server\LightNodeServer.cs,ProcessRequest,Cyclomatic complexity of the method is 8
Complex Method,LightNode.Server,MetaEnum,C:\repos\neuecc_LightNode\Source\LightNode.Server\Utility\MetaEnum.cs,TryParseStrict,Cyclomatic complexity of the method is 9
Complex Method,LightNode.Server,MetaEnum,C:\repos\neuecc_LightNode\Source\LightNode.Server\Utility\MetaEnum.cs,TryParse,Cyclomatic complexity of the method is 11
Complex Method,LightNode.Server,ValueProvider,C:\repos\neuecc_LightNode\Source\LightNode.Server\ValueProvider.cs,ParseMultipartValue,Cyclomatic complexity of the method is 12
Long Parameter List,LightNode.Server,ParameterBinder,C:\repos\neuecc_LightNode\Source\LightNode.Server\ParameterBinder.cs,BindParameter,The method has 5 parameters. Parameters: environment' options' coordinator' valueProvider' arguments
Long Parameter List,LightNode.Server,ReturnStatusCodeException,C:\repos\neuecc_LightNode\Source\LightNode.Server\ReturnStatusCodeException.cs,ReturnStatusCodeException,The method has 5 parameters. Parameters: statusCode' reasonPhrase' content' contentFormatter' environmentEmitter
Long Parameter List,LightNode.Server,ReturnStatusCodeException,C:\repos\neuecc_LightNode\Source\LightNode.Server\ReturnStatusCodeException.cs,ReturnStatusCodeException,The method has 5 parameters. Parameters: statusCode' reasonPhrase' content' contentFormatter' environmentEmitter
Long Parameter List,LightNode.Server,OperationHandler,C:\repos\neuecc_LightNode\Source\LightNode.Server\OperationHandler.cs,InvokeRecursive,The method has 5 parameters. Parameters: index' filters' options' context' coordinator
Long Parameter List,LightNode.Server,UnclosableStream,C:\repos\neuecc_LightNode\Source\LightNode.Server\Utility\UnclosableStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,LightNode.Server,UnclosableStream,C:\repos\neuecc_LightNode\Source\LightNode.Server\Utility\UnclosableStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Statement,LightNode.Server,ParameterBinder,C:\repos\neuecc_LightNode\Source\LightNode.Server\ParameterBinder.cs,BindParameter,The length of the statement  "                    else if ((!item.ParameterTypeIsString || options.ParameterStringImplicitNullAsDefault) && (item.ParameterTypeIsClass || item.ParameterTypeIsNullable)) " is 150.
Long Statement,LightNode.Server,ParameterBinder,C:\repos\neuecc_LightNode\Source\LightNode.Server\ParameterBinder.cs,BindParameter,The length of the statement  "                        coordinator.OnProcessInterrupt(options' environment' InterruptReason.ParameterBindMissing' "Lack of Parameter:" + item.Name); " is 125.
Long Statement,LightNode.Server,ParameterBinder,C:\repos\neuecc_LightNode\Source\LightNode.Server\ParameterBinder.cs,BindParameter,The length of the statement  "                    else if ((!item.ParameterTypeIsString || options.ParameterStringImplicitNullAsDefault) && (item.ParameterTypeIsClass || item.ParameterTypeIsNullable)) " is 150.
Long Statement,LightNode.Server,ParameterBinder,C:\repos\neuecc_LightNode\Source\LightNode.Server\ParameterBinder.cs,BindParameter,The length of the statement  "                        coordinator.OnProcessInterrupt(options' environment' InterruptReason.ParameterBindMissing' "Mismatch ParameterType:" + item.Name); " is 130.
Long Statement,LightNode.Server,ParameterBinder,C:\repos\neuecc_LightNode\Source\LightNode.Server\ParameterBinder.cs,BindParameter,The length of the statement  "                methodParameters[i] = arrayConv((values != null) ? values : (value != null) ? new[] { value } : (IList<string>)new string[0]); " is 126.
Long Statement,LightNode.Server,ReturnStatusCodeException,C:\repos\neuecc_LightNode\Source\LightNode.Server\ReturnStatusCodeException.cs,EmitCode,The length of the statement  "                responseHeader["Content-Type"] = new[] { contentFormatter.MediaType + ((encoding == null) ? "" : "; charset=" + encoding.WebName) }; " is 132.
Long Statement,LightNode.Server,LightNodeServer,C:\repos\neuecc_LightNode\Source\LightNode.Server\LightNodeServer.cs,RegisterHandler,The length of the statement  "                    throw new InvalidOperationException(string.Format("Type needs parameterless constructor' class:{0}"' classType.FullName)); " is 122.
Long Statement,LightNode.Server,LightNodeServer,C:\repos\neuecc_LightNode\Source\LightNode.Server\LightNodeServer.cs,RegisterHandler,The length of the statement  "                    if (methodInfo.IsSpecialName && (methodInfo.Name.StartsWith("set_") || methodInfo.Name.StartsWith("get_"))) continue; // as property " is 132.
Long Statement,LightNode.Server,LightNodeServer,C:\repos\neuecc_LightNode\Source\LightNode.Server\LightNodeServer.cs,RegisterHandler,The length of the statement  "                            throw new InvalidOperationException(string.Format("same class and method is not allowed' class:{0} method:{1}"' className' methodName)); " is 136.
Long Statement,LightNode.Server,LightNodeServer,C:\repos\neuecc_LightNode\Source\LightNode.Server\LightNodeServer.cs,RegisterHandler,The length of the statement  "            return handlers.Select(x => new KeyValuePair<string' OperationInfo>(x.Key.ToString()' new OperationInfo(x.Value))).ToList().AsReadOnly(); " is 137.
Long Statement,LightNode.Server,LightNodeServer,C:\repos\neuecc_LightNode\Source\LightNode.Server\LightNodeServer.cs,ProcessRequest,The length of the statement  "                var methodParameters = ParameterBinder.BindParameter(environment' options' coordinator' valueProvider' handler.Arguments); " is 122.
Long Statement,LightNode.Server,OperationHandler,C:\repos\neuecc_LightNode\Source\LightNode.Server\OperationHandler.cs,SelectAcceptEncodingFormatter,The length of the statement  "                .Select(kvp => selectedFormatters.FirstOrDefault(x => kvp.Item3.Equals(x.ContentEncoding' StringComparison.OrdinalIgnoreCase))) " is 127.
Long Statement,LightNode.Server,OperationHandler,C:\repos\neuecc_LightNode\Source\LightNode.Server\OperationHandler.cs,GetDescendingQualityHeaderValues,The length of the statement  "                    if (qSplitted.Length == 2 && qSplitted[0].Trim().Equals("q"' StringComparison.InvariantCultureIgnoreCase) && double.TryParse(qSplitted[1]' out q)) " is 146.
Long Statement,LightNode.Server,OperationHandler,C:\repos\neuecc_LightNode\Source\LightNode.Server\OperationHandler.cs,ExecuteOperation,The length of the statement  "                responseHeader["Content-Type"] = new[] { context.ContentFormatter.MediaType + ((encoding == null) ? "" : "; charset=" + encoding.WebName) }; " is 140.
Complex Conditional,LightNode.Server,ParameterBinder,C:\repos\neuecc_LightNode\Source\LightNode.Server\ParameterBinder.cs,BindParameter,The conditional expression  "(!item.ParameterTypeIsString || options.ParameterStringImplicitNullAsDefault) && (item.ParameterTypeIsClass || item.ParameterTypeIsNullable)"  is complex.
Complex Conditional,LightNode.Server,ParameterBinder,C:\repos\neuecc_LightNode\Source\LightNode.Server\ParameterBinder.cs,BindParameter,The conditional expression  "(!item.ParameterTypeIsString || options.ParameterStringImplicitNullAsDefault) && (item.ParameterTypeIsClass || item.ParameterTypeIsNullable)"  is complex.
Complex Conditional,LightNode.Server,LightNodeServer,C:\repos\neuecc_LightNode\Source\LightNode.Server\LightNodeServer.cs,RegisterHandler,The conditional expression  "methodName == "Equals"                       || methodName == "GetHashCode"                       || methodName == "GetType"                       || methodName == "ToString""  is complex.
Magic Number,LightNode.Server,LightNodeServer,C:\repos\neuecc_LightNode\Source\LightNode.Server\LightNodeServer.cs,SelectHandler,The following statement contains a magic number: if (keyBase.Length != 2)              {                  goto NOT_FOUND;              }
Magic Number,LightNode.Server,OperationHandler,C:\repos\neuecc_LightNode\Source\LightNode.Server\OperationHandler.cs,GetDescendingQualityHeaderValues,The following statement contains a magic number: foreach (var item in rawHeaders)              {                  var splitted = item.Split(';');                  if (splitted.Length == 1)                  {                      list.Add(Tuple.Create(index++' 1.0' splitted[0].Trim()));                  }                  else if (splitted.Length == 2)                  {                      var name = splitted[0].Trim();                      var rawQ = splitted[1];                      var q = 1.0;                      var qSplitted = rawQ.Split('=');                      if (qSplitted.Length == 2 && qSplitted[0].Trim().Equals("q"' StringComparison.InvariantCultureIgnoreCase) && double.TryParse(qSplitted[1]' out q))                      {                          list.Add(Tuple.Create(index++' q' name));                      }                      else                      {                          list.Add(Tuple.Create(index++' 1.0' name));                      }                  }              }
Magic Number,LightNode.Server,OperationHandler,C:\repos\neuecc_LightNode\Source\LightNode.Server\OperationHandler.cs,GetDescendingQualityHeaderValues,The following statement contains a magic number: foreach (var item in rawHeaders)              {                  var splitted = item.Split(';');                  if (splitted.Length == 1)                  {                      list.Add(Tuple.Create(index++' 1.0' splitted[0].Trim()));                  }                  else if (splitted.Length == 2)                  {                      var name = splitted[0].Trim();                      var rawQ = splitted[1];                      var q = 1.0;                      var qSplitted = rawQ.Split('=');                      if (qSplitted.Length == 2 && qSplitted[0].Trim().Equals("q"' StringComparison.InvariantCultureIgnoreCase) && double.TryParse(qSplitted[1]' out q))                      {                          list.Add(Tuple.Create(index++' q' name));                      }                      else                      {                          list.Add(Tuple.Create(index++' 1.0' name));                      }                  }              }
Magic Number,LightNode.Server,RequestPath,C:\repos\neuecc_LightNode\Source\LightNode.Server\RequestPath.cs,CombineHashCodes,The following statement contains a magic number: return (h1 << 5) + h1 ^ h2;
Magic Number,LightNode.Server,ValueProvider,C:\repos\neuecc_LightNode\Source\LightNode.Server\ValueProvider.cs,AppendValues,The following statement contains a magic number: foreach (var amp in urlEncodedString.Split('&'))              {                  var item = amp.Split('=');                  if (item.Length == 2)                  {                      var key = System.Net.WebUtility.UrlDecode(item[0]);                      var value = System.Net.WebUtility.UrlDecode(item[1]);                        object result;                      if (values.TryGetValue(key' out result))                      {                          if (result is string)                          {                              // second                              values[key] = new List<string>() { (string)result' value };                          }                          else                          {                              // third                              ((List<string>)result).Add(value);                          }                      }                      else                      {                          // first                          values[key] = value;                      }                  }              }
Magic Number,LightNode.Server,ValueProvider,C:\repos\neuecc_LightNode\Source\LightNode.Server\ValueProvider.cs,ParseMultipartValue,The following statement contains a magic number: while ((intB = stream.ReadByte()) != -1)              {                  // checking boundary                  var b = (byte)intB;                  if (b == boundary[boundaryLength++])                  {                      if (boundaryLength == boundary.Length)                      {                          // matched' go to next sequence.                          boundaryLength = 0;                          bufferInReadingBoundary.Position = 0;                          state = ReadMultipartState.ReadingHeader;                            // flush buffer                          if (buffer.Position != 0)                          {                              if (lastName == null) break;                                var key = lastName;                                if (lastBufferIsString)                              {                                  var bytes = buffer.GetBuffer();                                  var value = Encoding.UTF8.GetString(bytes' 0' (int)buffer.Position).Trim('\r'' '\n');                                    object result;                                  if (values.TryGetValue(key' out result))                                  {                                      if (result is string)                                      {                                          // second                                          values[key] = new List<string>() { (string)result' value };                                      }                                      else                                      {                                          // third                                          ((List<string>)result).Add(value);                                      }                                  }                                  else                                  {                                      // first                                      values[key] = value;                                  }                              }                              else                              {                                  var bytes = buffer.GetBuffer();                                  var preSkipCount = 0;                                  var postSkipCount = 0;                                  if (bytes.Length > 4)                                  {                                      if (bytes[0] == '\r')                                      {                                          preSkipCount++;                                          if (bytes[1] == '\n') preSkipCount++;                                      }                                      if (bytes[buffer.Position - 1] == '\n')                                      {                                          postSkipCount++;                                          if (bytes[buffer.Position - 2] == '\r') postSkipCount++;                                      }                                  }                                    var value = new byte[buffer.Position - preSkipCount - postSkipCount];                                  Buffer.BlockCopy(bytes' preSkipCount' value' 0' value.Length);                                    object result;                                  if (values.TryGetValue(key' out result))                                  {                                      if (result is byte[])                                      {                                          // second                                          values[key] = new List<byte[]>() { (byte[])result' value };                                      }                                      else                                      {                                          // third                                          ((List<byte[]>)result).Add(value);                                      }                                  }                                  else                                  {                                      // first                                      values[key] = value;                                  }                              }                                lastBufferIsString = false;                              lastName = null;                              buffer.Position = 0;                          }                            continue;                      }                      else                      {                          bufferInReadingBoundary.WriteByte(b);                      }                      // check new boundary                      continue;                  }                  else                  {                      if (bufferInReadingBoundary.Position != 0)                      {                          var bufArray = bufferInReadingBoundary.GetBuffer();                          for (int i = 0; i < bufferInReadingBoundary.Position; i++)                          {                              buffer.WriteByte(bufArray[i]);                          }                          bufferInReadingBoundary.Position = 0;                      }                        boundaryLength = 0;                  }                    if (state == ReadMultipartState.ReadingHeader)                  {                      // ReadLine                      headerBuffer.WriteByte(b);                        bool foundR = false;                      while ((intB = stream.ReadByte()) != -1)                      {                          b = (byte)intB;                          if (b == '\r')                          {                              foundR = true;                              continue;                          }                          else if (foundR && b == '\n')                          {                              foundR = false;                                // finish buffer.                              var stringBuffer = headerBuffer.GetBuffer();                              var headerString = Encoding.UTF8.GetString(stringBuffer' 0' (int)headerBuffer.Position).Trim('\r'' '\n');                                if (headerString.StartsWith("Content-Type") && headerString.Contains("text/plain"))                              {                                  lastBufferIsString = true;                              }                              if (headerString.StartsWith("Content-Disposition"))                              {                                  lastName = nameRegex.Match(headerString).Groups[1].Value;                                  state = ReadMultipartState.ReadingValue;                              }                                headerBuffer.Position = 0;                              break;                          }                            headerBuffer.WriteByte(b);                      }                  }                  else                  {                      buffer.WriteByte(b);                  }              }
Magic Number,LightNode.Server,ValueProvider,C:\repos\neuecc_LightNode\Source\LightNode.Server\ValueProvider.cs,ParseMultipartValue,The following statement contains a magic number: while ((intB = stream.ReadByte()) != -1)              {                  // checking boundary                  var b = (byte)intB;                  if (b == boundary[boundaryLength++])                  {                      if (boundaryLength == boundary.Length)                      {                          // matched' go to next sequence.                          boundaryLength = 0;                          bufferInReadingBoundary.Position = 0;                          state = ReadMultipartState.ReadingHeader;                            // flush buffer                          if (buffer.Position != 0)                          {                              if (lastName == null) break;                                var key = lastName;                                if (lastBufferIsString)                              {                                  var bytes = buffer.GetBuffer();                                  var value = Encoding.UTF8.GetString(bytes' 0' (int)buffer.Position).Trim('\r'' '\n');                                    object result;                                  if (values.TryGetValue(key' out result))                                  {                                      if (result is string)                                      {                                          // second                                          values[key] = new List<string>() { (string)result' value };                                      }                                      else                                      {                                          // third                                          ((List<string>)result).Add(value);                                      }                                  }                                  else                                  {                                      // first                                      values[key] = value;                                  }                              }                              else                              {                                  var bytes = buffer.GetBuffer();                                  var preSkipCount = 0;                                  var postSkipCount = 0;                                  if (bytes.Length > 4)                                  {                                      if (bytes[0] == '\r')                                      {                                          preSkipCount++;                                          if (bytes[1] == '\n') preSkipCount++;                                      }                                      if (bytes[buffer.Position - 1] == '\n')                                      {                                          postSkipCount++;                                          if (bytes[buffer.Position - 2] == '\r') postSkipCount++;                                      }                                  }                                    var value = new byte[buffer.Position - preSkipCount - postSkipCount];                                  Buffer.BlockCopy(bytes' preSkipCount' value' 0' value.Length);                                    object result;                                  if (values.TryGetValue(key' out result))                                  {                                      if (result is byte[])                                      {                                          // second                                          values[key] = new List<byte[]>() { (byte[])result' value };                                      }                                      else                                      {                                          // third                                          ((List<byte[]>)result).Add(value);                                      }                                  }                                  else                                  {                                      // first                                      values[key] = value;                                  }                              }                                lastBufferIsString = false;                              lastName = null;                              buffer.Position = 0;                          }                            continue;                      }                      else                      {                          bufferInReadingBoundary.WriteByte(b);                      }                      // check new boundary                      continue;                  }                  else                  {                      if (bufferInReadingBoundary.Position != 0)                      {                          var bufArray = bufferInReadingBoundary.GetBuffer();                          for (int i = 0; i < bufferInReadingBoundary.Position; i++)                          {                              buffer.WriteByte(bufArray[i]);                          }                          bufferInReadingBoundary.Position = 0;                      }                        boundaryLength = 0;                  }                    if (state == ReadMultipartState.ReadingHeader)                  {                      // ReadLine                      headerBuffer.WriteByte(b);                        bool foundR = false;                      while ((intB = stream.ReadByte()) != -1)                      {                          b = (byte)intB;                          if (b == '\r')                          {                              foundR = true;                              continue;                          }                          else if (foundR && b == '\n')                          {                              foundR = false;                                // finish buffer.                              var stringBuffer = headerBuffer.GetBuffer();                              var headerString = Encoding.UTF8.GetString(stringBuffer' 0' (int)headerBuffer.Position).Trim('\r'' '\n');                                if (headerString.StartsWith("Content-Type") && headerString.Contains("text/plain"))                              {                                  lastBufferIsString = true;                              }                              if (headerString.StartsWith("Content-Disposition"))                              {                                  lastName = nameRegex.Match(headerString).Groups[1].Value;                                  state = ReadMultipartState.ReadingValue;                              }                                headerBuffer.Position = 0;                              break;                          }                            headerBuffer.WriteByte(b);                      }                  }                  else                  {                      buffer.WriteByte(b);                  }              }
