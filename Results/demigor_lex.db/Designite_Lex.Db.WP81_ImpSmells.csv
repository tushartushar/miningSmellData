Implementation smell,Namespace,Class,File,Method,Description
Long Method,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,TryEnterReadLockCore,The method has 107 lines of code.
Long Method,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,TryEnterWriteLockCore,The method has 140 lines of code.
Long Method,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,TryEnterUpgradeableReadLockCore,The method has 102 lines of code.
Complex Method,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,GetThreadRWCount,Cyclomatic complexity of the method is 12
Complex Method,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,TryEnterReadLockCore,Cyclomatic complexity of the method is 16
Complex Method,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,TryEnterWriteLockCore,Cyclomatic complexity of the method is 22
Complex Method,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,TryEnterUpgradeableReadLockCore,Cyclomatic complexity of the method is 15
Complex Method,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,Dispose,Cyclomatic complexity of the method is 9
Complex Method,Lex.Db,TypeMap<T>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Mapping\TypeMap.cs,ExtractMemberEx,Cyclomatic complexity of the method is 11
Complex Method,System.IO,BufferedStream,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\BufferedStream.cs,Read,Cyclomatic complexity of the method is 14
Complex Method,System.IO,BufferedStream,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\BufferedStream.cs,Write,Cyclomatic complexity of the method is 15
Complex Method,System.IO,BufferedStream,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\BufferedStream.cs,Seek,Cyclomatic complexity of the method is 8
Long Parameter List,Lex.Db,DbTable<T>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Db\DbTable.cs,CreateIndex,The method has 5 parameters. Parameters: name' getter' comparer' members' lazyCtor
Long Parameter List,Lex.Db,DbTable<T>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Db\DbTable.cs,CreateIndex,The method has 5 parameters. Parameters: name' member1' comparer1' member2' comparer2
Long Parameter List,Lex.Db,DbTable<T>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Db\DbTable.cs,CreateIndex,The method has 7 parameters. Parameters: name' member1' comparer1' member2' comparer2' member3' comparer3
Long Parameter List,Lex.Db,TypeMap<T>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Mapping\TypeMap.cs,WithIndex,The method has 5 parameters. Parameters: name' indexBy' thenBy' comparerIndexBy' comparerThenBy
Long Parameter List,Lex.Db,TypeMap<T>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Mapping\TypeMap.cs,WithIndex,The method has 7 parameters. Parameters: name' indexBy' thenBy' andThenBy' comparerIndexBy' comparerThenBy' comparerAndThenBy
Long Parameter List,Lex.Db.Indexing,DataIndex<T;K>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Indexing\DataIndex.cs,DataIndex,The method has 6 parameters. Parameters: loader' name' getter' comparer' lazyCtor' members
Long Statement,Lex.Db,DbExplorer,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Db\DbInstance.cs,Initialize,The length of the statement  "      _namedTables = (from m in _namedMetadata select CreateTable(m.Value' m.Key)).ToDictionary(i => i.Name' StringComparer.OrdinalIgnoreCase); " is 137.
Long Statement,Lex.Db,DbExplorer,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Db\DbInstance.cs,InitPK,The length of the statement  "      var keyMethod = GetType().GetMethod("InitPKCore"' System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic); " is 134.
Long Statement,Lex.Db,DbTable<T>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Db\DbTable.cs,GetPrimaryIndex,The length of the statement  "        throw new ArgumentException(string.Format("Primary Index {0} mismatch ({1} expected)"' typeof(K).Name' KeyIndex.KeyType.Name)); " is 127.
Long Statement,Lex.Db,DbTable<T>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Db\DbTable.cs,GetIndex,The length of the statement  "        throw new ArgumentException(string.Format("Index {0}<{1}' {2}' {3}> not found"' name' typeof(I1).Name' typeof(I2).Name' typeof(I3).Name)); " is 138.
Long Statement,Lex.Db,DbTable<T>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Db\DbTable.cs,BuildGetter,The length of the statement  "      var tuple = Expression.New(typeof(Indexer<I1' I2>).GetConstructor(new[] { typeof(I1)' typeof(I2) })' obj.Member(member1)' obj.Member(member2)); " is 143.
Long Statement,Lex.Db,IndexQueryBase<T;K;R>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Indexing\Indexes.cs,Key,The length of the statement  "      return CloneAndUpdate(i => { i._args.Max = key; i._args.Min = key; i._args.MaxInclusive = true; i._args.MinInclusive = true; }); " is 128.
Long Statement,Lex.Db,Extensions,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Mapping\MemberMap.cs,Member,The length of the statement  "      return member.Target == null ? target.Member(member.Member) : member.Target.Clone(member.Self' target).Member(member.Member); " is 125.
Long Statement,System.IO,BufferedStream,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\BufferedStream.cs,Seek,The length of the statement  "          //Console.WriteLine("Seek: diff was "+diff+"' readpos was "+_readPos+"  adjusting buffer - shrinking by "+ (_readPos + diff)); " is 126.
Long Statement,Lex.Db.Mapping,Metadata<T>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Mapping\Metadata.cs,MakeDynamicReadMethod,The length of the statement  "      body = Expression.Assign(Expression.ArrayAccess(obj' Expression.Constant(idx))' Expression.Convert(body' typeof(object))); " is 122.
Long Statement,Lex.Db.Serialization,Serializers,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Serialization\Serializers.cs,GetWriteMethodFrom,The length of the statement  "      if (parameters.Length != 2 || parameters[0].ParameterType != typeof(DataWriter) || parameters[1].ParameterType != typeof(K)) " is 124.
Long Statement,Lex.Db.Serialization,Serializers,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Serialization\Serializers.cs,WriteValueNormal,The length of the statement  "      var writeValue = Expression.Call(null' GetWriteMethod(type)' writer' value);  // Serializers.WriteXXX(writer' obj.Property|Field); " is 130.
Long Statement,Lex.Db.FileSystem,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\FileSystem\DbTableStorage.cs,OpenWrite,The length of the statement  "          return new FileStream(name' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' buffered ? BufferSize : 4 * 1024); " is 123.
Complex Conditional,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,WaitOnEvent,The conditional expression  "_numWriteWaiters == 0 && _numWriteUpgradeWaiters == 0 && _numUpgradeWaiters == 0 && _numReadWaiters == 0"  is complex.
Complex Conditional,Lex.Db.Indexing,RBTree<TKey;TNode>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Indexing\RedBlackTree.cs,DeleteFix,The conditional expression  "(w.Left == null || w.Left.Color == RBTreeColor.Black) &&                (w.Right == null || w.Right.Color == RBTreeColor.Black)"  is complex.
Complex Conditional,Lex.Db.Indexing,RBTree<TKey;TNode>,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Indexing\RedBlackTree.cs,DeleteFix,The conditional expression  "(w.Right == null || w.Right.Color == RBTreeColor.Black) &&                (w.Left == null || w.Left.Color == RBTreeColor.Black)"  is complex.
Virtual Method Call from Constructor,Lex.Db.FileSystem,Reader,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\FileSystem\DbTableStorage.cs,Reader,The constructor "Reader" calls a virtual method "CreateStreams".
Virtual Method Call from Constructor,Lex.Db.IsolatedStorage,Reader,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\IsolatedStorage\DbTableStorage.cs,Reader,The constructor "Reader" calls a virtual method "CreateStreams".
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: var rem = len & 3;
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: len = len >> 2;
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: for (; len > 0; len--)        {          hash += GetUInt(data' idx);          var tmp = (GetUInt(data' idx + 2) << 11) ^ hash;          hash = (hash << 16) ^ tmp;          idx += 4;          hash += hash >> 11;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: for (; len > 0; len--)        {          hash += GetUInt(data' idx);          var tmp = (GetUInt(data' idx + 2) << 11) ^ hash;          hash = (hash << 16) ^ tmp;          idx += 4;          hash += hash >> 11;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: for (; len > 0; len--)        {          hash += GetUInt(data' idx);          var tmp = (GetUInt(data' idx + 2) << 11) ^ hash;          hash = (hash << 16) ^ tmp;          idx += 4;          hash += hash >> 11;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: for (; len > 0; len--)        {          hash += GetUInt(data' idx);          var tmp = (GetUInt(data' idx + 2) << 11) ^ hash;          hash = (hash << 16) ^ tmp;          idx += 4;          hash += hash >> 11;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: for (; len > 0; len--)        {          hash += GetUInt(data' idx);          var tmp = (GetUInt(data' idx + 2) << 11) ^ hash;          hash = (hash << 16) ^ tmp;          idx += 4;          hash += hash >> 11;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: switch (rem)        {          case 3:            hash += GetUInt(data' idx);            hash ^= hash << 16;            hash ^= (uint)data[idx + 2] << 18;            hash += hash >> 11;            break;            case 2:            hash += GetUInt(data' idx);            hash ^= hash << 11;            hash += hash >> 17;            break;            case 1:            hash += data[idx];            hash ^= hash << 10;            hash += hash >> 1;            break;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: switch (rem)        {          case 3:            hash += GetUInt(data' idx);            hash ^= hash << 16;            hash ^= (uint)data[idx + 2] << 18;            hash += hash >> 11;            break;            case 2:            hash += GetUInt(data' idx);            hash ^= hash << 11;            hash += hash >> 17;            break;            case 1:            hash += data[idx];            hash ^= hash << 10;            hash += hash >> 1;            break;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: switch (rem)        {          case 3:            hash += GetUInt(data' idx);            hash ^= hash << 16;            hash ^= (uint)data[idx + 2] << 18;            hash += hash >> 11;            break;            case 2:            hash += GetUInt(data' idx);            hash ^= hash << 11;            hash += hash >> 17;            break;            case 1:            hash += data[idx];            hash ^= hash << 10;            hash += hash >> 1;            break;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: switch (rem)        {          case 3:            hash += GetUInt(data' idx);            hash ^= hash << 16;            hash ^= (uint)data[idx + 2] << 18;            hash += hash >> 11;            break;            case 2:            hash += GetUInt(data' idx);            hash ^= hash << 11;            hash += hash >> 17;            break;            case 1:            hash += data[idx];            hash ^= hash << 10;            hash += hash >> 1;            break;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: switch (rem)        {          case 3:            hash += GetUInt(data' idx);            hash ^= hash << 16;            hash ^= (uint)data[idx + 2] << 18;            hash += hash >> 11;            break;            case 2:            hash += GetUInt(data' idx);            hash ^= hash << 11;            hash += hash >> 17;            break;            case 1:            hash += data[idx];            hash ^= hash << 10;            hash += hash >> 1;            break;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: switch (rem)        {          case 3:            hash += GetUInt(data' idx);            hash ^= hash << 16;            hash ^= (uint)data[idx + 2] << 18;            hash += hash >> 11;            break;            case 2:            hash += GetUInt(data' idx);            hash ^= hash << 11;            hash += hash >> 17;            break;            case 1:            hash += data[idx];            hash ^= hash << 10;            hash += hash >> 1;            break;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: switch (rem)        {          case 3:            hash += GetUInt(data' idx);            hash ^= hash << 16;            hash ^= (uint)data[idx + 2] << 18;            hash += hash >> 11;            break;            case 2:            hash += GetUInt(data' idx);            hash ^= hash << 11;            hash += hash >> 17;            break;            case 1:            hash += data[idx];            hash ^= hash << 10;            hash += hash >> 1;            break;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: switch (rem)        {          case 3:            hash += GetUInt(data' idx);            hash ^= hash << 16;            hash ^= (uint)data[idx + 2] << 18;            hash += hash >> 11;            break;            case 2:            hash += GetUInt(data' idx);            hash ^= hash << 11;            hash += hash >> 17;            break;            case 1:            hash += data[idx];            hash ^= hash << 10;            hash += hash >> 1;            break;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: switch (rem)        {          case 3:            hash += GetUInt(data' idx);            hash ^= hash << 16;            hash ^= (uint)data[idx + 2] << 18;            hash += hash >> 11;            break;            case 2:            hash += GetUInt(data' idx);            hash ^= hash << 11;            hash += hash >> 17;            break;            case 1:            hash += data[idx];            hash ^= hash << 10;            hash += hash >> 1;            break;        }
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: hash ^= hash << 3;
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: hash += hash >> 5;
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: hash ^= hash << 4;
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: hash += hash >> 17;
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: hash ^= hash << 25;
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following statement contains a magic number: hash += hash >> 6;
Magic Number,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,GetUInt,The following statement contains a magic number: return data[idx] + ((uint)data[idx + 1] << 8);
Magic Number,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,TryEnterWriteLockCore,The following statement contains a magic number: for (; ; )        {          if (IsWriterAcquired())          {            // Good case' there is no contention' we are basically done             SetWriterAcquired();            break;          }            //Check if there is just one upgrader' and no readers.          //Assumption: Only one thread can have the upgrade lock' so the           //following check will fail for all other threads that may sneak in          //when the upgrading thread is waiting.             if (upgradingToWrite)          {            uint readercount = GetNumReaders();              if (readercount == 1)            {              //Good case again' there is just one upgrader' and no readers.              SetWriterAcquired();    // indicate we have a writer.               break;            }              if (readercount == 2)            {              if (lrwc != null)              {                if (IsRwHashEntryChanged(lrwc' id))                  lrwc = GetThreadRWCount(id' false);                  if (lrwc.ReaderCount > 0)                {                  //This check is needed for EU->ER->EW case' as the owner count will be two.                   Debug.Assert(_isReentrant);                  Debug.Assert(_upgradeThreadHoldingRead);                    //Good case again' there is just one upgrader' and no readers.                   SetWriterAcquired();   // indicate we have a writer.                  break;                }              }            }          }            if (spincount < MaxSpinCount)          {            ExitMyLock();            if (millisecondsTimeout == 0)              return false;            spincount++;            SpinWait(spincount);            EnterMyLock();            continue;          }              if (upgradingToWrite)          {            if (_waitUpgradeEvent == null)   // Create the needed event             {              LazyCreateEvent(ref _waitUpgradeEvent' true);              continue;   // since we left the lock' start over.            }              Debug.Assert(_numWriteUpgradeWaiters == 0' "There can be at most one thread with the upgrade lock held.");              var retVal = WaitOnEvent(_waitUpgradeEvent' ref _numWriteUpgradeWaiters' millisecondsTimeout);              //The lock is not held in case of failure.            if (!retVal)              return false;          }          else          {            // Drat' we need to wait.  Mark that we have waiters and wait.            if (_writeEvent == null)     // create the needed event.             {              LazyCreateEvent(ref _writeEvent' true);              continue;   // since we left the lock' start over.             }              var retVal = WaitOnEvent(_writeEvent' ref _numWriteWaiters' millisecondsTimeout);            //The lock is not held in case of failure.             if (!retVal)              return false;          }        }
Magic Number,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,ExitAndWakeUpAppropriateWaitersPreferringWriters,The following statement contains a magic number: if (_isReentrant)        {          if (_numWriteUpgradeWaiters > 0 && _upgradeThreadHoldingRead && readercount == 2)          {            ExitMyLock();          // Exit before signaling to improve efficiency (wakee will need the lock)            _waitUpgradeEvent.Set();     // release all upgraders (however there can be at most one).             return;          }        }
Magic Number,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,SpinWait,The following statement contains a magic number: if ((spinCount < 5) && (Environment.ProcessorCount > 1))        {          Thread.SpinWait(LockSpinCycles * spinCount);        }        else if (spinCount < MaxSpinCount - 3)        {          Thread.Sleep(0);        }        else        {          Thread.Sleep(1);        }
Magic Number,Lex.Db,ReaderWriterLockSlim,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Framework\ReaderWriterLockSlim.cs,SpinWait,The following statement contains a magic number: if ((spinCount < 5) && (Environment.ProcessorCount > 1))        {          Thread.SpinWait(LockSpinCycles * spinCount);        }        else if (spinCount < MaxSpinCount - 3)        {          Thread.Sleep(0);        }        else        {          Thread.Sleep(1);        }
Magic Number,Lex.Db.Serialization,Serializers,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Serialization\Serializers.cs,GetWriteMethodFrom,The following statement contains a magic number: if (parameters.Length != 2 || parameters[0].ParameterType != typeof(DataWriter) || parameters[1].ParameterType != typeof(K))          throw new ArgumentException("Write method parameter type mismatch");
Magic Number,Lex.Db.Serialization,Serializers,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Serialization\Serializers.cs,Serializers,The following statement contains a magic number: _writerMethods = (from m in methods                          where m.Name.StartsWith("Write") && m.ReturnType == typeof(void)                          let parameters = m.GetParameters()                          where parameters.Length == 2 && parameters[0].ParameterType == typeof(DataWriter)                          select new { Method = m' Type = parameters[1].ParameterType }).ToDictionary(i => i.Type' i => i.Method);
Magic Number,Lex.Db.Serialization,DataReader,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Serialization\Serializers.cs,ReadGuid,The following statement contains a magic number: return new Guid(ReadBytes(16));
Magic Number,Lex.Db.Serialization,DataWriter,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Serialization\Serializers.cs,Write,The following statement contains a magic number: Write(value.ToByteArray()' 0' 16);
Magic Number,Lex.Db.FileSystem,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\FileSystem\DbTableStorage.cs,OpenRead,The following statement contains a magic number: for (int i = 0; i < 10; i++)          try          {  #if NETFX_CORE            Stream s = new OSFileStream(name' FileMode.OpenOrCreate' FileAccess.Read' FileShare.Read);            return buffered ? new BufferedStream(s' BufferSize) : s;  #else            return new FileStream(name' FileMode.OpenOrCreate' FileAccess.Read' FileShare.Read' buffered ? BufferSize : 4 * 1024);  #endif          }          catch          {  #if NETFX_CORE            Sleep(100);  #else            Thread.Sleep(100);  #endif          }
Magic Number,Lex.Db.FileSystem,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\FileSystem\DbTableStorage.cs,OpenRead,The following statement contains a magic number: for (int i = 0; i < 10; i++)          try          {  #if NETFX_CORE            Stream s = new OSFileStream(name' FileMode.OpenOrCreate' FileAccess.Read' FileShare.Read);            return buffered ? new BufferedStream(s' BufferSize) : s;  #else            return new FileStream(name' FileMode.OpenOrCreate' FileAccess.Read' FileShare.Read' buffered ? BufferSize : 4 * 1024);  #endif          }          catch          {  #if NETFX_CORE            Sleep(100);  #else            Thread.Sleep(100);  #endif          }
Magic Number,Lex.Db.FileSystem,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\FileSystem\DbTableStorage.cs,OpenRead,The following statement contains a magic number: for (int i = 0; i < 10; i++)          try          {  #if NETFX_CORE            Stream s = new OSFileStream(name' FileMode.OpenOrCreate' FileAccess.Read' FileShare.Read);            return buffered ? new BufferedStream(s' BufferSize) : s;  #else            return new FileStream(name' FileMode.OpenOrCreate' FileAccess.Read' FileShare.Read' buffered ? BufferSize : 4 * 1024);  #endif          }          catch          {  #if NETFX_CORE            Sleep(100);  #else            Thread.Sleep(100);  #endif          }
Magic Number,Lex.Db.FileSystem,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\FileSystem\DbTableStorage.cs,OpenRead,The following statement contains a magic number: for (int i = 0; i < 10; i++)          try          {  #if NETFX_CORE            Stream s = new OSFileStream(name' FileMode.OpenOrCreate' FileAccess.Read' FileShare.Read);            return buffered ? new BufferedStream(s' BufferSize) : s;  #else            return new FileStream(name' FileMode.OpenOrCreate' FileAccess.Read' FileShare.Read' buffered ? BufferSize : 4 * 1024);  #endif          }          catch          {  #if NETFX_CORE            Sleep(100);  #else            Thread.Sleep(100);  #endif          }
Magic Number,Lex.Db.FileSystem,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\FileSystem\DbTableStorage.cs,OpenWrite,The following statement contains a magic number: for (int i = 0; i < 10; i++)          try          {  #if NETFX_CORE            Stream s = new OSFileStream(name' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);            return buffered ? new BufferedStream(s' BufferSize) : s;  #else            return new FileStream(name' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' buffered ? BufferSize : 4 * 1024);  #endif          }          catch          {  #if NETFX_CORE            Sleep(100);  #else            Thread.Sleep(100);  #endif          }
Magic Number,Lex.Db.FileSystem,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\FileSystem\DbTableStorage.cs,OpenWrite,The following statement contains a magic number: for (int i = 0; i < 10; i++)          try          {  #if NETFX_CORE            Stream s = new OSFileStream(name' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);            return buffered ? new BufferedStream(s' BufferSize) : s;  #else            return new FileStream(name' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' buffered ? BufferSize : 4 * 1024);  #endif          }          catch          {  #if NETFX_CORE            Sleep(100);  #else            Thread.Sleep(100);  #endif          }
Magic Number,Lex.Db.FileSystem,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\FileSystem\DbTableStorage.cs,OpenWrite,The following statement contains a magic number: for (int i = 0; i < 10; i++)          try          {  #if NETFX_CORE            Stream s = new OSFileStream(name' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);            return buffered ? new BufferedStream(s' BufferSize) : s;  #else            return new FileStream(name' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' buffered ? BufferSize : 4 * 1024);  #endif          }          catch          {  #if NETFX_CORE            Sleep(100);  #else            Thread.Sleep(100);  #endif          }
Magic Number,Lex.Db.FileSystem,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\FileSystem\DbTableStorage.cs,OpenWrite,The following statement contains a magic number: for (int i = 0; i < 10; i++)          try          {  #if NETFX_CORE            Stream s = new OSFileStream(name' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);            return buffered ? new BufferedStream(s' BufferSize) : s;  #else            return new FileStream(name' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' buffered ? BufferSize : 4 * 1024);  #endif          }          catch          {  #if NETFX_CORE            Sleep(100);  #else            Thread.Sleep(100);  #endif          }
Magic Number,Lex.Db.IsolatedStorage,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\IsolatedStorage\DbTableStorage.cs,OpenRead,The following statement contains a magic number: for (int i = 0; i < 10; i++)          try          {            Stream s = _storage.OpenFile(name' FileMode.OpenOrCreate' FileAccess.Read' FileShare.Read);            return buffered ? new BufferedStream(s' BufferSize) : s;          }          catch (IsolatedStorageException)          {            Thread.Sleep(100);          }
Magic Number,Lex.Db.IsolatedStorage,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\IsolatedStorage\DbTableStorage.cs,OpenRead,The following statement contains a magic number: for (int i = 0; i < 10; i++)          try          {            Stream s = _storage.OpenFile(name' FileMode.OpenOrCreate' FileAccess.Read' FileShare.Read);            return buffered ? new BufferedStream(s' BufferSize) : s;          }          catch (IsolatedStorageException)          {            Thread.Sleep(100);          }
Magic Number,Lex.Db.IsolatedStorage,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\IsolatedStorage\DbTableStorage.cs,OpenWrite,The following statement contains a magic number: for (int i = 0; i < 10; i++)          try          {            Stream s = _storage.OpenFile(name' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);            return buffered ? new BufferedStream(s' BufferSize) : s;          }          catch (IsolatedStorageException)          {            Thread.Sleep(100);          }
Magic Number,Lex.Db.IsolatedStorage,DbTableStorage,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Storage\IsolatedStorage\DbTableStorage.cs,OpenWrite,The following statement contains a magic number: for (int i = 0; i < 10; i++)          try          {            Stream s = _storage.OpenFile(name' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);            return buffered ? new BufferedStream(s' BufferSize) : s;          }          catch (IsolatedStorageException)          {            Thread.Sleep(100);          }
Missing Default,Lex.Db,Hash,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Core\Hash.cs,Compute,The following switch statement is missing a default case: switch (rem)        {          case 3:            hash += GetUInt(data' idx);            hash ^= hash << 16;            hash ^= (uint)data[idx + 2] << 18;            hash += hash >> 11;            break;            case 2:            hash += GetUInt(data' idx);            hash ^= hash << 11;            hash += hash >> 17;            break;            case 1:            hash += data[idx];            hash ^= hash << 10;            hash += hash >> 1;            break;        }
Missing Default,Lex.Db,Extensions,C:\repos\demigor_lex.db\lib\Lex.Db.Shared\Mapping\MemberMap.cs,Clone,The following switch statement is missing a default case: switch (target.NodeType)        {          case ExpressionType.MemberAccess:            {              var ma = (MemberExpression)target;              return Expression.MakeMemberAccess(ma.Expression.Clone(oldExpr' newExpr)' ma.Member);            }        }
