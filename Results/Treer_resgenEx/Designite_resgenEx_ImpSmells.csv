Implementation smell,Namespace,Class,File,Method,Description
Long Method,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,Main,The method has 128 lines of code.
Complex Method,resgenEx.FileFormats,IslResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\islResourceReader.cs,Unescape,Cyclomatic complexity of the method is 15
Complex Method,resgenEx.FileFormats,IslResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\islResourceReader.cs,Load,Cyclomatic complexity of the method is 8
Complex Method,resgenEx.FileFormats,IslResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\islResourceWriter.cs,Escape,Cyclomatic complexity of the method is 29
Complex Method,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,Cyclomatic complexity of the method is 8
Complex Method,resgenEx.FileFormats,PoResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceReader.cs,Unescape,Cyclomatic complexity of the method is 24
Complex Method,resgenEx.FileFormats,PoResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceReader.cs,Load,Cyclomatic complexity of the method is 17
Complex Method,resgenEx.FileFormats,PoResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceWriter.cs,Escape,Cyclomatic complexity of the method is 19
Complex Method,resgenEx.FileFormats,PoResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceWriter.cs,AddResource,Cyclomatic complexity of the method is 15
Complex Method,resgenEx.FileFormats,TxtResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\TxtResourceReader.cs,Unescape,Cyclomatic complexity of the method is 20
Complex Method,resgenEx.FileFormats,TxtResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\TxtResourceWriter.cs,Escape,Cyclomatic complexity of the method is 16
Complex Method,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,GetReader,Cyclomatic complexity of the method is 11
Complex Method,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,Main,Cyclomatic complexity of the method is 50
Long Parameter List,resgenEx.FileFormats,PoResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceReader.cs,AddData,The method has 5 parameters.
Long Parameter List,resgenEx,ResourceItem,C:\repos\Treer_resgenEx\resgenEx\ResourceItem.cs,ResourceItem,The method has 5 parameters.
Long Identifier,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The length of the parameter ignoreRemainingExtractedComment is 31.
Long Statement,resgenEx.FileFormats,IslResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\islResourceReader.cs,AddData,The length of the statement  "			Console.WriteLine (String.Format ("Error: Found duplicate msgid {0} at line {1} - will overwrite the value from earlier instances."' msgid' sourceLineNumber)); " is 159.
Long Statement,resgenEx.FileFormats,PoResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceReader.cs,AddData,The length of the statement  "			Console.WriteLine (String.Format ("Error: Found duplicate msgid {0} at line {1} - will overwrite the value from earlier instances."' msgid' sourceLineNumber)); " is 159.
Long Statement,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,CompileResourceFile,The length of the statement  "				// refactoring to do: We should probably wrap the ResXResourceWriter' and replace our use of IResourceWriter with a ResourceItem based interface " is 144.
Long Statement,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,Main,The length of the statement  "				Console.WriteLine ("ResGen : error RG0000: Invalid " + "command line syntax.  Switch: \"/compile\"  Bad value: " + args [i] + ".  Use ResGen /? for usage information."); " is 169.
Long Statement,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,Main,The length of the statement  "				Console.WriteLine ("ResGen : error RG0000: Invalid command line syntax.  Switch: \"/nocomments\" cannot be used with \"/sourcecommentsonly\""); " is 143.
Long Statement,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,Main,The length of the statement  "				Console.WriteLine ("ResGen : error RG0000: Invalid command line syntax.  Switch: \"/nocomments\" cannot be used with \"/sourcecommentsonly\""); " is 143.
Long Statement,resgenEx,ResourceItem,C:\repos\Treer_resgenEx\resgenEx\ResourceItem.cs,Get,The length of the statement  "		throw new InvalidOperationException ("Object not handled for resource coversion: " + (value == null ? "null" : value.ToString ())); " is 131.
Empty Catch Block,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,CompileResourceFile,The method has an empty catch block.
Magic Number,resgenEx.FileFormats,IslResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\islResourceReader.cs,Load,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	line_num++;  	line = line.Trim ();  	if (line.Length == 0) {  		// it's a blank line  		if (!String.IsNullOrEmpty (commentAccumulator)) {  			// include blank lines if a comment was started  			commentAccumulator += line + "\n";  		}  	}  	else if (line [0] == ';') {  		// it's a comment  		if (line.Length > 1 && line [1] == ' ') {  			commentAccumulator += line.Substring (2) + "\n";  		}  		else {  			commentAccumulator += line.Substring (1) + "\n";  		}  		continue;  	}  	else if (line [0] == '[') {  		// It's a new section' any comment lines we've accumulated are unlikely to  		// be intended for the next item  		commentAccumulator = String.Empty;  	}  	else {  		int assignmentPos = line.IndexOf ('=');  		if (assignmentPos > 0) {  			// it's a msgid and msgstr  			AddData (line.Substring (0' assignmentPos).Trim ()' //msgid  			Unescape (line.Substring (assignmentPos + 1))' // msgstr  			commentAccumulator' line_num);  			commentAccumulator = String.Empty;  		}  	}  }  
Magic Number,resgenEx.FileFormats,IslResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\islResourceReader.cs,Load,The following statement contains a magic number: if (line.Length == 0) {  	// it's a blank line  	if (!String.IsNullOrEmpty (commentAccumulator)) {  		// include blank lines if a comment was started  		commentAccumulator += line + "\n";  	}  }  else if (line [0] == ';') {  	// it's a comment  	if (line.Length > 1 && line [1] == ' ') {  		commentAccumulator += line.Substring (2) + "\n";  	}  	else {  		commentAccumulator += line.Substring (1) + "\n";  	}  	continue;  }  else if (line [0] == '[') {  	// It's a new section' any comment lines we've accumulated are unlikely to  	// be intended for the next item  	commentAccumulator = String.Empty;  }  else {  	int assignmentPos = line.IndexOf ('=');  	if (assignmentPos > 0) {  		// it's a msgid and msgstr  		AddData (line.Substring (0' assignmentPos).Trim ()' //msgid  		Unescape (line.Substring (assignmentPos + 1))' // msgstr  		commentAccumulator' line_num);  		commentAccumulator = String.Empty;  	}  }  
Magic Number,resgenEx.FileFormats,IslResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\islResourceReader.cs,Load,The following statement contains a magic number: if (line [0] == ';') {  	// it's a comment  	if (line.Length > 1 && line [1] == ' ') {  		commentAccumulator += line.Substring (2) + "\n";  	}  	else {  		commentAccumulator += line.Substring (1) + "\n";  	}  	continue;  }  else if (line [0] == '[') {  	// It's a new section' any comment lines we've accumulated are unlikely to  	// be intended for the next item  	commentAccumulator = String.Empty;  }  else {  	int assignmentPos = line.IndexOf ('=');  	if (assignmentPos > 0) {  		// it's a msgid and msgstr  		AddData (line.Substring (0' assignmentPos).Trim ()' //msgid  		Unescape (line.Substring (assignmentPos + 1))' // msgstr  		commentAccumulator' line_num);  		commentAccumulator = String.Empty;  	}  }  
Magic Number,resgenEx.FileFormats,IslResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\islResourceReader.cs,Load,The following statement contains a magic number: if (line.Length > 1 && line [1] == ' ') {  	commentAccumulator += line.Substring (2) + "\n";  }  else {  	commentAccumulator += line.Substring (1) + "\n";  }  
Magic Number,resgenEx.FileFormats,IslResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\islResourceReader.cs,Load,The following statement contains a magic number: commentAccumulator += line.Substring (2) + "\n";  
Magic Number,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0 && line [0] == '#') {  		if (line.Length == 1) {  			result.AppendLine ();  		}  		else {  			if (Char.IsWhiteSpace (line [1])) {  				result.AppendLine (line.Substring (2).Trim ());  			}  			else if (line [1] == '.') {  				// It's an extracted-comment' we'll include those too (unless they were automatically generated)  				if (line.StartsWith (ResGen.cOriginalMessageComment_Prefix.TrimEnd ())) {  					// It's one of our auto generated comments  					// There's no place in .resx files for these' ignore it.  					ignoreRemainingExtractedComment = true;  					// it might be a multiline autogenerated comment' so ignore any #. comments from now on  					// The presence of an auto generated comment probably means there was a blank line Append() to the end of result.  					// We'll have to Trim the end of Result()' or find a better way to do this.  				}  				if (!ignoreRemainingExtractedComment)  					result.AppendLine (line.Substring (2).Trim ());  			}  		}  	}  }  
Magic Number,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The following statement contains a magic number: foreach (string line in lines) {  	if (line.Length > 0 && line [0] == '#') {  		if (line.Length == 1) {  			result.AppendLine ();  		}  		else {  			if (Char.IsWhiteSpace (line [1])) {  				result.AppendLine (line.Substring (2).Trim ());  			}  			else if (line [1] == '.') {  				// It's an extracted-comment' we'll include those too (unless they were automatically generated)  				if (line.StartsWith (ResGen.cOriginalMessageComment_Prefix.TrimEnd ())) {  					// It's one of our auto generated comments  					// There's no place in .resx files for these' ignore it.  					ignoreRemainingExtractedComment = true;  					// it might be a multiline autogenerated comment' so ignore any #. comments from now on  					// The presence of an auto generated comment probably means there was a blank line Append() to the end of result.  					// We'll have to Trim the end of Result()' or find a better way to do this.  				}  				if (!ignoreRemainingExtractedComment)  					result.AppendLine (line.Substring (2).Trim ());  			}  		}  	}  }  
Magic Number,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The following statement contains a magic number: if (line.Length > 0 && line [0] == '#') {  	if (line.Length == 1) {  		result.AppendLine ();  	}  	else {  		if (Char.IsWhiteSpace (line [1])) {  			result.AppendLine (line.Substring (2).Trim ());  		}  		else if (line [1] == '.') {  			// It's an extracted-comment' we'll include those too (unless they were automatically generated)  			if (line.StartsWith (ResGen.cOriginalMessageComment_Prefix.TrimEnd ())) {  				// It's one of our auto generated comments  				// There's no place in .resx files for these' ignore it.  				ignoreRemainingExtractedComment = true;  				// it might be a multiline autogenerated comment' so ignore any #. comments from now on  				// The presence of an auto generated comment probably means there was a blank line Append() to the end of result.  				// We'll have to Trim the end of Result()' or find a better way to do this.  			}  			if (!ignoreRemainingExtractedComment)  				result.AppendLine (line.Substring (2).Trim ());  		}  	}  }  
Magic Number,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The following statement contains a magic number: if (line.Length > 0 && line [0] == '#') {  	if (line.Length == 1) {  		result.AppendLine ();  	}  	else {  		if (Char.IsWhiteSpace (line [1])) {  			result.AppendLine (line.Substring (2).Trim ());  		}  		else if (line [1] == '.') {  			// It's an extracted-comment' we'll include those too (unless they were automatically generated)  			if (line.StartsWith (ResGen.cOriginalMessageComment_Prefix.TrimEnd ())) {  				// It's one of our auto generated comments  				// There's no place in .resx files for these' ignore it.  				ignoreRemainingExtractedComment = true;  				// it might be a multiline autogenerated comment' so ignore any #. comments from now on  				// The presence of an auto generated comment probably means there was a blank line Append() to the end of result.  				// We'll have to Trim the end of Result()' or find a better way to do this.  			}  			if (!ignoreRemainingExtractedComment)  				result.AppendLine (line.Substring (2).Trim ());  		}  	}  }  
Magic Number,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The following statement contains a magic number: if (line.Length == 1) {  	result.AppendLine ();  }  else {  	if (Char.IsWhiteSpace (line [1])) {  		result.AppendLine (line.Substring (2).Trim ());  	}  	else if (line [1] == '.') {  		// It's an extracted-comment' we'll include those too (unless they were automatically generated)  		if (line.StartsWith (ResGen.cOriginalMessageComment_Prefix.TrimEnd ())) {  			// It's one of our auto generated comments  			// There's no place in .resx files for these' ignore it.  			ignoreRemainingExtractedComment = true;  			// it might be a multiline autogenerated comment' so ignore any #. comments from now on  			// The presence of an auto generated comment probably means there was a blank line Append() to the end of result.  			// We'll have to Trim the end of Result()' or find a better way to do this.  		}  		if (!ignoreRemainingExtractedComment)  			result.AppendLine (line.Substring (2).Trim ());  	}  }  
Magic Number,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The following statement contains a magic number: if (line.Length == 1) {  	result.AppendLine ();  }  else {  	if (Char.IsWhiteSpace (line [1])) {  		result.AppendLine (line.Substring (2).Trim ());  	}  	else if (line [1] == '.') {  		// It's an extracted-comment' we'll include those too (unless they were automatically generated)  		if (line.StartsWith (ResGen.cOriginalMessageComment_Prefix.TrimEnd ())) {  			// It's one of our auto generated comments  			// There's no place in .resx files for these' ignore it.  			ignoreRemainingExtractedComment = true;  			// it might be a multiline autogenerated comment' so ignore any #. comments from now on  			// The presence of an auto generated comment probably means there was a blank line Append() to the end of result.  			// We'll have to Trim the end of Result()' or find a better way to do this.  		}  		if (!ignoreRemainingExtractedComment)  			result.AppendLine (line.Substring (2).Trim ());  	}  }  
Magic Number,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The following statement contains a magic number: if (Char.IsWhiteSpace (line [1])) {  	result.AppendLine (line.Substring (2).Trim ());  }  else if (line [1] == '.') {  	// It's an extracted-comment' we'll include those too (unless they were automatically generated)  	if (line.StartsWith (ResGen.cOriginalMessageComment_Prefix.TrimEnd ())) {  		// It's one of our auto generated comments  		// There's no place in .resx files for these' ignore it.  		ignoreRemainingExtractedComment = true;  		// it might be a multiline autogenerated comment' so ignore any #. comments from now on  		// The presence of an auto generated comment probably means there was a blank line Append() to the end of result.  		// We'll have to Trim the end of Result()' or find a better way to do this.  	}  	if (!ignoreRemainingExtractedComment)  		result.AppendLine (line.Substring (2).Trim ());  }  
Magic Number,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The following statement contains a magic number: if (Char.IsWhiteSpace (line [1])) {  	result.AppendLine (line.Substring (2).Trim ());  }  else if (line [1] == '.') {  	// It's an extracted-comment' we'll include those too (unless they were automatically generated)  	if (line.StartsWith (ResGen.cOriginalMessageComment_Prefix.TrimEnd ())) {  		// It's one of our auto generated comments  		// There's no place in .resx files for these' ignore it.  		ignoreRemainingExtractedComment = true;  		// it might be a multiline autogenerated comment' so ignore any #. comments from now on  		// The presence of an auto generated comment probably means there was a blank line Append() to the end of result.  		// We'll have to Trim the end of Result()' or find a better way to do this.  	}  	if (!ignoreRemainingExtractedComment)  		result.AppendLine (line.Substring (2).Trim ());  }  
Magic Number,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The following statement contains a magic number: result.AppendLine (line.Substring (2).Trim ());  
Magic Number,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The following statement contains a magic number: if (line [1] == '.') {  	// It's an extracted-comment' we'll include those too (unless they were automatically generated)  	if (line.StartsWith (ResGen.cOriginalMessageComment_Prefix.TrimEnd ())) {  		// It's one of our auto generated comments  		// There's no place in .resx files for these' ignore it.  		ignoreRemainingExtractedComment = true;  		// it might be a multiline autogenerated comment' so ignore any #. comments from now on  		// The presence of an auto generated comment probably means there was a blank line Append() to the end of result.  		// We'll have to Trim the end of Result()' or find a better way to do this.  	}  	if (!ignoreRemainingExtractedComment)  		result.AppendLine (line.Substring (2).Trim ());  }  
Magic Number,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The following statement contains a magic number: if (!ignoreRemainingExtractedComment)  	result.AppendLine (line.Substring (2).Trim ());  
Magic Number,resgenEx.FileFormats,PoItem,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoItem.cs,GeneralPurposeComment,The following statement contains a magic number: result.AppendLine (line.Substring (2).Trim ());  
Magic Number,resgenEx.FileFormats,PoResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceWriter.cs,AddResource,The following statement contains a magic number: if (options.Comments != CommentOptions.writeNoComments) {  	if (item is PoItem) {  		// We can preserve the comments exactly as they were  		s.Write (((PoItem)item).Metadata_PoRawComments);  	}  	else {  		// if FullComments is set' then store the original message in a rawComments  		// so the file could be converted into a .pot file (.po template file)  		// without losing information.  		string originalMessage = item.Metadata_OriginalValue;  		string sourceReference = item.Metadata_OriginalSource;  		if (options.Comments == CommentOptions.writeFullComments) {  			if (String.IsNullOrEmpty (originalMessage))  				originalMessage = item.Value;  			if (String.IsNullOrEmpty (sourceReference))  				sourceReference = SourceFile;  			if (item.Metadata_OriginalSourceLine > 0) {  				if (!String.IsNullOrEmpty (sourceReference))  					sourceReference += "' ";  				sourceReference += "line " + item.Metadata_OriginalSourceLine;  			}  		}  		else {  			// Don't include automatically generated comments such as file reference  			sourceReference = null;  		}  		if (!String.IsNullOrEmpty (item.Metadata_Comment)) {  			// "#." in a .po file indicates an extracted rawComments  			s.WriteLine ("#. {0}"' EscapeComment (item.Metadata_Comment' '.'));  			if (!String.IsNullOrEmpty (originalMessage))  				s.WriteLine ("#. ");  			// leave an empty line between this rawComments and when we list the originalMessage  		}  		if (!String.IsNullOrEmpty (originalMessage)) {  			// "#." in a .po file indicates an extracted rawComments  			if (originalMessage.Contains ("\n")) {  				// Start multi-line messages indented on a new line' and have each new line in the message indented  				s.WriteLine (ResGen.cOriginalMessageComment_Prefix + "\n#.    " + EscapeComment (originalMessage' '.'' 4));  			}  			else {  				s.WriteLine (ResGen.cOriginalMessageComment_Prefix + EscapeComment (originalMessage' '.'' 4));  			}  		}  		if (!String.IsNullOrEmpty (sourceReference)) {  			// "#:" in a .po file indicates a code reference rawComments' such as the line of source code the   			// string is used in' currently PoResourceWriter just inserts the source file name though.  			s.WriteLine ("#: {0}"' EscapeComment (sourceReference' '.'));  		}  		if (options.FormatFlags && (item.Metadata_Flags & TranslationFlags.csharpFormatString) != 0) {  			s.WriteLine ("#' csharp-format");  		}  	}  }  
Magic Number,resgenEx.FileFormats,PoResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceWriter.cs,AddResource,The following statement contains a magic number: if (options.Comments != CommentOptions.writeNoComments) {  	if (item is PoItem) {  		// We can preserve the comments exactly as they were  		s.Write (((PoItem)item).Metadata_PoRawComments);  	}  	else {  		// if FullComments is set' then store the original message in a rawComments  		// so the file could be converted into a .pot file (.po template file)  		// without losing information.  		string originalMessage = item.Metadata_OriginalValue;  		string sourceReference = item.Metadata_OriginalSource;  		if (options.Comments == CommentOptions.writeFullComments) {  			if (String.IsNullOrEmpty (originalMessage))  				originalMessage = item.Value;  			if (String.IsNullOrEmpty (sourceReference))  				sourceReference = SourceFile;  			if (item.Metadata_OriginalSourceLine > 0) {  				if (!String.IsNullOrEmpty (sourceReference))  					sourceReference += "' ";  				sourceReference += "line " + item.Metadata_OriginalSourceLine;  			}  		}  		else {  			// Don't include automatically generated comments such as file reference  			sourceReference = null;  		}  		if (!String.IsNullOrEmpty (item.Metadata_Comment)) {  			// "#." in a .po file indicates an extracted rawComments  			s.WriteLine ("#. {0}"' EscapeComment (item.Metadata_Comment' '.'));  			if (!String.IsNullOrEmpty (originalMessage))  				s.WriteLine ("#. ");  			// leave an empty line between this rawComments and when we list the originalMessage  		}  		if (!String.IsNullOrEmpty (originalMessage)) {  			// "#." in a .po file indicates an extracted rawComments  			if (originalMessage.Contains ("\n")) {  				// Start multi-line messages indented on a new line' and have each new line in the message indented  				s.WriteLine (ResGen.cOriginalMessageComment_Prefix + "\n#.    " + EscapeComment (originalMessage' '.'' 4));  			}  			else {  				s.WriteLine (ResGen.cOriginalMessageComment_Prefix + EscapeComment (originalMessage' '.'' 4));  			}  		}  		if (!String.IsNullOrEmpty (sourceReference)) {  			// "#:" in a .po file indicates a code reference rawComments' such as the line of source code the   			// string is used in' currently PoResourceWriter just inserts the source file name though.  			s.WriteLine ("#: {0}"' EscapeComment (sourceReference' '.'));  		}  		if (options.FormatFlags && (item.Metadata_Flags & TranslationFlags.csharpFormatString) != 0) {  			s.WriteLine ("#' csharp-format");  		}  	}  }  
Magic Number,resgenEx.FileFormats,PoResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceWriter.cs,AddResource,The following statement contains a magic number: if (item is PoItem) {  	// We can preserve the comments exactly as they were  	s.Write (((PoItem)item).Metadata_PoRawComments);  }  else {  	// if FullComments is set' then store the original message in a rawComments  	// so the file could be converted into a .pot file (.po template file)  	// without losing information.  	string originalMessage = item.Metadata_OriginalValue;  	string sourceReference = item.Metadata_OriginalSource;  	if (options.Comments == CommentOptions.writeFullComments) {  		if (String.IsNullOrEmpty (originalMessage))  			originalMessage = item.Value;  		if (String.IsNullOrEmpty (sourceReference))  			sourceReference = SourceFile;  		if (item.Metadata_OriginalSourceLine > 0) {  			if (!String.IsNullOrEmpty (sourceReference))  				sourceReference += "' ";  			sourceReference += "line " + item.Metadata_OriginalSourceLine;  		}  	}  	else {  		// Don't include automatically generated comments such as file reference  		sourceReference = null;  	}  	if (!String.IsNullOrEmpty (item.Metadata_Comment)) {  		// "#." in a .po file indicates an extracted rawComments  		s.WriteLine ("#. {0}"' EscapeComment (item.Metadata_Comment' '.'));  		if (!String.IsNullOrEmpty (originalMessage))  			s.WriteLine ("#. ");  		// leave an empty line between this rawComments and when we list the originalMessage  	}  	if (!String.IsNullOrEmpty (originalMessage)) {  		// "#." in a .po file indicates an extracted rawComments  		if (originalMessage.Contains ("\n")) {  			// Start multi-line messages indented on a new line' and have each new line in the message indented  			s.WriteLine (ResGen.cOriginalMessageComment_Prefix + "\n#.    " + EscapeComment (originalMessage' '.'' 4));  		}  		else {  			s.WriteLine (ResGen.cOriginalMessageComment_Prefix + EscapeComment (originalMessage' '.'' 4));  		}  	}  	if (!String.IsNullOrEmpty (sourceReference)) {  		// "#:" in a .po file indicates a code reference rawComments' such as the line of source code the   		// string is used in' currently PoResourceWriter just inserts the source file name though.  		s.WriteLine ("#: {0}"' EscapeComment (sourceReference' '.'));  	}  	if (options.FormatFlags && (item.Metadata_Flags & TranslationFlags.csharpFormatString) != 0) {  		s.WriteLine ("#' csharp-format");  	}  }  
Magic Number,resgenEx.FileFormats,PoResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceWriter.cs,AddResource,The following statement contains a magic number: if (item is PoItem) {  	// We can preserve the comments exactly as they were  	s.Write (((PoItem)item).Metadata_PoRawComments);  }  else {  	// if FullComments is set' then store the original message in a rawComments  	// so the file could be converted into a .pot file (.po template file)  	// without losing information.  	string originalMessage = item.Metadata_OriginalValue;  	string sourceReference = item.Metadata_OriginalSource;  	if (options.Comments == CommentOptions.writeFullComments) {  		if (String.IsNullOrEmpty (originalMessage))  			originalMessage = item.Value;  		if (String.IsNullOrEmpty (sourceReference))  			sourceReference = SourceFile;  		if (item.Metadata_OriginalSourceLine > 0) {  			if (!String.IsNullOrEmpty (sourceReference))  				sourceReference += "' ";  			sourceReference += "line " + item.Metadata_OriginalSourceLine;  		}  	}  	else {  		// Don't include automatically generated comments such as file reference  		sourceReference = null;  	}  	if (!String.IsNullOrEmpty (item.Metadata_Comment)) {  		// "#." in a .po file indicates an extracted rawComments  		s.WriteLine ("#. {0}"' EscapeComment (item.Metadata_Comment' '.'));  		if (!String.IsNullOrEmpty (originalMessage))  			s.WriteLine ("#. ");  		// leave an empty line between this rawComments and when we list the originalMessage  	}  	if (!String.IsNullOrEmpty (originalMessage)) {  		// "#." in a .po file indicates an extracted rawComments  		if (originalMessage.Contains ("\n")) {  			// Start multi-line messages indented on a new line' and have each new line in the message indented  			s.WriteLine (ResGen.cOriginalMessageComment_Prefix + "\n#.    " + EscapeComment (originalMessage' '.'' 4));  		}  		else {  			s.WriteLine (ResGen.cOriginalMessageComment_Prefix + EscapeComment (originalMessage' '.'' 4));  		}  	}  	if (!String.IsNullOrEmpty (sourceReference)) {  		// "#:" in a .po file indicates a code reference rawComments' such as the line of source code the   		// string is used in' currently PoResourceWriter just inserts the source file name though.  		s.WriteLine ("#: {0}"' EscapeComment (sourceReference' '.'));  	}  	if (options.FormatFlags && (item.Metadata_Flags & TranslationFlags.csharpFormatString) != 0) {  		s.WriteLine ("#' csharp-format");  	}  }  
Magic Number,resgenEx.FileFormats,PoResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceWriter.cs,AddResource,The following statement contains a magic number: if (!String.IsNullOrEmpty (originalMessage)) {  	// "#." in a .po file indicates an extracted rawComments  	if (originalMessage.Contains ("\n")) {  		// Start multi-line messages indented on a new line' and have each new line in the message indented  		s.WriteLine (ResGen.cOriginalMessageComment_Prefix + "\n#.    " + EscapeComment (originalMessage' '.'' 4));  	}  	else {  		s.WriteLine (ResGen.cOriginalMessageComment_Prefix + EscapeComment (originalMessage' '.'' 4));  	}  }  
Magic Number,resgenEx.FileFormats,PoResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceWriter.cs,AddResource,The following statement contains a magic number: if (!String.IsNullOrEmpty (originalMessage)) {  	// "#." in a .po file indicates an extracted rawComments  	if (originalMessage.Contains ("\n")) {  		// Start multi-line messages indented on a new line' and have each new line in the message indented  		s.WriteLine (ResGen.cOriginalMessageComment_Prefix + "\n#.    " + EscapeComment (originalMessage' '.'' 4));  	}  	else {  		s.WriteLine (ResGen.cOriginalMessageComment_Prefix + EscapeComment (originalMessage' '.'' 4));  	}  }  
Magic Number,resgenEx.FileFormats,PoResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceWriter.cs,AddResource,The following statement contains a magic number: if (originalMessage.Contains ("\n")) {  	// Start multi-line messages indented on a new line' and have each new line in the message indented  	s.WriteLine (ResGen.cOriginalMessageComment_Prefix + "\n#.    " + EscapeComment (originalMessage' '.'' 4));  }  else {  	s.WriteLine (ResGen.cOriginalMessageComment_Prefix + EscapeComment (originalMessage' '.'' 4));  }  
Magic Number,resgenEx.FileFormats,PoResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceWriter.cs,AddResource,The following statement contains a magic number: if (originalMessage.Contains ("\n")) {  	// Start multi-line messages indented on a new line' and have each new line in the message indented  	s.WriteLine (ResGen.cOriginalMessageComment_Prefix + "\n#.    " + EscapeComment (originalMessage' '.'' 4));  }  else {  	s.WriteLine (ResGen.cOriginalMessageComment_Prefix + EscapeComment (originalMessage' '.'' 4));  }  
Magic Number,resgenEx.FileFormats,PoResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceWriter.cs,AddResource,The following statement contains a magic number: s.WriteLine (ResGen.cOriginalMessageComment_Prefix + "\n#.    " + EscapeComment (originalMessage' '.'' 4));  
Magic Number,resgenEx.FileFormats,PoResourceWriter,C:\repos\Treer_resgenEx\resgenEx\FileFormats\PoResourceWriter.cs,AddResource,The following statement contains a magic number: s.WriteLine (ResGen.cOriginalMessageComment_Prefix + EscapeComment (originalMessage' '.'' 4));  
Magic Number,resgenEx.FileFormats,TxtResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\TxtResourceReader.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < value.Length; i++) {  	if (value [i] == '\\') {  		if (i == value.Length - 1)  			return null;  		i++;  		switch (value [i]) {  		case 'n':  			b.Append ('\n');  			break;  		case 'r':  			b.Append ('\r');  			break;  		case 't':  			b.Append ('\t');  			break;  		case 'u':  			int ch = int.Parse (value.Substring (++i' 4)' NumberStyles.HexNumber);  			b.Append (char.ConvertFromUtf32 (ch));  			i += 3;  			break;  		case '\\':  			b.Append ('\\');  			break;  		default:  			return null;  		}  	}  	else {  		b.Append (value [i]);  	}  }  
Magic Number,resgenEx.FileFormats,TxtResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\TxtResourceReader.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < value.Length; i++) {  	if (value [i] == '\\') {  		if (i == value.Length - 1)  			return null;  		i++;  		switch (value [i]) {  		case 'n':  			b.Append ('\n');  			break;  		case 'r':  			b.Append ('\r');  			break;  		case 't':  			b.Append ('\t');  			break;  		case 'u':  			int ch = int.Parse (value.Substring (++i' 4)' NumberStyles.HexNumber);  			b.Append (char.ConvertFromUtf32 (ch));  			i += 3;  			break;  		case '\\':  			b.Append ('\\');  			break;  		default:  			return null;  		}  	}  	else {  		b.Append (value [i]);  	}  }  
Magic Number,resgenEx.FileFormats,TxtResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\TxtResourceReader.cs,Unescape,The following statement contains a magic number: if (value [i] == '\\') {  	if (i == value.Length - 1)  		return null;  	i++;  	switch (value [i]) {  	case 'n':  		b.Append ('\n');  		break;  	case 'r':  		b.Append ('\r');  		break;  	case 't':  		b.Append ('\t');  		break;  	case 'u':  		int ch = int.Parse (value.Substring (++i' 4)' NumberStyles.HexNumber);  		b.Append (char.ConvertFromUtf32 (ch));  		i += 3;  		break;  	case '\\':  		b.Append ('\\');  		break;  	default:  		return null;  	}  }  else {  	b.Append (value [i]);  }  
Magic Number,resgenEx.FileFormats,TxtResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\TxtResourceReader.cs,Unescape,The following statement contains a magic number: if (value [i] == '\\') {  	if (i == value.Length - 1)  		return null;  	i++;  	switch (value [i]) {  	case 'n':  		b.Append ('\n');  		break;  	case 'r':  		b.Append ('\r');  		break;  	case 't':  		b.Append ('\t');  		break;  	case 'u':  		int ch = int.Parse (value.Substring (++i' 4)' NumberStyles.HexNumber);  		b.Append (char.ConvertFromUtf32 (ch));  		i += 3;  		break;  	case '\\':  		b.Append ('\\');  		break;  	default:  		return null;  	}  }  else {  	b.Append (value [i]);  }  
Magic Number,resgenEx.FileFormats,TxtResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\TxtResourceReader.cs,Unescape,The following statement contains a magic number: switch (value [i]) {  case 'n':  	b.Append ('\n');  	break;  case 'r':  	b.Append ('\r');  	break;  case 't':  	b.Append ('\t');  	break;  case 'u':  	int ch = int.Parse (value.Substring (++i' 4)' NumberStyles.HexNumber);  	b.Append (char.ConvertFromUtf32 (ch));  	i += 3;  	break;  case '\\':  	b.Append ('\\');  	break;  default:  	return null;  }  
Magic Number,resgenEx.FileFormats,TxtResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\TxtResourceReader.cs,Unescape,The following statement contains a magic number: switch (value [i]) {  case 'n':  	b.Append ('\n');  	break;  case 'r':  	b.Append ('\r');  	break;  case 't':  	b.Append ('\t');  	break;  case 'u':  	int ch = int.Parse (value.Substring (++i' 4)' NumberStyles.HexNumber);  	b.Append (char.ConvertFromUtf32 (ch));  	i += 3;  	break;  case '\\':  	b.Append ('\\');  	break;  default:  	return null;  }  
Magic Number,resgenEx.FileFormats,TxtResourceReader,C:\repos\Treer_resgenEx\resgenEx\FileFormats\TxtResourceReader.cs,Unescape,The following statement contains a magic number: i += 3;  
Magic Number,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,Main,The following statement contains a magic number: for (int i = 0; i < args.Length; i++) {  	switch (args [i].ToLower ()) {  	case "-h":  	case "/h":  	case "-?":  	case "/?":  		Usage ();  		return 1;  	/* this version has been specialized for use converting between '.resx'                       * and '.po' files' other formats will now fail! /compile is only used                      * for '.resources' files.                     case "/compile":                     case "-compile":                         // takes a list of .resX or .txt files to convert to .resources files                         // in one bulk operation' replacing .ext with .resources for the                          // output file name (if not set).                          if (inputFiles.Count > 0) {                             // the /compile option should be specified before any files                             Usage ();                             return 1;                         }                         compileMultiple = true;                         break;                     */case "/usesourcepath":  	case "-usesourcepath":  		// to resolve relative file paths' use the directory of the resource   		// file as current directory.  		if (compileMultiple) {  			// the /usesourcepath option should not appear after the  			// /compile switch on the command-line  			Console.WriteLine ("ResGen : error RG0000: Invalid " + "command line syntax.  Switch: \"/compile\"  Bad value: " + args [i] + ".  Use ResGen /? for usage information.");  			return 1;  		}  		useSourcePath = true;  		break;  	case "/nocomments":  	case "-nocomments":  		// don't export the rawComments from the source file to the destination   		// format' and don't include automatically created comments.  		if (options.Comments == CommentOptions.writeSourceCommentsOnly) {  			// the /nocomments option should not appear after the  			// /sourcecommentsonly switch on the command-line  			Console.WriteLine ("ResGen : error RG0000: Invalid command line syntax.  Switch: \"/nocomments\" cannot be used with \"/sourcecommentsonly\"");  			return 1;  		}  		options.Comments = CommentOptions.writeNoComments;  		break;  	case "/sourcecommentsonly":  	case "-sourcecommentsonly":  		// only export comments to the destination format that existed in the  		// source file. Do not include automatically created comments.  		if (options.Comments == CommentOptions.writeNoComments) {  			// the /nocomments option should not appear after the  			// /sourcecommentsonly switch on the command-line  			Console.WriteLine ("ResGen : error RG0000: Invalid command line syntax.  Switch: \"/nocomments\" cannot be used with \"/sourcecommentsonly\"");  			return 1;  		}  		options.Comments = CommentOptions.writeSourceCommentsOnly;  		break;  	case "/addformatflags":  	case "-addformatflags":  		// Format flags in a .po like csharp-format tells the tools to check that the msgid and msgstr   		// contain the same number of format specifications' but if your not using the english   		// strings as msgids then this just creates a bunch of erroneous warnings.  		options.FormatFlags = true;  		break;  	default:  		if (!IsFileArgument (args [i])) {  			Usage ();  			return 1;  		}  		ResourceInfo resInf = new ResourceInfo ();  		if (compileMultiple) {  			string[] pair = args [i].Split (''');  			switch (pair.Length) {  			case 1:  				resInf.InputFile = Path.GetFullPath (pair [0]);  				resInf.OutputFile = Path.ChangeExtension (resInf.InputFile' "resx");  				break;  			case 2:  				if (pair [1].Length == 0) {  					Console.WriteLine (@"error: You must specify an input & outfile file name like this:");  					Console.WriteLine ("inFile.po'outFile.resx.");  					Console.WriteLine ("You passed in '{0}'."' args [i]);  					return 1;  				}  				resInf.InputFile = Path.GetFullPath (pair [0]);  				resInf.OutputFile = Path.GetFullPath (pair [1]);  				break;  			default:  				Usage ();  				return 1;  			}  		}  		else {  			if ((i + 1) < args.Length) {  				resInf.InputFile = Path.GetFullPath (args [i]);  				// move to next arg' since we assume that one holds  				// the name of the output file  				i++;  				resInf.OutputFile = Path.GetFullPath (args [i]);  			}  			else {  				resInf.InputFile = Path.GetFullPath (args [i]);  				resInf.OutputFile = Path.ChangeExtension (resInf.InputFile' "resx");  			}  		}  		inputFiles.Add (resInf);  		break;  	}  }  
Magic Number,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,Main,The following statement contains a magic number: switch (args [i].ToLower ()) {  case "-h":  case "/h":  case "-?":  case "/?":  	Usage ();  	return 1;  /* this version has been specialized for use converting between '.resx'                       * and '.po' files' other formats will now fail! /compile is only used                      * for '.resources' files.                     case "/compile":                     case "-compile":                         // takes a list of .resX or .txt files to convert to .resources files                         // in one bulk operation' replacing .ext with .resources for the                          // output file name (if not set).                          if (inputFiles.Count > 0) {                             // the /compile option should be specified before any files                             Usage ();                             return 1;                         }                         compileMultiple = true;                         break;                     */case "/usesourcepath":  case "-usesourcepath":  	// to resolve relative file paths' use the directory of the resource   	// file as current directory.  	if (compileMultiple) {  		// the /usesourcepath option should not appear after the  		// /compile switch on the command-line  		Console.WriteLine ("ResGen : error RG0000: Invalid " + "command line syntax.  Switch: \"/compile\"  Bad value: " + args [i] + ".  Use ResGen /? for usage information.");  		return 1;  	}  	useSourcePath = true;  	break;  case "/nocomments":  case "-nocomments":  	// don't export the rawComments from the source file to the destination   	// format' and don't include automatically created comments.  	if (options.Comments == CommentOptions.writeSourceCommentsOnly) {  		// the /nocomments option should not appear after the  		// /sourcecommentsonly switch on the command-line  		Console.WriteLine ("ResGen : error RG0000: Invalid command line syntax.  Switch: \"/nocomments\" cannot be used with \"/sourcecommentsonly\"");  		return 1;  	}  	options.Comments = CommentOptions.writeNoComments;  	break;  case "/sourcecommentsonly":  case "-sourcecommentsonly":  	// only export comments to the destination format that existed in the  	// source file. Do not include automatically created comments.  	if (options.Comments == CommentOptions.writeNoComments) {  		// the /nocomments option should not appear after the  		// /sourcecommentsonly switch on the command-line  		Console.WriteLine ("ResGen : error RG0000: Invalid command line syntax.  Switch: \"/nocomments\" cannot be used with \"/sourcecommentsonly\"");  		return 1;  	}  	options.Comments = CommentOptions.writeSourceCommentsOnly;  	break;  case "/addformatflags":  case "-addformatflags":  	// Format flags in a .po like csharp-format tells the tools to check that the msgid and msgstr   	// contain the same number of format specifications' but if your not using the english   	// strings as msgids then this just creates a bunch of erroneous warnings.  	options.FormatFlags = true;  	break;  default:  	if (!IsFileArgument (args [i])) {  		Usage ();  		return 1;  	}  	ResourceInfo resInf = new ResourceInfo ();  	if (compileMultiple) {  		string[] pair = args [i].Split (''');  		switch (pair.Length) {  		case 1:  			resInf.InputFile = Path.GetFullPath (pair [0]);  			resInf.OutputFile = Path.ChangeExtension (resInf.InputFile' "resx");  			break;  		case 2:  			if (pair [1].Length == 0) {  				Console.WriteLine (@"error: You must specify an input & outfile file name like this:");  				Console.WriteLine ("inFile.po'outFile.resx.");  				Console.WriteLine ("You passed in '{0}'."' args [i]);  				return 1;  			}  			resInf.InputFile = Path.GetFullPath (pair [0]);  			resInf.OutputFile = Path.GetFullPath (pair [1]);  			break;  		default:  			Usage ();  			return 1;  		}  	}  	else {  		if ((i + 1) < args.Length) {  			resInf.InputFile = Path.GetFullPath (args [i]);  			// move to next arg' since we assume that one holds  			// the name of the output file  			i++;  			resInf.OutputFile = Path.GetFullPath (args [i]);  		}  		else {  			resInf.InputFile = Path.GetFullPath (args [i]);  			resInf.OutputFile = Path.ChangeExtension (resInf.InputFile' "resx");  		}  	}  	inputFiles.Add (resInf);  	break;  }  
Magic Number,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,Main,The following statement contains a magic number: if (compileMultiple) {  	string[] pair = args [i].Split (''');  	switch (pair.Length) {  	case 1:  		resInf.InputFile = Path.GetFullPath (pair [0]);  		resInf.OutputFile = Path.ChangeExtension (resInf.InputFile' "resx");  		break;  	case 2:  		if (pair [1].Length == 0) {  			Console.WriteLine (@"error: You must specify an input & outfile file name like this:");  			Console.WriteLine ("inFile.po'outFile.resx.");  			Console.WriteLine ("You passed in '{0}'."' args [i]);  			return 1;  		}  		resInf.InputFile = Path.GetFullPath (pair [0]);  		resInf.OutputFile = Path.GetFullPath (pair [1]);  		break;  	default:  		Usage ();  		return 1;  	}  }  else {  	if ((i + 1) < args.Length) {  		resInf.InputFile = Path.GetFullPath (args [i]);  		// move to next arg' since we assume that one holds  		// the name of the output file  		i++;  		resInf.OutputFile = Path.GetFullPath (args [i]);  	}  	else {  		resInf.InputFile = Path.GetFullPath (args [i]);  		resInf.OutputFile = Path.ChangeExtension (resInf.InputFile' "resx");  	}  }  
Magic Number,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,Main,The following statement contains a magic number: switch (pair.Length) {  case 1:  	resInf.InputFile = Path.GetFullPath (pair [0]);  	resInf.OutputFile = Path.ChangeExtension (resInf.InputFile' "resx");  	break;  case 2:  	if (pair [1].Length == 0) {  		Console.WriteLine (@"error: You must specify an input & outfile file name like this:");  		Console.WriteLine ("inFile.po'outFile.resx.");  		Console.WriteLine ("You passed in '{0}'."' args [i]);  		return 1;  	}  	resInf.InputFile = Path.GetFullPath (pair [0]);  	resInf.OutputFile = Path.GetFullPath (pair [1]);  	break;  default:  	Usage ();  	return 1;  }  
Magic Number,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,IsFileArgument,The following statement contains a magic number: return (RunningOnUnix && arg.Length > 2 && arg.IndexOf ('/'' 2) != -1);  
Magic Number,resgenEx,ResGen,C:\repos\Treer_resgenEx\resgenEx\Main.cs,IsFileArgument,The following statement contains a magic number: return (RunningOnUnix && arg.Length > 2 && arg.IndexOf ('/'' 2) != -1);  
