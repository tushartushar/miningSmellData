Implementation smell,Namespace,Class,File,Method,Description
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CsvParser,The method has 134 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The method has 229 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The method has 131 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The method has 108 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The method has 160 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The method has 253 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The method has 163 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The method has 152 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The method has 431 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The method has 294 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The method has 206 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The method has 159 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The method has 212 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The method has 113 lines of code.
Long Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The method has 198 lines of code.
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,GetCsvNumericCulture,Cyclomatic complexity of the method is 11
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetMapUnits,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,GetSource,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,Refresh,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,webclient_OpenReadCompleted,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,Cyclomatic complexity of the method is 11
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,Cyclomatic complexity of the method is 14
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetCurrentTileMatrixSet,Cyclomatic complexity of the method is 8
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,Cyclomatic complexity of the method is 33
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,Cyclomatic complexity of the method is 24
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractLatLonBox,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractEnvelope,Cyclomatic complexity of the method is 10
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,Cyclomatic complexity of the method is 31
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Flush,Cyclomatic complexity of the method is 9
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,Cyclomatic complexity of the method is 25
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,Cyclomatic complexity of the method is 12
Complex Method,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,Cyclomatic complexity of the method is 13
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The method has 6 parameters. Parameters: distanceMatrix' size' x' y' intensityMap' width
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleMapAsync,The method has 5 parameters. Parameters: styleMap' xDoc' credentials' callback' clientCertificate
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleUrlAsync,The method has 5 parameters. Parameters: styleUrl' xDoc' credentials' callback' clientCertificate
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Init,The method has 7 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' z
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,StaticTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Zlib.cs,StaticTree,The method has 5 parameters. Parameters: static_tree' extra_bits' extra_base' elems' max_length
Long Parameter List,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZlibBaseStream,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZlibStream.cs,ZlibBaseStream,The method has 5 parameters. Parameters: stream' compressionMode' level' wantRfc1950Header' leaveOpen
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,,The length of the parameter SourceSpatialReferenceProperty is 30.
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,,The length of the parameter FeaturePlacemarkerDescriptorProperty is 36.
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipConstants,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipConstants.cs,,The length of the parameter Zip64EndOfCentralDirectoryRecordSignature is 41.
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipConstants,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipConstants.cs,,The length of the parameter Zip64EndOfCentralDirectoryLocatorSignature is 42.
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipConstants,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipConstants.cs,,The length of the parameter EndOfCentralDirectorySignature is 30.
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipConstants,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipConstants.cs,,The length of the parameter ZipEntryDataDescriptorSignature is 31.
Long Identifier,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,,The length of the parameter _TrimVolumeFromFullyQualifiedPaths is 34.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,The length of the statement  "							if ((!string.IsNullOrEmpty(row[j])) && double.IsNaN(x) && ((!string.IsNullOrEmpty(XFieldName) && XFieldName == headers[j]) || " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,The length of the statement  "							else if ((!string.IsNullOrEmpty(row[j])) && double.IsNaN(y) && ((!string.IsNullOrEmpty(YFieldName) && YFieldName == headers[j]) || " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,SetStream,The length of the statement  "						if (col.EndsWith("\""' StringComparison.InvariantCultureIgnoreCase) && !col.EndsWith("\\\""' StringComparison.InvariantCultureIgnoreCase) && col.Length != 1) " is 157.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The length of the statement  "			double lon2 = lon1 + Math.Atan2(Math.Sin(brng) * Math.Sin(dR) * Math.Cos(lat1)' Math.Cos(dR) - Math.Sin(lat1) * Math.Sin(lat2)); " is 128.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateLocation,The length of the statement  "				MapPoint newLocation = new ESRI.ArcGIS.Client.Geometry.MapPoint(GeoCoordinate.Longitude' GeoCoordinate.Latitude) { SpatialReference = new SpatialReference(4326) }; " is 163.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The length of the statement  "					matrix[i * width + j] = (ushort)Math.Max((size - (Math.Sqrt(Math.Pow(i - size + 1' 2) + Math.Pow(j - size + 1' 2))))' 0); " is 121.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,OnMapChanged,The length of the statement  "            ResetRefreshTimer();  // stopping the timer when newmap is null allows to avoid memory leak when the layer is removed from the map " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,Initialize,The length of the statement  "				if (!_visibleLayerIds.Contains(0)) // FolderIds 0 is the layer itself (Note : we can't test here the top folder visibility (folderid=1) since the kml document has not been parsed yet' so _hasRootContainer is not initialized yet) " is 228.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GenerateVisibilityIDs,The length of the statement  "			// Then go recursively through the sublayers and  concat with  the visible IDs of the sublayers (but don't go through the hierarchy for networklinks (i.e. _isRoot)) " is 164.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GenerateVisibilityIDs,The length of the statement  "			return ownIDs.Concat(ChildLayers.OfType<KmlLayer>().SelectMany(InternalGenerateVisibilityIDs)).ToArray(); // ToArray freezes the result " is 135.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,InternalGenerateVisibilityIDs,The length of the statement  "			// For NetworkLinks (i.e. _isRoot)' don't go through the hierarchy and return an empty enumeration (Network links visibility is not managed by arcgis.com) " is 154.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,InternalGenerateVisibilityIDs,The length of the statement  "			// Create an enumeration either empty (if the layer is not visible) or containing the current ID (if the layer is visible) " is 122.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "				_hasRootContainer = _isRoot && fd.hasRootContainer; // the root container has been collapsed (info needed to generate internal folderIDs) " is 137.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "					// VisibleLayerIds is set --> layer created from a web map --> check that the layer must stay visible (_hasRootContainer is set only after the file has been parsed) " is 164.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "					if (_hasRootContainer && !_visibleLayerIds.Contains(1)) // FolderIds 1 is the top level folder that may not be visible in SL " is 124.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "					// Note : use internal constructor' so properties such as MapTip' ProxyUrl' VisibleLayers.. are reported to the children " is 120.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The length of the statement  "						kmlLayer.Visible = _visibleLayerIds != null ? _visibleLayerIds.Contains(kmlLayer._folderId) : IsContainerVisible(fullPath' container.Visible); " is 142.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GetBaseUri,The length of the statement  "			return GetParentsAndSelf(this).Select(l => l.Url).FirstOrDefault(u => u != null); // Go up the hierarchy and return the first Url " is 129.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,IsContainerVisible,The length of the statement  "			// look for a wildcard defined at a sublevel  (e.g. VisibleLayers="myFolder/*" makes visible all paths beginning by myFolder/) " is 126.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,IsContainerVisible,The length of the statement  "			IEnumerable<string> subpaths = path.Select((c' ind) => c == '/' ? path.Substring(0' ind) : null).Where(subpath => subpath != null); " is 131.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,AssignFolderIDs,The length of the statement  "				// store the folderID as attribute of the in memory XML document' so the info is available when parsing the documents or folders " is 128.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,NeedNumericId,The length of the statement  "				bool isCandidate = name == "BalloonStyle" || name == "LineStyle" || name == "IconStyle" || name == "Icon" || name == "LookAt" " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,IsInRegion,The length of the statement  "			return !(lod < RegionInfo.MinLodPixels || (lod > RegionInfo.MaxLodPixels && RegionInfo.MaxLodPixels != -1)); // Keep ! to take care of NaN " is 138.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,SetResolutionRange,The length of the statement  "				foreach (var layer in ChildLayers.Where(l => !(l is KmlLayer) || (l as KmlLayer).Url == null)) // Eliminate the networklinks from the list " is 138.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WebMercatorProjectionService,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectAsync,The length of the statement  "				var result = graphics.Where(g => g != null).Select(g => new Graphic {Geometry = Project(g.Geometry' outSpatialReference)}); " is 123.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfos,The length of the statement  "			return (layers.Elements(XName.Get("Layer"' ns)).Select(layer => CreateLayerInfo(layer' ns' inheritedAttribution)).ToList()); " is 124.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,The length of the statement  "			layerInfo.Abstract = layer.Element(XName.Get("Abstract"' ns)) == null ? null : layer.Element(XName.Get("Abstract"' ns)).Value; " is 126.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,The length of the statement  "			var attribution = layer.Element(XName.Get("Attribution"' ns)) == null ? null : layer.Element(XName.Get("Attribution"' ns)); " is 123.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CreateLayerInfo,The length of the statement  "				layerInfo.Attribution.Title = attribution.Element(XName.Get("Title"' ns)) == null ? inheritedAttribution : attribution.Element(XName.Get("Title"' ns)).Value; " is 157.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The length of the statement  "				SupportedImageFormats = new ReadOnlyCollection<string>(new List<string>(from c in formats where c.Value != null select c.Value)); " is 129.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The length of the statement  "			_useCrsFormat = new List<int>{4326' 4269' 4267}; // initialize with all wkid that supports crs and remove from the list when an EPSG:xxxx format is supported (prefered format for backward compatibility reason) " is 209.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetEnvelope,The length of the statement  "			   element.Attribute("minx") == null ? double.MinValue : double.Parse(element.Attribute("minx").Value' CultureInfo.InvariantCulture)' " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetEnvelope,The length of the statement  "			   element.Attribute("miny") == null ? double.MinValue : double.Parse(element.Attribute("miny").Value' CultureInfo.InvariantCulture)' " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetEnvelope,The length of the statement  "			   element.Attribute("maxx") == null ? double.MaxValue : double.Parse(element.Attribute("maxx").Value' CultureInfo.InvariantCulture)' " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetEnvelope,The length of the statement  "			   element.Attribute("maxy") == null ? double.MaxValue : double.Parse(element.Attribute("maxy").Value' CultureInfo.InvariantCulture) " is 129.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetEnvelope,The length of the statement  "				envelope = useLatLon ? new Envelope(extent.YMin' extent.XMin' extent.YMax' extent.XMax) { SpatialReference = sref } : extent; " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The length of the statement  "			bool useCrsFormat = _useCrsFormat != null && _useCrsFormat.Contains(extentWKID); // Need to use CRS:xx format ==> x'y order " is 123.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The length of the statement  "			onComplete(Utilities.PrefixProxy(ProxyUrl' mapURL.ToString()).AbsoluteUri' new ImageResult(new ESRI.ArcGIS.Client.Geometry.Envelope() " is 133.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,OnTokenPropertyChanged,The length of the statement  "			// if the token has changed and if the initialization is on the way or has failed --> initialize again the layer with the new token " is 131.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,OnTokenPropertyChanged,The length of the statement  "			// if the initialization was OK with the previous token --> nothing to do since we assume that the token doesn't change the metadata " is 132.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The length of the statement  "				TileMatrixLimitsInfo tileMatrixLimits = CurrentTileMatrixSetLink == null ? null : CurrentTileMatrixSetLink.TileMatrixLimits.FirstOrDefault(tml => tml.TileMatrix == matrix.Identifier); " is 183.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The length of the statement  "					if (CurrentTileMatrixSetLink != null && CurrentTileMatrixSetLink.TileMatrixLimits.Any()) // some limits are specified --> no limits for one level means no tile for this level " is 174.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The length of the statement  "				string resourceTemplateUrl = CurrentLayer.ResourceUrls.Where(r => r.Format == ImageFormat && r.ResourceType == "tile").Select(r => r.Template).FirstOrDefault(); " is 160.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetCurrentDimensionValues,The length of the statement  "					WmtsDimensionValue wmtsDimensionValue = DimensionValues == null ? null : DimensionValues.FirstOrDefault(dv => dv.Identifier == dimensionInfo.Identifier); " is 153.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetTileInfo,The length of the statement  "			if (CurrentTileMatrixSet.Matrices.Any(tm => tm.TileWidth != tileWidth || tm.TileHeight != tileHeight || !tm.TopLeftCorner.Equals(topLeftCorner))) " is 145.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,SetTileInfo,The length of the statement  "				matrices = CurrentTileMatrixSetLink.TileMatrixLimits.Join(CurrentTileMatrixSet.Matrices' tmsl => tmsl.TileMatrix' m => m.Identifier' (tmsl' m) => m); " is 149.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ConvertToResolution,The length of the statement  "			// GetScale for a map resolution of 1 (i.e one map unit by pixel) gives the number of pixels by map unit of the specified SR " is 124.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseCapabilities,The length of the statement  "				LayerInfos = contents.Elements(XName.Get("Layer"' ns)).Select(layerElement => ParseLayer(layerElement' owsns.NamespaceName' ns)).ToList(); " is 138.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseCapabilities,The length of the statement  "				TileMatrixSets = contents.Elements(XName.Get("TileMatrixSet"' ns)).Select(elt => ParseTileMatrixSet(elt' owsns.NamespaceName' ns)).ToList(); " is 140.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseLayer,The length of the statement  "				Formats = layerElement.Elements(XName.Get("Format"' nsname)).Select(formatElement => formatElement.GetValue()).ToList()' " is 120.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseLayer,The length of the statement  "				TileMatrixSetLinks = layerElement.Elements(XName.Get("TileMatrixSetLink"' nsname)).Select(element => ParseTileMatrixSetLink(element' nsname)).ToList()' " is 151.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSetLink,The length of the statement  "			                                                     	: tileMatrixSetLimitsElement.Elements(XName.Get("TileMatrixLimits"' nsname)).Select(elt => ParseTileMatrixLimits(elt' nsname)); " is 127.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The length of the statement  "				Matrices = element.Elements(XName.Get("TileMatrix"' nsname)).Select(elt => ParseTileMatrix(elt' owsnsname' nsname)).ToList() " is 124.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The length of the statement  "			tileMatrixSet.Extent = ParseEnvelope(element.Element(XName.Get("BoundingBox"' owsnsname))' tileMatrixSet.SpatialReference' owsnsname); " is 134.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,XPathSelectElement,The length of the statement  "					element = element.Elements(XName.Get(eltName' ns.NamespaceName)).Where(elt => elt.GetAttributeValue(XName.Get(attName)) == value).FirstOrDefault(); " is 147.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,PointSymbolDescriptor,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,GetDefaultSymbol,The length of the statement  "			var defaultIconSource = new MemoryStream(Convert.FromBase64String("iVBORw0KGgoAAAANSUhEUgAAAA4AAAAQCAMAAAARSr4IAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAA9QTFRF/xkAkpOSzMzMAAAA////5g9v4AAAADFJREFUeNpiYEQBDIwsCMDETDqXgQGCYbIMDCAeQjGYh0MWXS+5zmBCAswMzCgAIMAAMR8Cl/k132AAAAAASUVORK5CYII=")); " is 299.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The length of the statement  "			UniqueValueRenderer renderer = new UniqueValueRenderer(); // dummy renderer used to create the legend items (since creation of the swatches from the symbol is not that obvious)  " is 176.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The length of the statement  "						ComputeIconTranslationValues(style' g.Symbol as KmlPlaceMarkerSymbol' ((g.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage); " is 154.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,UpdateGraphicsAndRenderer,The length of the statement  "					ComputeIconTranslationValues(f.Symbol.style' graphic.Symbol as KmlPlaceMarkerSymbol' ((graphic.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage); " is 175.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The length of the statement  "                    // If feature color is White with an alpha channel' this can be managed with Opacity' else we need the to blend the color with the icon " is 135.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The length of the statement  "					uiElement.RenderTransform = new RotateTransform {Angle = -feature.Rotation}; // KML rotations are specified in a counterclockwise direction " is 139.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The length of the statement  "				// If the map is based on WebMercatore coordinates' project the envelope (weird at small scale but acceptable at large scale) " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "			// Process the styles if they are not already known (the styles are shared by all folders/documents' so process them only once) " is 127.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "				IEnumerable<XElement> styles = xElement.Descendants().Where(e => e.Name.LocalName == "Style" && (string)e.Attribute("id") != null); " is 131.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "				IEnumerable<XElement> styleMaps = xElement.Descendants().Where(e => e.Name.LocalName == "StyleMap" && (string)e.Attribute("id") != null); " is 137.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "			foreach (XElement container in xElement.Elements().Where(element => element.Name.LocalName == "Folder" || element.Name.LocalName == "Document" || element.Name.LocalName == "NetworkLink")) " is 187.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "			foreach (XElement element in xElement.Elements().Where(element => element.Name == kmlNS + "Placemark" || element.Name == kmlNS + "GroundOverlay" )) " is 147.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "					GetStyleUrlAsync(styleElement.Value' null' credentials' kmlStyle => CreateFeatureDefinition(kmlStyle' featureElement' null' context) " is 132.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "			// At this point' some inner styles are possibly on the way to being downloaded and so the feature definitions are not created yet " is 130.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The length of the statement  "				// Avoid useless level when there is no groundoverlay' no placemark and only one folder or document at the root level without any lod info " is 138.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,StyleDownloaded,The length of the statement  "				GetStyleUrlAsync(state.StyleId' xDoc' state.Credentials' kmlStyle => StoreZipfileAndCallback(kmlStyle' state.Callback' zipFile) " is 127.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The length of the statement  "				// kmlStyle is null when the placemark doesn't reference any shared style (or a shared style that we are not able to download) " is 126.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractCoordinate,The length of the statement  "                    if (double.TryParse(xy[0]' System.Globalization.NumberStyles.Float' CultureInfo.InvariantCulture' out x) && double.TryParse(xy[1]' System.Globalization.NumberStyles.Float' CultureInfo.InvariantCulture' out y)) " is 209.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleUrlAsync,The length of the statement  "				// If there is no starting # and no KML doc referenced' we search also in current KML file (may happen that the # is missing in some KML doc) " is 141.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyleUrlAsync,The length of the statement  "						XElement style = xDoc.Descendants().FirstOrDefault(e => e.Name.LocalName == "Style" && (string)e.Attribute("id") == styleId); " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,CRC32,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Crc32.cs,GetCrc32AndCopy,The length of the statement  "                    //    _RunningCrc32Result = ((_RunningCrc32Result) >> 8) ^ crc32Table[(buffer[i]) ^ ((_RunningCrc32Result) & 0x000000FF)]; " is 122.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The length of the statement  "            if (day <= 0) { day = 1; } // ArcGIS server returns 0x0020 as date : not sure of the meaning (winzip displays the current date) " is 127.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The length of the statement  "            UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00)); " is 132.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The length of the statement  "            UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800)); " is 132.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "                    throw new BadReadException(String.Format("  ZipEntry::ReadDirEntry(): Bad signature (0x{0:X8}) at position 0x{1:X8}"' signature' s.Position)); " is 142.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "            zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256); " is 129.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "                zde._LocalFileName = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.Utf8StringFromBuffer(block' block.Length); " is 126.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "                zde._LocalFileName = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.StringFromBuffer(block' block.Length' expectedEncoding); " is 140.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "                    zde._Comment = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.Utf8StringFromBuffer(block' block.Length); " is 120.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "                    zde._Comment = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.StringFromBuffer(block' block.Length' expectedEncoding); " is 134.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The length of the statement  "                    throw new BadReadException(String.Format("  ZipEntry::ReadHeader(): Bad signature (0x{0:X8}) at position  0x{1:X8}"' signature' ze.ArchiveStream.Position)); " is 156.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The length of the statement  "                //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position)); " is 196.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The length of the statement  "                    long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature); " is 150.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_ExtractOne,The length of the statement  "                ? new ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.DeflateStream(input2' ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.CompressionMode.Decompress' true) " is 155.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The length of the statement  "                                //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead)); " is 145.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The length of the statement  "                                    throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead)); " is 168.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The length of the statement  "                                    throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead)); " is 125.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The length of the statement  "                                    throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead)); " is 157.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The length of the statement  "                                    throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' " is 135.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The length of the statement  "                                    throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead)); " is 169.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The length of the statement  "                throw new BadReadException(String.Format("  ZipFile::Read(): Bad signature (0x{0:X8}) looking for ZIP64 EoCD Record at position 0x{1:X8}"' datum' s.Position)); " is 159.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,VerifyBeginningOfZipFile,The length of the statement  "                throw new BadReadException(String.Format("  ZipFile::Read(): Bad signature (0x{0:X8}) at start of file at position 0x{1:X8}"' datum' s.Position)); " is 146.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The length of the statement  "                throw new BadReadException(String.Format("  ZipFile::Read(): Bad signature ({0:X8}) at position 0x{1:X8}"' signature' s.Position)); " is 131.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Extract,The length of the statement  "                throw new ZipException("Cannot extract."' new ArgumentException("The OutputStream must be a writable stream."' "outputStream")); " is 128.
Long Statement,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Extract,The length of the statement  "                throw new ZipException("Cannot extract."' new ArgumentException("The file name must be neither null nor empty."' "fileName")); " is 126.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,The conditional expression  "(!string.IsNullOrEmpty(row[j])) && double.IsNaN(x) && ((!string.IsNullOrEmpty(XFieldName) && XFieldName == headers[j]) ||  								(string.IsNullOrEmpty(XFieldName) && LON_FIELDS.Contains(headers[j].ToLowerInvariant())))"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CreateGraphics,The conditional expression  "(!string.IsNullOrEmpty(row[j])) && double.IsNaN(y) && ((!string.IsNullOrEmpty(YFieldName) && YFieldName == headers[j]) ||  								(string.IsNullOrEmpty(YFieldName) && LAT_FIELDS.Contains(headers[j].ToLowerInvariant())))"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,GetCsvNumericCulture,The conditional expression  "(!string.IsNullOrEmpty(XFieldName) && XFieldName == headers[i]) ||                          (string.IsNullOrEmpty(XFieldName) && LON_FIELDS.Contains(headers[i].ToLowerInvariant()))"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,GetCsvNumericCulture,The conditional expression  "(!string.IsNullOrEmpty(YFieldName) && YFieldName == headers[i]) ||                                  (string.IsNullOrEmpty(YFieldName) && LAT_FIELDS.Contains(headers[i].ToLowerInvariant()))"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,TryStartGps,The conditional expression  "permission && Visible && Map != null && IsEnabled && GeoPositionWatcher != null"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,TryStartGps,The conditional expression  "result && GeoPositionWatcher != null && GeoPositionWatcher.Position != null &&  				GeoPositionWatcher.Position.Location != null && !GeoPositionWatcher.Position.Location.IsUnknown"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateLocation,The conditional expression  "Map != null && Map.SpatialReference != null && GeoCoordinate != null && GeoCoordinate != GeoCoordinate.Unknown"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,Circle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateRing,The conditional expression  "!double.IsNaN(Radius) && Radius > 0 && Center != null && PointCount > 2"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,GetSource,The conditional expression  "p.X >= extent2.XMin && p.Y >= extent2.YMin &&  						p.X <= extent2.XMax && p.Y <= extent2.YMax"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,RefreshOnRegionAsync,The conditional expression  "map == null || !NeedRefreshOnRegion || _isLoading || _isLoaded"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The conditional expression  "SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913)"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,OnUrlPropertyChanged,The conditional expression  "!SkipGetCapabilities && (IsInitialized || _initializing) && !string.IsNullOrEmpty(newUrl)"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The conditional expression  "CurrentTileMatrixSet == null || CurrentLayer == null || CurrentTileMatrixSet.Matrices == null ||  					level < 0 || CurrentTileMatrixSet.Matrices.Count() <= level"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetTileUrl,The conditional expression  "row < minTileRow || row > maxTileRow || col < minTileCol || col > maxTileCol"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The conditional expression  "map != null && map.SpatialReference != null && IsWebMercator(map.SpatialReference)  					&& envelope.SpatialReference != null && envelope.SpatialReference.WKID == 4326"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The conditional expression  "!featureDefs.groundOverlays.Any() && !featureDefs.placemarks.Any() && singleContainer != null && folderId == 0  				&& (singleContainer.RegionInfo == null || !singleContainer.RegionInfo.HasLods())   				&& string.IsNullOrEmpty(singleContainer.Url) && singleContainer.TimeExtent ==  null"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractLatLonBox,The conditional expression  "north.HasValue && south.HasValue && east.HasValue && west.HasValue"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The conditional expression  "(_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/')"  is complex.
Complex Conditional,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,VerifyBeginningOfZipFile,The conditional expression  "datum != ZipConstants.PackedToRemovableMedia  // weird edge case                  && datum != ZipConstants.ZipEntrySignature   // normal BOF marker                  && datum != ZipConstants.EndOfCentralDirectorySignature  // for zip file with no entries                  && (datum & 0x0000FFFF) != 0x00005A4D"  is complex.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GetKmzContents,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetValidVersionNumber,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,LowerThan13Version,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetValidVersionNumber,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,GetIconImage,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,ReadSignature,The method has an empty catch block.
Empty Catch Block,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZlibBaseStream,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZlibStream.cs,Close,The method has an empty catch block.
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,CsvLayer,The following statement contains a magic number: SourceSpatialReference = new SpatialReference(4326);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRss.cs,loader_LoadCompleted,The following statement contains a magic number: this.SpatialReference = new Geometry.SpatialReference(4326);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result)  			{  				SyndicationFeed feed;  				List<SyndicationItem> feedItems = new List<SyndicationItem>();    				using (XmlReader reader = XmlReader.Create(s))  				{  					feed = SyndicationFeed.Load(reader);  					foreach (SyndicationItem feedItem in feed.Items)  					{  						SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;    						string slong = "";  						string slat = "";  						Geometry.Geometry g = null;  						IDictionary<string' object> attributes = new Dictionary<string'object>();  						foreach (SyndicationElementExtension ee in ec)  						{  							if (ee.OuterNamespace.Equals(_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								//This is not part of the georss-simple spec' but this makes it support a common  								//use-case with geo:lat/geo:long coordinate pairs' as described at  								//http://www.w3.org/2003/01/geo/  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("lat"):  										{  											slat = xr.ReadElementContentAsString();  											break;  										}  									case ("long"):  										{  											slong = xr.ReadElementContentAsString();  											break;  										}  									case ("Point"):  										{  											XmlReader xmlPoint = xr.ReadSubtree();  											while (xmlPoint.Read())  											{  												if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slat = xmlPoint.ReadElementContentAsString();  												}  												else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slong = xmlPoint.ReadElementContentAsString();  												}  											}  											break;  										}  								}  							}  							else if (ee.OuterNamespace.Equals(_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("point"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											slong = sxsy[1];  											slat = sxsy[0];  											break;  										}  									case ("line"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polyline line = new Polyline() { SpatialReference = new SpatialReference(4326) };  												line.Paths.Add(pnts);  												g = line;  											}  											break;  										}  									case ("polygon"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polygon line = new Polygon() { SpatialReference = new SpatialReference(4326) };  												line.Rings.Add(pnts);  												g = line;  											}  											break;  										}  									case ("box"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null && pnts.Count == 2)  											{  												g = new Envelope(pnts[0]' pnts[1]) { SpatialReference = new SpatialReference(4326) };  											}  											break;  										}  									case ("circle"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											if (sxsy.Length == 3)  											{  												double x = double.NaN' y = double.NaN' r = double.NaN;  												string stX = sxsy[1];  												string stY = sxsy[0];  												string stR = sxsy[2];  												if (double.TryParse(stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  													double.TryParse(stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) &&  													double.TryParse(stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r))  												{  													g = GetRadiusAsPolygonGeodesic(new MapPoint(x' y)' r' 360);  												}  											}  											break;  										}    									case ("where"): //GeoRSS-GML  										{  											//GML geometry parsing goes here. However this is not  											//part of GeoRSS-simple and not supported for this datasource  											//We'll just ignore these entries  											break;  										}  									#region Attributes  									case ("elev"):  										{  											string sp = xr.ReadElementContentAsString();  											double elevation = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  												attributes.Add("elev"' elevation);  											break;  										}  									case ("floor"):  										{  											string sp = xr.ReadElementContentAsString();  											int floor = 0;  											if (int.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  												attributes.Add("floor"' floor);  											break;  										}  									case ("radius"):  										{  											string sp = xr.ReadElementContentAsString();  											double radius = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  												attributes.Add("radius"' radius);  											break;  										}  									//case ("featuretypetag"):  									//case ("relationshiptag"):  									//case ("featurename"):  									default:  										{  											string sp = xr.ReadElementContentAsString();  											attributes.Add(ee.OuterName' sp);  											break;  										}  									#endregion  								}  							}  						}    						if (!string.IsNullOrEmpty(slong) && !string.IsNullOrEmpty(slat))  						{  							double x = double.NaN;  							double y = double.NaN;  							if (double.TryParse(slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  								double.TryParse(slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  								g = new MapPoint(x' y' new SpatialReference(4326));  						}  						if (g != null)  						{  							Graphic graphic = new Graphic() { Geometry = g };  							  							if(feedItem.Title != null)  								graphic.Attributes.Add("Title"' feedItem.Title.Text);  							if (feedItem.Summary != null)  								graphic.Attributes.Add("Summary"' feedItem.Summary.Text);  							if (feedItem.PublishDate != null)  							{  								graphic.Attributes.Add("PublishDate"' feedItem.PublishDate);  								graphic.TimeExtent = new TimeExtent(feedItem.PublishDate.DateTime);  							}  							if (feedItem.Links.Count > 0)  								graphic.Attributes.Add("Link"' feedItem.Links[0].Uri);  							graphic.Attributes.Add("FeedItem"' feedItem);  							graphic.Attributes.Add("Id"' feedItem.Id);  							foreach(var val in attributes)  								if(!graphic.Attributes.ContainsKey(val.Key))  								graphic.Attributes.Add(val.Key' val.Value);  							  							// Add attribute GeometryType used by renderer  							string gt = null;  							if (g is MapPoint)  								gt = "point";  							else if (g is Polyline)  								gt = "line";  							else if (g is Polygon || g is Envelope)  								gt = "polygon";  							if (gt != null)  								graphic.Attributes.Add(GeometryTypeAttribute' gt);  							graphics.Add(graphic);  						}  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result)  			{  				SyndicationFeed feed;  				List<SyndicationItem> feedItems = new List<SyndicationItem>();    				using (XmlReader reader = XmlReader.Create(s))  				{  					feed = SyndicationFeed.Load(reader);  					foreach (SyndicationItem feedItem in feed.Items)  					{  						SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;    						string slong = "";  						string slat = "";  						Geometry.Geometry g = null;  						IDictionary<string' object> attributes = new Dictionary<string'object>();  						foreach (SyndicationElementExtension ee in ec)  						{  							if (ee.OuterNamespace.Equals(_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								//This is not part of the georss-simple spec' but this makes it support a common  								//use-case with geo:lat/geo:long coordinate pairs' as described at  								//http://www.w3.org/2003/01/geo/  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("lat"):  										{  											slat = xr.ReadElementContentAsString();  											break;  										}  									case ("long"):  										{  											slong = xr.ReadElementContentAsString();  											break;  										}  									case ("Point"):  										{  											XmlReader xmlPoint = xr.ReadSubtree();  											while (xmlPoint.Read())  											{  												if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slat = xmlPoint.ReadElementContentAsString();  												}  												else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slong = xmlPoint.ReadElementContentAsString();  												}  											}  											break;  										}  								}  							}  							else if (ee.OuterNamespace.Equals(_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("point"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											slong = sxsy[1];  											slat = sxsy[0];  											break;  										}  									case ("line"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polyline line = new Polyline() { SpatialReference = new SpatialReference(4326) };  												line.Paths.Add(pnts);  												g = line;  											}  											break;  										}  									case ("polygon"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polygon line = new Polygon() { SpatialReference = new SpatialReference(4326) };  												line.Rings.Add(pnts);  												g = line;  											}  											break;  										}  									case ("box"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null && pnts.Count == 2)  											{  												g = new Envelope(pnts[0]' pnts[1]) { SpatialReference = new SpatialReference(4326) };  											}  											break;  										}  									case ("circle"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											if (sxsy.Length == 3)  											{  												double x = double.NaN' y = double.NaN' r = double.NaN;  												string stX = sxsy[1];  												string stY = sxsy[0];  												string stR = sxsy[2];  												if (double.TryParse(stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  													double.TryParse(stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) &&  													double.TryParse(stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r))  												{  													g = GetRadiusAsPolygonGeodesic(new MapPoint(x' y)' r' 360);  												}  											}  											break;  										}    									case ("where"): //GeoRSS-GML  										{  											//GML geometry parsing goes here. However this is not  											//part of GeoRSS-simple and not supported for this datasource  											//We'll just ignore these entries  											break;  										}  									#region Attributes  									case ("elev"):  										{  											string sp = xr.ReadElementContentAsString();  											double elevation = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  												attributes.Add("elev"' elevation);  											break;  										}  									case ("floor"):  										{  											string sp = xr.ReadElementContentAsString();  											int floor = 0;  											if (int.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  												attributes.Add("floor"' floor);  											break;  										}  									case ("radius"):  										{  											string sp = xr.ReadElementContentAsString();  											double radius = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  												attributes.Add("radius"' radius);  											break;  										}  									//case ("featuretypetag"):  									//case ("relationshiptag"):  									//case ("featurename"):  									default:  										{  											string sp = xr.ReadElementContentAsString();  											attributes.Add(ee.OuterName' sp);  											break;  										}  									#endregion  								}  							}  						}    						if (!string.IsNullOrEmpty(slong) && !string.IsNullOrEmpty(slat))  						{  							double x = double.NaN;  							double y = double.NaN;  							if (double.TryParse(slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  								double.TryParse(slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  								g = new MapPoint(x' y' new SpatialReference(4326));  						}  						if (g != null)  						{  							Graphic graphic = new Graphic() { Geometry = g };  							  							if(feedItem.Title != null)  								graphic.Attributes.Add("Title"' feedItem.Title.Text);  							if (feedItem.Summary != null)  								graphic.Attributes.Add("Summary"' feedItem.Summary.Text);  							if (feedItem.PublishDate != null)  							{  								graphic.Attributes.Add("PublishDate"' feedItem.PublishDate);  								graphic.TimeExtent = new TimeExtent(feedItem.PublishDate.DateTime);  							}  							if (feedItem.Links.Count > 0)  								graphic.Attributes.Add("Link"' feedItem.Links[0].Uri);  							graphic.Attributes.Add("FeedItem"' feedItem);  							graphic.Attributes.Add("Id"' feedItem.Id);  							foreach(var val in attributes)  								if(!graphic.Attributes.ContainsKey(val.Key))  								graphic.Attributes.Add(val.Key' val.Value);  							  							// Add attribute GeometryType used by renderer  							string gt = null;  							if (g is MapPoint)  								gt = "point";  							else if (g is Polyline)  								gt = "line";  							else if (g is Polygon || g is Envelope)  								gt = "polygon";  							if (gt != null)  								graphic.Attributes.Add(GeometryTypeAttribute' gt);  							graphics.Add(graphic);  						}  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result)  			{  				SyndicationFeed feed;  				List<SyndicationItem> feedItems = new List<SyndicationItem>();    				using (XmlReader reader = XmlReader.Create(s))  				{  					feed = SyndicationFeed.Load(reader);  					foreach (SyndicationItem feedItem in feed.Items)  					{  						SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;    						string slong = "";  						string slat = "";  						Geometry.Geometry g = null;  						IDictionary<string' object> attributes = new Dictionary<string'object>();  						foreach (SyndicationElementExtension ee in ec)  						{  							if (ee.OuterNamespace.Equals(_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								//This is not part of the georss-simple spec' but this makes it support a common  								//use-case with geo:lat/geo:long coordinate pairs' as described at  								//http://www.w3.org/2003/01/geo/  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("lat"):  										{  											slat = xr.ReadElementContentAsString();  											break;  										}  									case ("long"):  										{  											slong = xr.ReadElementContentAsString();  											break;  										}  									case ("Point"):  										{  											XmlReader xmlPoint = xr.ReadSubtree();  											while (xmlPoint.Read())  											{  												if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slat = xmlPoint.ReadElementContentAsString();  												}  												else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slong = xmlPoint.ReadElementContentAsString();  												}  											}  											break;  										}  								}  							}  							else if (ee.OuterNamespace.Equals(_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("point"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											slong = sxsy[1];  											slat = sxsy[0];  											break;  										}  									case ("line"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polyline line = new Polyline() { SpatialReference = new SpatialReference(4326) };  												line.Paths.Add(pnts);  												g = line;  											}  											break;  										}  									case ("polygon"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polygon line = new Polygon() { SpatialReference = new SpatialReference(4326) };  												line.Rings.Add(pnts);  												g = line;  											}  											break;  										}  									case ("box"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null && pnts.Count == 2)  											{  												g = new Envelope(pnts[0]' pnts[1]) { SpatialReference = new SpatialReference(4326) };  											}  											break;  										}  									case ("circle"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											if (sxsy.Length == 3)  											{  												double x = double.NaN' y = double.NaN' r = double.NaN;  												string stX = sxsy[1];  												string stY = sxsy[0];  												string stR = sxsy[2];  												if (double.TryParse(stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  													double.TryParse(stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) &&  													double.TryParse(stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r))  												{  													g = GetRadiusAsPolygonGeodesic(new MapPoint(x' y)' r' 360);  												}  											}  											break;  										}    									case ("where"): //GeoRSS-GML  										{  											//GML geometry parsing goes here. However this is not  											//part of GeoRSS-simple and not supported for this datasource  											//We'll just ignore these entries  											break;  										}  									#region Attributes  									case ("elev"):  										{  											string sp = xr.ReadElementContentAsString();  											double elevation = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  												attributes.Add("elev"' elevation);  											break;  										}  									case ("floor"):  										{  											string sp = xr.ReadElementContentAsString();  											int floor = 0;  											if (int.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  												attributes.Add("floor"' floor);  											break;  										}  									case ("radius"):  										{  											string sp = xr.ReadElementContentAsString();  											double radius = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  												attributes.Add("radius"' radius);  											break;  										}  									//case ("featuretypetag"):  									//case ("relationshiptag"):  									//case ("featurename"):  									default:  										{  											string sp = xr.ReadElementContentAsString();  											attributes.Add(ee.OuterName' sp);  											break;  										}  									#endregion  								}  							}  						}    						if (!string.IsNullOrEmpty(slong) && !string.IsNullOrEmpty(slat))  						{  							double x = double.NaN;  							double y = double.NaN;  							if (double.TryParse(slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  								double.TryParse(slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  								g = new MapPoint(x' y' new SpatialReference(4326));  						}  						if (g != null)  						{  							Graphic graphic = new Graphic() { Geometry = g };  							  							if(feedItem.Title != null)  								graphic.Attributes.Add("Title"' feedItem.Title.Text);  							if (feedItem.Summary != null)  								graphic.Attributes.Add("Summary"' feedItem.Summary.Text);  							if (feedItem.PublishDate != null)  							{  								graphic.Attributes.Add("PublishDate"' feedItem.PublishDate);  								graphic.TimeExtent = new TimeExtent(feedItem.PublishDate.DateTime);  							}  							if (feedItem.Links.Count > 0)  								graphic.Attributes.Add("Link"' feedItem.Links[0].Uri);  							graphic.Attributes.Add("FeedItem"' feedItem);  							graphic.Attributes.Add("Id"' feedItem.Id);  							foreach(var val in attributes)  								if(!graphic.Attributes.ContainsKey(val.Key))  								graphic.Attributes.Add(val.Key' val.Value);  							  							// Add attribute GeometryType used by renderer  							string gt = null;  							if (g is MapPoint)  								gt = "point";  							else if (g is Polyline)  								gt = "line";  							else if (g is Polygon || g is Envelope)  								gt = "polygon";  							if (gt != null)  								graphic.Attributes.Add(GeometryTypeAttribute' gt);  							graphics.Add(graphic);  						}  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result)  			{  				SyndicationFeed feed;  				List<SyndicationItem> feedItems = new List<SyndicationItem>();    				using (XmlReader reader = XmlReader.Create(s))  				{  					feed = SyndicationFeed.Load(reader);  					foreach (SyndicationItem feedItem in feed.Items)  					{  						SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;    						string slong = "";  						string slat = "";  						Geometry.Geometry g = null;  						IDictionary<string' object> attributes = new Dictionary<string'object>();  						foreach (SyndicationElementExtension ee in ec)  						{  							if (ee.OuterNamespace.Equals(_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								//This is not part of the georss-simple spec' but this makes it support a common  								//use-case with geo:lat/geo:long coordinate pairs' as described at  								//http://www.w3.org/2003/01/geo/  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("lat"):  										{  											slat = xr.ReadElementContentAsString();  											break;  										}  									case ("long"):  										{  											slong = xr.ReadElementContentAsString();  											break;  										}  									case ("Point"):  										{  											XmlReader xmlPoint = xr.ReadSubtree();  											while (xmlPoint.Read())  											{  												if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slat = xmlPoint.ReadElementContentAsString();  												}  												else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slong = xmlPoint.ReadElementContentAsString();  												}  											}  											break;  										}  								}  							}  							else if (ee.OuterNamespace.Equals(_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("point"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											slong = sxsy[1];  											slat = sxsy[0];  											break;  										}  									case ("line"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polyline line = new Polyline() { SpatialReference = new SpatialReference(4326) };  												line.Paths.Add(pnts);  												g = line;  											}  											break;  										}  									case ("polygon"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polygon line = new Polygon() { SpatialReference = new SpatialReference(4326) };  												line.Rings.Add(pnts);  												g = line;  											}  											break;  										}  									case ("box"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null && pnts.Count == 2)  											{  												g = new Envelope(pnts[0]' pnts[1]) { SpatialReference = new SpatialReference(4326) };  											}  											break;  										}  									case ("circle"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											if (sxsy.Length == 3)  											{  												double x = double.NaN' y = double.NaN' r = double.NaN;  												string stX = sxsy[1];  												string stY = sxsy[0];  												string stR = sxsy[2];  												if (double.TryParse(stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  													double.TryParse(stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) &&  													double.TryParse(stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r))  												{  													g = GetRadiusAsPolygonGeodesic(new MapPoint(x' y)' r' 360);  												}  											}  											break;  										}    									case ("where"): //GeoRSS-GML  										{  											//GML geometry parsing goes here. However this is not  											//part of GeoRSS-simple and not supported for this datasource  											//We'll just ignore these entries  											break;  										}  									#region Attributes  									case ("elev"):  										{  											string sp = xr.ReadElementContentAsString();  											double elevation = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  												attributes.Add("elev"' elevation);  											break;  										}  									case ("floor"):  										{  											string sp = xr.ReadElementContentAsString();  											int floor = 0;  											if (int.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  												attributes.Add("floor"' floor);  											break;  										}  									case ("radius"):  										{  											string sp = xr.ReadElementContentAsString();  											double radius = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  												attributes.Add("radius"' radius);  											break;  										}  									//case ("featuretypetag"):  									//case ("relationshiptag"):  									//case ("featurename"):  									default:  										{  											string sp = xr.ReadElementContentAsString();  											attributes.Add(ee.OuterName' sp);  											break;  										}  									#endregion  								}  							}  						}    						if (!string.IsNullOrEmpty(slong) && !string.IsNullOrEmpty(slat))  						{  							double x = double.NaN;  							double y = double.NaN;  							if (double.TryParse(slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  								double.TryParse(slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  								g = new MapPoint(x' y' new SpatialReference(4326));  						}  						if (g != null)  						{  							Graphic graphic = new Graphic() { Geometry = g };  							  							if(feedItem.Title != null)  								graphic.Attributes.Add("Title"' feedItem.Title.Text);  							if (feedItem.Summary != null)  								graphic.Attributes.Add("Summary"' feedItem.Summary.Text);  							if (feedItem.PublishDate != null)  							{  								graphic.Attributes.Add("PublishDate"' feedItem.PublishDate);  								graphic.TimeExtent = new TimeExtent(feedItem.PublishDate.DateTime);  							}  							if (feedItem.Links.Count > 0)  								graphic.Attributes.Add("Link"' feedItem.Links[0].Uri);  							graphic.Attributes.Add("FeedItem"' feedItem);  							graphic.Attributes.Add("Id"' feedItem.Id);  							foreach(var val in attributes)  								if(!graphic.Attributes.ContainsKey(val.Key))  								graphic.Attributes.Add(val.Key' val.Value);  							  							// Add attribute GeometryType used by renderer  							string gt = null;  							if (g is MapPoint)  								gt = "point";  							else if (g is Polyline)  								gt = "line";  							else if (g is Polygon || g is Envelope)  								gt = "polygon";  							if (gt != null)  								graphic.Attributes.Add(GeometryTypeAttribute' gt);  							graphics.Add(graphic);  						}  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result)  			{  				SyndicationFeed feed;  				List<SyndicationItem> feedItems = new List<SyndicationItem>();    				using (XmlReader reader = XmlReader.Create(s))  				{  					feed = SyndicationFeed.Load(reader);  					foreach (SyndicationItem feedItem in feed.Items)  					{  						SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;    						string slong = "";  						string slat = "";  						Geometry.Geometry g = null;  						IDictionary<string' object> attributes = new Dictionary<string'object>();  						foreach (SyndicationElementExtension ee in ec)  						{  							if (ee.OuterNamespace.Equals(_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								//This is not part of the georss-simple spec' but this makes it support a common  								//use-case with geo:lat/geo:long coordinate pairs' as described at  								//http://www.w3.org/2003/01/geo/  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("lat"):  										{  											slat = xr.ReadElementContentAsString();  											break;  										}  									case ("long"):  										{  											slong = xr.ReadElementContentAsString();  											break;  										}  									case ("Point"):  										{  											XmlReader xmlPoint = xr.ReadSubtree();  											while (xmlPoint.Read())  											{  												if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slat = xmlPoint.ReadElementContentAsString();  												}  												else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slong = xmlPoint.ReadElementContentAsString();  												}  											}  											break;  										}  								}  							}  							else if (ee.OuterNamespace.Equals(_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("point"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											slong = sxsy[1];  											slat = sxsy[0];  											break;  										}  									case ("line"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polyline line = new Polyline() { SpatialReference = new SpatialReference(4326) };  												line.Paths.Add(pnts);  												g = line;  											}  											break;  										}  									case ("polygon"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polygon line = new Polygon() { SpatialReference = new SpatialReference(4326) };  												line.Rings.Add(pnts);  												g = line;  											}  											break;  										}  									case ("box"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null && pnts.Count == 2)  											{  												g = new Envelope(pnts[0]' pnts[1]) { SpatialReference = new SpatialReference(4326) };  											}  											break;  										}  									case ("circle"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											if (sxsy.Length == 3)  											{  												double x = double.NaN' y = double.NaN' r = double.NaN;  												string stX = sxsy[1];  												string stY = sxsy[0];  												string stR = sxsy[2];  												if (double.TryParse(stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  													double.TryParse(stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) &&  													double.TryParse(stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r))  												{  													g = GetRadiusAsPolygonGeodesic(new MapPoint(x' y)' r' 360);  												}  											}  											break;  										}    									case ("where"): //GeoRSS-GML  										{  											//GML geometry parsing goes here. However this is not  											//part of GeoRSS-simple and not supported for this datasource  											//We'll just ignore these entries  											break;  										}  									#region Attributes  									case ("elev"):  										{  											string sp = xr.ReadElementContentAsString();  											double elevation = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  												attributes.Add("elev"' elevation);  											break;  										}  									case ("floor"):  										{  											string sp = xr.ReadElementContentAsString();  											int floor = 0;  											if (int.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  												attributes.Add("floor"' floor);  											break;  										}  									case ("radius"):  										{  											string sp = xr.ReadElementContentAsString();  											double radius = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  												attributes.Add("radius"' radius);  											break;  										}  									//case ("featuretypetag"):  									//case ("relationshiptag"):  									//case ("featurename"):  									default:  										{  											string sp = xr.ReadElementContentAsString();  											attributes.Add(ee.OuterName' sp);  											break;  										}  									#endregion  								}  							}  						}    						if (!string.IsNullOrEmpty(slong) && !string.IsNullOrEmpty(slat))  						{  							double x = double.NaN;  							double y = double.NaN;  							if (double.TryParse(slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  								double.TryParse(slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  								g = new MapPoint(x' y' new SpatialReference(4326));  						}  						if (g != null)  						{  							Graphic graphic = new Graphic() { Geometry = g };  							  							if(feedItem.Title != null)  								graphic.Attributes.Add("Title"' feedItem.Title.Text);  							if (feedItem.Summary != null)  								graphic.Attributes.Add("Summary"' feedItem.Summary.Text);  							if (feedItem.PublishDate != null)  							{  								graphic.Attributes.Add("PublishDate"' feedItem.PublishDate);  								graphic.TimeExtent = new TimeExtent(feedItem.PublishDate.DateTime);  							}  							if (feedItem.Links.Count > 0)  								graphic.Attributes.Add("Link"' feedItem.Links[0].Uri);  							graphic.Attributes.Add("FeedItem"' feedItem);  							graphic.Attributes.Add("Id"' feedItem.Id);  							foreach(var val in attributes)  								if(!graphic.Attributes.ContainsKey(val.Key))  								graphic.Attributes.Add(val.Key' val.Value);  							  							// Add attribute GeometryType used by renderer  							string gt = null;  							if (g is MapPoint)  								gt = "point";  							else if (g is Polyline)  								gt = "line";  							else if (g is Polygon || g is Envelope)  								gt = "polygon";  							if (gt != null)  								graphic.Attributes.Add(GeometryTypeAttribute' gt);  							graphics.Add(graphic);  						}  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result)  			{  				SyndicationFeed feed;  				List<SyndicationItem> feedItems = new List<SyndicationItem>();    				using (XmlReader reader = XmlReader.Create(s))  				{  					feed = SyndicationFeed.Load(reader);  					foreach (SyndicationItem feedItem in feed.Items)  					{  						SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;    						string slong = "";  						string slat = "";  						Geometry.Geometry g = null;  						IDictionary<string' object> attributes = new Dictionary<string'object>();  						foreach (SyndicationElementExtension ee in ec)  						{  							if (ee.OuterNamespace.Equals(_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								//This is not part of the georss-simple spec' but this makes it support a common  								//use-case with geo:lat/geo:long coordinate pairs' as described at  								//http://www.w3.org/2003/01/geo/  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("lat"):  										{  											slat = xr.ReadElementContentAsString();  											break;  										}  									case ("long"):  										{  											slong = xr.ReadElementContentAsString();  											break;  										}  									case ("Point"):  										{  											XmlReader xmlPoint = xr.ReadSubtree();  											while (xmlPoint.Read())  											{  												if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slat = xmlPoint.ReadElementContentAsString();  												}  												else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slong = xmlPoint.ReadElementContentAsString();  												}  											}  											break;  										}  								}  							}  							else if (ee.OuterNamespace.Equals(_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("point"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											slong = sxsy[1];  											slat = sxsy[0];  											break;  										}  									case ("line"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polyline line = new Polyline() { SpatialReference = new SpatialReference(4326) };  												line.Paths.Add(pnts);  												g = line;  											}  											break;  										}  									case ("polygon"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polygon line = new Polygon() { SpatialReference = new SpatialReference(4326) };  												line.Rings.Add(pnts);  												g = line;  											}  											break;  										}  									case ("box"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null && pnts.Count == 2)  											{  												g = new Envelope(pnts[0]' pnts[1]) { SpatialReference = new SpatialReference(4326) };  											}  											break;  										}  									case ("circle"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											if (sxsy.Length == 3)  											{  												double x = double.NaN' y = double.NaN' r = double.NaN;  												string stX = sxsy[1];  												string stY = sxsy[0];  												string stR = sxsy[2];  												if (double.TryParse(stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  													double.TryParse(stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) &&  													double.TryParse(stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r))  												{  													g = GetRadiusAsPolygonGeodesic(new MapPoint(x' y)' r' 360);  												}  											}  											break;  										}    									case ("where"): //GeoRSS-GML  										{  											//GML geometry parsing goes here. However this is not  											//part of GeoRSS-simple and not supported for this datasource  											//We'll just ignore these entries  											break;  										}  									#region Attributes  									case ("elev"):  										{  											string sp = xr.ReadElementContentAsString();  											double elevation = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  												attributes.Add("elev"' elevation);  											break;  										}  									case ("floor"):  										{  											string sp = xr.ReadElementContentAsString();  											int floor = 0;  											if (int.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  												attributes.Add("floor"' floor);  											break;  										}  									case ("radius"):  										{  											string sp = xr.ReadElementContentAsString();  											double radius = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  												attributes.Add("radius"' radius);  											break;  										}  									//case ("featuretypetag"):  									//case ("relationshiptag"):  									//case ("featurename"):  									default:  										{  											string sp = xr.ReadElementContentAsString();  											attributes.Add(ee.OuterName' sp);  											break;  										}  									#endregion  								}  							}  						}    						if (!string.IsNullOrEmpty(slong) && !string.IsNullOrEmpty(slat))  						{  							double x = double.NaN;  							double y = double.NaN;  							if (double.TryParse(slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  								double.TryParse(slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  								g = new MapPoint(x' y' new SpatialReference(4326));  						}  						if (g != null)  						{  							Graphic graphic = new Graphic() { Geometry = g };  							  							if(feedItem.Title != null)  								graphic.Attributes.Add("Title"' feedItem.Title.Text);  							if (feedItem.Summary != null)  								graphic.Attributes.Add("Summary"' feedItem.Summary.Text);  							if (feedItem.PublishDate != null)  							{  								graphic.Attributes.Add("PublishDate"' feedItem.PublishDate);  								graphic.TimeExtent = new TimeExtent(feedItem.PublishDate.DateTime);  							}  							if (feedItem.Links.Count > 0)  								graphic.Attributes.Add("Link"' feedItem.Links[0].Uri);  							graphic.Attributes.Add("FeedItem"' feedItem);  							graphic.Attributes.Add("Id"' feedItem.Id);  							foreach(var val in attributes)  								if(!graphic.Attributes.ContainsKey(val.Key))  								graphic.Attributes.Add(val.Key' val.Value);  							  							// Add attribute GeometryType used by renderer  							string gt = null;  							if (g is MapPoint)  								gt = "point";  							else if (g is Polyline)  								gt = "line";  							else if (g is Polygon || g is Envelope)  								gt = "polygon";  							if (gt != null)  								graphic.Attributes.Add(GeometryTypeAttribute' gt);  							graphics.Add(graphic);  						}  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result)  			{  				SyndicationFeed feed;  				List<SyndicationItem> feedItems = new List<SyndicationItem>();    				using (XmlReader reader = XmlReader.Create(s))  				{  					feed = SyndicationFeed.Load(reader);  					foreach (SyndicationItem feedItem in feed.Items)  					{  						SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;    						string slong = "";  						string slat = "";  						Geometry.Geometry g = null;  						IDictionary<string' object> attributes = new Dictionary<string'object>();  						foreach (SyndicationElementExtension ee in ec)  						{  							if (ee.OuterNamespace.Equals(_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								//This is not part of the georss-simple spec' but this makes it support a common  								//use-case with geo:lat/geo:long coordinate pairs' as described at  								//http://www.w3.org/2003/01/geo/  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("lat"):  										{  											slat = xr.ReadElementContentAsString();  											break;  										}  									case ("long"):  										{  											slong = xr.ReadElementContentAsString();  											break;  										}  									case ("Point"):  										{  											XmlReader xmlPoint = xr.ReadSubtree();  											while (xmlPoint.Read())  											{  												if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slat = xmlPoint.ReadElementContentAsString();  												}  												else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slong = xmlPoint.ReadElementContentAsString();  												}  											}  											break;  										}  								}  							}  							else if (ee.OuterNamespace.Equals(_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("point"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											slong = sxsy[1];  											slat = sxsy[0];  											break;  										}  									case ("line"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polyline line = new Polyline() { SpatialReference = new SpatialReference(4326) };  												line.Paths.Add(pnts);  												g = line;  											}  											break;  										}  									case ("polygon"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polygon line = new Polygon() { SpatialReference = new SpatialReference(4326) };  												line.Rings.Add(pnts);  												g = line;  											}  											break;  										}  									case ("box"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null && pnts.Count == 2)  											{  												g = new Envelope(pnts[0]' pnts[1]) { SpatialReference = new SpatialReference(4326) };  											}  											break;  										}  									case ("circle"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											if (sxsy.Length == 3)  											{  												double x = double.NaN' y = double.NaN' r = double.NaN;  												string stX = sxsy[1];  												string stY = sxsy[0];  												string stR = sxsy[2];  												if (double.TryParse(stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  													double.TryParse(stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) &&  													double.TryParse(stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r))  												{  													g = GetRadiusAsPolygonGeodesic(new MapPoint(x' y)' r' 360);  												}  											}  											break;  										}    									case ("where"): //GeoRSS-GML  										{  											//GML geometry parsing goes here. However this is not  											//part of GeoRSS-simple and not supported for this datasource  											//We'll just ignore these entries  											break;  										}  									#region Attributes  									case ("elev"):  										{  											string sp = xr.ReadElementContentAsString();  											double elevation = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  												attributes.Add("elev"' elevation);  											break;  										}  									case ("floor"):  										{  											string sp = xr.ReadElementContentAsString();  											int floor = 0;  											if (int.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  												attributes.Add("floor"' floor);  											break;  										}  									case ("radius"):  										{  											string sp = xr.ReadElementContentAsString();  											double radius = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  												attributes.Add("radius"' radius);  											break;  										}  									//case ("featuretypetag"):  									//case ("relationshiptag"):  									//case ("featurename"):  									default:  										{  											string sp = xr.ReadElementContentAsString();  											attributes.Add(ee.OuterName' sp);  											break;  										}  									#endregion  								}  							}  						}    						if (!string.IsNullOrEmpty(slong) && !string.IsNullOrEmpty(slat))  						{  							double x = double.NaN;  							double y = double.NaN;  							if (double.TryParse(slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  								double.TryParse(slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  								g = new MapPoint(x' y' new SpatialReference(4326));  						}  						if (g != null)  						{  							Graphic graphic = new Graphic() { Geometry = g };  							  							if(feedItem.Title != null)  								graphic.Attributes.Add("Title"' feedItem.Title.Text);  							if (feedItem.Summary != null)  								graphic.Attributes.Add("Summary"' feedItem.Summary.Text);  							if (feedItem.PublishDate != null)  							{  								graphic.Attributes.Add("PublishDate"' feedItem.PublishDate);  								graphic.TimeExtent = new TimeExtent(feedItem.PublishDate.DateTime);  							}  							if (feedItem.Links.Count > 0)  								graphic.Attributes.Add("Link"' feedItem.Links[0].Uri);  							graphic.Attributes.Add("FeedItem"' feedItem);  							graphic.Attributes.Add("Id"' feedItem.Id);  							foreach(var val in attributes)  								if(!graphic.Attributes.ContainsKey(val.Key))  								graphic.Attributes.Add(val.Key' val.Value);  							  							// Add attribute GeometryType used by renderer  							string gt = null;  							if (g is MapPoint)  								gt = "point";  							else if (g is Polyline)  								gt = "line";  							else if (g is Polygon || g is Envelope)  								gt = "polygon";  							if (gt != null)  								graphic.Attributes.Add(GeometryTypeAttribute' gt);  							graphics.Add(graphic);  						}  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following statement contains a magic number: using (Stream s = e.Result)  			{  				SyndicationFeed feed;  				List<SyndicationItem> feedItems = new List<SyndicationItem>();    				using (XmlReader reader = XmlReader.Create(s))  				{  					feed = SyndicationFeed.Load(reader);  					foreach (SyndicationItem feedItem in feed.Items)  					{  						SyndicationElementExtensionCollection ec = feedItem.ElementExtensions;    						string slong = "";  						string slat = "";  						Geometry.Geometry g = null;  						IDictionary<string' object> attributes = new Dictionary<string'object>();  						foreach (SyndicationElementExtension ee in ec)  						{  							if (ee.OuterNamespace.Equals(_W3CGEONAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								//This is not part of the georss-simple spec' but this makes it support a common  								//use-case with geo:lat/geo:long coordinate pairs' as described at  								//http://www.w3.org/2003/01/geo/  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("lat"):  										{  											slat = xr.ReadElementContentAsString();  											break;  										}  									case ("long"):  										{  											slong = xr.ReadElementContentAsString();  											break;  										}  									case ("Point"):  										{  											XmlReader xmlPoint = xr.ReadSubtree();  											while (xmlPoint.Read())  											{  												if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slat = xmlPoint.ReadElementContentAsString();  												}  												else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slong = xmlPoint.ReadElementContentAsString();  												}  											}  											break;  										}  								}  							}  							else if (ee.OuterNamespace.Equals(_GEORSSNAMESPACE_' StringComparison.OrdinalIgnoreCase))  							{  								XmlReader xr = ee.GetReader();  								switch (ee.OuterName)  								{  									case ("point"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											slong = sxsy[1];  											slat = sxsy[0];  											break;  										}  									case ("line"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polyline line = new Polyline() { SpatialReference = new SpatialReference(4326) };  												line.Paths.Add(pnts);  												g = line;  											}  											break;  										}  									case ("polygon"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null)  											{  												Polygon line = new Polygon() { SpatialReference = new SpatialReference(4326) };  												line.Rings.Add(pnts);  												g = line;  											}  											break;  										}  									case ("box"):  										{  											string sp = xr.ReadElementContentAsString();  											PointCollection pnts = StringToPoints(sp);  											if (pnts != null && pnts.Count == 2)  											{  												g = new Envelope(pnts[0]' pnts[1]) { SpatialReference = new SpatialReference(4326) };  											}  											break;  										}  									case ("circle"):  										{  											string sp = xr.ReadElementContentAsString();  											string[] sxsy = sp.Split(new char[] { ' ' });  											if (sxsy.Length == 3)  											{  												double x = double.NaN' y = double.NaN' r = double.NaN;  												string stX = sxsy[1];  												string stY = sxsy[0];  												string stR = sxsy[2];  												if (double.TryParse(stY' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  													double.TryParse(stX' NumberStyles.Any' CultureInfo.InvariantCulture' out x) &&  													double.TryParse(stR' NumberStyles.Any' CultureInfo.InvariantCulture' out r))  												{  													g = GetRadiusAsPolygonGeodesic(new MapPoint(x' y)' r' 360);  												}  											}  											break;  										}    									case ("where"): //GeoRSS-GML  										{  											//GML geometry parsing goes here. However this is not  											//part of GeoRSS-simple and not supported for this datasource  											//We'll just ignore these entries  											break;  										}  									#region Attributes  									case ("elev"):  										{  											string sp = xr.ReadElementContentAsString();  											double elevation = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out elevation))  												attributes.Add("elev"' elevation);  											break;  										}  									case ("floor"):  										{  											string sp = xr.ReadElementContentAsString();  											int floor = 0;  											if (int.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out floor))  												attributes.Add("floor"' floor);  											break;  										}  									case ("radius"):  										{  											string sp = xr.ReadElementContentAsString();  											double radius = 0;  											if (double.TryParse(sp' NumberStyles.Any' CultureInfo.InvariantCulture' out radius))  												attributes.Add("radius"' radius);  											break;  										}  									//case ("featuretypetag"):  									//case ("relationshiptag"):  									//case ("featurename"):  									default:  										{  											string sp = xr.ReadElementContentAsString();  											attributes.Add(ee.OuterName' sp);  											break;  										}  									#endregion  								}  							}  						}    						if (!string.IsNullOrEmpty(slong) && !string.IsNullOrEmpty(slat))  						{  							double x = double.NaN;  							double y = double.NaN;  							if (double.TryParse(slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  								double.TryParse(slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  								g = new MapPoint(x' y' new SpatialReference(4326));  						}  						if (g != null)  						{  							Graphic graphic = new Graphic() { Geometry = g };  							  							if(feedItem.Title != null)  								graphic.Attributes.Add("Title"' feedItem.Title.Text);  							if (feedItem.Summary != null)  								graphic.Attributes.Add("Summary"' feedItem.Summary.Text);  							if (feedItem.PublishDate != null)  							{  								graphic.Attributes.Add("PublishDate"' feedItem.PublishDate);  								graphic.TimeExtent = new TimeExtent(feedItem.PublishDate.DateTime);  							}  							if (feedItem.Links.Count > 0)  								graphic.Attributes.Add("Link"' feedItem.Links[0].Uri);  							graphic.Attributes.Add("FeedItem"' feedItem);  							graphic.Attributes.Add("Id"' feedItem.Id);  							foreach(var val in attributes)  								if(!graphic.Attributes.ContainsKey(val.Key))  								graphic.Attributes.Add(val.Key' val.Value);  							  							// Add attribute GeometryType used by renderer  							string gt = null;  							if (g is MapPoint)  								gt = "point";  							else if (g is Polyline)  								gt = "line";  							else if (g is Polygon || g is Envelope)  								gt = "polygon";  							if (gt != null)  								graphic.Attributes.Add(GeometryTypeAttribute' gt);  							graphics.Add(graphic);  						}  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,StringToPoints,The following statement contains a magic number: for (int i = 0; i < sxsy.Length - 1; i+=2)  			{  				string slat = sxsy[i];  				string slong = sxsy[i + 1];  				double x = double.NaN;  				double y = double.NaN;  				if (double.TryParse(slat' NumberStyles.Any' CultureInfo.InvariantCulture' out y) &&  					double.TryParse(slong' NumberStyles.Any' CultureInfo.InvariantCulture' out x))  					pnts.Add(new MapPoint(x' y));  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: Polygon poly = new Polygon() { SpatialReference = new SpatialReference(4326) };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (line.Paths.Count > 1)  			{  				PointCollection ring = line.Paths[0];  				MapPoint last = ring[ring.Count - 1];  				for (int i = 1; i < line.Paths.Count; i++)  				{  					PointCollection pnts = line.Paths[i];  					ring.Add(new MapPoint(180 * Math.Sign(last.X)' 90 * Math.Sign(center.Y)));  					last = pnts[0];  					ring.Add(new MapPoint(180 * Math.Sign(last.X)' 90 * Math.Sign(center.Y)));  					foreach (MapPoint p in pnts)  						ring.Add(p);  					last = pnts[pnts.Count - 1];  				}  				poly.Rings.Add(ring);  			}  			else  			{  				poly.Rings.Add(line.Paths[0]);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (line.Paths.Count > 1)  			{  				PointCollection ring = line.Paths[0];  				MapPoint last = ring[ring.Count - 1];  				for (int i = 1; i < line.Paths.Count; i++)  				{  					PointCollection pnts = line.Paths[i];  					ring.Add(new MapPoint(180 * Math.Sign(last.X)' 90 * Math.Sign(center.Y)));  					last = pnts[0];  					ring.Add(new MapPoint(180 * Math.Sign(last.X)' 90 * Math.Sign(center.Y)));  					foreach (MapPoint p in pnts)  						ring.Add(p);  					last = pnts[pnts.Count - 1];  				}  				poly.Rings.Add(ring);  			}  			else  			{  				poly.Rings.Add(line.Paths[0]);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (line.Paths.Count > 1)  			{  				PointCollection ring = line.Paths[0];  				MapPoint last = ring[ring.Count - 1];  				for (int i = 1; i < line.Paths.Count; i++)  				{  					PointCollection pnts = line.Paths[i];  					ring.Add(new MapPoint(180 * Math.Sign(last.X)' 90 * Math.Sign(center.Y)));  					last = pnts[0];  					ring.Add(new MapPoint(180 * Math.Sign(last.X)' 90 * Math.Sign(center.Y)));  					foreach (MapPoint p in pnts)  						ring.Add(p);  					last = pnts[pnts.Count - 1];  				}  				poly.Rings.Add(ring);  			}  			else  			{  				poly.Rings.Add(line.Paths[0]);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (line.Paths.Count > 1)  			{  				PointCollection ring = line.Paths[0];  				MapPoint last = ring[ring.Count - 1];  				for (int i = 1; i < line.Paths.Count; i++)  				{  					PointCollection pnts = line.Paths[i];  					ring.Add(new MapPoint(180 * Math.Sign(last.X)' 90 * Math.Sign(center.Y)));  					last = pnts[0];  					ring.Add(new MapPoint(180 * Math.Sign(last.X)' 90 * Math.Sign(center.Y)));  					foreach (MapPoint p in pnts)  						ring.Add(p);  					last = pnts[pnts.Count - 1];  				}  				poly.Rings.Add(ring);  			}  			else  			{  				poly.Rings.Add(line.Paths[0]);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2)  			{  				PointCollection pnts = new PointCollection();  				pnts.Add(new MapPoint(-180' -90));  				pnts.Add(new MapPoint(180' -90));  				pnts.Add(new MapPoint(180' 90));  				pnts.Add(new MapPoint(-180' 90));  				pnts.Add(new MapPoint(-180' -90));  				poly.Rings.Add(pnts); //Exterior  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2)  			{  				PointCollection pnts = new PointCollection();  				pnts.Add(new MapPoint(-180' -90));  				pnts.Add(new MapPoint(180' -90));  				pnts.Add(new MapPoint(180' 90));  				pnts.Add(new MapPoint(-180' 90));  				pnts.Add(new MapPoint(-180' -90));  				poly.Rings.Add(pnts); //Exterior  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2)  			{  				PointCollection pnts = new PointCollection();  				pnts.Add(new MapPoint(-180' -90));  				pnts.Add(new MapPoint(180' -90));  				pnts.Add(new MapPoint(180' 90));  				pnts.Add(new MapPoint(-180' 90));  				pnts.Add(new MapPoint(-180' -90));  				poly.Rings.Add(pnts); //Exterior  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2)  			{  				PointCollection pnts = new PointCollection();  				pnts.Add(new MapPoint(-180' -90));  				pnts.Add(new MapPoint(180' -90));  				pnts.Add(new MapPoint(180' 90));  				pnts.Add(new MapPoint(-180' 90));  				pnts.Add(new MapPoint(-180' -90));  				poly.Rings.Add(pnts); //Exterior  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2)  			{  				PointCollection pnts = new PointCollection();  				pnts.Add(new MapPoint(-180' -90));  				pnts.Add(new MapPoint(180' -90));  				pnts.Add(new MapPoint(180' 90));  				pnts.Add(new MapPoint(-180' 90));  				pnts.Add(new MapPoint(-180' -90));  				poly.Rings.Add(pnts); //Exterior  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2)  			{  				PointCollection pnts = new PointCollection();  				pnts.Add(new MapPoint(-180' -90));  				pnts.Add(new MapPoint(180' -90));  				pnts.Add(new MapPoint(180' 90));  				pnts.Add(new MapPoint(-180' 90));  				pnts.Add(new MapPoint(-180' -90));  				poly.Rings.Add(pnts); //Exterior  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2)  			{  				PointCollection pnts = new PointCollection();  				pnts.Add(new MapPoint(-180' -90));  				pnts.Add(new MapPoint(180' -90));  				pnts.Add(new MapPoint(180' 90));  				pnts.Add(new MapPoint(-180' 90));  				pnts.Add(new MapPoint(-180' -90));  				poly.Rings.Add(pnts); //Exterior  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2)  			{  				PointCollection pnts = new PointCollection();  				pnts.Add(new MapPoint(-180' -90));  				pnts.Add(new MapPoint(180' -90));  				pnts.Add(new MapPoint(180' 90));  				pnts.Add(new MapPoint(-180' 90));  				pnts.Add(new MapPoint(-180' -90));  				poly.Rings.Add(pnts); //Exterior  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2)  			{  				PointCollection pnts = new PointCollection();  				pnts.Add(new MapPoint(-180' -90));  				pnts.Add(new MapPoint(180' -90));  				pnts.Add(new MapPoint(180' 90));  				pnts.Add(new MapPoint(-180' 90));  				pnts.Add(new MapPoint(-180' -90));  				poly.Rings.Add(pnts); //Exterior  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2)  			{  				PointCollection pnts = new PointCollection();  				pnts.Add(new MapPoint(-180' -90));  				pnts.Add(new MapPoint(180' -90));  				pnts.Add(new MapPoint(180' 90));  				pnts.Add(new MapPoint(-180' 90));  				pnts.Add(new MapPoint(-180' -90));  				poly.Rings.Add(pnts); //Exterior  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2)  			{  				PointCollection pnts = new PointCollection();  				pnts.Add(new MapPoint(-180' -90));  				pnts.Add(new MapPoint(180' -90));  				pnts.Add(new MapPoint(180' 90));  				pnts.Add(new MapPoint(-180' 90));  				pnts.Add(new MapPoint(-180' -90));  				poly.Rings.Add(pnts); //Exterior  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusAsPolygonGeodesic,The following statement contains a magic number: if (distance > _EARTHCIRCUMFERENCE_ * Math.PI / 2 && line.Paths.Count != 2)  			{  				PointCollection pnts = new PointCollection();  				pnts.Add(new MapPoint(-180' -90));  				pnts.Add(new MapPoint(180' -90));  				pnts.Add(new MapPoint(180' 90));  				pnts.Add(new MapPoint(-180' 90));  				pnts.Add(new MapPoint(-180' -90));  				poly.Rings.Add(pnts); //Exterior  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: Polyline line = new Polyline() { SpatialReference = new SpatialReference(4326) };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: for (int i = 0; i < pointCount; i++)  			{  				//double angle = i / 180.0 * Math.PI;  				MapPoint p = GetPointFromHeadingGeodesic(center' distance' i);  				if (pnts.Count > 0)  				{  					MapPoint lastPoint = pnts[pnts.Count - 1];  					int sign = Math.Sign(p.X);  					if (Math.Abs(p.X - lastPoint.X) > 180)  					{   //We crossed the date line  						double lat = LatitudeAtLongitude(lastPoint' p' sign * -180);  						pnts.Add(new MapPoint(sign * -180' lat));  						pnts = new PointCollection();  						line.Paths.Add(pnts);  						pnts.Add(new MapPoint(sign * 180' lat));  					}  				}  				pnts.Add(p);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: for (int i = 0; i < pointCount; i++)  			{  				//double angle = i / 180.0 * Math.PI;  				MapPoint p = GetPointFromHeadingGeodesic(center' distance' i);  				if (pnts.Count > 0)  				{  					MapPoint lastPoint = pnts[pnts.Count - 1];  					int sign = Math.Sign(p.X);  					if (Math.Abs(p.X - lastPoint.X) > 180)  					{   //We crossed the date line  						double lat = LatitudeAtLongitude(lastPoint' p' sign * -180);  						pnts.Add(new MapPoint(sign * -180' lat));  						pnts = new PointCollection();  						line.Paths.Add(pnts);  						pnts.Add(new MapPoint(sign * 180' lat));  					}  				}  				pnts.Add(p);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: for (int i = 0; i < pointCount; i++)  			{  				//double angle = i / 180.0 * Math.PI;  				MapPoint p = GetPointFromHeadingGeodesic(center' distance' i);  				if (pnts.Count > 0)  				{  					MapPoint lastPoint = pnts[pnts.Count - 1];  					int sign = Math.Sign(p.X);  					if (Math.Abs(p.X - lastPoint.X) > 180)  					{   //We crossed the date line  						double lat = LatitudeAtLongitude(lastPoint' p' sign * -180);  						pnts.Add(new MapPoint(sign * -180' lat));  						pnts = new PointCollection();  						line.Paths.Add(pnts);  						pnts.Add(new MapPoint(sign * 180' lat));  					}  				}  				pnts.Add(p);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetRadiusGeodesicAsPolyline,The following statement contains a magic number: for (int i = 0; i < pointCount; i++)  			{  				//double angle = i / 180.0 * Math.PI;  				MapPoint p = GetPointFromHeadingGeodesic(center' distance' i);  				if (pnts.Count > 0)  				{  					MapPoint lastPoint = pnts[pnts.Count - 1];  					int sign = Math.Sign(p.X);  					if (Math.Abs(p.X - lastPoint.X) > 180)  					{   //We crossed the date line  						double lat = LatitudeAtLongitude(lastPoint' p' sign * -180);  						pnts.Add(new MapPoint(sign * -180' lat));  						pnts = new PointCollection();  						line.Paths.Add(pnts);  						pnts.Add(new MapPoint(sign * 180' lat));  					}  				}  				pnts.Add(p);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: double lon1 = p1.X / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: double lon2 = p2.X / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: double lat1 = p1.Y / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: double lat2 = p2.Y / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: lon = lon / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,LatitudeAtLongitude,The following statement contains a magic number: return Math.Atan((Math.Sin(lat1) * Math.Cos(lat2) * Math.Sin(lon - lon2)  	 - Math.Sin(lat2) * Math.Cos(lat1) * Math.Sin(lon - lon1)) / (Math.Cos(lat1) * Math.Cos(lat2) * Math.Sin(lon1 - lon2)))  			/ Math.PI * 180;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: double brng = heading / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: double lon1 = start.X / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: double lat1 = start.Y / 180 * Math.PI;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: double dR = distance / 6378137;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: double lon = lon2 / Math.PI * 180;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: double lat = lat2 / Math.PI * 180;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lon < -180) lon += 360;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lon < -180) lon += 360;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lat < -90) lat += 180;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lat < -90) lat += 180;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lon > 180) lon -= 360;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lon > 180) lon -= 360;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lat > 90) lat -= 180;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,GetPointFromHeadingGeodesic,The following statement contains a magic number: while (lat > 90) lat -= 180;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: System.Windows.Media.RadialGradientBrush brush = new System.Windows.Media.RadialGradientBrush()  			{  				Center = new Point(.25' .25)'  				GradientOrigin = new Point(.25' .25)'  				RadiusX = 1'  				RadiusY = 1  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: System.Windows.Media.RadialGradientBrush brush = new System.Windows.Media.RadialGradientBrush()  			{  				Center = new Point(.25' .25)'  				GradientOrigin = new Point(.25' .25)'  				RadiusX = 1'  				RadiusY = 1  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: System.Windows.Media.RadialGradientBrush brush = new System.Windows.Media.RadialGradientBrush()  			{  				Center = new Point(.25' .25)'  				GradientOrigin = new Point(.25' .25)'  				RadiusX = 1'  				RadiusY = 1  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: System.Windows.Media.RadialGradientBrush brush = new System.Windows.Media.RadialGradientBrush()  			{  				Center = new Point(.25' .25)'  				GradientOrigin = new Point(.25' .25)'  				RadiusX = 1'  				RadiusY = 1  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: AccuracyCircleSymbol = new SimpleFillSymbol() {  					BorderBrush = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(90' 255' 255' 255))'  					Fill = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromArgb(20' 65' 76' 249))'  					BorderThickness = 3  				};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: animationTimerLocation.Interval = TimeSpan.FromMilliseconds(33);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GpsLayer,The following statement contains a magic number: animationTimerAccuracy.Interval = TimeSpan.FromMilliseconds(33);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,TryStartGps,The following statement contains a magic number: if (permission && Visible && Map != null && IsEnabled && GeoPositionWatcher != null)                  result = GeoPositionWatcher.TryStart(true' TimeSpan.FromSeconds(10));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateAccuracyCircle,The following statement contains a magic number: if (Map != null && !double.IsNaN(Map.Resolution))  			{  				var c = accuracyCircle.Geometry as Circle;  				if (GeoCoordinate == null || double.IsNaN(GeoCoordinate.HorizontalAccuracy) || GeoCoordinate.HorizontalAccuracy < 15)  				{  					c.Radius = double.NaN;  					c.UpdateRing();  				}  				else  				{  					double size = GetAccuracyInMapUnits();  					if (c.Radius != size)  					{  						if (location.Geometry != null)  						{  							animateRadiusFrom = double.IsNaN(c.Radius) ? 0 : c.Radius;  							animateRadiusTo = size;  							if (AnimateUpdates)  							{  								animateAccuracyStartTime = DateTime.Now;  								animationTimerAccuracy.Start();  							}  							else   							{  								c.Radius = size;  								c.UpdateRing();  							}  						}  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateLocation,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null && GeoCoordinate != GeoCoordinate.Unknown )  			{  				MapPoint newLocation = new ESRI.ArcGIS.Client.Geometry.MapPoint(GeoCoordinate.Longitude' GeoCoordinate.Latitude) { SpatialReference = new SpatialReference(4326) };  				if (!Map.SpatialReference.Equals(newLocation.SpatialReference))  				{  					if (WebMercatorSR.Equals(Map.SpatialReference))  						newLocation = merc.FromGeographic(newLocation) as MapPoint;  					else  					{  						if (ProjectionService != null)  						{  							if (!ProjectionService.IsBusy)  							{  								var geom = newLocation;  								EventHandler<Tasks.GraphicsEventArgs> handler = null;  								handler = (a' b) =>  									{  										(a as IProjectionService).ProjectCompleted -= handler;  										if (b.Results != null && b.Results.Count > 0 && b.Results[0].Geometry is MapPoint)  											BeginAnimateLocation(b.Results[0].Geometry as MapPoint);  									};  								ProjectionService.ProjectCompleted += handler;  								ProjectionService.ProjectAsync(new Graphic[] { new Graphic() { Geometry = geom } }' Map.SpatialReference);  							}  							else  							{  								EventHandler<Tasks.GraphicsEventArgs> handler = null;  								handler = (a' b) =>  									{  										ProjectionService.ProjectCompleted -= handler;  										UpdateLocation(); //Try again  									};  								ProjectionService.ProjectCompleted += handler; //Wait for task to complete  							}  						}  						return; //Wait for projection to complete  					}  				}  				BeginAnimateLocation(newLocation);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnits,The following statement contains a magic number: if (Map != null && Map.SpatialReference != null && GeoCoordinate != null)  			{  				//From MSDN doc on GeoCoordinate.HorizontalAccuracy:   				//The accuracy of the latitude and longitude' in meters.  				//The accuracy can be considered the radius of certainty of the   				//latitude and longitude data. A circular area that is formed   				//with the accuracy as the radius and the latitude and longitude  				//coordinates as the center contains the actual location.  				double acc = GeoCoordinate.HorizontalAccuracy;  				string unit = GetMapUnits();  				switch(unit)  				{  					case "esriDecimalDegrees":  						double brng = 0;  						double lon1 = GeoCoordinate.Longitude / 180 * Math.PI;  						double lat1 = GeoCoordinate.Latitude / 180 * Math.PI;  						double dR = acc / 6378137; //Angular distance in radians  						double lat2 = Math.Asin(Math.Sin(lat1) * Math.Cos(dR) + Math.Cos(lat1) * Math.Sin(dR) * Math.Cos(brng));  						double lat = lat2 / Math.PI * 180;  						while (lat < -90) lat += 180;  						while (lat > 90) lat -= 180;  						return Math.Abs(lat - GeoCoordinate.Latitude);  					case "esriMeters":  						return acc;  					case "esriMillimeters":  						return acc * 1000;  					case "esriCentimeters":  						return acc * 100;  					case "esriDecimeters":  						return acc * 10;  					case "esriKilometers":  						return acc * 0.001;  					case "esriInches":  						return acc * 39.3700787;  					case "esriFeet":  						return acc * 3.2808399;  					case "esriYards":  						return acc * 1.0936133;  					case "esriMiles":  						return acc * 0.000621371192;  					case "esriNauticalMiles":  						return acc * 0.000539956803;  					default:  						return GetAccuracyInMapUnitsFromScale();  				}  			}  			else return double.NaN;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnitsFromScale,The following statement contains a magic number: if (!double.IsNaN(scale) && !double.IsNaN(resolution) && !double.IsNaN(acc) )  			{  				var resInMeters = (96 * resolution) / scale * 39.3700787;  				return resInMeters * acc;  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetAccuracyInMapUnitsFromScale,The following statement contains a magic number: if (!double.IsNaN(scale) && !double.IsNaN(resolution) && !double.IsNaN(acc) )  			{  				var resInMeters = (96 * resolution) / scale * 39.3700787;  				return resInMeters * acc;  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetMapUnits,The following statement contains a magic number: if (Map.SpatialReference.WKID == 4326) return "esriDecimalDegrees";
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,GetMapUnits,The following statement contains a magic number: if (Map.SpatialReference.Equals(new SpatialReference(102100))) return "esriMeters";
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,Circle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,Circle,The following statement contains a magic number: PointCount = 90;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,Circle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateRing,The following statement contains a magic number: if (!double.IsNaN(Radius) && Radius > 0 && Center != null && PointCount > 2)  				{  					PointCollection pnts = new PointCollection();  					for (int i = PointCount; i >= 0; i--)  					{  						double rad = 2 * Math.PI / PointCount * i;  						double x = Math.Cos(rad) * Radius + Center.X;  						double y = Math.Sin(rad) * Radius + Center.Y;  						pnts.Add(new MapPoint(x' y));  					}  					if (Rings.Count == 0)  						Rings.Add(pnts);  					else  						Rings[0] = pnts;  				}  				else                      Rings.Clear();
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,Circle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,UpdateRing,The following statement contains a magic number: if (!double.IsNaN(Radius) && Radius > 0 && Center != null && PointCount > 2)  				{  					PointCollection pnts = new PointCollection();  					for (int i = PointCount; i >= 0; i--)  					{  						double rad = 2 * Math.PI / PointCount * i;  						double x = Math.Cos(rad) * Radius + Center.X;  						double y = Math.Sin(rad) * Radius + Center.Y;  						pnts.Add(new MapPoint(x' y));  					}  					if (Rings.Count == 0)  						Rings.Add(pnts);  					else  						Rings[0] = pnts;  				}  				else                      Rings.Clear();
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,HeatMapLayer,The following statement contains a magic number: stops.Add(new GradientStop() { Color = Colors.Blue' Offset = .5 });
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,HeatMapLayer,The following statement contains a magic number: stops.Add(new GradientStop() { Color = Colors.Red' Offset = .75 });
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,HeatMapLayer,The following statement contains a magic number: stops.Add(new GradientStop() { Color = Colors.Yellow' Offset = .8 });
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,OnIntensityPropertyChanged,The following statement contains a magic number: if (dp.IsInitialized)  			{  				if (dp.timer == null)  				{  					dp.timer = new System.Windows.Threading.DispatcherTimer() { Interval = TimeSpan.FromMilliseconds(50) };  					dp.timer.Tick += (s' e2) =>  					{  						dp.timer.Stop();  						dp.OnLayerChanged();  					};  				}  				dp.timer.Stop();  				dp.timer.Start();  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: int height = (int)args[2];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: int size = (int)args[3];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: List<ThreadSafeGradientStop> stops = (List<ThreadSafeGradientStop>)args[4];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: List<HeatPoint> points = (List<HeatPoint>)args[5];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: OnImageComplete onComplete = (OnImageComplete)args[6];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: size = size * 2 + 1;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: if (max < 2) max = 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: if (max < 2) max = 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: for (int idx = 0; idx < height; idx++)      // Height (y)  			{  #if SILVERLIGHT  				int rowstart = ei.GetRowStart(idx);  #endif  				for (int jdx = 0; jdx < width; jdx++)     // Width (x)  				{  					Color c = InterpolateColor(output[idx * width + jdx] / (float)max' stops);  #if SILVERLIGHT  					ei.SetPixelAtRowStart(jdx' rowstart' c.R' c.G' c.B' c.A);  #else  					int color = (c.A << 24) + (c.R << 16) + (c.G << 8) + c.B;  					pixels[idx * width + jdx] = color;  #endif			  				}  				if (worker.CancellationPending)  				{  					e.Cancel = true;  					e.Result = null;  					output = null;  #if SILVERLIGHT  					ei = null;  #else  					pixels = null;  #endif  					return;  				}  				//Raise the progress event for each line rendered  				worker.ReportProgress((idx + 1) * 100 / height);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: for (int idx = 0; idx < height; idx++)      // Height (y)  			{  #if SILVERLIGHT  				int rowstart = ei.GetRowStart(idx);  #endif  				for (int jdx = 0; jdx < width; jdx++)     // Width (x)  				{  					Color c = InterpolateColor(output[idx * width + jdx] / (float)max' stops);  #if SILVERLIGHT  					ei.SetPixelAtRowStart(jdx' rowstart' c.R' c.G' c.B' c.A);  #else  					int color = (c.A << 24) + (c.R << 16) + (c.G << 8) + c.B;  					pixels[idx * width + jdx] = color;  #endif			  				}  				if (worker.CancellationPending)  				{  					e.Cancel = true;  					e.Result = null;  					output = null;  #if SILVERLIGHT  					ei = null;  #else  					pixels = null;  #endif  					return;  				}  				//Raise the progress event for each line rendered  				worker.ReportProgress((idx + 1) * 100 / height);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: for (int idx = 0; idx < height; idx++)      // Height (y)  			{  #if SILVERLIGHT  				int rowstart = ei.GetRowStart(idx);  #endif  				for (int jdx = 0; jdx < width; jdx++)     // Width (x)  				{  					Color c = InterpolateColor(output[idx * width + jdx] / (float)max' stops);  #if SILVERLIGHT  					ei.SetPixelAtRowStart(jdx' rowstart' c.R' c.G' c.B' c.A);  #else  					int color = (c.A << 24) + (c.R << 16) + (c.G << 8) + c.B;  					pixels[idx * width + jdx] = color;  #endif			  				}  				if (worker.CancellationPending)  				{  					e.Cancel = true;  					e.Result = null;  					output = null;  #if SILVERLIGHT  					ei = null;  #else  					pixels = null;  #endif  					return;  				}  				//Raise the progress event for each line rendered  				worker.ReportProgress((idx + 1) * 100 / height);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_DoWork,The following statement contains a magic number: for (int idx = 0; idx < height; idx++)      // Height (y)  			{  #if SILVERLIGHT  				int rowstart = ei.GetRowStart(idx);  #endif  				for (int jdx = 0; jdx < width; jdx++)     // Width (x)  				{  					Color c = InterpolateColor(output[idx * width + jdx] / (float)max' stops);  #if SILVERLIGHT  					ei.SetPixelAtRowStart(jdx' rowstart' c.R' c.G' c.B' c.A);  #else  					int color = (c.A << 24) + (c.R << 16) + (c.G << 8) + c.B;  					pixels[idx * width + jdx] = color;  #endif			  				}  				if (worker.CancellationPending)  				{  					e.Cancel = true;  					e.Result = null;  					output = null;  #if SILVERLIGHT  					ei = null;  #else  					pixels = null;  #endif  					return;  				}  				//Raise the progress event for each line rendered  				worker.ReportProgress((idx + 1) * 100 / height);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_RunWorkerCompleted,The following statement contains a magic number: int height = (int)result[2];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_RunWorkerCompleted,The following statement contains a magic number: Envelope extent = (Envelope)result[3];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_RunWorkerCompleted,The following statement contains a magic number: OnImageComplete onComplete = (OnImageComplete)result[4];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_RunWorkerCompleted,The following statement contains a magic number: int stride = width * (pf.BitsPerPixel / 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_RunWorkerCompleted,The following statement contains a magic number: BitmapSource image = BitmapSource.Create(width' height' 96' 96' pf' palette' (int[])result[0]' stride);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,renderThread_RunWorkerCompleted,The following statement contains a magic number: BitmapSource image = BitmapSource.Create(width' height' 96' 96' pf' palette' (int[])result[0]' stride);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The following statement contains a magic number: for (int i = 0; i < size * 2 - 1; i++)  			{  				int start = (y - size + 1 + i) * width + x - size;  				for (int j = 0; j < size * 2 - 1; j++)  				{  					if (j + x - size < 0 || j + x - size >= width) continue;  					int idx = start + j;  					if (idx < 0 || idx >= intensityMap.Length)  						continue;  					intensityMap[idx] += distanceMatrix[i * (size * 2 - 1) + j];  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The following statement contains a magic number: for (int i = 0; i < size * 2 - 1; i++)  			{  				int start = (y - size + 1 + i) * width + x - size;  				for (int j = 0; j < size * 2 - 1; j++)  				{  					if (j + x - size < 0 || j + x - size >= width) continue;  					int idx = start + j;  					if (idx < 0 || idx >= intensityMap.Length)  						continue;  					intensityMap[idx] += distanceMatrix[i * (size * 2 - 1) + j];  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,AddPoint,The following statement contains a magic number: for (int i = 0; i < size * 2 - 1; i++)  			{  				int start = (y - size + 1 + i) * width + x - size;  				for (int j = 0; j < size * 2 - 1; j++)  				{  					if (j + x - size < 0 || j + x - size >= width) continue;  					int idx = start + j;  					if (idx < 0 || idx >= intensityMap.Length)  						continue;  					intensityMap[idx] += distanceMatrix[i * (size * 2 - 1) + j];  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: int width = size * 2 - 1;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: ushort[] matrix = new ushort[(int)Math.Pow(width' 2)];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: for (int i = 0; i < width; i++)  			{  				for (int j = 0; j < width; j++)  				{  					matrix[i * width + j] = (ushort)Math.Max((size - (Math.Sqrt(Math.Pow(i - size + 1' 2) + Math.Pow(j - size + 1' 2))))' 0);  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,CreateDistanceMatrix,The following statement contains a magic number: for (int i = 0; i < width; i++)  			{  				for (int j = 0; j < width; j++)  				{  					matrix[i * width + j] = (ushort)Math.Max((size - (Math.Sqrt(Math.Pow(i - size + 1' 2) + Math.Pow(j - size + 1' 2))))' 0);  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RadialGradientBrush brush = new RadialGradientBrush()  			{  				Center = new Point(0.5' 0.5)'  				RadiusX = 0.5'  				RadiusY = 0.5'  				GradientOrigin = new Point(0.5' 0.5)'  				GradientStops = new GradientStopCollection()  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RadialGradientBrush brush = new RadialGradientBrush()  			{  				Center = new Point(0.5' 0.5)'  				RadiusX = 0.5'  				RadiusY = 0.5'  				GradientOrigin = new Point(0.5' 0.5)'  				GradientStops = new GradientStopCollection()  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RadialGradientBrush brush = new RadialGradientBrush()  			{  				Center = new Point(0.5' 0.5)'  				RadiusX = 0.5'  				RadiusY = 0.5'  				GradientOrigin = new Point(0.5' 0.5)'  				GradientStops = new GradientStopCollection()  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RadialGradientBrush brush = new RadialGradientBrush()  			{  				Center = new Point(0.5' 0.5)'  				RadiusX = 0.5'  				RadiusY = 0.5'  				GradientOrigin = new Point(0.5' 0.5)'  				GradientStops = new GradientStopCollection()  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RadialGradientBrush brush = new RadialGradientBrush()  			{  				Center = new Point(0.5' 0.5)'  				RadiusX = 0.5'  				RadiusY = 0.5'  				GradientOrigin = new Point(0.5' 0.5)'  				GradientStops = new GradientStopCollection()  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RadialGradientBrush brush = new RadialGradientBrush()  			{  				Center = new Point(0.5' 0.5)'  				RadiusX = 0.5'  				RadiusY = 0.5'  				GradientOrigin = new Point(0.5' 0.5)'  				GradientStops = new GradientStopCollection()  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: Rectangle rect = new Rectangle() { Height = 20' Width = 20' Fill = brush };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: Rectangle rect = new Rectangle() { Height = 20' Width = 20' Fill = brush };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RenderTargetBitmap renderTargetBitmap = new RenderTargetBitmap(20' 20' 96' 96' PixelFormats.Pbgra32);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RenderTargetBitmap renderTargetBitmap = new RenderTargetBitmap(20' 20' 96' 96' PixelFormats.Pbgra32);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RenderTargetBitmap renderTargetBitmap = new RenderTargetBitmap(20' 20' 96' 96' PixelFormats.Pbgra32);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,HeatMapLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\HeatMap\HeatMapLayer.cs,QueryLegendInfos,The following statement contains a magic number: RenderTargetBitmap renderTargetBitmap = new RenderTargetBitmap(20' 20' 96' 96' PixelFormats.Pbgra32);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,backgroundWorker_RunWorkerCompleted,The following statement contains a magic number: if (e.Error != null)              {                  this.InitializationFailure = new ArgumentException(Properties.Resources.KmlLayer_DocumentParsingFailed);              }              else              {                  // Create graphic features from definitions -- this code requires the UI thread                  FeatureDefinition fd = (FeatureDefinition)e.Result;    				// Initialize the layer name with the name info coming from the KML document  				Name = fd.name;    				_hasRootContainer = _isRoot && fd.hasRootContainer; // the root container has been collapsed (info needed to generate internal folderIDs)    				if (_visibleLayerIds != null && !IsInitialized)  				{  					// VisibleLayerIds is set --> layer created from a web map --> check that the layer must stay visible (_hasRootContainer is set only after the file has been parsed)  					if (_hasRootContainer && !_visibleLayerIds.Contains(1)) // FolderIds 1 is the top level folder that may not be visible in SL  					{  						Visible = false;  						_isLoading = false;  						base.Initialize();  						return;  					}  				}    				// Store the parsed styles to be able to pass them to children  				_context.Styles = fd.styles;    				// Create ground overlays and add to element layer  				if (fd.groundOverlays.Any())  				{  					ElementLayer elementLayer = new ElementLayer { ID = Properties.Resources.KmlLayer_GroundOverlaysSublayer };  					fd.CreateGroundOverlays(elementLayer' _context.Images' Map);  					ChildLayers.Add(elementLayer);  					if (IsInitialized)  						elementLayer.Initialize(); // should be done by the group layer (to remove when Bug#2718 is fixed)  				}  				  				// Create graphics and add to graphics layer  				if (fd.placemarks.Any())  				{  					KmlGraphicsLayer kmlGraphicsLayer = new KmlGraphicsLayer  					{  						ID = Properties.Resources.KmlLayer_PlacemarksSublayer'  						ProjectionService = ProjectionService'  						IsHidden = _hideChildren  					};  					fd.CreateGraphics(kmlGraphicsLayer' _context.Images);  #if !WINDOWS_PHONE  					kmlGraphicsLayer.MapTip = MapTip;  #endif  					ChildLayers.Add(kmlGraphicsLayer);  					if (IsInitialized)  						kmlGraphicsLayer.Initialize(); // should be done by the group layer  (to remove when Bug#2718 is fixed)    					// Setting the Spatial Reference of the KML layer to 4326:  					if (this.SpatialReference == null)  					{  					    this.SpatialReference = new Geometry.SpatialReference(4326);  					}  				}    				// Create a sub KML layer for each container  				foreach (ContainerInfo container in fd.containers)  				{  					string fullPath = _fullPath == null ? (container.Name ?? string.Empty) : string.Concat(_fullPath' "/"' container.Name);  					// Note : use internal constructor' so properties such as MapTip' ProxyUrl' VisibleLayers.. are reported to the children  					var kmlLayer = new KmlLayer(this)  					               	{  					               		ID = container.Name'  					               		Name = container.Name'  					               		_fullPath = fullPath'  					               		RefreshInterval = TimeSpan.FromSeconds(container.RefreshInterval)'  					               		VisibleTimeExtent = container.TimeExtent'  					               		RegionInfo = container.RegionInfo'  					               		_folderId = container.FolderId'  					               		_hideChildren = container.HideChildren'  					               		IsHidden = _hideChildren  					               	};    					bool isOk = true;  					if (string.IsNullOrEmpty(container.Url))  					{  						// Set the visibility of the layer  						// There are 3 ways to define the visibility of a folder or document' by priority order:  						//    - by the internal VisibleLayerIds property (for the layers inside a web map)  						//    - by the public VisibleLayers property  						//    - by the visibility defined in the KML document  						kmlLayer.Visible = _visibleLayerIds != null ? _visibleLayerIds.Contains(kmlLayer._folderId) : IsContainerVisible(fullPath' container.Visible);  						kmlLayer._visibleLayerIds = _visibleLayerIds;    						// Subfolder : Create a context object and initialize a KmlLayer with it  						kmlLayer._context = new KmlLayerContext  						                      	{  						                      		Element = container.Element' // The XElement that the KML layer has to process  						                      		Styles = _context.Styles'  						                      		Images = _context.Images'  						                      		AtomAuthor = container.AtomAuthor'  						                      		AtomHref = container.AtomHref  						                      	};  					}  					else  					{  						// NetworkLink : initialize the Url  						Uri containerUri = GetUri(container.Url' GetBaseUri());  						if (containerUri != null)  						{  							kmlLayer.Url = containerUri;  							kmlLayer.ViewRefreshMode = container.ViewRefreshMode;  						}  						else  							isOk = false; // bad url' don't create the child layer    						// Set the visibility of the layer  						// For a network link' the internal VisibleLayerIds property is not used.  						kmlLayer.Visible = IsContainerVisible(fullPath' container.Visible);  					}    					if (isOk)  					{  						ChildLayers.Add(kmlLayer);  						if (IsInitialized)  							kmlLayer.Initialize(); // should be done by the group layer --> to remove later (after or with CR2718)  					}  				}    				// Check that the layer refresh interval is compatible with infos coming from NetworkLinkControl  				if (fd.networkLinkControl != null)  				{  					if (RefreshInterval != TimeSpan.Zero && fd.networkLinkControl.MinRefreshPeriod > 0.0)  						RefreshInterval = TimeSpan.FromSeconds(Math.Max(RefreshInterval.Seconds' fd.networkLinkControl.MinRefreshPeriod));  				}  				  				// Set resolution range from the Region/Lods info of the parent  				SetResolutionRange();    			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,IsStreamCompressed,The following statement contains a magic number: if (reader.BaseStream.Position < reader.BaseStream.Length)              {                  int headerSignature = reader.ReadInt32();                  if (headerSignature == 67324752) //PKZIP                      isCompressed = true;                    // Reset stream back to beginning                  inputStream.Seek(0' SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectGroundOverlays,The following statement contains a magic number: if (!spatialReference.Equals(new SpatialReference(102100)) && !spatialReference.Equals(new SpatialReference(4326)))  				return;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectGroundOverlays,The following statement contains a magic number: if (!spatialReference.Equals(new SpatialReference(102100)) && !spatialReference.Equals(new SpatialReference(4326)))  				return;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectGroundOverlays,The following statement contains a magic number: var webMercatorSR = new SpatialReference(102100);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectGroundOverlays,The following statement contains a magic number: var wgs84SR = new SpatialReference(4326);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebMercatorProjectionService,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,ProjectAsync,The following statement contains a magic number: if (outSpatialReference == null ||  				outSpatialReference.WKID != 4326 &&  				!outSpatialReference.Equals(MercatorSref))  			{  				//This projector doesn't support this out sref -> Return geometry untouched  				ProjectCompleted(this' new Tasks.GraphicsEventArgs(graphics.ToList()' null));  			}  			else  			{  				//Perform projection  				var result = graphics.Where(g => g != null).Select(g => new Graphic {Geometry = Project(g.Geometry' outSpatialReference)});    				ProjectCompleted(this' new Tasks.GraphicsEventArgs(result.ToList()' null));  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebMercatorProjectionService,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,Project,The following statement contains a magic number: var toMercator = outSpatialReference.WKID != 4326;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebMercatorProjectionService,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,Project,The following statement contains a magic number: if (geometry != null && geometry.SpatialReference != null &&  				!geometry.SpatialReference.Equals(outSpatialReference))  			{  				Projection.WebMercator projector = new Projection.WebMercator();  				if (toMercator && geometry.SpatialReference.WKID == 4326)  					//Data is 4326 and must projected to webmercator  					return projector.FromGeographic(geometry);  				if (!toMercator && MercatorSref.Equals(geometry.SpatialReference))  					//Data is in webmercator and must be projected to 4326  					return projector.ToGeographic(geometry);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: TileInfo = new TileInfo  			{  				Height = 256'  				Width = 256'  				Origin = new MapPoint(-CornerCoordinate' CornerCoordinate) { SpatialReference = SpatialReference }'  				SpatialReference = SpatialReference'  				Lods = new Lod[19]  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: TileInfo = new TileInfo  			{  				Height = 256'  				Width = 256'  				Origin = new MapPoint(-CornerCoordinate' CornerCoordinate) { SpatialReference = SpatialReference }'  				SpatialReference = SpatialReference'  				Lods = new Lod[19]  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: TileInfo = new TileInfo  			{  				Height = 256'  				Width = 256'  				Origin = new MapPoint(-CornerCoordinate' CornerCoordinate) { SpatialReference = SpatialReference }'  				SpatialReference = SpatialReference'  				Lods = new Lod[19]  			};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: double resolution = CornerCoordinate * 2 / 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: double resolution = CornerCoordinate * 2 / 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WebTiledLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\WebTiledLayer\WebTiledLayer.cs,WebTiledLayer,The following statement contains a magic number: for (int i = 0; i < TileInfo.Lods.Length; i++)  			{  				TileInfo.Lods[i] = new Lod { Resolution = resolution };  				resolution /= 2;  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat = new List<int>{4326' 4269' 4267};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat = new List<int>{4326' 4269' 4267};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: _useCrsFormat = new List<int>{4326' 4269' 4267};
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: foreach (var element in SRSs)  			{  				string value = element.Value;  				if (value == "EPSG:4326")  					_useCrsFormat.Remove(4326);  				else if (value == "EPSG:4269")  					_useCrsFormat.Remove(4269);  				else if (value == "EPSG:4267")  					_useCrsFormat.Remove(4267);  				var sref = GetSpatialReference(value);  				if (sref != null && !supportedIDs.Contains(sref.WKID))  					supportedIDs.Add(sref.WKID);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: foreach (var element in SRSs)  			{  				string value = element.Value;  				if (value == "EPSG:4326")  					_useCrsFormat.Remove(4326);  				else if (value == "EPSG:4269")  					_useCrsFormat.Remove(4269);  				else if (value == "EPSG:4267")  					_useCrsFormat.Remove(4267);  				var sref = GetSpatialReference(value);  				if (sref != null && !supportedIDs.Contains(sref.WKID))  					supportedIDs.Add(sref.WKID);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: foreach (var element in SRSs)  			{  				string value = element.Value;  				if (value == "EPSG:4326")  					_useCrsFormat.Remove(4326);  				else if (value == "EPSG:4269")  					_useCrsFormat.Remove(4269);  				else if (value == "EPSG:4267")  					_useCrsFormat.Remove(4267);  				var sref = GetSpatialReference(value);  				if (sref != null && !supportedIDs.Contains(sref.WKID))  					supportedIDs.Add(sref.WKID);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ParseCapabilities,The following statement contains a magic number: if (elements.Any())  			{  				FullExtent = GetEnvelope(elements.First()' lowerThan13);  				if (FullExtent != null)  					SpatialReference = FullExtent.SpatialReference;  			}  			else if (lowerThan13)  			{  				// Get Extent from former "LatLonBoundingBox" element  				var element = xDoc.Descendants(XName.Get("LatLonBoundingBox"' ns)).First();  				SpatialReference = new SpatialReference(4326);  				FullExtent = GetEnvelope(element' true);  				if (FullExtent != null)  					FullExtent.SpatialReference = SpatialReference;  						}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913))  			{  				if (!SupportedSpatialReferenceIDs.Contains(extentWKID))  				{  					if (SupportedSpatialReferenceIDs.Contains(3857))  						extentWKID = 3857;  					else if (SupportedSpatialReferenceIDs.Contains(102100))  						extentWKID = 102100;  					else if (SupportedSpatialReferenceIDs.Contains(102113))  						extentWKID = 102113;  					else if (SupportedSpatialReferenceIDs.Contains(900913))  						extentWKID = 900913;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913))  			{  				if (!SupportedSpatialReferenceIDs.Contains(extentWKID))  				{  					if (SupportedSpatialReferenceIDs.Contains(3857))  						extentWKID = 3857;  					else if (SupportedSpatialReferenceIDs.Contains(102100))  						extentWKID = 102100;  					else if (SupportedSpatialReferenceIDs.Contains(102113))  						extentWKID = 102113;  					else if (SupportedSpatialReferenceIDs.Contains(900913))  						extentWKID = 900913;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913))  			{  				if (!SupportedSpatialReferenceIDs.Contains(extentWKID))  				{  					if (SupportedSpatialReferenceIDs.Contains(3857))  						extentWKID = 3857;  					else if (SupportedSpatialReferenceIDs.Contains(102100))  						extentWKID = 102100;  					else if (SupportedSpatialReferenceIDs.Contains(102113))  						extentWKID = 102113;  					else if (SupportedSpatialReferenceIDs.Contains(900913))  						extentWKID = 900913;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913))  			{  				if (!SupportedSpatialReferenceIDs.Contains(extentWKID))  				{  					if (SupportedSpatialReferenceIDs.Contains(3857))  						extentWKID = 3857;  					else if (SupportedSpatialReferenceIDs.Contains(102100))  						extentWKID = 102100;  					else if (SupportedSpatialReferenceIDs.Contains(102113))  						extentWKID = 102113;  					else if (SupportedSpatialReferenceIDs.Contains(900913))  						extentWKID = 900913;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913))  			{  				if (!SupportedSpatialReferenceIDs.Contains(extentWKID))  				{  					if (SupportedSpatialReferenceIDs.Contains(3857))  						extentWKID = 3857;  					else if (SupportedSpatialReferenceIDs.Contains(102100))  						extentWKID = 102100;  					else if (SupportedSpatialReferenceIDs.Contains(102113))  						extentWKID = 102113;  					else if (SupportedSpatialReferenceIDs.Contains(900913))  						extentWKID = 900913;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913))  			{  				if (!SupportedSpatialReferenceIDs.Contains(extentWKID))  				{  					if (SupportedSpatialReferenceIDs.Contains(3857))  						extentWKID = 3857;  					else if (SupportedSpatialReferenceIDs.Contains(102100))  						extentWKID = 102100;  					else if (SupportedSpatialReferenceIDs.Contains(102113))  						extentWKID = 102113;  					else if (SupportedSpatialReferenceIDs.Contains(900913))  						extentWKID = 900913;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913))  			{  				if (!SupportedSpatialReferenceIDs.Contains(extentWKID))  				{  					if (SupportedSpatialReferenceIDs.Contains(3857))  						extentWKID = 3857;  					else if (SupportedSpatialReferenceIDs.Contains(102100))  						extentWKID = 102100;  					else if (SupportedSpatialReferenceIDs.Contains(102113))  						extentWKID = 102113;  					else if (SupportedSpatialReferenceIDs.Contains(900913))  						extentWKID = 900913;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913))  			{  				if (!SupportedSpatialReferenceIDs.Contains(extentWKID))  				{  					if (SupportedSpatialReferenceIDs.Contains(3857))  						extentWKID = 3857;  					else if (SupportedSpatialReferenceIDs.Contains(102100))  						extentWKID = 102100;  					else if (SupportedSpatialReferenceIDs.Contains(102113))  						extentWKID = 102113;  					else if (SupportedSpatialReferenceIDs.Contains(900913))  						extentWKID = 900913;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913))  			{  				if (!SupportedSpatialReferenceIDs.Contains(extentWKID))  				{  					if (SupportedSpatialReferenceIDs.Contains(3857))  						extentWKID = 3857;  					else if (SupportedSpatialReferenceIDs.Contains(102100))  						extentWKID = 102100;  					else if (SupportedSpatialReferenceIDs.Contains(102113))  						extentWKID = 102113;  					else if (SupportedSpatialReferenceIDs.Contains(900913))  						extentWKID = 900913;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913))  			{  				if (!SupportedSpatialReferenceIDs.Contains(extentWKID))  				{  					if (SupportedSpatialReferenceIDs.Contains(3857))  						extentWKID = 3857;  					else if (SupportedSpatialReferenceIDs.Contains(102100))  						extentWKID = 102100;  					else if (SupportedSpatialReferenceIDs.Contains(102113))  						extentWKID = 102113;  					else if (SupportedSpatialReferenceIDs.Contains(900913))  						extentWKID = 900913;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913))  			{  				if (!SupportedSpatialReferenceIDs.Contains(extentWKID))  				{  					if (SupportedSpatialReferenceIDs.Contains(3857))  						extentWKID = 3857;  					else if (SupportedSpatialReferenceIDs.Contains(102100))  						extentWKID = 102100;  					else if (SupportedSpatialReferenceIDs.Contains(102113))  						extentWKID = 102113;  					else if (SupportedSpatialReferenceIDs.Contains(900913))  						extentWKID = 900913;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetUrl,The following statement contains a magic number: if (SupportedSpatialReferenceIDs != null &&  				(extentWKID == 102100 || extentWKID == 102113 || extentWKID == 3857 || extentWKID == 900913))  			{  				if (!SupportedSpatialReferenceIDs.Contains(extentWKID))  				{  					if (SupportedSpatialReferenceIDs.Contains(3857))  						extentWKID = 3857;  					else if (SupportedSpatialReferenceIDs.Contains(102100))  						extentWKID = 102100;  					else if (SupportedSpatialReferenceIDs.Contains(102113))  						extentWKID = 102113;  					else if (SupportedSpatialReferenceIDs.Contains(900913))  						extentWKID = 900913;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,UseLatLon,The following statement contains a magic number: int length = LatLongCRSRanges.Length / 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (!string.IsNullOrEmpty(crs))  			{  				if (crs.Contains("EPSG:"))  				{  					int.TryParse(crs.Split(':').Last()' NumberStyles.None' CultureInfo.InvariantCulture' out wkid);  				}  				else if (crs == "CRS:84") // WGS84  					wkid = 4326;  				else if (crs == "CRS:83") // NAD83  					wkid = 4269;  				else if (crs == "CRS:27") // NAD27  					wkid = 4267;  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (!string.IsNullOrEmpty(crs))  			{  				if (crs.Contains("EPSG:"))  				{  					int.TryParse(crs.Split(':').Last()' NumberStyles.None' CultureInfo.InvariantCulture' out wkid);  				}  				else if (crs == "CRS:84") // WGS84  					wkid = 4326;  				else if (crs == "CRS:83") // NAD83  					wkid = 4269;  				else if (crs == "CRS:27") // NAD27  					wkid = 4267;  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,GetSpatialReference,The following statement contains a magic number: if (!string.IsNullOrEmpty(crs))  			{  				if (crs.Contains("EPSG:"))  				{  					int.TryParse(crs.Split(':').Last()' NumberStyles.None' CultureInfo.InvariantCulture' out wkid);  				}  				else if (crs == "CRS:84") // WGS84  					wkid = 4326;  				else if (crs == "CRS:83") // NAD83  					wkid = 4269;  				else if (crs == "CRS:27") // NAD27  					wkid = 4267;  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CrsFromSR,The following statement contains a magic number: if (wkid == 4326)  				return "CRS:84";
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CrsFromSR,The following statement contains a magic number: if (wkid == 4269)  				return "CRS:83";
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,CrsFromSR,The following statement contains a magic number: if (wkid == 4267)  				return "CRS:27";
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ScaleHintToScale,The following statement contains a magic number: const double inchesPerMeter = 10000.0 / 254.0;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ScaleHintToScale,The following statement contains a magic number: const double inchesPerMeter = 10000.0 / 254.0;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ScaleHintToScale,The following statement contains a magic number: const double sqrt2 = 1.4142;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wms\Wms.cs,ScaleHintToScale,The following statement contains a magic number: const int dpi = 96;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,UseLatLon,The following statement contains a magic number: int length = _latLongCrsRanges.Length / 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The following statement contains a magic number: if (tileMatrixSet.SpatialReference.WKID == 3857)  			{  				useLatLon = tileMatrixSet.Matrices.First().TopLeftCorner.Y < -2E7;  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,WmtsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,ParseTileMatrixSet,The following statement contains a magic number: if (tileMatrixSet.SpatialReference.WKID == 3857)  			{  				useLatLon = tileMatrixSet.Matrices.First().TopLeftCorner.Y < -2E7;  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetMapPoint,The following statement contains a magic number: if (points.Count() != 2)  				return null;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS != null)  			{  				if (CRS.Contains("EPSG:"))  				{  					int.TryParse(CRS.Split(':').Last()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  				} else if (CRS.EndsWith("CRS84")) // WGS84  					WKID = 4326;  				else if (CRS.EndsWith("CRS83")) // NAD83  					WKID = 4269;  				else if (CRS.EndsWith("CRS27")) // NAD27  					WKID = 4267;    				if (WKID == 900913)  					WKID = 3857; // change google ID to the normalized one (EPSG:900913 is not supposed to exist)    				if (WKID == 0)  					throw new Exception("Unrecognized SR : " + CRS);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS != null)  			{  				if (CRS.Contains("EPSG:"))  				{  					int.TryParse(CRS.Split(':').Last()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  				} else if (CRS.EndsWith("CRS84")) // WGS84  					WKID = 4326;  				else if (CRS.EndsWith("CRS83")) // NAD83  					WKID = 4269;  				else if (CRS.EndsWith("CRS27")) // NAD27  					WKID = 4267;    				if (WKID == 900913)  					WKID = 3857; // change google ID to the normalized one (EPSG:900913 is not supposed to exist)    				if (WKID == 0)  					throw new Exception("Unrecognized SR : " + CRS);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS != null)  			{  				if (CRS.Contains("EPSG:"))  				{  					int.TryParse(CRS.Split(':').Last()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  				} else if (CRS.EndsWith("CRS84")) // WGS84  					WKID = 4326;  				else if (CRS.EndsWith("CRS83")) // NAD83  					WKID = 4269;  				else if (CRS.EndsWith("CRS27")) // NAD27  					WKID = 4267;    				if (WKID == 900913)  					WKID = 3857; // change google ID to the normalized one (EPSG:900913 is not supposed to exist)    				if (WKID == 0)  					throw new Exception("Unrecognized SR : " + CRS);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS != null)  			{  				if (CRS.Contains("EPSG:"))  				{  					int.TryParse(CRS.Split(':').Last()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  				} else if (CRS.EndsWith("CRS84")) // WGS84  					WKID = 4326;  				else if (CRS.EndsWith("CRS83")) // NAD83  					WKID = 4269;  				else if (CRS.EndsWith("CRS27")) // NAD27  					WKID = 4267;    				if (WKID == 900913)  					WKID = 3857; // change google ID to the normalized one (EPSG:900913 is not supposed to exist)    				if (WKID == 0)  					throw new Exception("Unrecognized SR : " + CRS);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources,XmlExtension,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Wmts\Wmts.cs,GetSpatialReference,The following statement contains a magic number: if (CRS != null)  			{  				if (CRS.Contains("EPSG:"))  				{  					int.TryParse(CRS.Split(':').Last()' NumberStyles.None' CultureInfo.InvariantCulture' out WKID);  				} else if (CRS.EndsWith("CRS84")) // WGS84  					WKID = 4326;  				else if (CRS.EndsWith("CRS83")) // NAD83  					WKID = 4269;  				else if (CRS.EndsWith("CRS27")) // NAD27  					WKID = 4267;    				if (WKID == 900913)  					WKID = 3857; // change google ID to the normalized one (EPSG:900913 is not supposed to exist)    				if (WKID == 0)  					throw new Exception("Unrecognized SR : " + CRS);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Gps,GpsSymbol,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsSymbol.cs,GpsSymbol,The following statement contains a magic number: Size = 20;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconHotspotX = 0.5;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconHotspotY = 0.5;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.LineColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.LineColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.LineColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.LineColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.PolyFillColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.PolyFillColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.PolyFillColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.PolyFillColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KMLStyle,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,KMLStyle,The following statement contains a magic number: this.IconColor = Color.FromArgb(255' 255' 255' 255);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,PointSymbolDescriptor,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,GetDefaultSymbol,The following statement contains a magic number: return new KmlPlaceMarkerSymbol() { Height = 40' Width = 40' Fill = new ImageBrush() { ImageSource = bmp } };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,PointSymbolDescriptor,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,GetDefaultSymbol,The following statement contains a magic number: return new KmlPlaceMarkerSymbol() { Height = 40' Width = 40' Fill = new ImageBrush() { ImageSource = bmp } };
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The following statement contains a magic number: foreach (PlacemarkDescriptor feature in placemarks)  			{  				KMLStyle style = feature.Symbol.style;    				if (style.ZipFile != null)  				{  					// Look for the image in the zip file  					if (style.IconImage == null && !String.IsNullOrEmpty(style.IconHref))  					{  						style.IconImage = GetIconImage(style.ZipFile' style.IconHref.ToLower());  					}    					style.ZipFile.Dispose();  					style.ZipFile = null;  				}                    //Define handlers upfront so we can unhook from them  #if SILVERLIGHT                  EventHandler<RoutedEventArgs>  #else                  EventHandler  #endif   imageCompleted = null;  #if SILVERLIGHT                  EventHandler<ExceptionRoutedEventArgs> 		  #else                  EventHandler<ExceptionEventArgs>  #endif   imageFailed = null;    				// If the style has an HREF then it is associated with an image  				if (style.IconImage == null && !String.IsNullOrEmpty(style.IconHref))  				{  					// If the image is already loaded in the image dictionary' use it  					if (images.ContainsKey(style.IconHref.ToLower()))  						style.IconImage = images[style.IconHref.ToLower()];  					else  					{  						// Get the image using the HREF and store the image in the images dictionary so that if  						// other features reference it' it is cached                          style.IconImage = GetIconImage(style.IconHref);                          if (style.IconImage != null && (style.IconImage as ImageBrush).ImageSource != null)  							{                              var bi = (style.IconImage as ImageBrush).ImageSource as BitmapImage;                              if (bi != null)                              {                                  imageFailed = (s' e) =>                                  {                                      var b = s as BitmapImage;  #if SILVERLIGHT                                                 if (imageCompleted != null) b.ImageOpened -= imageCompleted;                                      if(imageFailed != null) b.ImageFailed -= imageFailed;  #else                                      if (imageCompleted != null) b.DownloadCompleted -= imageCompleted;                                      if (imageFailed != null) b.DownloadFailed -= imageFailed;  #endif                                      var key = b.GetValue(BitmapImageKeyProperty) as string;  								layer.Dispatcher.BeginInvoke((Action)delegate  								{								  									UpdateGraphicsAndRenderer(layer' renderer' key);  								});                                  };    #if SILVERLIGHT                                                                      bi.ImageFailed += imageFailed;  #else                                  bi.DownloadFailed += imageFailed;  #endif                              }                          }  						images.Add(style.IconHref.ToLower()' style.IconImage);  					}  				}    				// Create a new graphic from the metadata and construct the symbol using polymorphism  				Graphic g = new Graphic()  				{  					Geometry = feature.Geometry'  					Symbol = feature.Symbol.CreateSymbol()'  					TimeExtent = feature.TimeExtent  				};  				g.SetValue(FeaturePlacemarkerDescriptorProperty' feature);  				// Create legend entry  				string label;  				string description;  				GetRendererInfo(feature' style' out label' out description);    				if (!string.IsNullOrEmpty(label) && !renderer.Infos.Any(info => info.Label == label))  					renderer.Infos.Add(new UniqueValueInfo { Label = label' Description = description' Symbol = g.Symbol });    				// Adjust and assign picture marker symbol properties  				if (g.Geometry is ESRI.ArcGIS.Client.Geometry.MapPoint && g.Symbol is KmlPlaceMarkerSymbol)  				{  					try  					{  						KmlPlaceMarkerSymbol ms = g.Symbol as KmlPlaceMarkerSymbol;    						// To match sizing of Google Earth' default size of point images is 40x40  						ms.Height = 40;  						ms.Width = 40;                            ms.Fill = style.IconImage;                          ms.IconColor = style.IconColor;    						// Default to half the pixel size (width and height) if symbol offsets are 0 (supported in wpf and sl3)  						ImageBrush ib = ms.Fill;  						BitmapImage bi = ib.ImageSource as BitmapImage;  #if SILVERLIGHT  						if (bi.PixelHeight == 0 || bi.PixelWidth == 0)  #else  						if (bi.IsDownloading)  #endif  						{                              imageCompleted = (s' e) =>  							{                                  var b = s as BitmapImage;  #if SILVERLIGHT                                                                      if (imageCompleted != null) b.ImageOpened -= imageCompleted;                                  if(imageFailed != null) b.ImageFailed -= imageFailed;  #else                                  if (imageCompleted != null) b.DownloadCompleted -= imageCompleted;                                  if (imageFailed != null) b.DownloadFailed -= imageFailed;  #endif                                  ComputeIconTranslationValues(style' ms' b);  							};  #if SILVERLIGHT                                 bi.ImageOpened += imageCompleted;  #else                              bi.DownloadCompleted += imageCompleted;  #endif                          }  						else  						{  							ComputeIconTranslationValues(style' ms' bi);  						}    					}  					catch  					{  						g.Symbol = PointSymbolDescriptor.GetDefaultSymbol();  						ComputeIconTranslationValues(style' g.Symbol as KmlPlaceMarkerSymbol' ((g.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage);  						var info = renderer.Infos.FirstOrDefault(i => i.Label == label);  						if (info != null)  						{  							info.Symbol = g.Symbol;  						}  					}  				}    				// Copy attributes values from metadata to graphic  				foreach (var attribute in feature.Attributes)  				{  					g.Attributes.Add(attribute.Key' attribute.Value);  				}    				// If the balloontext property has been assigned a value in the style associated with this  				// graphic feature' then add it to the attributes collection.  				if (!String.IsNullOrEmpty(style.BalloonText))  				{  					g.Attributes.Add("balloonText"' style.BalloonText);  				}    				// Add graphic to graphics layer  				graphics.Add(g);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGraphics,The following statement contains a magic number: foreach (PlacemarkDescriptor feature in placemarks)  			{  				KMLStyle style = feature.Symbol.style;    				if (style.ZipFile != null)  				{  					// Look for the image in the zip file  					if (style.IconImage == null && !String.IsNullOrEmpty(style.IconHref))  					{  						style.IconImage = GetIconImage(style.ZipFile' style.IconHref.ToLower());  					}    					style.ZipFile.Dispose();  					style.ZipFile = null;  				}                    //Define handlers upfront so we can unhook from them  #if SILVERLIGHT                  EventHandler<RoutedEventArgs>  #else                  EventHandler  #endif   imageCompleted = null;  #if SILVERLIGHT                  EventHandler<ExceptionRoutedEventArgs> 		  #else                  EventHandler<ExceptionEventArgs>  #endif   imageFailed = null;    				// If the style has an HREF then it is associated with an image  				if (style.IconImage == null && !String.IsNullOrEmpty(style.IconHref))  				{  					// If the image is already loaded in the image dictionary' use it  					if (images.ContainsKey(style.IconHref.ToLower()))  						style.IconImage = images[style.IconHref.ToLower()];  					else  					{  						// Get the image using the HREF and store the image in the images dictionary so that if  						// other features reference it' it is cached                          style.IconImage = GetIconImage(style.IconHref);                          if (style.IconImage != null && (style.IconImage as ImageBrush).ImageSource != null)  							{                              var bi = (style.IconImage as ImageBrush).ImageSource as BitmapImage;                              if (bi != null)                              {                                  imageFailed = (s' e) =>                                  {                                      var b = s as BitmapImage;  #if SILVERLIGHT                                                 if (imageCompleted != null) b.ImageOpened -= imageCompleted;                                      if(imageFailed != null) b.ImageFailed -= imageFailed;  #else                                      if (imageCompleted != null) b.DownloadCompleted -= imageCompleted;                                      if (imageFailed != null) b.DownloadFailed -= imageFailed;  #endif                                      var key = b.GetValue(BitmapImageKeyProperty) as string;  								layer.Dispatcher.BeginInvoke((Action)delegate  								{								  									UpdateGraphicsAndRenderer(layer' renderer' key);  								});                                  };    #if SILVERLIGHT                                                                      bi.ImageFailed += imageFailed;  #else                                  bi.DownloadFailed += imageFailed;  #endif                              }                          }  						images.Add(style.IconHref.ToLower()' style.IconImage);  					}  				}    				// Create a new graphic from the metadata and construct the symbol using polymorphism  				Graphic g = new Graphic()  				{  					Geometry = feature.Geometry'  					Symbol = feature.Symbol.CreateSymbol()'  					TimeExtent = feature.TimeExtent  				};  				g.SetValue(FeaturePlacemarkerDescriptorProperty' feature);  				// Create legend entry  				string label;  				string description;  				GetRendererInfo(feature' style' out label' out description);    				if (!string.IsNullOrEmpty(label) && !renderer.Infos.Any(info => info.Label == label))  					renderer.Infos.Add(new UniqueValueInfo { Label = label' Description = description' Symbol = g.Symbol });    				// Adjust and assign picture marker symbol properties  				if (g.Geometry is ESRI.ArcGIS.Client.Geometry.MapPoint && g.Symbol is KmlPlaceMarkerSymbol)  				{  					try  					{  						KmlPlaceMarkerSymbol ms = g.Symbol as KmlPlaceMarkerSymbol;    						// To match sizing of Google Earth' default size of point images is 40x40  						ms.Height = 40;  						ms.Width = 40;                            ms.Fill = style.IconImage;                          ms.IconColor = style.IconColor;    						// Default to half the pixel size (width and height) if symbol offsets are 0 (supported in wpf and sl3)  						ImageBrush ib = ms.Fill;  						BitmapImage bi = ib.ImageSource as BitmapImage;  #if SILVERLIGHT  						if (bi.PixelHeight == 0 || bi.PixelWidth == 0)  #else  						if (bi.IsDownloading)  #endif  						{                              imageCompleted = (s' e) =>  							{                                  var b = s as BitmapImage;  #if SILVERLIGHT                                                                      if (imageCompleted != null) b.ImageOpened -= imageCompleted;                                  if(imageFailed != null) b.ImageFailed -= imageFailed;  #else                                  if (imageCompleted != null) b.DownloadCompleted -= imageCompleted;                                  if (imageFailed != null) b.DownloadFailed -= imageFailed;  #endif                                  ComputeIconTranslationValues(style' ms' b);  							};  #if SILVERLIGHT                                 bi.ImageOpened += imageCompleted;  #else                              bi.DownloadCompleted += imageCompleted;  #endif                          }  						else  						{  							ComputeIconTranslationValues(style' ms' bi);  						}    					}  					catch  					{  						g.Symbol = PointSymbolDescriptor.GetDefaultSymbol();  						ComputeIconTranslationValues(style' g.Symbol as KmlPlaceMarkerSymbol' ((g.Symbol as KmlPlaceMarkerSymbol).Fill as ImageBrush).ImageSource as BitmapImage);  						var info = renderer.Infos.FirstOrDefault(i => i.Label == label);  						if (info != null)  						{  							info.Symbol = g.Symbol;  						}  					}  				}    				// Copy attributes values from metadata to graphic  				foreach (var attribute in feature.Attributes)  				{  					g.Attributes.Add(attribute.Key' attribute.Value);  				}    				// If the balloontext property has been assigned a value in the style associated with this  				// graphic feature' then add it to the attributes collection.  				if (!String.IsNullOrEmpty(style.BalloonText))  				{  					g.Attributes.Add("balloonText"' style.BalloonText);  				}    				// Add graphic to graphics layer  				graphics.Add(g);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: foreach (GroundOverlayDescriptor feature in groundOverlays)  			{  				UIElement uiElement;    				if (!String.IsNullOrEmpty(feature.IconHref))  				{  					ImageSource imageSource;    					// If the image is provided in kmz content' use it  					if (images.ContainsKey(feature.IconHref.ToLower()))  					{  						imageSource = images[feature.IconHref.ToLower()].ImageSource;  					}  					else  					{  						// Get the image using the HREF  						imageSource = new BitmapImage(KmlLayer.GetUri(feature.IconHref' _baseUri));  					}                        // If feature color is White with an alpha channel' this can be managed with Opacity' else we need the to blend the color with the icon                      double opacity;                      bool needBlendEffect;                        if (feature.Color.R == byte.MaxValue && feature.Color.G == byte.MaxValue && feature.Color.B == byte.MaxValue)                      {                          opacity = (double)feature.Color.A / byte.MaxValue;                          needBlendEffect = false;                      }                      else                      {                          opacity = 1.0;                          needBlendEffect = true;                      }    					uiElement = new Image  					            	{  					            		Source = imageSource'  					            		Stretch = Stretch.Fill'  					            		Opacity = opacity  					            	};                      if (needBlendEffect)                      {                          uiElement.Effect = new MultiplyBlendEffect{BlendColor = feature.Color};                      }  				}  				else  				{  					// Just add a rectangle  					uiElement = new Rectangle { Fill = new SolidColorBrush(feature.Color)};  				}    				// Set the time extent  				if (feature.TimeExtent != null)  					ElementLayer.SetTimeExtent(uiElement' feature.TimeExtent);    				// Set the rotation  				if (feature.Rotation != 0.0)  				{  					uiElement.RenderTransformOrigin = new Point(0.5' 0.5);  					uiElement.RenderTransform = new RotateTransform {Angle = -feature.Rotation}; // KML rotations are specified in a counterclockwise direction  				}    				// Set the envelope  				var elementLayerEnvelopeProperty = ElementLayer.EnvelopeProperty;  				var envelope = feature.Envelope;    				// If the map is based on WebMercatore coordinates' project the envelope (weird at small scale but acceptable at large scale)  				if (map != null && map.SpatialReference != null && IsWebMercator(map.SpatialReference)  					&& envelope.SpatialReference != null && envelope.SpatialReference.WKID == 4326) // should always be the case  				{  					envelope = (new Projection.WebMercator()).FromGeographic(envelope) as Envelope;  				}  				uiElement.SetValue(elementLayerEnvelopeProperty' envelope);    				// Add element to element layer  				layer.Children.Add(uiElement);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: foreach (GroundOverlayDescriptor feature in groundOverlays)  			{  				UIElement uiElement;    				if (!String.IsNullOrEmpty(feature.IconHref))  				{  					ImageSource imageSource;    					// If the image is provided in kmz content' use it  					if (images.ContainsKey(feature.IconHref.ToLower()))  					{  						imageSource = images[feature.IconHref.ToLower()].ImageSource;  					}  					else  					{  						// Get the image using the HREF  						imageSource = new BitmapImage(KmlLayer.GetUri(feature.IconHref' _baseUri));  					}                        // If feature color is White with an alpha channel' this can be managed with Opacity' else we need the to blend the color with the icon                      double opacity;                      bool needBlendEffect;                        if (feature.Color.R == byte.MaxValue && feature.Color.G == byte.MaxValue && feature.Color.B == byte.MaxValue)                      {                          opacity = (double)feature.Color.A / byte.MaxValue;                          needBlendEffect = false;                      }                      else                      {                          opacity = 1.0;                          needBlendEffect = true;                      }    					uiElement = new Image  					            	{  					            		Source = imageSource'  					            		Stretch = Stretch.Fill'  					            		Opacity = opacity  					            	};                      if (needBlendEffect)                      {                          uiElement.Effect = new MultiplyBlendEffect{BlendColor = feature.Color};                      }  				}  				else  				{  					// Just add a rectangle  					uiElement = new Rectangle { Fill = new SolidColorBrush(feature.Color)};  				}    				// Set the time extent  				if (feature.TimeExtent != null)  					ElementLayer.SetTimeExtent(uiElement' feature.TimeExtent);    				// Set the rotation  				if (feature.Rotation != 0.0)  				{  					uiElement.RenderTransformOrigin = new Point(0.5' 0.5);  					uiElement.RenderTransform = new RotateTransform {Angle = -feature.Rotation}; // KML rotations are specified in a counterclockwise direction  				}    				// Set the envelope  				var elementLayerEnvelopeProperty = ElementLayer.EnvelopeProperty;  				var envelope = feature.Envelope;    				// If the map is based on WebMercatore coordinates' project the envelope (weird at small scale but acceptable at large scale)  				if (map != null && map.SpatialReference != null && IsWebMercator(map.SpatialReference)  					&& envelope.SpatialReference != null && envelope.SpatialReference.WKID == 4326) // should always be the case  				{  					envelope = (new Projection.WebMercator()).FromGeographic(envelope) as Envelope;  				}  				uiElement.SetValue(elementLayerEnvelopeProperty' envelope);    				// Add element to element layer  				layer.Children.Add(uiElement);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,CreateGroundOverlays,The following statement contains a magic number: foreach (GroundOverlayDescriptor feature in groundOverlays)  			{  				UIElement uiElement;    				if (!String.IsNullOrEmpty(feature.IconHref))  				{  					ImageSource imageSource;    					// If the image is provided in kmz content' use it  					if (images.ContainsKey(feature.IconHref.ToLower()))  					{  						imageSource = images[feature.IconHref.ToLower()].ImageSource;  					}  					else  					{  						// Get the image using the HREF  						imageSource = new BitmapImage(KmlLayer.GetUri(feature.IconHref' _baseUri));  					}                        // If feature color is White with an alpha channel' this can be managed with Opacity' else we need the to blend the color with the icon                      double opacity;                      bool needBlendEffect;                        if (feature.Color.R == byte.MaxValue && feature.Color.G == byte.MaxValue && feature.Color.B == byte.MaxValue)                      {                          opacity = (double)feature.Color.A / byte.MaxValue;                          needBlendEffect = false;                      }                      else                      {                          opacity = 1.0;                          needBlendEffect = true;                      }    					uiElement = new Image  					            	{  					            		Source = imageSource'  					            		Stretch = Stretch.Fill'  					            		Opacity = opacity  					            	};                      if (needBlendEffect)                      {                          uiElement.Effect = new MultiplyBlendEffect{BlendColor = feature.Color};                      }  				}  				else  				{  					// Just add a rectangle  					uiElement = new Rectangle { Fill = new SolidColorBrush(feature.Color)};  				}    				// Set the time extent  				if (feature.TimeExtent != null)  					ElementLayer.SetTimeExtent(uiElement' feature.TimeExtent);    				// Set the rotation  				if (feature.Rotation != 0.0)  				{  					uiElement.RenderTransformOrigin = new Point(0.5' 0.5);  					uiElement.RenderTransform = new RotateTransform {Angle = -feature.Rotation}; // KML rotations are specified in a counterclockwise direction  				}    				// Set the envelope  				var elementLayerEnvelopeProperty = ElementLayer.EnvelopeProperty;  				var envelope = feature.Envelope;    				// If the map is based on WebMercatore coordinates' project the envelope (weird at small scale but acceptable at large scale)  				if (map != null && map.SpatialReference != null && IsWebMercator(map.SpatialReference)  					&& envelope.SpatialReference != null && envelope.SpatialReference.WKID == 4326) // should always be the case  				{  					envelope = (new Projection.WebMercator()).FromGeographic(envelope) as Envelope;  				}  				uiElement.SetValue(elementLayerEnvelopeProperty' envelope);    				// Add element to element layer  				layer.Children.Add(uiElement);  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,The following statement contains a magic number: ms.Height = 40;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,The following statement contains a magic number: ms.Width = 40;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,Convert,The following statement contains a magic number: foreach (XElement container in xElement.Elements().Where(element => element.Name.LocalName == "Folder" || element.Name.LocalName == "Document" || element.Name.LocalName == "NetworkLink"))  			{  				ContainerInfo containerInfo = new ContainerInfo  				                         	{  				                         		Element = container'  				                         		Url = null' // only for networklink  				                         		Visible = true'  				                         		AtomAuthor = context.AtomAuthor' // Use parent value by default  				                         		AtomHref = context.AtomHref  // Use parent value by default  				                         	};    				XNamespace kmlContainerNS = container.Name.Namespace;  				if (container.Name.LocalName == "NetworkLink")  				{  					string hrefValue = "";  					string composite = "";  					string layerids = "";    					// Link takes precedence over Url from KML version 2.1 and later:  					XElement url = container.Element(kmlContainerNS + "Link") ?? container.Element(kmlContainerNS + "Url");  					if (url != null)  					{  						XElement href = url.Element(kmlContainerNS + "href");  						if (href != null)  						{  							hrefValue = href.Value;  						}    						// This next section is to parse special elements that only occur when an ArcGIS Server KML   						// is to be processed.  						XElement view = url.Element(kmlContainerNS + "viewFormat");  						if (view != null)  						{  							int begIdx = view.Value.IndexOf("Composite");  							if (begIdx != -1)  							{  								int endIdx = view.Value.IndexOf("&"' begIdx);  								if (endIdx != -1)  									composite = view.Value.Substring(begIdx' endIdx - begIdx);  							}    							begIdx = view.Value.IndexOf("LayerIDs");  							if (begIdx != -1)  							{  								int endIdx = view.Value.IndexOf("&"' begIdx);  								if (endIdx != -1)  									layerids = view.Value.Substring(begIdx' endIdx - begIdx);  							}  						}    						// If network link URL is successfully extracted' then add to container list  						if (!String.IsNullOrEmpty(hrefValue))  						{  							// extract refreshInterval  							XElement refreshMode = url.Element(kmlContainerNS + "refreshMode");  							if (refreshMode != null && refreshMode.Value == "onInterval")  							{  								XElement refreshInterval = url.Element(kmlContainerNS + "refreshInterval");  								if (refreshInterval != null)  									containerInfo.RefreshInterval = GetDoubleValue(refreshInterval);  								else  									containerInfo.RefreshInterval = 4; // default value   							}    							XElement viewRefreshMode = url.Element(kmlContainerNS + "viewRefreshMode");  							if (viewRefreshMode != null)  							{  								ViewRefreshMode viewRefreshModeEnum;    								try // Enum.TryParse doesn't exist in 3.5  								{  									viewRefreshModeEnum = (ViewRefreshMode)Enum.Parse(typeof(ViewRefreshMode)' viewRefreshMode.Value' true);  									containerInfo.ViewRefreshMode = viewRefreshModeEnum;  								}  								catch{}  							}    							// the following values are for processing specialized ArcGIS Server KML links  							// generated from REST endpoints.  							if (!String.IsNullOrEmpty(composite))  								hrefValue += "?" + composite;    							if (!String.IsNullOrEmpty(layerids))  							{  								if (!String.IsNullOrEmpty(hrefValue))  									hrefValue += "&" + layerids;  								else  									hrefValue += "?" + layerids;  							}  							containerInfo.Url = hrefValue;    						}  						else  							containerInfo = null; // Link without href. Should not happen. Skip it.  					}  					else  						containerInfo = null; // NetworkLink without Link/Url. Should not happen. Skip it.  				}  				else  				{  					// Folder or Document XElement   					XElement linkElement = container.Elements(atomNS + "link").Where(element => element.HasAttributes).FirstOrDefault();  					if (linkElement != null)  					{  						// Overwrite global default value only upon successful extraction from element  						string tempHref = GetAtomHref(linkElement);  						if (!String.IsNullOrEmpty(tempHref))  							containerInfo.AtomHref = new Uri(tempHref);  					}    					XElement authorElement = container.Element(atomNS + "author");  					if (authorElement != null)  					{  						// Overwrite global default value only upon successful extraction from element  						string tempAuthor = GetAtomAuthor(authorElement);  						if (!String.IsNullOrEmpty(tempAuthor))  							containerInfo.AtomAuthor = tempAuthor;  					}  				}    				if (containerInfo != null)  				{  					XElement visibilityElement = container.Element(kmlContainerNS + "visibility");  					if (visibilityElement != null)  					{  						containerInfo.Visible = GetBooleanValue(visibilityElement);  					}    					XElement nameElement = container.Element(kmlContainerNS + "name");  					if (nameElement != null)  					{  						containerInfo.Name = nameElement.Value.Trim();  					}    					containerInfo.RegionInfo = ExtractRegion(container);    					// Look for a listItemType element that can be set to 'checkHideChildren' to prevent cildren to be seen in the legend  					XElement listItemTypeElement = container.XPathSelectElement("Style/ListStyle/listItemType"' kmlContainerNS);  					if (listItemTypeElement != null)  					{  						if (listItemTypeElement.Value == "checkHideChildren")  							containerInfo.HideChildren = true;  					}    					if (container.HasAttributes && container.Attribute(KmlLayer.FolderIdAttributeName) != null)  					{  						containerInfo.FolderId = (int)container.Attribute(KmlLayer.FolderIdAttributeName);  					}    					containerInfo.TimeExtent = ExtractTimeExtent(container);  					featureDefs.AddContainer(containerInfo);  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,DownloadStyleAsync,The following statement contains a magic number: if (styleUrl.StartsWith("http://") || styleUrl.StartsWith("https://"))  			{  				// Split style into file URL and style id  				string[] tokens = styleUrl.Split('#');  				if (tokens.Length == 2)  				{  					// Store current state so event handler can resume  					DownloadStyleState state = new DownloadStyleState('#' + tokens[1]' credentials' callback  #if !SILVERLIGHT  ' clientCertificate  #endif  );  					WebClient webClient = Utilities.CreateWebClient();    					if (credentials != null)  						webClient.Credentials = credentials;  #if !SILVERLIGHT  					if (clientCertificate != null)  						(webClient as CompressResponseWebClient).ClientCertificate = clientCertificate;  #endif    					webClient.OpenReadCompleted += StyleDownloaded;  					webClient.OpenReadAsync(Utilities.PrefixProxy(ProxyUrl' tokens[0])' state);  					_waitHelper.AddOne();  					return;  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The following statement contains a magic number: if (feature.Name.LocalName == "Placemark")  			{  				// kmlStyle is null when the placemark doesn't reference any shared style (or a shared style that we are not able to download)  				// in this case' use a default style  				if (kmlStyle == null)  					kmlStyle = new KMLStyle();    				// Determine what kind of feature is present in the placemark. If an input geometry is present' then the  				// style has already been determined and this method is being called recursively for each child element  				// of a multi-geometry placemarker.  				XElement geomElement = null;  				if (geometry != null)  				{  					geomElement = geometry;  				}  				else  				{  					geomElement = GetFeatureType(feature);    					// Override any settings from the inline style "Style" node  					XElement styleElement = feature.Element(kmlNS + "Style");  					if (styleElement != null)  					{  						GetStyle(styleElement' kmlStyle);  					}  				}    				PlacemarkDescriptor fd = null;    				if (geomElement != null && geomElement.Name != null)  				{  					switch (geomElement.Name.LocalName)  					{  						case "Point":  							fd = ExtractPoint(kmlStyle' geomElement);  							break;    						case "LineString":  							fd = ExtractPolyLine(kmlStyle' geomElement);  							break;    						case "LinearRing":  							fd = ExtractLinearRing(kmlStyle' geomElement);  							break;    						case "Polygon":  							fd = ExtractPolygon(kmlStyle' geomElement);  							break;    						case "MultiGeometry":  							foreach (XElement item in geomElement.Elements())  							{  								// Use recursion to walk the hierarchy of embedded definitions  								CreateFeatureDefinition(kmlStyle' feature' item' context);  							}  							break;    						case "LatLonBox":  							ExtractFeatureStyleInfo(kmlStyle' feature);  							fd = ExtractLatLonBox(kmlStyle' geomElement);  							break;  					}    					// If a feature definition was created' then assign timeextent' attributes and add to collection  					if (fd != null)  					{  						fd.TimeExtent = ExtractTimeExtent(feature' fd.Attributes);    						if (fd.Geometry != null)  							fd.Geometry.SpatialReference = new SpatialReference(4326);    						XElement descElement = feature.Element(kmlNS + "description");  						if (descElement != null)  							fd.Attributes.Add("description"' descElement.Value);    						XElement nameElement = feature.Element(kmlNS + "name");  						if (nameElement != null)  							fd.Attributes.Add("name"' nameElement.Value);    						if (atomNS != null)  						{  							// Initialize to parent value  							Uri atomHrefValue = context.AtomHref;    							// If node exists' has attributes' and can be successfully extracted' then extract  							// this value.  							XElement atomHrefElement = feature.Element(atomNS + "link");  							if (atomHrefElement != null && atomHrefElement.HasAttributes)  							{  								string tempHref = GetAtomHref(atomHrefElement);  								if (!String.IsNullOrEmpty(tempHref))  									atomHrefValue = new Uri(tempHref);  							}    							// If a value was extracted or assigned from a parent' then add to attributes  							if (atomHrefValue != null)  								fd.Attributes.Add("atomHref"' atomHrefValue);    							// AtomAuthor : Initialize to parent value  							string atomValue = context.AtomAuthor;    							// If node exists' has attributes' and can be successfully extracted' then extract  							// this value.  							XElement atomAuthorElement = feature.Element(atomNS + "author");  							if (atomAuthorElement != null)  							{  								string tempAuthor = GetAtomAuthor(atomAuthorElement);  								if (!String.IsNullOrEmpty(tempAuthor))  									atomValue = tempAuthor;  							}    							// If a value was extracted or assigned from a parent' then add to attributes  							if (!String.IsNullOrEmpty(atomValue))  								fd.Attributes.Add("atomAuthor"' atomValue);  						}    						// Extract extended information  						XElement extendedDataElement = feature.Element(kmlNS + "ExtendedData");  						if (extendedDataElement != null)  						{  							List<KmlExtendedData> extendedList = new List<KmlExtendedData>();  							IEnumerable<XElement> dataElements =  								from e in extendedDataElement.Descendants(kmlNS + "Data")  								select e;  							foreach (XElement data in dataElements)  							{  								XAttribute name = data.Attribute("name");  								if (name != null)  								{  									KmlExtendedData listItem = new KmlExtendedData();  									listItem.Name = name.Value;    									foreach (XElement dataChild in data.Descendants())  									{  										if (dataChild.Name == kmlNS + "displayName")  											listItem.DisplayName = dataChild.Value;  										else if (dataChild.Name == kmlNS + "value")  											listItem.Value = dataChild.Value;  									}    									extendedList.Add(listItem);  								}  							}    							if (extendedList.Count > 0)  								fd.Attributes.Add("extendedData"' extendedList);  						}    						featureDefs.AddPlacemark(fd);  					}  				}  			}  			else if (feature.Name.LocalName == "GroundOverlay")  			{  				XElement latLonBoxElement = feature.Element(kmlNS + "LatLonBox");    				if (latLonBoxElement != null)  				{  					GroundOverlayDescriptor fd = new GroundOverlayDescriptor  					                             	{  					                             		Envelope = ExtractEnvelope(latLonBoxElement)'  					                             		TimeExtent = ExtractTimeExtent(feature)  					                             	};    					XElement rotationElement = latLonBoxElement.Element(kmlNS + "rotation");  					if (rotationElement != null)  						fd.Rotation = GetDoubleValue(rotationElement);    					XElement colorElement = feature.Element(kmlNS + "color");  					if (colorElement != null)  						fd.Color = GetColorFromHexString(colorElement.Value);  					else  						fd.Color = System.Windows.Media.Colors.White; // Default = white    					XElement iconElement = feature.Element(kmlNS + "Icon");  					if (iconElement != null)  					{  						XElement href = iconElement.Element(kmlNS + "href");  						if (href != null)  						{  							fd.IconHref = href.Value;  						}  					}    					featureDefs.AddGroundOverlay(fd);  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractEnvelope,The following statement contains a magic number: return north.HasValue && south.HasValue && east.HasValue && west.HasValue  			       	? new Envelope(west.Value' south.Value' east.Value' north.Value) { SpatialReference = new SpatialReference(4326)}  			       	: null;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractCoordinate,The following statement contains a magic number: if (!String.IsNullOrEmpty(coordinate))              {                  // Split input string into an array of strings using comma as the delimiter                  string[] xy = coordinate.Split(new string[] { "'" }' StringSplitOptions.RemoveEmptyEntries);                    // Make sure X and Y coordinate strings are available                  if (xy.Length >= 2)                  {                      double x' y;                        // Create new MapPoint object passing in X and Y values to constructor                      if (double.TryParse(xy[0]' System.Globalization.NumberStyles.Float' CultureInfo.InvariantCulture' out x) && double.TryParse(xy[1]' System.Globalization.NumberStyles.Float' CultureInfo.InvariantCulture' out y))                      {                          mp = new MapPoint(x' y);                      }                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (iconStyle != null)              {                  XElement icon = iconStyle.Element(kmlNS + "Icon");                  if (icon != null)                  {                      XElement href = icon.Element(kmlNS + "href");                      if (href != null)                      {                          string iconUrl = href.Value;                          const string googlePal = "root://icons/palette-";                          if(iconUrl.StartsWith(googlePal' StringComparison.OrdinalIgnoreCase))                          {                              // Replace Google earth built-in palette URL by the real URL                              int x = 0;                              int y = 0;                              int numPalette = 0;                              XElement xElement = icon.Element(kmlNS + "x");                              if (xElement != null)                                  int.TryParse(xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);                              XElement yElement = icon.Element(kmlNS + "y");                              if (yElement != null)                                  int.TryParse(yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);                              string pal = iconUrl.Substring(googlePal.Length' 1);                              int.TryParse(pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);                              if (numPalette > 0)                              {                                  int numIcon = 8 * (7 - y/32) + x/32;                                  iconUrl = string.Format("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);                              }                          }                            kmlStyle.IconHref = iconUrl;                        }                  }                    // Extract IconColor                  XElement iconColor = iconStyle.Element(kmlNS + "color");                  if (iconColor != null)                  {                      kmlStyle.IconColor = GetColorFromHexString(iconColor.Value);                  }                    // If the hotspot element is present' make use of it                  XElement hotspot = iconStyle.Element(kmlNS + "hotSpot");                  if (hotspot != null)                  {                      XAttribute units;                      XAttribute val;                        units = hotspot.Attribute("xunits");                      if (units != null)                      {                          try                          {                              kmlStyle.IconHotspotUnitsX = (HotSpotUnitType)Enum.Parse(typeof(HotSpotUnitType)' units.Value' true);                              val = hotspot.Attribute("x");                              if (val != null)                              {                                  double x;                                  if (double.TryParse(val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out x))                                      kmlStyle.IconHotspotX = x;                              }                          }                          catch { }                      }                        units = hotspot.Attribute("yunits");                      if (units != null)                      {                          try                          {                              kmlStyle.IconHotspotUnitsY = (HotSpotUnitType)Enum.Parse(typeof(HotSpotUnitType)' units.Value' true);                              val = hotspot.Attribute("y");                              if (val != null)                              {                                  double y;                                  if (double.TryParse(val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out y))                                      kmlStyle.IconHotspotY = y;                              }                          }                          catch { }                      }                  }                    // If the heading element is present' make use of it                  XElement heading = iconStyle.Element(kmlNS + "heading");                  if (heading != null)                  {                      double degrees;                      if (double.TryParse(heading.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out degrees))                          kmlStyle.IconHeading = degrees;                  }                    // If the scale element is present' make use of it                  XElement scale = iconStyle.Element(kmlNS + "scale");                  if (scale != null)                  {                      double scaleAmount;                      if (double.TryParse(scale.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out scaleAmount))                          kmlStyle.IconScale = scaleAmount;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (iconStyle != null)              {                  XElement icon = iconStyle.Element(kmlNS + "Icon");                  if (icon != null)                  {                      XElement href = icon.Element(kmlNS + "href");                      if (href != null)                      {                          string iconUrl = href.Value;                          const string googlePal = "root://icons/palette-";                          if(iconUrl.StartsWith(googlePal' StringComparison.OrdinalIgnoreCase))                          {                              // Replace Google earth built-in palette URL by the real URL                              int x = 0;                              int y = 0;                              int numPalette = 0;                              XElement xElement = icon.Element(kmlNS + "x");                              if (xElement != null)                                  int.TryParse(xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);                              XElement yElement = icon.Element(kmlNS + "y");                              if (yElement != null)                                  int.TryParse(yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);                              string pal = iconUrl.Substring(googlePal.Length' 1);                              int.TryParse(pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);                              if (numPalette > 0)                              {                                  int numIcon = 8 * (7 - y/32) + x/32;                                  iconUrl = string.Format("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);                              }                          }                            kmlStyle.IconHref = iconUrl;                        }                  }                    // Extract IconColor                  XElement iconColor = iconStyle.Element(kmlNS + "color");                  if (iconColor != null)                  {                      kmlStyle.IconColor = GetColorFromHexString(iconColor.Value);                  }                    // If the hotspot element is present' make use of it                  XElement hotspot = iconStyle.Element(kmlNS + "hotSpot");                  if (hotspot != null)                  {                      XAttribute units;                      XAttribute val;                        units = hotspot.Attribute("xunits");                      if (units != null)                      {                          try                          {                              kmlStyle.IconHotspotUnitsX = (HotSpotUnitType)Enum.Parse(typeof(HotSpotUnitType)' units.Value' true);                              val = hotspot.Attribute("x");                              if (val != null)                              {                                  double x;                                  if (double.TryParse(val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out x))                                      kmlStyle.IconHotspotX = x;                              }                          }                          catch { }                      }                        units = hotspot.Attribute("yunits");                      if (units != null)                      {                          try                          {                              kmlStyle.IconHotspotUnitsY = (HotSpotUnitType)Enum.Parse(typeof(HotSpotUnitType)' units.Value' true);                              val = hotspot.Attribute("y");                              if (val != null)                              {                                  double y;                                  if (double.TryParse(val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out y))                                      kmlStyle.IconHotspotY = y;                              }                          }                          catch { }                      }                  }                    // If the heading element is present' make use of it                  XElement heading = iconStyle.Element(kmlNS + "heading");                  if (heading != null)                  {                      double degrees;                      if (double.TryParse(heading.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out degrees))                          kmlStyle.IconHeading = degrees;                  }                    // If the scale element is present' make use of it                  XElement scale = iconStyle.Element(kmlNS + "scale");                  if (scale != null)                  {                      double scaleAmount;                      if (double.TryParse(scale.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out scaleAmount))                          kmlStyle.IconScale = scaleAmount;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (iconStyle != null)              {                  XElement icon = iconStyle.Element(kmlNS + "Icon");                  if (icon != null)                  {                      XElement href = icon.Element(kmlNS + "href");                      if (href != null)                      {                          string iconUrl = href.Value;                          const string googlePal = "root://icons/palette-";                          if(iconUrl.StartsWith(googlePal' StringComparison.OrdinalIgnoreCase))                          {                              // Replace Google earth built-in palette URL by the real URL                              int x = 0;                              int y = 0;                              int numPalette = 0;                              XElement xElement = icon.Element(kmlNS + "x");                              if (xElement != null)                                  int.TryParse(xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);                              XElement yElement = icon.Element(kmlNS + "y");                              if (yElement != null)                                  int.TryParse(yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);                              string pal = iconUrl.Substring(googlePal.Length' 1);                              int.TryParse(pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);                              if (numPalette > 0)                              {                                  int numIcon = 8 * (7 - y/32) + x/32;                                  iconUrl = string.Format("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);                              }                          }                            kmlStyle.IconHref = iconUrl;                        }                  }                    // Extract IconColor                  XElement iconColor = iconStyle.Element(kmlNS + "color");                  if (iconColor != null)                  {                      kmlStyle.IconColor = GetColorFromHexString(iconColor.Value);                  }                    // If the hotspot element is present' make use of it                  XElement hotspot = iconStyle.Element(kmlNS + "hotSpot");                  if (hotspot != null)                  {                      XAttribute units;                      XAttribute val;                        units = hotspot.Attribute("xunits");                      if (units != null)                      {                          try                          {                              kmlStyle.IconHotspotUnitsX = (HotSpotUnitType)Enum.Parse(typeof(HotSpotUnitType)' units.Value' true);                              val = hotspot.Attribute("x");                              if (val != null)                              {                                  double x;                                  if (double.TryParse(val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out x))                                      kmlStyle.IconHotspotX = x;                              }                          }                          catch { }                      }                        units = hotspot.Attribute("yunits");                      if (units != null)                      {                          try                          {                              kmlStyle.IconHotspotUnitsY = (HotSpotUnitType)Enum.Parse(typeof(HotSpotUnitType)' units.Value' true);                              val = hotspot.Attribute("y");                              if (val != null)                              {                                  double y;                                  if (double.TryParse(val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out y))                                      kmlStyle.IconHotspotY = y;                              }                          }                          catch { }                      }                  }                    // If the heading element is present' make use of it                  XElement heading = iconStyle.Element(kmlNS + "heading");                  if (heading != null)                  {                      double degrees;                      if (double.TryParse(heading.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out degrees))                          kmlStyle.IconHeading = degrees;                  }                    // If the scale element is present' make use of it                  XElement scale = iconStyle.Element(kmlNS + "scale");                  if (scale != null)                  {                      double scaleAmount;                      if (double.TryParse(scale.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out scaleAmount))                          kmlStyle.IconScale = scaleAmount;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetStyle,The following statement contains a magic number: if (iconStyle != null)              {                  XElement icon = iconStyle.Element(kmlNS + "Icon");                  if (icon != null)                  {                      XElement href = icon.Element(kmlNS + "href");                      if (href != null)                      {                          string iconUrl = href.Value;                          const string googlePal = "root://icons/palette-";                          if(iconUrl.StartsWith(googlePal' StringComparison.OrdinalIgnoreCase))                          {                              // Replace Google earth built-in palette URL by the real URL                              int x = 0;                              int y = 0;                              int numPalette = 0;                              XElement xElement = icon.Element(kmlNS + "x");                              if (xElement != null)                                  int.TryParse(xElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out x);                              XElement yElement = icon.Element(kmlNS + "y");                              if (yElement != null)                                  int.TryParse(yElement.Value' NumberStyles.Integer' CultureInfo.InvariantCulture' out y);                              string pal = iconUrl.Substring(googlePal.Length' 1);                              int.TryParse(pal' NumberStyles.Integer' CultureInfo.InvariantCulture' out numPalette);                              if (numPalette > 0)                              {                                  int numIcon = 8 * (7 - y/32) + x/32;                                  iconUrl = string.Format("http://maps.google.com/mapfiles/kml/pal{0}/icon{1}.png"' numPalette' numIcon);                              }                          }                            kmlStyle.IconHref = iconUrl;                        }                  }                    // Extract IconColor                  XElement iconColor = iconStyle.Element(kmlNS + "color");                  if (iconColor != null)                  {                      kmlStyle.IconColor = GetColorFromHexString(iconColor.Value);                  }                    // If the hotspot element is present' make use of it                  XElement hotspot = iconStyle.Element(kmlNS + "hotSpot");                  if (hotspot != null)                  {                      XAttribute units;                      XAttribute val;                        units = hotspot.Attribute("xunits");                      if (units != null)                      {                          try                          {                              kmlStyle.IconHotspotUnitsX = (HotSpotUnitType)Enum.Parse(typeof(HotSpotUnitType)' units.Value' true);                              val = hotspot.Attribute("x");                              if (val != null)                              {                                  double x;                                  if (double.TryParse(val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out x))                                      kmlStyle.IconHotspotX = x;                              }                          }                          catch { }                      }                        units = hotspot.Attribute("yunits");                      if (units != null)                      {                          try                          {                              kmlStyle.IconHotspotUnitsY = (HotSpotUnitType)Enum.Parse(typeof(HotSpotUnitType)' units.Value' true);                              val = hotspot.Attribute("y");                              if (val != null)                              {                                  double y;                                  if (double.TryParse(val.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out y))                                      kmlStyle.IconHotspotY = y;                              }                          }                          catch { }                      }                  }                    // If the heading element is present' make use of it                  XElement heading = iconStyle.Element(kmlNS + "heading");                  if (heading != null)                  {                      double degrees;                      if (double.TryParse(heading.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out degrees))                          kmlStyle.IconHeading = degrees;                  }                    // If the scale element is present' make use of it                  XElement scale = iconStyle.Element(kmlNS + "scale");                  if (scale != null)                  {                      double scaleAmount;                      if (double.TryParse(scale.Value' NumberStyles.Float' CultureInfo.InvariantCulture' out scaleAmount))                          kmlStyle.IconScale = scaleAmount;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetColorFromHexString,The following statement contains a magic number: if (s.Length == 8)              {                  // Be advised that the values are not ARGB' but instead ABGR.                  byte a = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte b = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(4' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(6' 2)' 16);                  return System.Windows.Media.Color.FromArgb(a' r' g' b);              }              else              {                  byte b = System.Convert.ToByte(s.Substring(0' 2)' 16);                  byte g = System.Convert.ToByte(s.Substring(2' 2)' 16);                  byte r = System.Convert.ToByte(s.Substring(4' 2)' 16);                  return System.Windows.Media.Color.FromArgb(255' r' g' b);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractTimeExtentFromDate,The following statement contains a magic number: if (strsDate.Length > 2 && !int.TryParse(strsDate[2]' out day))  				return null;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,ExtractTimeExtentFromDate,The following statement contains a magic number: if (strsDate.Length > 2 && !int.TryParse(strsDate[2]' out day))  				return null;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,CRC32,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Crc32.cs,ComputeCrc32,The following statement contains a magic number: return (Int32)(crc32Table[(W ^ B) & 0xFF] ^ (W >> 8));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,CRC32,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Crc32.cs,SlurpBlock,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int x = offset + i;                  _RunningCrc32Result = ((_RunningCrc32Result) >> 8) ^ crc32Table[(block[x]) ^ ((_RunningCrc32Result) & 0x000000FF)];              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,CRC32,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Crc32.cs,CRC32,The following statement contains a magic number: unchecked              {                  // This is the official polynomial used by CRC32 in PKZip.                  // Often the polynomial is shown reversed as 0x04C11DB7.                  UInt32 dwPolynomial = 0xEDB88320;                  UInt32 i' j;                    crc32Table = new UInt32[256];                    UInt32 dwCrc;                  for (i = 0; i < 256; i++)                  {                      dwCrc = i;                      for (j = 8; j > 0; j--)                      {                          if ((dwCrc & 1) == 1)                          {                              dwCrc = (dwCrc >> 1) ^ dwPolynomial;                          }                          else                          {                              dwCrc >>= 1;                          }                      }                      crc32Table[i] = dwCrc;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,CRC32,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Crc32.cs,CRC32,The following statement contains a magic number: unchecked              {                  // This is the official polynomial used by CRC32 in PKZip.                  // Often the polynomial is shown reversed as 0x04C11DB7.                  UInt32 dwPolynomial = 0xEDB88320;                  UInt32 i' j;                    crc32Table = new UInt32[256];                    UInt32 dwCrc;                  for (i = 0; i < 256; i++)                  {                      dwCrc = i;                      for (j = 8; j > 0; j--)                      {                          if ((dwCrc & 1) == 1)                          {                              dwCrc = (dwCrc >> 1) ^ dwPolynomial;                          }                          else                          {                              dwCrc >>= 1;                          }                      }                      crc32Table[i] = dwCrc;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,CRC32,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Crc32.cs,CRC32,The following statement contains a magic number: unchecked              {                  // This is the official polynomial used by CRC32 in PKZip.                  // Often the polynomial is shown reversed as 0x04C11DB7.                  UInt32 dwPolynomial = 0xEDB88320;                  UInt32 i' j;                    crc32Table = new UInt32[256];                    UInt32 dwCrc;                  for (i = 0; i < 256; i++)                  {                      dwCrc = i;                      for (j = 8; j > 0; j--)                      {                          if ((dwCrc & 1) == 1)                          {                              dwCrc = (dwCrc >> 1) ^ dwPolynomial;                          }                          else                          {                              dwCrc >>= 1;                          }                      }                      crc32Table[i] = dwCrc;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                        case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if (((SharedUtils.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = Flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              ;                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              for (int i = 0; i < t; i++)                              {                                  blens[i] = 0;                              }                          }                          {                              b = SharedUtils.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SharedUtils.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SharedUtils.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.AvailableBytesIn = n;                                      z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SharedUtils.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          write = q;                                          return Flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SharedUtils.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SharedUtils.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      write = q;                                      return Flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions							                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                            if ((r = codes.Process(this' z' r)) != ZlibConstants.Z_STREAM_END)                          {                              return Flush(z' r);                          }                          r = ZlibConstants.Z_OK;                          p = z.NextIn; n = z.AvailableBytesIn; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = Flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              write = q;                              return Flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = ZlibConstants.Z_STREAM_END;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                        case BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          write = q;                          return Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following statement contains a magic number: while (true)              {                  switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                                blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn; n = z.AvailableBytesIn; b = blocks.bitb; k = blocks.bitk;                              q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SharedUtils.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                    blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.write = q;                                  return blocks.Flush(z' r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                                if (m == 0)                              {                                  if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.write = q; r = blocks.Flush(z' r);                                      q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.read != 0)                                      {                                          q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                          blocks.write = q;                                          return blocks.Flush(z' r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.read != 0)                              {                                  q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.write = q; r = blocks.Flush(z' r);                                  q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.read != 0)                                  {                                      q = 0; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.write = q;                                      return blocks.Flush(z' r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.write = q; r = blocks.Flush(z' r);                          q = blocks.write; m = q < blocks.read ? blocks.read - q - 1 : blocks.end - q;                            if (blocks.read != blocks.write)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.write = q;                              return blocks.Flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.write = q;                          return blocks.Flush(z' r);                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: do              {                  // assume called with m >= 258 && n >= 10                  // get literal/length code                  while (k < (20))                  {                      // max bits for literal/length code                      n--;                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                  }                    t = b & ml;                  tp = tl;                  tp_index = tl_index;                  tp_index_t_3 = (tp_index + t) * 3;                  if ((e = tp[tp_index_t_3]) == 0)                  {                      b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        s.window[q++] = (byte)tp[tp_index_t_3 + 2];                      m--;                      continue;                  }                  do                  {                        b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                        if ((e & 16) != 0)                      {                          e &= 15;                          c = tp[tp_index_t_3 + 2] + ((int)b & inflate_mask[e]);                            b >>= e; k -= e;                            // decode distance base of block to copy                          while (k < (15))                          {                              // max bits for distance code                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                          }                            t = b & md;                          tp = td;                          tp_index = td_index;                          tp_index_t_3 = (tp_index + t) * 3;                          e = tp[tp_index_t_3];                            do                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                if ((e & 16) != 0)                              {                                  // get extra bits to add to distance base                                  e &= 15;                                  while (k < (e))                                  {                                      // get extra bits (up to 13)                                      n--;                                      b |= (z.InputBuffer[p++] & 0xff) << k; k += 8;                                  }                                    d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);                                    b >>= (e); k -= (e);                                    // do the copy                                  m -= c;                                  if (q >= d)                                  {                                      // offset before dest                                      //  just copy                                      r = q - d;                                      if (q - r > 0 && 2 > (q - r))                                      {                                          s.window[q++] = s.window[r++]; // minimum count is three'                                          s.window[q++] = s.window[r++]; // so unroll loop a little                                          c -= 2;                                      }                                      else                                      {                                          Array.Copy(s.window' r' s.window' q' 2);                                          q += 2; r += 2; c -= 2;                                      }                                  }                                  else                                  {                                      // else offset after destination                                      r = q - d;                                      do                                      {                                          r += s.end; // force pointer in window                                      }                                      while (r < 0); // covers invalid distances                                      e = s.end - r;                                      if (c > e)                                      {                                          // if source crosses'                                          c -= e; // wrapped copy                                          if (q - r > 0 && e > (q - r))                                          {                                              do                                              {                                                  s.window[q++] = s.window[r++];                                              }                                              while (--e != 0);                                          }                                          else                                          {                                              Array.Copy(s.window' r' s.window' q' e);                                              q += e; r += e; e = 0;                                          }                                          r = 0; // copy rest from start of window                                      }                                  }                                    // copy all or what's left                                  if (q - r > 0 && c > (q - r))                                  {                                      do                                      {                                          s.window[q++] = s.window[r++];                                      }                                      while (--c != 0);                                  }                                  else                                  {                                      Array.Copy(s.window' r' s.window' q' c);                                      q += c; r += c; c = 0;                                  }                                  break;                              }                              else if ((e & 64) == 0)                              {                                  t += tp[tp_index_t_3 + 2];                                  t += (b & inflate_mask[e]);                                  tp_index_t_3 = (tp_index + t) * 3;                                  e = tp[tp_index_t_3];                              }                              else                              {                                  z.Message = "invalid distance code";                                    c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                                    s.bitb = b; s.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  s.write = q;                                    return ZlibConstants.Z_DATA_ERROR;                              }                          }                          while (true);                          break;                      }                        if ((e & 64) == 0)                      {                          t += tp[tp_index_t_3 + 2];                          t += (b & inflate_mask[e]);                          tp_index_t_3 = (tp_index + t) * 3;                          if ((e = tp[tp_index_t_3]) == 0)                          {                                b >>= (tp[tp_index_t_3 + 1]); k -= (tp[tp_index_t_3 + 1]);                                s.window[q++] = (byte)tp[tp_index_t_3 + 2];                              m--;                              break;                          }                      }                      else if ((e & 32) != 0)                      {                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_STREAM_END;                      }                      else                      {                          z.Message = "invalid literal/length code";                            c = z.AvailableBytesIn - n; c = (k >> 3) < c ? k >> 3 : c; n += c; p -= c; k -= (c << 3);                            s.bitb = b; s.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          s.write = q;                            return ZlibConstants.Z_DATA_ERROR;                      }                  }                  while (true);              }              while (m >= 258 && n >= 10);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateCodes,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,InflateFast,The following statement contains a magic number: k -= (c << 3);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Initialize,The following statement contains a magic number: if (w < 8 || w > 15)              {                  End(z);                  throw new ZlibException("Bad window size.");                    //return ZlibConstants.Z_STREAM_ERROR;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Initialize,The following statement contains a magic number: if (w < 8 || w > 15)              {                  End(z);                  throw new ZlibException("Bad window size.");                    //return ZlibConstants.Z_STREAM_ERROR;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Inflate,The following statement contains a magic number: while (true)              {                  switch (z.istate.mode)                  {                      case METHOD:                          if (z.AvailableBytesIn == 0)                              return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                                                    if (((z.istate.method = z.InputBuffer[z.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("unknown compression method (0x{0:X2})"' z.istate.method);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.Message = String.Format("invalid window size ({0})"' (z.istate.method >> 4) + 8);                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.AvailableBytesIn == 0) return r;                                                     r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          b = (z.InputBuffer[z.NextIn++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.Message = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                          z._Adler32 = z.istate.need;                          z.istate.mode = DICT0;                          return ZlibConstants.Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.Message = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.Process(z' r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END) return r;                            r = f;                          z.istate.blocks.Reset(z' z.istate.was);                          if (!z.istate.HandleRfc1950HeaderBytes)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need = ((z.InputBuffer[z.NextIn++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.AvailableBytesIn == 0) return r;                          r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (((z.InputBuffer[z.NextIn++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.AvailableBytesIn == 0) return r;                            r = f;                            z.AvailableBytesIn--; z.TotalBytesIn++;                          z.istate.need += (z.InputBuffer[z.NextIn++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.Message = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return ZlibConstants.Z_STREAM_END;                        case BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' z.Message));                      //return ZlibConstants.Z_DATA_ERROR;                        default:                          throw new ZlibException("Stream error.");                      //return ZlibConstants.Z_STREAM_ERROR;                    }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Sync,The following statement contains a magic number: while (n != 0 && m < 4)              {                  if (z.InputBuffer[p] == mark[m])                  {                      m++;                  }                  else if (z.InputBuffer[p] != 0)                  {                      m = 0;                  }                  else                  {                      m = 4 - m;                  }                  p++; n--;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Sync,The following statement contains a magic number: while (n != 0 && m < 4)              {                  if (z.InputBuffer[p] == mark[m])                  {                      m++;                  }                  else if (z.InputBuffer[p] != 0)                  {                      m = 0;                  }                  else                  {                      m = 4 - m;                  }                  p++; n--;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateManager,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Sync,The following statement contains a magic number: if (m != 4)              {                  return ZlibConstants.Z_DATA_ERROR;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = (z > l)?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= (a + 1); // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						{  							// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						}  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (sbyte) j; // bits in this table  							r[1] = (sbyte) l; // bits to dump before this table  							j = SharedUtils.URShift(i' (w - l));  							r[2] = (int) (q - u[h - 1] - j); // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (sbyte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (sbyte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (sbyte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SharedUtils.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SharedUtils.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: initWorkArea(19);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: result = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: if (result != Z_OK || (bd[0] == 0 && nl > 257))  			{  				if (result == Z_DATA_ERROR)  				{  					z.Message = "oversubscribed distance tree";  				}  				else if (result == Z_BUF_ERROR)  				{  					z.Message = "incomplete distance tree";  					result = Z_DATA_ERROR;  				}  				else if (result != Z_MEM_ERROR)  				{  					z.Message = "empty distance tree with lengths";  					result = Z_DATA_ERROR;  				}  				return result;  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,initWorkArea,The following statement contains a magic number: if (hn == null)  			{  				hn = new int[1];  				v = new int[vsize];  				c = new int[BMAX + 1];  				r = new int[3];  				u = new int[BMAX];  				x = new int[BMAX + 1];  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InfTree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\InfTree.cs,initWorkArea,The following statement contains a magic number: for (int i = 0; i < 3; i++)  			{  				r[i] = 0;  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,RoundToEvenSecond,The following statement contains a magic number: if ((source.Second % 2) == 1)                  source += new TimeSpan(0' 0' 1);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,TrimVolumeAndSwapSlashes,The following statement contains a magic number: if (pathName.Length < 2) return pathName.Replace('\\'' '/');
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,TrimVolumeAndSwapSlashes,The following statement contains a magic number: return (((pathName[1] == ':') && (pathName[2] == '\\')) ? pathName.Substring(3) : pathName)                  .Replace('\\'' '/');
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,TrimVolumeAndSwapSlashes,The following statement contains a magic number: return (((pathName[1] == ':') && (pathName[2] == '\\')) ? pathName.Substring(3) : pathName)                  .Replace('\\'' '/');
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,_ReadFourBytes,The following statement contains a magic number: byte[] block = new byte[4];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = (((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = (((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = (((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = (((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = (((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: int BATCH_SIZE = 65536;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: byte[] targetBytes = new byte[4];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[0] = (byte)(SignatureToFind >> 24);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[1] = (byte)((SignatureToFind & 0x00FF0000) >> 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[2] = (byte)((SignatureToFind & 0x0000FF00) >> 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[2] = (byte)((SignatureToFind & 0x0000FF00) >> 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[3] = (byte)(SignatureToFind & 0x000000FF);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: do              {                  n = stream.Read(batch' 0' batch.Length);                  if (n != 0)                  {                      for (int i = 0; i < n; i++)                      {                          if (batch[i] == targetBytes[3])                          {                              long curPosition = stream.Position;                              stream.Seek(i - n' System.IO.SeekOrigin.Current);                              int sig = ReadSignature(stream);                              success = (sig == SignatureToFind);                              if (!success)                              {                                  stream.Seek(curPosition' System.IO.SeekOrigin.Begin);                              }                              else                                  break; // out of for loop                          }                      }                  }                  else break;                  if (success) break;              } while (true);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,FindSignature,The following statement contains a magic number: long bytesRead = (stream.Position - startingPosition) - 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (packedDateTime == 0xFFFF || packedDateTime == 0)                  return new System.DateTime(1995' 1' 1' 0' 0' 0' 0);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: Int16 packedDate = (Int16)((packedDateTime & 0xffff0000) >> 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: int year = 1980 + ((packedDate & 0xFE00) >> 9);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: int year = 1980 + ((packedDate & 0xFE00) >> 9);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: int month = (packedDate & 0x01E0) >> 5;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: int hour = (packedTime & 0xF800) >> 11;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: int minute = (packedTime & 0x07E0) >> 5;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: int second = (packedTime & 0x001F) * 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (second >= 60) { minute++; second = 0; }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (minute >= 60) { hour++; minute = 0; }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,PackedToDateTime,The following statement contains a magic number: if (hour >= 24) { day++; hour = 0; }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,DateTimeToPacked,The following statement contains a magic number: Int32 result = (Int32)(((UInt32)(packedDate << 16)) | packedTime);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,GetTempFilename,The following statement contains a magic number: do              {                  candidate = "DotNetZip-" + GenerateRandomStringImpl(8' 97) + ".tmp";              } while (System.IO.File.Exists(candidate));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,GetTempFilename,The following statement contains a magic number: do              {                  candidate = "DotNetZip-" + GenerateRandomStringImpl(8' 97) + ".tmp";              } while (System.IO.File.Exists(candidate));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,GenerateRandomStringImpl,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  if (WantMixedCase)                      delta = (_rnd.Next(2) == 0) ? 65 : 97;                  a[i] = GetOneRandomChar(delta);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,GenerateRandomStringImpl,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  if (WantMixedCase)                      delta = (_rnd.Next(2) == 0) ? 65 : 97;                  a[i] = GetOneRandomChar(delta);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,GenerateRandomStringImpl,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  if (WantMixedCase)                      delta = (_rnd.Next(2) == 0) ? 65 : 97;                  a[i] = GetOneRandomChar(delta);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtilities,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Shared.cs,GetOneRandomChar,The following statement contains a magic number: return (char)(_rnd.Next(26) + delta);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Tree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256?_dist_code[dist]:_dist_code[256 + (SharedUtils.URShift((dist)' 7))]);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Tree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256?_dist_code[dist]:_dist_code[256 + (SharedUtils.URShift((dist)' 7))]);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Tree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256?_dist_code[dist]:_dist_code[256 + (SharedUtils.URShift((dist)' 7))]);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Tree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				int len = tree[n * 2 + 1];  				if (len == 0)  					continue;  				// Now reverse the bits  				tree[n * 2] = (short) (bi_reverse(next_code[len]++' len));  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Tree,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				int len = tree[n * 2 + 1];  				if (len == 0)  					continue;  				// Now reverse the bits  				tree[n * 2] = (short) (bi_reverse(next_code[len]++' len));  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: if (IsNotValidZipDirEntrySig(signature))              {                  s.Seek(-4' System.IO.SeekOrigin.Current);                    // Getting "not a ZipDirEntry signature" here is not always wrong or an error.                   // This can happen when walking through a zipfile.  After the last ZipDirEntry'                   // we expect to read an EndOfCentralDirectorySignature.  When we get this is how we                   // know we've reached the end of the central directory.                   if (signature != ZipConstants.EndOfCentralDirectorySignature &&                      signature != ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)                  {                      throw new BadReadException(String.Format("  ZipEntry::ReadDirEntry(): Bad signature (0x{0:X8}) at position 0x{1:X8}"' signature' s.Position));                  }                  return null;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: int bytesRead = 42 + 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: int bytesRead = 42 + 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: byte[] block = new byte[42];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._VersionMadeBy = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._VersionNeeded = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._BitField = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressionMethod = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._filenameLength = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._extraFieldLength = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._commentLength = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: i += 2;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._InternalFileAttrs = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: if (zde._Encryption == EncryptionAlgorithm.PkzipWeak)              {                  // the "encryption header" of 12 bytes precedes the file data                  zde._CompressedFileDataSize -= 12;  			}
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: bytesRead += 4;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (ZipEntry.IsNotValidSig(signature))              {                  // Getting "not a ZipEntry signature" is not always wrong or an error.                   // This will happen after the last entry in a zipfile.  In that case' we                   // expect to read :                   //    a ZipDirEntry signature (if a non-empty zip file) or                   //    a ZipConstants.EndOfCentralDirectorySignature.                    //                  // Anything else is a surprise.                    ze.ArchiveStream.Seek(-4' System.IO.SeekOrigin.Current); // unread the signature                  if (ZipEntry.IsNotValidZipDirEntrySig(signature) && (signature != ZipConstants.EndOfCentralDirectorySignature))                  {                      throw new BadReadException(String.Format("  ZipEntry::ReadHeader(): Bad signature (0x{0:X8}) at position  0x{1:X8}"' signature' ze.ArchiveStream.Position));                  }                  return false;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: byte[] block = new byte[26];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._VersionNeeded = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._BitField = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressionMethod = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: {                  ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                  ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                    // validate ZIP64?  No.  We don't need to be pedantic about it.                   //if (((uint)ze._CompressedSize == 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize != 0xFFFFFFFF) ||                  //    ((uint)ze._CompressedSize != 0xFFFFFFFF &&                  //    (uint)ze._UncompressedSize == 0xFFFFFFFF))                  //    throw new BadReadException(String.Format("  ZipEntry::Read(): Inconsistent uncompressed size (0x{0:X8}) for zip64' at position  0x{1:X16}"' ze._UncompressedSize' ze.ArchiveStream.Position));                    if ((uint)ze._CompressedSize == 0xFFFFFFFF ||                      (uint)ze._UncompressedSize == 0xFFFFFFFF)                        ze._InputUsesZip64 = true;                      //throw new BadReadException("  DotNetZip does not currently support reading the ZIP64 format.");              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: Int16 filenameLength = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[i++] + block[i++] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if (!ze._LocalFileName.EndsWith("/") && (ze._BitField & 0x0008) == 0x0008)              {                  // This descriptor exists only if bit 3 of the general                  // purpose bit flag is set (see below).  It is byte aligned                  // and immediately follows the last byte of compressed data.                  // This descriptor is used only when it was not possible to                  // seek in the output .ZIP file' e.g.' when the output .ZIP file                  // was standard output or a non-seekable device.  For ZIP64(tm) format                  // archives' the compressed and uncompressed sizes are 8 bytes each.                    long posn = ze.ArchiveStream.Position;                    // Here' we're going to loop until we find a ZipEntryDataDescriptorSignature and                   // a consistent data record after that.   To be consistent' the data record must                   // indicate the length of the entry data.                   bool wantMore = true;                  long SizeOfDataRead = 0;                  int tries = 0;                  while (wantMore)                  {                      tries++;                      // We call the FindSignature shared routine to find the specified signature                      // in the already-opened zip archive' starting from the current cursor                      // position in that filestream.  There are two possibilities: either we                      // find the signature or we don't.  If we cannot find it' then the routine                      // returns -1' and the ReadHeader() method returns false' indicating we                      // cannot read a legal entry header.  If we have found it' then the                      // FindSignature() method returns the number of bytes in the stream we had                      // to seek forward' to find the sig.  We need this to determine if the zip                      // entry is valid' later.                        long d = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.FindSignature(ze.ArchiveStream' ZipConstants.ZipEntryDataDescriptorSignature);                      if (d == -1) return false;                        // total size of data read (through all loops of this).                       SizeOfDataRead += d;                        if (ze._InputUsesZip64 == true)                      {                          // read 1x 4-byte (CRC) and 2x 8-bytes (Compressed Size' Uncompressed Size)                          block = new byte[20];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 20) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                          ze._UncompressedSize = BitConverter.ToInt64(block' i);                          i += 8;                            ze._LengthOfTrailer += 24;  // bytes including sig' CRC' Comp and Uncomp sizes                      }                      else                      {                          // read 3x 4-byte fields (CRC' Compressed Size' Uncompressed Size)                          block = new byte[12];                          n = ze.ArchiveStream.Read(block' 0' block.Length);                          if (n != 12) return false;                            // do not increment bytesRead - it is for entry header only.                          // the data we have just read is a footer (falls after the file data)                          //bytesRead += n;                             i = 0;                          ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                          ze._LengthOfTrailer += 16;  // bytes including sig' CRC' Comp and Uncomp sizes                        }                        wantMore = (SizeOfDataRead != ze._CompressedSize);                      if (wantMore)                      {                          // Seek back to un-read the last 12 bytes  - maybe THEY contain                           // the ZipEntryDataDescriptorSignature.                          // (12 bytes for the CRC' Comp and Uncomp size.)                          ze.ArchiveStream.Seek(-12' System.IO.SeekOrigin.Current);                            // Adjust the size to account for the false signature read in                           // FindSignature().                          SizeOfDataRead += 4;                      }                  }                    //if (SizeOfDataRead != ze._CompressedSize)                  //    throw new BadReadException("Data format error (bit 3 is set)");                    // seek back to previous position' to prepare to read file data                  ze.ArchiveStream.Seek(posn' System.IO.SeekOrigin.Begin);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if ((ze._BitField & 0x01) == 0x01)              {    #if AESCRYPTO                  if (ze.Encryption == EncryptionAlgorithm.WinZipAes128 ||                      ze.Encryption == EncryptionAlgorithm.WinZipAes256)                  {                      // read in the WinZip AES metadata                      ze._aesCrypto = WinZipAesCrypto.ReadFromStream(null' ze._KeyStrengthInBits' ze.ArchiveStream);                      bytesRead += ze._aesCrypto.SizeOfEncryptionMetadata - 10;                      ze._CompressedFileDataSize = ze.CompressedSize - ze._aesCrypto.SizeOfEncryptionMetadata;                      ze._LengthOfTrailer += 10;                  }                  else  #endif                  {                      // read in the header data for "weak" encryption                      ze._WeakEncryptionHeader = new byte[12];                      bytesRead += ZipEntry.ReadWeakEncryptionHeader(ze._archiveStream' ze._WeakEncryptionHeader);                      // decrease the filedata size by 12 bytes                      ze._CompressedFileDataSize -= 12;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: if ((ze._BitField & 0x01) == 0x01)              {    #if AESCRYPTO                  if (ze.Encryption == EncryptionAlgorithm.WinZipAes128 ||                      ze.Encryption == EncryptionAlgorithm.WinZipAes256)                  {                      // read in the WinZip AES metadata                      ze._aesCrypto = WinZipAesCrypto.ReadFromStream(null' ze._KeyStrengthInBits' ze.ArchiveStream);                      bytesRead += ze._aesCrypto.SizeOfEncryptionMetadata - 10;                      ze._CompressedFileDataSize = ze.CompressedSize - ze._aesCrypto.SizeOfEncryptionMetadata;                      ze._LengthOfTrailer += 10;                  }                  else  #endif                  {                      // read in the header data for "weak" encryption                      ze._WeakEncryptionHeader = new byte[12];                      bytesRead += ZipEntry.ReadWeakEncryptionHeader(ze._archiveStream' ze._WeakEncryptionHeader);                      // decrease the filedata size by 12 bytes                      ze._CompressedFileDataSize -= 12;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadWeakEncryptionHeader,The following statement contains a magic number: int additionalBytesRead = s.Read(buffer' 0' 12);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ReadWeakEncryptionHeader,The following statement contains a magic number: if (additionalBytesRead != 12)                  throw new ZipException(String.Format("Unexpected end of data at position 0x{0:X8}"' s.Position));
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,Read,The following statement contains a magic number: if (((entry._BitField & 0x0008) == 0x0008) && !entry.FileName.EndsWith("/"))              {                  // _InputUsesZip64 is set in ReadHeader()                  int DescriptorSize = (entry._InputUsesZip64) ? 24 : 16;                  s.Seek(DescriptorSize' System.IO.SeekOrigin.Current);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,Read,The following statement contains a magic number: if (((entry._BitField & 0x0008) == 0x0008) && !entry.FileName.EndsWith("/"))              {                  // _InputUsesZip64 is set in ReadHeader()                  int DescriptorSize = (entry._InputUsesZip64) ? 24 : 16;                  s.Seek(DescriptorSize' System.IO.SeekOrigin.Current);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,HandlePK00Prefix,The following statement contains a magic number: if (datum != ZipConstants.PackedToRemovableMedia)              {                  s.Seek(-4' System.IO.SeekOrigin.Current); // unread the block              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,HandleUnexpectedDataDescriptor,The following statement contains a magic number: if (datum == entry._Crc32)              {                  int sz = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadInt(s);                  if (sz == entry._CompressedSize)                  {                      sz = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadInt(s);                      if (sz == entry._UncompressedSize)                      {                          // ignore everything and discard it.                      }                      else                          s.Seek(-12' System.IO.SeekOrigin.Current); // unread the three blocks                  }                  else                      s.Seek(-8' System.IO.SeekOrigin.Current); // unread the two blocks              }              else                  s.Seek(-4' System.IO.SeekOrigin.Current);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,HandleUnexpectedDataDescriptor,The following statement contains a magic number: if (datum == entry._Crc32)              {                  int sz = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadInt(s);                  if (sz == entry._CompressedSize)                  {                      sz = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadInt(s);                      if (sz == entry._UncompressedSize)                      {                          // ignore everything and discard it.                      }                      else                          s.Seek(-12' System.IO.SeekOrigin.Current); // unread the three blocks                  }                  else                      s.Seek(-8' System.IO.SeekOrigin.Current); // unread the two blocks              }              else                  s.Seek(-4' System.IO.SeekOrigin.Current);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,HandleUnexpectedDataDescriptor,The following statement contains a magic number: if (datum == entry._Crc32)              {                  int sz = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadInt(s);                  if (sz == entry._CompressedSize)                  {                      sz = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadInt(s);                      if (sz == entry._UncompressedSize)                      {                          // ignore everything and discard it.                      }                      else                          s.Seek(-12' System.IO.SeekOrigin.Current); // unread the three blocks                  }                  else                      s.Seek(-8' System.IO.SeekOrigin.Current); // unread the two blocks              }              else                  s.Seek(-4' System.IO.SeekOrigin.Current);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: if (_zipfile._zip64 != Zip64Option.Never)              {                  // add extra field for zip64 here                  blockZip64 = new byte[4 + 28];                  int i = 0;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                  //blockZip64[i++] = 0x99;                  //blockZip64[i++] = 0x99;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                 blockZip64[i++] = 0x99;                 blockZip64[i++] = 0x99;                     // DataSize                  blockZip64[i++] = 0x1c;  // decimal 28 - this is important                  blockZip64[i++] = 0x00;                    // The actual metadata - we may or may not have real values yet...                    // uncompressed size                  Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // compressed size                  Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // relative offset                  Array.Copy(BitConverter.GetBytes(_RelativeOffsetOfLocalHeader)' 0' blockZip64' i' 8);                  i += 8;                  // starting disk number                  Array.Copy(BitConverter.GetBytes(0)' 0' blockZip64' i' 4);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: if (_zipfile._zip64 != Zip64Option.Never)              {                  // add extra field for zip64 here                  blockZip64 = new byte[4 + 28];                  int i = 0;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                  //blockZip64[i++] = 0x99;                  //blockZip64[i++] = 0x99;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                 blockZip64[i++] = 0x99;                 blockZip64[i++] = 0x99;                     // DataSize                  blockZip64[i++] = 0x1c;  // decimal 28 - this is important                  blockZip64[i++] = 0x00;                    // The actual metadata - we may or may not have real values yet...                    // uncompressed size                  Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // compressed size                  Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // relative offset                  Array.Copy(BitConverter.GetBytes(_RelativeOffsetOfLocalHeader)' 0' blockZip64' i' 8);                  i += 8;                  // starting disk number                  Array.Copy(BitConverter.GetBytes(0)' 0' blockZip64' i' 4);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: if (_zipfile._zip64 != Zip64Option.Never)              {                  // add extra field for zip64 here                  blockZip64 = new byte[4 + 28];                  int i = 0;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                  //blockZip64[i++] = 0x99;                  //blockZip64[i++] = 0x99;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                 blockZip64[i++] = 0x99;                 blockZip64[i++] = 0x99;                     // DataSize                  blockZip64[i++] = 0x1c;  // decimal 28 - this is important                  blockZip64[i++] = 0x00;                    // The actual metadata - we may or may not have real values yet...                    // uncompressed size                  Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // compressed size                  Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // relative offset                  Array.Copy(BitConverter.GetBytes(_RelativeOffsetOfLocalHeader)' 0' blockZip64' i' 8);                  i += 8;                  // starting disk number                  Array.Copy(BitConverter.GetBytes(0)' 0' blockZip64' i' 4);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: if (_zipfile._zip64 != Zip64Option.Never)              {                  // add extra field for zip64 here                  blockZip64 = new byte[4 + 28];                  int i = 0;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                  //blockZip64[i++] = 0x99;                  //blockZip64[i++] = 0x99;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                 blockZip64[i++] = 0x99;                 blockZip64[i++] = 0x99;                     // DataSize                  blockZip64[i++] = 0x1c;  // decimal 28 - this is important                  blockZip64[i++] = 0x00;                    // The actual metadata - we may or may not have real values yet...                    // uncompressed size                  Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // compressed size                  Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // relative offset                  Array.Copy(BitConverter.GetBytes(_RelativeOffsetOfLocalHeader)' 0' blockZip64' i' 8);                  i += 8;                  // starting disk number                  Array.Copy(BitConverter.GetBytes(0)' 0' blockZip64' i' 4);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: if (_zipfile._zip64 != Zip64Option.Never)              {                  // add extra field for zip64 here                  blockZip64 = new byte[4 + 28];                  int i = 0;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                  //blockZip64[i++] = 0x99;                  //blockZip64[i++] = 0x99;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                 blockZip64[i++] = 0x99;                 blockZip64[i++] = 0x99;                     // DataSize                  blockZip64[i++] = 0x1c;  // decimal 28 - this is important                  blockZip64[i++] = 0x00;                    // The actual metadata - we may or may not have real values yet...                    // uncompressed size                  Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // compressed size                  Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // relative offset                  Array.Copy(BitConverter.GetBytes(_RelativeOffsetOfLocalHeader)' 0' blockZip64' i' 8);                  i += 8;                  // starting disk number                  Array.Copy(BitConverter.GetBytes(0)' 0' blockZip64' i' 4);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: if (_zipfile._zip64 != Zip64Option.Never)              {                  // add extra field for zip64 here                  blockZip64 = new byte[4 + 28];                  int i = 0;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                  //blockZip64[i++] = 0x99;                  //blockZip64[i++] = 0x99;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                 blockZip64[i++] = 0x99;                 blockZip64[i++] = 0x99;                     // DataSize                  blockZip64[i++] = 0x1c;  // decimal 28 - this is important                  blockZip64[i++] = 0x00;                    // The actual metadata - we may or may not have real values yet...                    // uncompressed size                  Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // compressed size                  Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // relative offset                  Array.Copy(BitConverter.GetBytes(_RelativeOffsetOfLocalHeader)' 0' blockZip64' i' 8);                  i += 8;                  // starting disk number                  Array.Copy(BitConverter.GetBytes(0)' 0' blockZip64' i' 4);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: if (_zipfile._zip64 != Zip64Option.Never)              {                  // add extra field for zip64 here                  blockZip64 = new byte[4 + 28];                  int i = 0;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                  //blockZip64[i++] = 0x99;                  //blockZip64[i++] = 0x99;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                 blockZip64[i++] = 0x99;                 blockZip64[i++] = 0x99;                     // DataSize                  blockZip64[i++] = 0x1c;  // decimal 28 - this is important                  blockZip64[i++] = 0x00;                    // The actual metadata - we may or may not have real values yet...                    // uncompressed size                  Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // compressed size                  Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // relative offset                  Array.Copy(BitConverter.GetBytes(_RelativeOffsetOfLocalHeader)' 0' blockZip64' i' 8);                  i += 8;                  // starting disk number                  Array.Copy(BitConverter.GetBytes(0)' 0' blockZip64' i' 4);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: if (_zipfile._zip64 != Zip64Option.Never)              {                  // add extra field for zip64 here                  blockZip64 = new byte[4 + 28];                  int i = 0;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                  //blockZip64[i++] = 0x99;                  //blockZip64[i++] = 0x99;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                 blockZip64[i++] = 0x99;                 blockZip64[i++] = 0x99;                     // DataSize                  blockZip64[i++] = 0x1c;  // decimal 28 - this is important                  blockZip64[i++] = 0x00;                    // The actual metadata - we may or may not have real values yet...                    // uncompressed size                  Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // compressed size                  Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // relative offset                  Array.Copy(BitConverter.GetBytes(_RelativeOffsetOfLocalHeader)' 0' blockZip64' i' 8);                  i += 8;                  // starting disk number                  Array.Copy(BitConverter.GetBytes(0)' 0' blockZip64' i' 4);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ConsExtraField,The following statement contains a magic number: if (_zipfile._zip64 != Zip64Option.Never)              {                  // add extra field for zip64 here                  blockZip64 = new byte[4 + 28];                  int i = 0;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                  //blockZip64[i++] = 0x99;                  //blockZip64[i++] = 0x99;                    // HeaderId = dummy data now' maybe set to 0x0001 (ZIP64) later.                 blockZip64[i++] = 0x99;                 blockZip64[i++] = 0x99;                     // DataSize                  blockZip64[i++] = 0x1c;  // decimal 28 - this is important                  blockZip64[i++] = 0x00;                    // The actual metadata - we may or may not have real values yet...                    // uncompressed size                  Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // compressed size                  Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' blockZip64' i' 8);                  i += 8;                  // relative offset                  Array.Copy(BitConverter.GetBytes(_RelativeOffsetOfLocalHeader)' 0' blockZip64' i' 8);                  i += 8;                  // starting disk number                  Array.Copy(BitConverter.GetBytes(0)' 0' blockZip64' i' 4);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The following statement contains a magic number: if ((_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/'))              {                  // trim off volume letter' colon' and slash                  s1 = SlashFixed.Substring(3);              }              else if ((FileName.Length >= 4)               && ((SlashFixed[0] == '/') && (SlashFixed[1] == '/')))              {                  int n = SlashFixed.IndexOf('/'' 2);                  //System.Console.WriteLine("input Path '{0}'"' FileName);                  //System.Console.WriteLine("xformed: '{0}'"' SlashFixed);                  //System.Console.WriteLine("third slash: {0}\n"' n);                  if (n == -1)                      throw new ArgumentException("The path for that entry appears to be badly formatted");                  s1 = SlashFixed.Substring(n + 1);              }              else if ((FileName.Length >= 3)               && ((SlashFixed[0] == '.') && (SlashFixed[1] == '/')))              {                  // trim off dot and slash                  s1 = SlashFixed.Substring(2);              }              else              {                  s1 = SlashFixed;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The following statement contains a magic number: if ((_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/'))              {                  // trim off volume letter' colon' and slash                  s1 = SlashFixed.Substring(3);              }              else if ((FileName.Length >= 4)               && ((SlashFixed[0] == '/') && (SlashFixed[1] == '/')))              {                  int n = SlashFixed.IndexOf('/'' 2);                  //System.Console.WriteLine("input Path '{0}'"' FileName);                  //System.Console.WriteLine("xformed: '{0}'"' SlashFixed);                  //System.Console.WriteLine("third slash: {0}\n"' n);                  if (n == -1)                      throw new ArgumentException("The path for that entry appears to be badly formatted");                  s1 = SlashFixed.Substring(n + 1);              }              else if ((FileName.Length >= 3)               && ((SlashFixed[0] == '.') && (SlashFixed[1] == '/')))              {                  // trim off dot and slash                  s1 = SlashFixed.Substring(2);              }              else              {                  s1 = SlashFixed;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The following statement contains a magic number: if ((_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/'))              {                  // trim off volume letter' colon' and slash                  s1 = SlashFixed.Substring(3);              }              else if ((FileName.Length >= 4)               && ((SlashFixed[0] == '/') && (SlashFixed[1] == '/')))              {                  int n = SlashFixed.IndexOf('/'' 2);                  //System.Console.WriteLine("input Path '{0}'"' FileName);                  //System.Console.WriteLine("xformed: '{0}'"' SlashFixed);                  //System.Console.WriteLine("third slash: {0}\n"' n);                  if (n == -1)                      throw new ArgumentException("The path for that entry appears to be badly formatted");                  s1 = SlashFixed.Substring(n + 1);              }              else if ((FileName.Length >= 3)               && ((SlashFixed[0] == '.') && (SlashFixed[1] == '/')))              {                  // trim off dot and slash                  s1 = SlashFixed.Substring(2);              }              else              {                  s1 = SlashFixed;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The following statement contains a magic number: if ((_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/'))              {                  // trim off volume letter' colon' and slash                  s1 = SlashFixed.Substring(3);              }              else if ((FileName.Length >= 4)               && ((SlashFixed[0] == '/') && (SlashFixed[1] == '/')))              {                  int n = SlashFixed.IndexOf('/'' 2);                  //System.Console.WriteLine("input Path '{0}'"' FileName);                  //System.Console.WriteLine("xformed: '{0}'"' SlashFixed);                  //System.Console.WriteLine("third slash: {0}\n"' n);                  if (n == -1)                      throw new ArgumentException("The path for that entry appears to be badly formatted");                  s1 = SlashFixed.Substring(n + 1);              }              else if ((FileName.Length >= 3)               && ((SlashFixed[0] == '.') && (SlashFixed[1] == '/')))              {                  // trim off dot and slash                  s1 = SlashFixed.Substring(2);              }              else              {                  s1 = SlashFixed;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The following statement contains a magic number: if ((_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/'))              {                  // trim off volume letter' colon' and slash                  s1 = SlashFixed.Substring(3);              }              else if ((FileName.Length >= 4)               && ((SlashFixed[0] == '/') && (SlashFixed[1] == '/')))              {                  int n = SlashFixed.IndexOf('/'' 2);                  //System.Console.WriteLine("input Path '{0}'"' FileName);                  //System.Console.WriteLine("xformed: '{0}'"' SlashFixed);                  //System.Console.WriteLine("third slash: {0}\n"' n);                  if (n == -1)                      throw new ArgumentException("The path for that entry appears to be badly formatted");                  s1 = SlashFixed.Substring(n + 1);              }              else if ((FileName.Length >= 3)               && ((SlashFixed[0] == '.') && (SlashFixed[1] == '/')))              {                  // trim off dot and slash                  s1 = SlashFixed.Substring(2);              }              else              {                  s1 = SlashFixed;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The following statement contains a magic number: if ((_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/'))              {                  // trim off volume letter' colon' and slash                  s1 = SlashFixed.Substring(3);              }              else if ((FileName.Length >= 4)               && ((SlashFixed[0] == '/') && (SlashFixed[1] == '/')))              {                  int n = SlashFixed.IndexOf('/'' 2);                  //System.Console.WriteLine("input Path '{0}'"' FileName);                  //System.Console.WriteLine("xformed: '{0}'"' SlashFixed);                  //System.Console.WriteLine("third slash: {0}\n"' n);                  if (n == -1)                      throw new ArgumentException("The path for that entry appears to be badly formatted");                  s1 = SlashFixed.Substring(n + 1);              }              else if ((FileName.Length >= 3)               && ((SlashFixed[0] == '.') && (SlashFixed[1] == '/')))              {                  // trim off dot and slash                  s1 = SlashFixed.Substring(2);              }              else              {                  s1 = SlashFixed;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The following statement contains a magic number: if ((_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/'))              {                  // trim off volume letter' colon' and slash                  s1 = SlashFixed.Substring(3);              }              else if ((FileName.Length >= 4)               && ((SlashFixed[0] == '/') && (SlashFixed[1] == '/')))              {                  int n = SlashFixed.IndexOf('/'' 2);                  //System.Console.WriteLine("input Path '{0}'"' FileName);                  //System.Console.WriteLine("xformed: '{0}'"' SlashFixed);                  //System.Console.WriteLine("third slash: {0}\n"' n);                  if (n == -1)                      throw new ArgumentException("The path for that entry appears to be badly formatted");                  s1 = SlashFixed.Substring(n + 1);              }              else if ((FileName.Length >= 3)               && ((SlashFixed[0] == '.') && (SlashFixed[1] == '/')))              {                  // trim off dot and slash                  s1 = SlashFixed.Substring(2);              }              else              {                  s1 = SlashFixed;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,_GetEncodedFileNameBytes,The following statement contains a magic number: if (s2 == s1)              {                  // file can be encoded with ibm437' now try comment                    // case 1: no comment.  use ibm437                  if (_Comment == null || _Comment.Length == 0)                  {                      _actualEncoding = ibm437;                      return result;                  }                    // there is a comment.  Get the encoded form.                  System.Text.Encoding commentEncoding = GenerateCommentBytes();  #if !SILVERLIGHT                  // case 2: if the comment also uses 437' we're good.                   if (commentEncoding.CodePage == 437)                  {                      _actualEncoding = ibm437;                      return result;                  }  #endif                  // case 3: comment requires non-437 code page.  Use the same                  // code page for the filename.                  _actualEncoding = commentEncoding;                  result = commentEncoding.GetBytes(s1);                  return result;              }              else              {                  // Cannot encode with ibm437 safely.                  // Therefore' use the provisional encoding                  result = _provisionalAlternateEncoding.GetBytes(s1);                  if (_Comment != null && _Comment.Length != 0)                  {                      _CommentBytes = _provisionalAlternateEncoding.GetBytes(_Comment);                  }                    _actualEncoding = _provisionalAlternateEncoding;                  return result;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: if (extraFieldLength > 0)              {                  byte[] Buffer = this._Extra = new byte[extraFieldLength];                  additionalBytesRead = s.Read(Buffer' 0' Buffer.Length);                    int j = 0;                  while (j < Buffer.Length)                  {                      int start = j;                        UInt16 HeaderId = (UInt16)(Buffer[j] + Buffer[j + 1] * 256);                      Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);                        j += 4;                        switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }                        // move to the next Header in the extra field                      j = start + DataSize + 4;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: if (extraFieldLength > 0)              {                  byte[] Buffer = this._Extra = new byte[extraFieldLength];                  additionalBytesRead = s.Read(Buffer' 0' Buffer.Length);                    int j = 0;                  while (j < Buffer.Length)                  {                      int start = j;                        UInt16 HeaderId = (UInt16)(Buffer[j] + Buffer[j + 1] * 256);                      Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);                        j += 4;                        switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }                        // move to the next Header in the extra field                      j = start + DataSize + 4;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: if (extraFieldLength > 0)              {                  byte[] Buffer = this._Extra = new byte[extraFieldLength];                  additionalBytesRead = s.Read(Buffer' 0' Buffer.Length);                    int j = 0;                  while (j < Buffer.Length)                  {                      int start = j;                        UInt16 HeaderId = (UInt16)(Buffer[j] + Buffer[j + 1] * 256);                      Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);                        j += 4;                        switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }                        // move to the next Header in the extra field                      j = start + DataSize + 4;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: if (extraFieldLength > 0)              {                  byte[] Buffer = this._Extra = new byte[extraFieldLength];                  additionalBytesRead = s.Read(Buffer' 0' Buffer.Length);                    int j = 0;                  while (j < Buffer.Length)                  {                      int start = j;                        UInt16 HeaderId = (UInt16)(Buffer[j] + Buffer[j + 1] * 256);                      Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);                        j += 4;                        switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }                        // move to the next Header in the extra field                      j = start + DataSize + 4;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: if (extraFieldLength > 0)              {                  byte[] Buffer = this._Extra = new byte[extraFieldLength];                  additionalBytesRead = s.Read(Buffer' 0' Buffer.Length);                    int j = 0;                  while (j < Buffer.Length)                  {                      int start = j;                        UInt16 HeaderId = (UInt16)(Buffer[j] + Buffer[j + 1] * 256);                      Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);                        j += 4;                        switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }                        // move to the next Header in the extra field                      j = start + DataSize + 4;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: if (extraFieldLength > 0)              {                  byte[] Buffer = this._Extra = new byte[extraFieldLength];                  additionalBytesRead = s.Read(Buffer' 0' Buffer.Length);                    int j = 0;                  while (j < Buffer.Length)                  {                      int start = j;                        UInt16 HeaderId = (UInt16)(Buffer[j] + Buffer[j + 1] * 256);                      Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);                        j += 4;                        switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }                        // move to the next Header in the extra field                      j = start + DataSize + 4;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: if (extraFieldLength > 0)              {                  byte[] Buffer = this._Extra = new byte[extraFieldLength];                  additionalBytesRead = s.Read(Buffer' 0' Buffer.Length);                    int j = 0;                  while (j < Buffer.Length)                  {                      int start = j;                        UInt16 HeaderId = (UInt16)(Buffer[j] + Buffer[j + 1] * 256);                      Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);                        j += 4;                        switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }                        // move to the next Header in the extra field                      j = start + DataSize + 4;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: if (extraFieldLength > 0)              {                  byte[] Buffer = this._Extra = new byte[extraFieldLength];                  additionalBytesRead = s.Read(Buffer' 0' Buffer.Length);                    int j = 0;                  while (j < Buffer.Length)                  {                      int start = j;                        UInt16 HeaderId = (UInt16)(Buffer[j] + Buffer[j + 1] * 256);                      Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);                        j += 4;                        switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }                        // move to the next Header in the extra field                      j = start + DataSize + 4;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: if (extraFieldLength > 0)              {                  byte[] Buffer = this._Extra = new byte[extraFieldLength];                  additionalBytesRead = s.Read(Buffer' 0' Buffer.Length);                    int j = 0;                  while (j < Buffer.Length)                  {                      int start = j;                        UInt16 HeaderId = (UInt16)(Buffer[j] + Buffer[j + 1] * 256);                      Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);                        j += 4;                        switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }                        // move to the next Header in the extra field                      j = start + DataSize + 4;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: if (extraFieldLength > 0)              {                  byte[] Buffer = this._Extra = new byte[extraFieldLength];                  additionalBytesRead = s.Read(Buffer' 0' Buffer.Length);                    int j = 0;                  while (j < Buffer.Length)                  {                      int start = j;                        UInt16 HeaderId = (UInt16)(Buffer[j] + Buffer[j + 1] * 256);                      Int16 DataSize = (short)(Buffer[j + 2] + Buffer[j + 3] * 256);                        j += 4;                        switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }                        // move to the next Header in the extra field                      j = start + DataSize + 4;                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: byte[] block = new byte[30];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 filenameLength = (short)(block[26] + block[27] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 filenameLength = (short)(block[26] + block[27] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 filenameLength = (short)(block[26] + block[27] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[28] + block[29] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[28] + block[29] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[28] + block[29] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: this._LengthOfHeader = 30 + extraFieldLength + filenameLength;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: this.__FileDataPosition = _RelativeOffsetOfLocalHeader + 30 + filenameLength + extraFieldLength;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: if (this._Encryption == EncryptionAlgorithm.PkzipWeak)              {                  this.__FileDataPosition += 12;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: try              {  #if OPTIMIZE_WI6612                  if (!s.CanSeek)                  {                      ReadIntoInstance_Orig(zf);                      return;                  }                    long origPosn = s.Position;                    // Try reading the central directory' rather than scanning the file.                       uint datum = VerifyBeginningOfZipFile(s);                    if (datum == ZipConstants.EndOfCentralDirectorySignature)                      return;                      // start at the end of the file...                  // seek backwards a bit' then look for the EoCD signature.                   int nTries = 0;                  bool success = false;                    // The size of the end-of-central-directory-footer plus 2 bytes is 18.                  // This implies an archive comment length of 0.                  // We'll add a margin of safety and start "in front" of that' when                   // looking for the EndOfCentralDirectorySignature                  long posn = s.Length - 64;                  long maxSeekback = Math.Max(s.Length - 0x4000' 10);                  do                  {                      s.Seek(posn' System.IO.SeekOrigin.Begin);                      long bytesRead = SharedUtilities.FindSignature(s' (int)ZipConstants.EndOfCentralDirectorySignature);                      if (bytesRead != -1)                          success = true;                      else                      {                          nTries++;                          //weird - with NETCF' negative offsets from SeekOrigin.End DO NOT WORK                          posn -= (32 * (nTries + 1) * nTries); // increasingly larger                          if (posn < 0) posn = 0;                      }                  }                  //while (!success && nTries < 3);                  while (!success && posn > maxSeekback);                    if (success)                  {                      byte[] block = new byte[16];                      zf.ReadStream.Read(block' 0' block.Length);                      int i = 12;                        uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                      if (Offset32 == 0xFFFFFFFF)                      {                          Zip64SeekToCentralDirectory(s);                      }                      else                      {                          s.Seek(Offset32' System.IO.SeekOrigin.Begin);                      }                        ReadCentralDirectory(zf);                  }                  else                  {                      // Could not find the central directory.                      // Fallback to the old method.                      s.Seek(origPosn' System.IO.SeekOrigin.Begin);                      ReadIntoInstance_Orig(zf);                  }    #else                  ReadIntoInstance_Orig(zf);  #endif                }              catch //(Exception e1)              {                  if (zf._ReadStreamIsOurs && zf._readstream != null)                  {                      try                      {                          zf._readstream.Close();                          zf._readstream.Dispose();                          zf._readstream = null;                      }                      finally { }                  }                    throw; // new Ionic.Utils.Zip.ZipException("Exception while reading"' e1);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: try              {  #if OPTIMIZE_WI6612                  if (!s.CanSeek)                  {                      ReadIntoInstance_Orig(zf);                      return;                  }                    long origPosn = s.Position;                    // Try reading the central directory' rather than scanning the file.                       uint datum = VerifyBeginningOfZipFile(s);                    if (datum == ZipConstants.EndOfCentralDirectorySignature)                      return;                      // start at the end of the file...                  // seek backwards a bit' then look for the EoCD signature.                   int nTries = 0;                  bool success = false;                    // The size of the end-of-central-directory-footer plus 2 bytes is 18.                  // This implies an archive comment length of 0.                  // We'll add a margin of safety and start "in front" of that' when                   // looking for the EndOfCentralDirectorySignature                  long posn = s.Length - 64;                  long maxSeekback = Math.Max(s.Length - 0x4000' 10);                  do                  {                      s.Seek(posn' System.IO.SeekOrigin.Begin);                      long bytesRead = SharedUtilities.FindSignature(s' (int)ZipConstants.EndOfCentralDirectorySignature);                      if (bytesRead != -1)                          success = true;                      else                      {                          nTries++;                          //weird - with NETCF' negative offsets from SeekOrigin.End DO NOT WORK                          posn -= (32 * (nTries + 1) * nTries); // increasingly larger                          if (posn < 0) posn = 0;                      }                  }                  //while (!success && nTries < 3);                  while (!success && posn > maxSeekback);                    if (success)                  {                      byte[] block = new byte[16];                      zf.ReadStream.Read(block' 0' block.Length);                      int i = 12;                        uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                      if (Offset32 == 0xFFFFFFFF)                      {                          Zip64SeekToCentralDirectory(s);                      }                      else                      {                          s.Seek(Offset32' System.IO.SeekOrigin.Begin);                      }                        ReadCentralDirectory(zf);                  }                  else                  {                      // Could not find the central directory.                      // Fallback to the old method.                      s.Seek(origPosn' System.IO.SeekOrigin.Begin);                      ReadIntoInstance_Orig(zf);                  }    #else                  ReadIntoInstance_Orig(zf);  #endif                }              catch //(Exception e1)              {                  if (zf._ReadStreamIsOurs && zf._readstream != null)                  {                      try                      {                          zf._readstream.Close();                          zf._readstream.Dispose();                          zf._readstream = null;                      }                      finally { }                  }                    throw; // new Ionic.Utils.Zip.ZipException("Exception while reading"' e1);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: try              {  #if OPTIMIZE_WI6612                  if (!s.CanSeek)                  {                      ReadIntoInstance_Orig(zf);                      return;                  }                    long origPosn = s.Position;                    // Try reading the central directory' rather than scanning the file.                       uint datum = VerifyBeginningOfZipFile(s);                    if (datum == ZipConstants.EndOfCentralDirectorySignature)                      return;                      // start at the end of the file...                  // seek backwards a bit' then look for the EoCD signature.                   int nTries = 0;                  bool success = false;                    // The size of the end-of-central-directory-footer plus 2 bytes is 18.                  // This implies an archive comment length of 0.                  // We'll add a margin of safety and start "in front" of that' when                   // looking for the EndOfCentralDirectorySignature                  long posn = s.Length - 64;                  long maxSeekback = Math.Max(s.Length - 0x4000' 10);                  do                  {                      s.Seek(posn' System.IO.SeekOrigin.Begin);                      long bytesRead = SharedUtilities.FindSignature(s' (int)ZipConstants.EndOfCentralDirectorySignature);                      if (bytesRead != -1)                          success = true;                      else                      {                          nTries++;                          //weird - with NETCF' negative offsets from SeekOrigin.End DO NOT WORK                          posn -= (32 * (nTries + 1) * nTries); // increasingly larger                          if (posn < 0) posn = 0;                      }                  }                  //while (!success && nTries < 3);                  while (!success && posn > maxSeekback);                    if (success)                  {                      byte[] block = new byte[16];                      zf.ReadStream.Read(block' 0' block.Length);                      int i = 12;                        uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                      if (Offset32 == 0xFFFFFFFF)                      {                          Zip64SeekToCentralDirectory(s);                      }                      else                      {                          s.Seek(Offset32' System.IO.SeekOrigin.Begin);                      }                        ReadCentralDirectory(zf);                  }                  else                  {                      // Could not find the central directory.                      // Fallback to the old method.                      s.Seek(origPosn' System.IO.SeekOrigin.Begin);                      ReadIntoInstance_Orig(zf);                  }    #else                  ReadIntoInstance_Orig(zf);  #endif                }              catch //(Exception e1)              {                  if (zf._ReadStreamIsOurs && zf._readstream != null)                  {                      try                      {                          zf._readstream.Close();                          zf._readstream.Dispose();                          zf._readstream = null;                      }                      finally { }                  }                    throw; // new Ionic.Utils.Zip.ZipException("Exception while reading"' e1);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: try              {  #if OPTIMIZE_WI6612                  if (!s.CanSeek)                  {                      ReadIntoInstance_Orig(zf);                      return;                  }                    long origPosn = s.Position;                    // Try reading the central directory' rather than scanning the file.                       uint datum = VerifyBeginningOfZipFile(s);                    if (datum == ZipConstants.EndOfCentralDirectorySignature)                      return;                      // start at the end of the file...                  // seek backwards a bit' then look for the EoCD signature.                   int nTries = 0;                  bool success = false;                    // The size of the end-of-central-directory-footer plus 2 bytes is 18.                  // This implies an archive comment length of 0.                  // We'll add a margin of safety and start "in front" of that' when                   // looking for the EndOfCentralDirectorySignature                  long posn = s.Length - 64;                  long maxSeekback = Math.Max(s.Length - 0x4000' 10);                  do                  {                      s.Seek(posn' System.IO.SeekOrigin.Begin);                      long bytesRead = SharedUtilities.FindSignature(s' (int)ZipConstants.EndOfCentralDirectorySignature);                      if (bytesRead != -1)                          success = true;                      else                      {                          nTries++;                          //weird - with NETCF' negative offsets from SeekOrigin.End DO NOT WORK                          posn -= (32 * (nTries + 1) * nTries); // increasingly larger                          if (posn < 0) posn = 0;                      }                  }                  //while (!success && nTries < 3);                  while (!success && posn > maxSeekback);                    if (success)                  {                      byte[] block = new byte[16];                      zf.ReadStream.Read(block' 0' block.Length);                      int i = 12;                        uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                      if (Offset32 == 0xFFFFFFFF)                      {                          Zip64SeekToCentralDirectory(s);                      }                      else                      {                          s.Seek(Offset32' System.IO.SeekOrigin.Begin);                      }                        ReadCentralDirectory(zf);                  }                  else                  {                      // Could not find the central directory.                      // Fallback to the old method.                      s.Seek(origPosn' System.IO.SeekOrigin.Begin);                      ReadIntoInstance_Orig(zf);                  }    #else                  ReadIntoInstance_Orig(zf);  #endif                }              catch //(Exception e1)              {                  if (zf._ReadStreamIsOurs && zf._readstream != null)                  {                      try                      {                          zf._readstream.Close();                          zf._readstream.Dispose();                          zf._readstream = null;                      }                      finally { }                  }                    throw; // new Ionic.Utils.Zip.ZipException("Exception while reading"' e1);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: try              {  #if OPTIMIZE_WI6612                  if (!s.CanSeek)                  {                      ReadIntoInstance_Orig(zf);                      return;                  }                    long origPosn = s.Position;                    // Try reading the central directory' rather than scanning the file.                       uint datum = VerifyBeginningOfZipFile(s);                    if (datum == ZipConstants.EndOfCentralDirectorySignature)                      return;                      // start at the end of the file...                  // seek backwards a bit' then look for the EoCD signature.                   int nTries = 0;                  bool success = false;                    // The size of the end-of-central-directory-footer plus 2 bytes is 18.                  // This implies an archive comment length of 0.                  // We'll add a margin of safety and start "in front" of that' when                   // looking for the EndOfCentralDirectorySignature                  long posn = s.Length - 64;                  long maxSeekback = Math.Max(s.Length - 0x4000' 10);                  do                  {                      s.Seek(posn' System.IO.SeekOrigin.Begin);                      long bytesRead = SharedUtilities.FindSignature(s' (int)ZipConstants.EndOfCentralDirectorySignature);                      if (bytesRead != -1)                          success = true;                      else                      {                          nTries++;                          //weird - with NETCF' negative offsets from SeekOrigin.End DO NOT WORK                          posn -= (32 * (nTries + 1) * nTries); // increasingly larger                          if (posn < 0) posn = 0;                      }                  }                  //while (!success && nTries < 3);                  while (!success && posn > maxSeekback);                    if (success)                  {                      byte[] block = new byte[16];                      zf.ReadStream.Read(block' 0' block.Length);                      int i = 12;                        uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                      if (Offset32 == 0xFFFFFFFF)                      {                          Zip64SeekToCentralDirectory(s);                      }                      else                      {                          s.Seek(Offset32' System.IO.SeekOrigin.Begin);                      }                        ReadCentralDirectory(zf);                  }                  else                  {                      // Could not find the central directory.                      // Fallback to the old method.                      s.Seek(origPosn' System.IO.SeekOrigin.Begin);                      ReadIntoInstance_Orig(zf);                  }    #else                  ReadIntoInstance_Orig(zf);  #endif                }              catch //(Exception e1)              {                  if (zf._ReadStreamIsOurs && zf._readstream != null)                  {                      try                      {                          zf._readstream.Close();                          zf._readstream.Dispose();                          zf._readstream = null;                      }                      finally { }                  }                    throw; // new Ionic.Utils.Zip.ZipException("Exception while reading"' e1);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: try              {  #if OPTIMIZE_WI6612                  if (!s.CanSeek)                  {                      ReadIntoInstance_Orig(zf);                      return;                  }                    long origPosn = s.Position;                    // Try reading the central directory' rather than scanning the file.                       uint datum = VerifyBeginningOfZipFile(s);                    if (datum == ZipConstants.EndOfCentralDirectorySignature)                      return;                      // start at the end of the file...                  // seek backwards a bit' then look for the EoCD signature.                   int nTries = 0;                  bool success = false;                    // The size of the end-of-central-directory-footer plus 2 bytes is 18.                  // This implies an archive comment length of 0.                  // We'll add a margin of safety and start "in front" of that' when                   // looking for the EndOfCentralDirectorySignature                  long posn = s.Length - 64;                  long maxSeekback = Math.Max(s.Length - 0x4000' 10);                  do                  {                      s.Seek(posn' System.IO.SeekOrigin.Begin);                      long bytesRead = SharedUtilities.FindSignature(s' (int)ZipConstants.EndOfCentralDirectorySignature);                      if (bytesRead != -1)                          success = true;                      else                      {                          nTries++;                          //weird - with NETCF' negative offsets from SeekOrigin.End DO NOT WORK                          posn -= (32 * (nTries + 1) * nTries); // increasingly larger                          if (posn < 0) posn = 0;                      }                  }                  //while (!success && nTries < 3);                  while (!success && posn > maxSeekback);                    if (success)                  {                      byte[] block = new byte[16];                      zf.ReadStream.Read(block' 0' block.Length);                      int i = 12;                        uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                      if (Offset32 == 0xFFFFFFFF)                      {                          Zip64SeekToCentralDirectory(s);                      }                      else                      {                          s.Seek(Offset32' System.IO.SeekOrigin.Begin);                      }                        ReadCentralDirectory(zf);                  }                  else                  {                      // Could not find the central directory.                      // Fallback to the old method.                      s.Seek(origPosn' System.IO.SeekOrigin.Begin);                      ReadIntoInstance_Orig(zf);                  }    #else                  ReadIntoInstance_Orig(zf);  #endif                }              catch //(Exception e1)              {                  if (zf._ReadStreamIsOurs && zf._readstream != null)                  {                      try                      {                          zf._readstream.Close();                          zf._readstream.Dispose();                          zf._readstream = null;                      }                      finally { }                  }                    throw; // new Ionic.Utils.Zip.ZipException("Exception while reading"' e1);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: try              {  #if OPTIMIZE_WI6612                  if (!s.CanSeek)                  {                      ReadIntoInstance_Orig(zf);                      return;                  }                    long origPosn = s.Position;                    // Try reading the central directory' rather than scanning the file.                       uint datum = VerifyBeginningOfZipFile(s);                    if (datum == ZipConstants.EndOfCentralDirectorySignature)                      return;                      // start at the end of the file...                  // seek backwards a bit' then look for the EoCD signature.                   int nTries = 0;                  bool success = false;                    // The size of the end-of-central-directory-footer plus 2 bytes is 18.                  // This implies an archive comment length of 0.                  // We'll add a margin of safety and start "in front" of that' when                   // looking for the EndOfCentralDirectorySignature                  long posn = s.Length - 64;                  long maxSeekback = Math.Max(s.Length - 0x4000' 10);                  do                  {                      s.Seek(posn' System.IO.SeekOrigin.Begin);                      long bytesRead = SharedUtilities.FindSignature(s' (int)ZipConstants.EndOfCentralDirectorySignature);                      if (bytesRead != -1)                          success = true;                      else                      {                          nTries++;                          //weird - with NETCF' negative offsets from SeekOrigin.End DO NOT WORK                          posn -= (32 * (nTries + 1) * nTries); // increasingly larger                          if (posn < 0) posn = 0;                      }                  }                  //while (!success && nTries < 3);                  while (!success && posn > maxSeekback);                    if (success)                  {                      byte[] block = new byte[16];                      zf.ReadStream.Read(block' 0' block.Length);                      int i = 12;                        uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                      if (Offset32 == 0xFFFFFFFF)                      {                          Zip64SeekToCentralDirectory(s);                      }                      else                      {                          s.Seek(Offset32' System.IO.SeekOrigin.Begin);                      }                        ReadCentralDirectory(zf);                  }                  else                  {                      // Could not find the central directory.                      // Fallback to the old method.                      s.Seek(origPosn' System.IO.SeekOrigin.Begin);                      ReadIntoInstance_Orig(zf);                  }    #else                  ReadIntoInstance_Orig(zf);  #endif                }              catch //(Exception e1)              {                  if (zf._ReadStreamIsOurs && zf._readstream != null)                  {                      try                      {                          zf._readstream.Close();                          zf._readstream.Dispose();                          zf._readstream = null;                      }                      finally { }                  }                    throw; // new Ionic.Utils.Zip.ZipException("Exception while reading"' e1);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: try              {  #if OPTIMIZE_WI6612                  if (!s.CanSeek)                  {                      ReadIntoInstance_Orig(zf);                      return;                  }                    long origPosn = s.Position;                    // Try reading the central directory' rather than scanning the file.                       uint datum = VerifyBeginningOfZipFile(s);                    if (datum == ZipConstants.EndOfCentralDirectorySignature)                      return;                      // start at the end of the file...                  // seek backwards a bit' then look for the EoCD signature.                   int nTries = 0;                  bool success = false;                    // The size of the end-of-central-directory-footer plus 2 bytes is 18.                  // This implies an archive comment length of 0.                  // We'll add a margin of safety and start "in front" of that' when                   // looking for the EndOfCentralDirectorySignature                  long posn = s.Length - 64;                  long maxSeekback = Math.Max(s.Length - 0x4000' 10);                  do                  {                      s.Seek(posn' System.IO.SeekOrigin.Begin);                      long bytesRead = SharedUtilities.FindSignature(s' (int)ZipConstants.EndOfCentralDirectorySignature);                      if (bytesRead != -1)                          success = true;                      else                      {                          nTries++;                          //weird - with NETCF' negative offsets from SeekOrigin.End DO NOT WORK                          posn -= (32 * (nTries + 1) * nTries); // increasingly larger                          if (posn < 0) posn = 0;                      }                  }                  //while (!success && nTries < 3);                  while (!success && posn > maxSeekback);                    if (success)                  {                      byte[] block = new byte[16];                      zf.ReadStream.Read(block' 0' block.Length);                      int i = 12;                        uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                      if (Offset32 == 0xFFFFFFFF)                      {                          Zip64SeekToCentralDirectory(s);                      }                      else                      {                          s.Seek(Offset32' System.IO.SeekOrigin.Begin);                      }                        ReadCentralDirectory(zf);                  }                  else                  {                      // Could not find the central directory.                      // Fallback to the old method.                      s.Seek(origPosn' System.IO.SeekOrigin.Begin);                      ReadIntoInstance_Orig(zf);                  }    #else                  ReadIntoInstance_Orig(zf);  #endif                }              catch //(Exception e1)              {                  if (zf._ReadStreamIsOurs && zf._readstream != null)                  {                      try                      {                          zf._readstream.Close();                          zf._readstream.Dispose();                          zf._readstream = null;                      }                      finally { }                  }                    throw; // new Ionic.Utils.Zip.ZipException("Exception while reading"' e1);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: try              {  #if OPTIMIZE_WI6612                  if (!s.CanSeek)                  {                      ReadIntoInstance_Orig(zf);                      return;                  }                    long origPosn = s.Position;                    // Try reading the central directory' rather than scanning the file.                       uint datum = VerifyBeginningOfZipFile(s);                    if (datum == ZipConstants.EndOfCentralDirectorySignature)                      return;                      // start at the end of the file...                  // seek backwards a bit' then look for the EoCD signature.                   int nTries = 0;                  bool success = false;                    // The size of the end-of-central-directory-footer plus 2 bytes is 18.                  // This implies an archive comment length of 0.                  // We'll add a margin of safety and start "in front" of that' when                   // looking for the EndOfCentralDirectorySignature                  long posn = s.Length - 64;                  long maxSeekback = Math.Max(s.Length - 0x4000' 10);                  do                  {                      s.Seek(posn' System.IO.SeekOrigin.Begin);                      long bytesRead = SharedUtilities.FindSignature(s' (int)ZipConstants.EndOfCentralDirectorySignature);                      if (bytesRead != -1)                          success = true;                      else                      {                          nTries++;                          //weird - with NETCF' negative offsets from SeekOrigin.End DO NOT WORK                          posn -= (32 * (nTries + 1) * nTries); // increasingly larger                          if (posn < 0) posn = 0;                      }                  }                  //while (!success && nTries < 3);                  while (!success && posn > maxSeekback);                    if (success)                  {                      byte[] block = new byte[16];                      zf.ReadStream.Read(block' 0' block.Length);                      int i = 12;                        uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                      if (Offset32 == 0xFFFFFFFF)                      {                          Zip64SeekToCentralDirectory(s);                      }                      else                      {                          s.Seek(Offset32' System.IO.SeekOrigin.Begin);                      }                        ReadCentralDirectory(zf);                  }                  else                  {                      // Could not find the central directory.                      // Fallback to the old method.                      s.Seek(origPosn' System.IO.SeekOrigin.Begin);                      ReadIntoInstance_Orig(zf);                  }    #else                  ReadIntoInstance_Orig(zf);  #endif                }              catch //(Exception e1)              {                  if (zf._ReadStreamIsOurs && zf._readstream != null)                  {                      try                      {                          zf._readstream.Close();                          zf._readstream.Dispose();                          zf._readstream = null;                      }                      finally { }                  }                    throw; // new Ionic.Utils.Zip.ZipException("Exception while reading"' e1);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: try              {  #if OPTIMIZE_WI6612                  if (!s.CanSeek)                  {                      ReadIntoInstance_Orig(zf);                      return;                  }                    long origPosn = s.Position;                    // Try reading the central directory' rather than scanning the file.                       uint datum = VerifyBeginningOfZipFile(s);                    if (datum == ZipConstants.EndOfCentralDirectorySignature)                      return;                      // start at the end of the file...                  // seek backwards a bit' then look for the EoCD signature.                   int nTries = 0;                  bool success = false;                    // The size of the end-of-central-directory-footer plus 2 bytes is 18.                  // This implies an archive comment length of 0.                  // We'll add a margin of safety and start "in front" of that' when                   // looking for the EndOfCentralDirectorySignature                  long posn = s.Length - 64;                  long maxSeekback = Math.Max(s.Length - 0x4000' 10);                  do                  {                      s.Seek(posn' System.IO.SeekOrigin.Begin);                      long bytesRead = SharedUtilities.FindSignature(s' (int)ZipConstants.EndOfCentralDirectorySignature);                      if (bytesRead != -1)                          success = true;                      else                      {                          nTries++;                          //weird - with NETCF' negative offsets from SeekOrigin.End DO NOT WORK                          posn -= (32 * (nTries + 1) * nTries); // increasingly larger                          if (posn < 0) posn = 0;                      }                  }                  //while (!success && nTries < 3);                  while (!success && posn > maxSeekback);                    if (success)                  {                      byte[] block = new byte[16];                      zf.ReadStream.Read(block' 0' block.Length);                      int i = 12;                        uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                      if (Offset32 == 0xFFFFFFFF)                      {                          Zip64SeekToCentralDirectory(s);                      }                      else                      {                          s.Seek(Offset32' System.IO.SeekOrigin.Begin);                      }                        ReadCentralDirectory(zf);                  }                  else                  {                      // Could not find the central directory.                      // Fallback to the old method.                      s.Seek(origPosn' System.IO.SeekOrigin.Begin);                      ReadIntoInstance_Orig(zf);                  }    #else                  ReadIntoInstance_Orig(zf);  #endif                }              catch //(Exception e1)              {                  if (zf._ReadStreamIsOurs && zf._readstream != null)                  {                      try                      {                          zf._readstream.Close();                          zf._readstream.Dispose();                          zf._readstream = null;                      }                      finally { }                  }                    throw; // new Ionic.Utils.Zip.ZipException("Exception while reading"' e1);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadIntoInstance,The following statement contains a magic number: try              {  #if OPTIMIZE_WI6612                  if (!s.CanSeek)                  {                      ReadIntoInstance_Orig(zf);                      return;                  }                    long origPosn = s.Position;                    // Try reading the central directory' rather than scanning the file.                       uint datum = VerifyBeginningOfZipFile(s);                    if (datum == ZipConstants.EndOfCentralDirectorySignature)                      return;                      // start at the end of the file...                  // seek backwards a bit' then look for the EoCD signature.                   int nTries = 0;                  bool success = false;                    // The size of the end-of-central-directory-footer plus 2 bytes is 18.                  // This implies an archive comment length of 0.                  // We'll add a margin of safety and start "in front" of that' when                   // looking for the EndOfCentralDirectorySignature                  long posn = s.Length - 64;                  long maxSeekback = Math.Max(s.Length - 0x4000' 10);                  do                  {                      s.Seek(posn' System.IO.SeekOrigin.Begin);                      long bytesRead = SharedUtilities.FindSignature(s' (int)ZipConstants.EndOfCentralDirectorySignature);                      if (bytesRead != -1)                          success = true;                      else                      {                          nTries++;                          //weird - with NETCF' negative offsets from SeekOrigin.End DO NOT WORK                          posn -= (32 * (nTries + 1) * nTries); // increasingly larger                          if (posn < 0) posn = 0;                      }                  }                  //while (!success && nTries < 3);                  while (!success && posn > maxSeekback);                    if (success)                  {                      byte[] block = new byte[16];                      zf.ReadStream.Read(block' 0' block.Length);                      int i = 12;                        uint Offset32 = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);                      if (Offset32 == 0xFFFFFFFF)                      {                          Zip64SeekToCentralDirectory(s);                      }                      else                      {                          s.Seek(Offset32' System.IO.SeekOrigin.Begin);                      }                        ReadCentralDirectory(zf);                  }                  else                  {                      // Could not find the central directory.                      // Fallback to the old method.                      s.Seek(origPosn' System.IO.SeekOrigin.Begin);                      ReadIntoInstance_Orig(zf);                  }    #else                  ReadIntoInstance_Orig(zf);  #endif                }              catch //(Exception e1)              {                  if (zf._ReadStreamIsOurs && zf._readstream != null)                  {                      try                      {                          zf._readstream.Close();                          zf._readstream.Dispose();                          zf._readstream = null;                      }                      finally { }                  }                    throw; // new Ionic.Utils.Zip.ZipException("Exception while reading"' e1);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: byte[] block = new byte[16];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: s.Seek(-40' System.IO.SeekOrigin.Current);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: s.Read(block' 0' 16);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: Int64 Offset64 = BitConverter.ToInt64(block' 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: s.Read(block' 0' 8);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: Offset64 = BitConverter.ToInt64(block' 36);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature == ZipConstants.Zip64EndOfCentralDirectoryRecordSignature)              {                  // We have a ZIP64 EOCD                  // This data block is 4 bytes sig' 8 bytes size' 44 bytes fixed data'                   // followed by a variable-sized extension block.  We have read the sig already.                   block = new byte[8 + 44];                  s.Read(block' 0' block.Length);                    Int64 DataSize = BitConverter.ToInt64(block' 0);  // == 44 + the variable length                    if (DataSize < 44)                      throw new ZipException("Bad DataSize in the ZIP64 Central Directory.");                    i = 8;                  i += 2; // version made by                  i += 2; // version needed to extract                    i += 4; // number of this disk                  i += 4; // number of the disk with the start of the CD                    i += 8; // total number of entries in the CD on this disk                  i += 8; // total number of entries in the CD                     i += 8; // size of the CD                    i += 8; // offset of the CD                    block = new byte[DataSize - 44];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);                  if (signature != ZipConstants.Zip64EndOfCentralDirectoryLocatorSignature)                      throw new ZipException("Inconsistent metadata in the ZIP64 Central Directory.");                    block = new byte[16];                  s.Read(block' 0' block.Length);                  // discard the result                    signature = ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip.SharedUtilities.ReadSignature(s);              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: if (signature != ZipConstants.EndOfCentralDirectorySignature)              {                  s.Seek(-4' System.IO.SeekOrigin.Current);                  throw new BadReadException(String.Format("  ZipFile::Read(): Bad signature ({0:X8}) at position 0x{1:X8}"' signature' s.Position));              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[16];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadZipFileComment,The following statement contains a magic number: byte[] block = new byte[2];
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadZipFileComment,The following statement contains a magic number: Int16 commentLength = (short)(block[0] + block[1] * 256);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipFile,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipFile.cs,ReadZipFileComment,The following statement contains a magic number: if (commentLength > 0)              {                  block = new byte[commentLength];                  zf.ReadStream.Read(block' 0' block.Length);                    // workitem 6513 - only use UTF8 as necessary                  // test reflexivity                  string s1 = DefaultEncoding.GetString(block' 0' block.Length);                  byte[] b2 = DefaultEncoding.GetBytes(s1);                  if (BlocksAreEqual(block' b2))                  {                      zf.Comment = s1;                  }                  else                  {                      // need alternate (non IBM437) encoding                      // workitem 6415                      // use UTF8 if the caller hasn't already set a non-default encoding  #if !SILVERLIGHT                      System.Text.Encoding e = (zf._provisionalAlternateEncoding.CodePage == 437)                          ? System.Text.Encoding.UTF8                          : zf._provisionalAlternateEncoding;  #else  					System.Text.Encoding e = System.Text.Encoding.UTF8;  #endif  					zf.Comment = e.GetString(block' 0' block.Length);                  }              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,SharedUtils,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Zlib.cs,URShift,The following statement contains a magic number: if (number >= 0)                  return number >> bits;              else                  return (number >> bits) + (2 << ~bits);
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Adler,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Zlib.cs,Adler32,The following statement contains a magic number: long s2 = (adler >> 16) & 0xffff;
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Adler,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Zlib.cs,Adler32,The following statement contains a magic number: while (len > 0)              {                  k = len < NMAX ? len : NMAX;                  len -= k;                  while (k >= 16)                  {                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      k -= 16;                  }                  if (k != 0)                  {                      do                      {                          s1 += (buf[index++] & 0xff); s2 += s1;                      }                      while (--k != 0);                  }                  s1 %= BASE;                  s2 %= BASE;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Adler,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Zlib.cs,Adler32,The following statement contains a magic number: while (len > 0)              {                  k = len < NMAX ? len : NMAX;                  len -= k;                  while (k >= 16)                  {                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      s1 += (buf[index++] & 0xff); s2 += s1;                      k -= 16;                  }                  if (k != 0)                  {                      do                      {                          s1 += (buf[index++] & 0xff); s2 += s1;                      }                      while (--k != 0);                  }                  s1 %= BASE;                  s2 %= BASE;              }
Magic Number,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,Adler,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Zlib.cs,Adler32,The following statement contains a magic number: return (s2 << 16) | s1;
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources,CsvLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\CsvLayer\CsvLayer.cs,ConvertToExpectedType,The following switch statement is missing a default case: switch (expectedValueType)  			{  				case Field.FieldType.Date:  					if (!(valueObject is DateTime))  					{  						try  						{  							if (valueObject is string)  							{                                        string str_date = ((string)valueObject).ToLower();                                  if (str_date.Contains("utc"))                                  {                                      str_date = str_date.Replace("utc"' "");                                      result = DateTime.Parse((string)str_date' numericCulture' DateTimeStyles.AssumeUniversal);                                  }                                  else                                      result = DateTime.Parse((string)valueObject' numericCulture);  							}  							else  							{  								long time = 0;  								if (valueObject.GetType() == typeof(long)) time = (long)valueObject;  								else if (valueObject.GetType() == typeof(int)) time = (int)valueObject;  								else time = Convert.ToInt64(valueObject' numericCulture);  								result = Epoch.AddMilliseconds((double)time);  							}  						}  						catch { }  					}  					break;  				case Field.FieldType.Double:  					if (valueObject.GetType() != typeof(double))  					{  						try { result = Convert.ToDouble(valueObject' numericCulture); }  						catch { }  					}  					break;  				case Field.FieldType.Single:  					if (valueObject.GetType() != typeof(float))  					{  						try { result = Convert.ToSingle(valueObject' numericCulture); }  						catch { }  					}  					break;  				case Field.FieldType.Integer:  					if (valueObject.GetType() != typeof(int))  					{  						try { result = Convert.ToInt32(valueObject' numericCulture); }  						catch { }  					}  					break;  				case Field.FieldType.SmallInteger:  					if (valueObject.GetType() != typeof(short))  					{  						try { result = Convert.ToInt16(valueObject' numericCulture); }  						catch { }  					}  					break;  				case Field.FieldType.GUID:  					if (valueObject.GetType() != typeof(Guid))  					{  						Guid output;  						var valueStr = Convert.ToString(valueObject' numericCulture);  						if (!string.IsNullOrEmpty(valueStr))  						{  							if (Guid.TryParse(valueStr' out output))  								result = output;  						}  					}  					break;  			}
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources,GeoRssLoader,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GeoRss\GeoRssLoader.cs,wc_OpenReadCompleted,The following switch statement is missing a default case: switch (ee.OuterName)  								{  									case ("lat"):  										{  											slat = xr.ReadElementContentAsString();  											break;  										}  									case ("long"):  										{  											slong = xr.ReadElementContentAsString();  											break;  										}  									case ("Point"):  										{  											XmlReader xmlPoint = xr.ReadSubtree();  											while (xmlPoint.Read())  											{  												if (xmlPoint.LocalName == "lat" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slat = xmlPoint.ReadElementContentAsString();  												}  												else if (xmlPoint.LocalName == "long" && xmlPoint.NamespaceURI == _W3CGEONAMESPACE_)  												{  													slong = xmlPoint.ReadElementContentAsString();  												}  											}  											break;  										}  								}
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources,GpsLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\GpsLayer\GpsLayer.cs,watcher_StatusChanged,The following switch statement is missing a default case: switch (e.Status)  			{  				case GeoPositionStatus.Disabled:  				case GeoPositionStatus.Initializing:  				case GeoPositionStatus.NoData:  					UpdateLocation();  					UpdateAccuracyCircle();  					GeoCoordinate = null;  					Position = null;  					break;  				case GeoPositionStatus.Ready:  					//  					break;  			}
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources,KmlLayer,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlLayer.cs,GetKmzContents,The following switch statement is missing a default case: switch (filename.Substring(lastPeriod).ToLower())                  {                      case ".jpg":                      case ".jpeg":                      case ".png":  #if !SILVERLIGHT                      case ".bmp":                      case ".gif":  #endif  						// If the file is an image' then add it to the dictionary of images and use                          // its filename as the key since this will match the subsequent KML style                          // information for point features.  						try  						{                              BitmapImage thumbnailBitmap = new BitmapImage();  #if SILVERLIGHT                              thumbnailBitmap.SetSource(ms);  #else                              thumbnailBitmap.BeginInit();                              thumbnailBitmap.StreamSource = ms;                              thumbnailBitmap.EndInit();  #endif                              ImageBrush ib = new ImageBrush();                              ib.ImageSource = thumbnailBitmap;                              _context.Images.Add(filename.ToLower()' ib);  						}  						catch { }                            break;                        case ".kml":                          // Create the XDocument object from the input stream  						xDoc = LoadDocument(ms);                          break;                    }
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,The following switch statement is missing a default case: switch (style.IconHotspotUnitsX)              {                  case HotSpotUnitType.Pixels:                      ms.TranslateX = style.IconHotspotX * -1;                      break;                    case HotSpotUnitType.Fraction:                      ms.TranslateX = (ms.Width * style.IconHotspotX) * -1;                      break;              }
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,FeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\FeatureDefinition.cs,ComputeIconTranslationValues,The following switch statement is missing a default case: switch (style.IconHotspotUnitsY)              {                  case HotSpotUnitType.Pixels:                      ms.TranslateY = (ms.Height - style.IconHotspotY) * -1;                      break;                    case HotSpotUnitType.Fraction:                      ms.TranslateY = (ms.Height * style.IconHotspotY) * -1;                      break;              }
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,GetKmzContents,The following switch statement is missing a default case: switch (filename.Substring(lastPeriod).ToLower())  				{  					case ".kml":  						// Create the XDocument object from the input stream  						xDoc = KmlLayer.LoadDocument(ms);  						break;  				}
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml,KmlToFeatureDefinition,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\CommonAPI\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\KmlToFeatureDefinition.cs,CreateFeatureDefinition,The following switch statement is missing a default case: switch (geomElement.Name.LocalName)  					{  						case "Point":  							fd = ExtractPoint(kmlStyle' geomElement);  							break;    						case "LineString":  							fd = ExtractPolyLine(kmlStyle' geomElement);  							break;    						case "LinearRing":  							fd = ExtractLinearRing(kmlStyle' geomElement);  							break;    						case "Polygon":  							fd = ExtractPolygon(kmlStyle' geomElement);  							break;    						case "MultiGeometry":  							foreach (XElement item in geomElement.Elements())  							{  								// Use recursion to walk the hierarchy of embedded definitions  								CreateFeatureDefinition(kmlStyle' feature' item' context);  							}  							break;    						case "LatLonBox":  							ExtractFeatureStyleInfo(kmlStyle' feature);  							fd = ExtractLatLonBox(kmlStyle' geomElement);  							break;  					}
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,InflateBlocks,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\Inflate.cs,Process,The following switch statement is missing a default case: switch (SharedUtils.URShift(t' 1))                          {                                case 0:  // stored                                   {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SharedUtils.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0' z);                                  }                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SharedUtils.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  write = q;                                  return Flush(z' r);                          }
Missing Default,ESRI.ArcGIS.Client.Toolkit.DataSources.Kml.Zip,ZipEntry,C:\repos\Esri_arcgis-toolkit-sl-wpf\src\WPF\API\ESRI.ArcGIS.Client.Toolkit.DataSources\Kml\Zip\ZipDirEntry.cs,ProcessExtraField,The following switch statement is missing a default case: switch (HeaderId)                      {                          case 0x0001: // ZIP64                              {                                  // The _IsZip64Format flag is true IFF the prior compressed/uncompressed size values were 0xFFFFFFFF.                                  // But we don't need to be rigid about this.  Some zip archives don't behave this way.                                    //if (!ze._IsZip64Format)                                  //throw new BadReadException(String.Format("  Found zip64 metadata when none expected at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._InputUsesZip64 = true;                                    if (DataSize > 28)                                      throw new BadReadException(String.Format("  Inconsistent datasize (0x{0:X4}) for ZIP64 extra field at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    if (this._UncompressedSize == 0xFFFFFFFF)                                  {                                      this._UncompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._CompressedSize == 0xFFFFFFFF)                                  {                                      this._CompressedSize = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  if (this._RelativeOffsetOfLocalHeader == 0xFFFFFFFF)                                  {                                      this._RelativeOffsetOfLocalHeader = BitConverter.ToInt64(Buffer' j);                                      j += 8;                                  }                                  // ignore the potential last 4 bytes - I don't know what to do with them anyway.                              }                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              //Console.WriteLine("Found WinZip AES Encryption header (compression:0x{0:X2})"' this._CompressionMethod);                              if (this._CompressionMethod == 0x0063)                              {                                  if ((this._BitField & 0x01) != 0x01)                                      throw new BadReadException(String.Format("  Inconsistent metadata at position 0x{0:X16}"' s.Position - additionalBytesRead));                                    this._sourceIsEncrypted = true;                                    //this._aesCrypto = new WinZipAesCrypto(this);                                  // see spec at http://www.winzip.com/aes_info.htm                                  if (DataSize != 7)                                      throw new BadReadException(String.Format("  Inconsistent WinZip AES datasize (0x{0:X4}) at position 0x{1:X16}"' DataSize' s.Position - additionalBytesRead));                                    this._WinZipAesMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (this._WinZipAesMethod != 0x01 && this._WinZipAesMethod != 0x02)                                      throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"'                                          this._WinZipAesMethod' s.Position - additionalBytesRead));                                    Int16 vendorId = BitConverter.ToInt16(Buffer' j);                                  j += 2;                                  if (vendorId != 0x4541)                                      throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' s.Position - additionalBytesRead));                                    this._KeyStrengthInBits = -1;                                  if (Buffer[j] == 1) _KeyStrengthInBits = 128;                                  if (Buffer[j] == 3) _KeyStrengthInBits = 256;                                    if (this._KeyStrengthInBits < 0)                                      throw new Exception(String.Format("Invalid key strength ({0})"' this._KeyStrengthInBits));                                    this.Encryption = (this._KeyStrengthInBits == 128)                                      ? EncryptionAlgorithm.WinZipAes128                                      : EncryptionAlgorithm.WinZipAes256;                                    j++;                                    // set the actual compression method                                  this._CompressionMethod = BitConverter.ToInt16(Buffer' j);                                  j += 2; // a formality                              }                              break;  #endif                      }
